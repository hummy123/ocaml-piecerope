
let data = [|
  (0, 0, "/// This is an implementation of a general purpose skip list. It was originally\n/// ported from a version of skiplists intended for efficient string handling\n/// found here - https://github.com/josephg/rustrope\n\n/// This implementation is not optimized for strings (there's some string\n/// specific features like unicode handling which have been intentionally\n/// removed for simplicity). But it does have another somewhat unusual feature -\n/// users can specify their own size function, and lookups, inserts and deletes\n/// can use their custom length property to specify offsets.\n\n/// Unlike other rust rope implementations, this implementation should be very\n/// fast; but it manages that through heavy use of unsafe pointers and C-style\n/// dynamic arrays.\n\nuse std::{mem, ptr};\nuse std::alloc::{alloc, dealloc, Layout};\nuse std::cmp::min;\n\nuse rand::{RngCore, Rng, SeedableRng};\nuse rand::rngs::SmallRng;\n\n/// The likelyhood a node will have height (n+1) instead of n\nconst BIAS: u8 = 100; // out of 256.\n\n/// The number of items in each node. Must fit in a u8 thanks to Node.\n// const NODE_NUM_ITEMS: usize = 100;\nconst NODE_NUM_ITEMS: usize = 100;\n\n/// Rope operations will move to linear time after NODE_STR_SIZE * 2 ^\n/// MAX_HEIGHT length. (With a smaller constant the higher this is). On the flip\n/// side, cursors grow linearly with this number; so smaller is marginally\n/// better when the contents are smaller.\nconst MAX_HEIGHT: usize = 20;\n\nconst MAX_HEIGHT_U8: u8 = MAX_HEIGHT as u8; // convenience.\n\n/// The whole list is configured through a single generic trait parameter\npub trait ListConfig {\n    type Item: Default + Copy;\n\n    /// Applications which have custom sizes (or do their own\n    /// run-length-encoding) can define their own size function for items. When\n    /// items are inserted or replaced, the position is specified using the\n    /// custom size defined here.\n    fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\n    fn userlen_of_slice(items: &[Self::Item]) -> usize {\n        items.iter().fold(0, |acc, item| {\n            acc + Self::get_usersize(item)\n        })\n    }\n\n    fn split_item(_item: Self::Item) -> (Self::Item, Self::Item) {\n        unimplemented!(\"Cannot insert in the middle of an item - split_item is not defined in trait\");\n    }\n\n    // type RngType: rand::RngCore = rand::rngs::SmallRng;\n    // fn get_rng() -> Self::RngType {\n    //     use rand::SeedableRng;\n    //     // rand::rngs::SmallRng::from_seed(SeedableRng::seed_from_u64(10))\n    //     rand::rngs::SmallRng::from_entropy()\n    // }\n}\n\n/// This represents a single entry in either the nexts pointers list or in an\n/// iterator.\n#[derive(Debug, PartialEq, Eq)]\nstruct SkipEntry<C: ListConfig> {\n    /// The node being pointed to.\n    node: *mut Node<C>,\n\n    /// The number of *items* between the start of the current node and the\n    /// start of the next node. That means nexts entry 0 contains the length of\n    /// the current node.\n    skip_usersize: usize,\n}\n\n// We can't use #[derive()] here for Copy and Clone due to a bug in the rust\n// compiler: https://github.com/rust-lang/rust/issues/26925\nimpl<C: ListConfig> Copy for SkipEntry<C> {}\nimpl<C: ListConfig> Clone for SkipEntry<C> {\n    fn clone(&self) -> Self { *self }\n}\n\nimpl<C: ListConfig> SkipEntry<C> {\n    fn new_null() -> Self {\n        SkipEntry { node: ptr::null_mut(), skip_usersize: 0 }\n    }\n}\n\n\n/// The node structure is designed in a very fancy way which would be more at\n/// home in C or something like that. The basic idea is that the node structure\n/// is fixed size in memory, but the proportion of that space taken up by\n/// characters and by the height differ depending on a node's height. This\n/// results in a lot of `unsafe` blocks. I think the tradeoff is worth it but I\n/// could be wrong here. You probably wouldn't lose much performance in practice\n/// by replacing the inline structure with a smallvec - but that would waste\n/// memory in small nodes, and require extra pointer indirection on large nodes.\n/// It also wouldn't remove all the unsafe here.\n///\n/// A different representation (which might be better or worse - I can't tell)\n/// would be to have the nodes all be the same size in memory and change the\n/// *proportion* of the node's memory that is used by the string field vs the\n/// next pointers. That might be lighter weight for the allocator because the\n/// struct itself would be a fixed size; but I'm not sure if it would be better.\n#[repr(C)] // Prevent parameter reordering.\nstruct Node<C: ListConfig> {\n    /// We start with the items themselves. Only the first `num_items` of this\n    /// list is in use. The user specified length of the items in the node is\n    /// stored in nexts[0].skip_items. This is initialized with\n    /// Default::default() for the type, but when MaybeUninit completely lands,\n    /// it will be possible to make this a tiny bit faster by leaving the list\n    /// initially uninitialized.\n    items: [C::Item; NODE_NUM_ITEMS],\n\n    /// Number of items in `items` in use / filled.\n    num_items: u8,\n\n    /// Height of nexts array.\n    height: u8,\n\n    // #[repr(align(std::align_of::<SkipEntry>()))]\n    \n    /// In reality this array has the size of height, allocated using more or\n    /// less direct calls to malloc() at runtime based on the randomly generated\n    /// size. The size is always at least 1.\n    nexts: [SkipEntry<C>; 0],\n}\n\n// Make sure nexts uses correct alignment. This should be guaranteed by repr(C)\n// This test will fail if this ever stops being true.\n#[test]\nfn test_align() {\n    struct TestConfig;\n    impl ListConfig for TestConfig {\n        type Item = u8;\n        fn get_usersize(_item: &Self::Item) -> usize { 1 }\n    }\n    #[repr(C)] struct Check([SkipEntry<TestConfig>; 0]);\n    assert!(mem::align_of::<Check>() >= mem::align_of::<SkipEntry<TestConfig>>());\n    // TODO: It'd be good to also check the alignment of the nexts field in Node.\n}\n\nfn random_height<R: RngCore>(rng: &mut R) -> u8 {\n    let mut h: u8 = 1;\n    // Should I use a csrng here? Does it matter?\n    while h < MAX_HEIGHT_U8 && rng.gen::<u8>() < BIAS { h+=1; }\n    h\n}\n\n#[repr(C)]\npub struct SkipList<C: ListConfig> {\n    // TODO: Consider putting the head item on the heap. For the use case here\n    // its almost certainly fine either way. The code feels a bit cleaner if its\n    // on the heap (and then iterators will be able to outlast a move of the\n    // skiplist parent). But its also very nice having the code run fast for\n    // small lists. Most lists are small, and it makes sense to optimize for\n    // that.\n\n    // TODO: For safety, pointers in to this structure should be Pin<> if we\n    // ever want to hold on to iterators.\n\n    /// The total number of items in the skip list. This is not used internally -\n    /// just here for bookkeeping.\n    num_items: usize,\n    /// Size of the list in user specified units.\n    num_usercount: usize,\n\n    /// The RNG we use to generate node heights. Specifying it explicitly allows\n    /// unit tests and randomizer runs to be predictable, which is very helpful\n    /// during debugging. I'm still not sure how the type of this should be\n    /// specified. Should it be a generic parameter? Box<dyn *>?\n    /// ??\n    rng: SmallRng,\n\n    /// The first node is inline. The height is 1 more than the max height we've\n    /// ever used. The highest next entry points to {null, total usersize}.\n    head: Node<C>,\n\n    /// This is so dirty. The first node is embedded in SkipList; but we need to\n    /// allocate enough room for height to get arbitrarily large. I could insist\n    /// on SkipList always getting allocated on the heap, but for small lists its\n    /// much better to be on the stack.\n    ///\n    /// So this struct is repr(C) and I'm just padding out the struct directly.\n    /// All accesses should go through head because otherwise I think we violate\n    /// aliasing rules.\n    _nexts_padding: [SkipEntry<C>; MAX_HEIGHT],\n}\n\n\n\nimpl<C: ListConfig> Node<C> {\n    // Do I need to be explicit about the lifetime of the references being tied\n    // to the lifetime of the node?\n    fn nexts(&self) -> &[SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts(self.nexts.as_ptr(), self.height as usize)\n        }\n    }\n\n    fn nexts_mut(&mut self) -> &mut [SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.nexts.as_mut_ptr(), self.height as usize)\n        }\n    }\n\n    fn layout_with_height(height: u8) -> Layout {\n        Layout::from_size_align(\n            mem::size_of::<Node<C>>() + mem::size_of::<SkipEntry<C>>() * (height as usize),\n            mem::align_of::<Node<C>>()).unwrap()\n    }\n\n    fn alloc_with_height(height: u8) -> *mut Node<C> {\n        assert!(height >= 1 && height <= MAX_HEIGHT_U8);\n\n        unsafe {\n            let node = alloc(Self::layout_with_height(height)) as *mut Node<C>;\n            (*node) = Node {\n                items: [C::Item::default(); NODE_NUM_ITEMS],\n                num_items: 0,\n                height: height,\n                nexts: [],\n            };\n\n            for next in (*node).nexts_mut() {\n                *next = SkipEntry::new_null();\n            }\n\n            node\n        }\n    }\n\n    fn alloc<R: RngCore>(rng: &mut R) -> *mut Node<C> {\n        Self::alloc_with_height(random_height(rng))\n    }\n\n    unsafe fn free(p: *mut Node<C>) {\n        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n    }\n\n    fn content_slice(&self) -> &[C::Item] {\n        &self.items[..self.num_items as usize]\n    }\n\n    // The height is at least 1, so this is always valid.\n    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n        unsafe { &*self.nexts.as_ptr() }\n    }\n\n    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n        unsafe { &mut *self.nexts.as_mut_ptr() }\n    }\n\n    // TODO: Rename to len() ?\n    fn get_userlen(&self) -> usize {\n        self.first_skip_entry().skip_usersize\n    }\n    \n    fn get_next_ptr(&self) -> *mut Node<C> {\n        self.first_skip_entry().node\n    }\n\n    /// I dunno where this logic should live, but we want to get the index of\n    /// the item at the specified offset into the node (and the offset into the\n    /// item).\n    /// \n    /// If the offset lands between items, we could return either the previous or next item.\n    /// \n    /// Returns (index, item_offset).\n    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) -> (usize, usize) {\n        if usersize_offset == 0 { return (0, 0); }\n\n        for (i, item) in self.content_slice().iter().enumerate() {\n            let usersize = C::get_usersize(item);\n            if usersize > usersize_offset {\n                return (i, usersize_offset);\n            } else if usersize == usersize_offset {\n                return if stick_end { (i, usersize_offset) } else { (i+1, 0) }\n            } else {\n                usersize_offset -= usersize;\n            }\n        }\n        panic!(\"Could not find requested offset within the node\");\n    }\n}\n\nstruct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\nimpl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n    type Item = &'a Node<C>;\n\n    fn next(&mut self) -> Option<&'a Node<C>> {\n        let prev = self.0;\n        if let Some(n) = self.0 {\n            *self = NodeIter(unsafe { n.first_skip_entry().node.as_ref() });\n        }\n        prev\n    }\n}\n\n/// This is a set of pointers with metadata into a location in the list needed\n/// to skip ahead, delete and insert in items. A cursor is reasonably heavy\n/// weight - we fill in and maintain as many entries as the height of the list\n/// dictates.\n///\n/// This is not needed for simply iterating sequentially through nodes and data.\n/// For that look at NodeIter.\n///\n/// Note most/all methods using cursors are unsafe. This is because cursors use\n/// raw mutable pointers into the list, so when used the following rules have to\n/// be followed:\n///\n/// - Whenever a write happens (insert/remove/replace), any cursor not passed to\n///   the write function is invalid.\n/// - While a cursor is held the SkipList struct should be considered pinned and\n///   must not be moved or deleted\n#[derive(Copy, Clone, Debug)]\nstruct Cursor<C: ListConfig> {\n    // TODO: Add a phantom lifetime reference to the skip list root for safety.\n\n    // This isn't strictly necessary. Earlier versions tacked this on to the\n    // last item in entries... I'm still not sure the cleanest way to do this.\n    userpos: usize,\n\n    entries: [SkipEntry<C>; MAX_HEIGHT],\n}\n\nimpl<C: ListConfig> Cursor<C> {\n    fn update_offsets(&mut self, height: usize, by: isize) {\n        for i in 0..height {\n            unsafe {\n                // This is weird but makes sense when you realise the nexts in\n                // the cursor are pointers into the elements that have the\n                // actual pointers.\n                // Also adding a usize + isize is awful in rust :/\n                let skip = &mut (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n                *skip = skip.wrapping_add(by as usize);\n            }\n        }\n    }\n\n    /// Move a cursor to the start of the next node. Returns the new node (or a\n    /// nullptr if this is the end of the list).\n    fn advance_node(&mut self) -> *mut Node<C> {\n        unsafe {\n            let SkipEntry { node: e, skip_usersize: offset } = self.entries[0];\n            // offset tells us how far into the current element we are (in\n            // usersize). We need to increment the offsets by the entry's\n            // remaining length to get to the start of the next node.\n            let advance_by = (*e).get_userlen() - offset;\n            let next = (*e).get_next_ptr();\n            let height = (*next).height as usize;\n\n            for i in 0..height {\n                self.entries[i] = SkipEntry {\n                    node: next,\n                    skip_usersize: 0\n                };\n            }\n\n            for i in height..self.entries.len() {\n                self.entries[i].skip_usersize += advance_by;\n            }\n\n            self.userpos += advance_by;\n\n            next\n        }\n    }\n\n    /// Get the pointer to the cursor's current node\n    fn here_ptr(&self) -> *mut Node<C> {\n        self.entries[0].node\n    }\n}\n\nimpl<C: ListConfig> PartialEq for Cursor<C> {\n    fn eq(&self, other: &Self) -> bool {\n        if self.userpos != other.userpos { return false; }\n        for i in 0..MAX_HEIGHT {\n            let a = &self.entries[i];\n            let b = &other.entries[i];\n            if a.node != b.node || a.skip_usersize != b.skip_usersize { return false; }\n        }\n        true\n    }\n}\nimpl<C: ListConfig> Eq for Cursor<C> {}\n\nimpl<C: ListConfig> SkipList<C> {\n    pub fn new() -> Self {\n        SkipList::<C> {\n            num_items: 0,\n            num_usercount: 0,\n            rng: SmallRng::seed_from_u64(123),\n            head: Node {\n                items: [C::Item::default(); NODE_NUM_ITEMS],\n                num_items: 0,\n                height: 1, // Stores max height of list nodes\n                nexts: [],\n            },\n            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n        }\n    }\n\n    pub fn new_from_slice(s: &[C::Item]) -> Self {\n        let mut rope = Self::new();\n        rope.insert_at(0, s);\n        rope\n    }\n\n    pub fn get_userlen(&self) -> usize {\n        self.num_usercount\n    }\n\n    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n    \n    pub fn len_items(&self) -> usize {\n        self.num_items as usize\n    }\n\n    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), self._nexts_padding.len())\n        }\n    }\n\n    /// Walk the list and validate internal constraints. This is used for\n    /// testing the structure itself, and should generally not be called by\n    /// users.\n    pub fn check(&self) {\n        // #[cfg(test)]\n        {\n            assert!(self.head.height >= 1);\n            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n            // let skip_over = self.get_top_entry();\n            // println!(\"Skip over skip chars {}, num bytes {}\", skip_over.skip_items, self.num_bytes);\n\n            let mut iter = [SkipEntry {\n                // Bleh.\n                node: &self.head as *const Node<C> as *mut Node<C>,\n                // The skips will store the total distance travelled since the\n                // start of this traversal at each height. All the entries above\n                // head.height are ignored though.\n                skip_usersize: 0\n            }; MAX_HEIGHT];\n\n            let mut num_items = 0;\n            let mut num_usercount = 0;\n\n            for n in self.iter() {\n                // println!(\"visiting {:?}\", n.as_str());\n                assert!((n as *const Node<C> == &self.head as *const Node<C>) || n.num_items > 0);\n                assert!(n.height <= MAX_HEIGHT_U8);\n                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n                // Make sure the number of items matches the count\n                let local_count = C::userlen_of_slice(&n.items[0..n.num_items as usize]);\n                assert_eq!(local_count, n.get_userlen());\n\n                // assert_eq!(n.as_str().chars().count(), n.num_chars());\n                for (i, entry) in iter[0..n.height as usize].iter_mut().enumerate() {\n                    assert_eq!(entry.node as *const Node<C>, n as *const Node<C>);\n                    assert_eq!(entry.skip_usersize, num_usercount);\n\n                    // println!(\"replacing entry {:?} with {:?}\", entry, n.nexts()[i].node);\n                    entry.node = n.nexts()[i].node;\n                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n                }\n\n                num_items += n.num_items as usize;\n                num_usercount += n.get_userlen();\n            }\n\n            for entry in iter[0..self.head.height as usize].iter() {\n                // println!(\"{:?}\", entry);\n                assert!(entry.node.is_null());\n                assert_eq!(entry.skip_usersize, num_usercount);\n            }\n            \n            // println!(\"self bytes: {}, count bytes {}\", self.num_bytes, num_bytes);\n            assert_eq!(self.num_items, num_items);\n            assert_eq!(self.get_userlen(), num_usercount);\n        }\n    }\n    \n    \n    /// Internal function for creating a cursor at a particular location in the\n    /// skiplist. The returned cursor is a list of nodes which point past the\n    /// specified position, as well as offsets of how far into their character\n    /// lists the specified characters are.\n    /// \n    /// Note this does not calculate the index and offset in the current node.\n    ///\n    /// TODO: This should be Pin<&self>.\n    fn iter_at_userpos(&self, target_userpos: usize) -> Cursor<C> {\n        assert!(target_userpos <= self.get_userlen());\n\n        let mut e: *const Node<C> = &self.head;\n        let mut height = self.head.height as usize - 1;\n        \n        let mut offset = target_userpos; // How many more items to skip\n\n        // We're populating the head node pointer to simplify the case when the\n        // iterator grows. We could put offset into the skip_usersize but it\n        // would only be *mostly* correct, not always correct. (Since cursor\n        // entries above height are not updated by insert.)\n        let mut cursor = Cursor {\n            entries: [SkipEntry {\n                node: &self.head as *const _ as *mut _,\n                skip_usersize: usize::MAX\n            }; MAX_HEIGHT],\n            userpos: target_userpos,\n        };\n\n        loop { // while height >= 0\n            let en = unsafe { &*e };\n            let next = en.nexts()[height];\n            let skip = next.skip_usersize;\n            if offset > skip {\n                // Go right.\n                debug_assert!(e == &self.head || en.num_items > 0);\n                offset -= skip;\n                e = next.node;\n                assert!(!e.is_null(), \"Internal constraint violation: Reached rope end prematurely\");\n            } else {\n                // Record this and go down.\n                cursor.entries[height] = SkipEntry {\n                    skip_usersize: offset,\n                    node: e as *mut Node<C>, // This is pretty gross\n                };\n\n                if height == 0 { break; } else { height -= 1; }\n            }\n        };\n\n        // We should always land within the node we're pointing to.\n        debug_assert!(offset <= unsafe { &*cursor.here_ptr() }.get_userlen());\n        cursor\n    }\n\n    // Internal fn to create a new node at the specified iterator filled with\n    // the specified content. The passed cursor should point at the end of the\n    // previous node. It will be updated to point to the end of the newly\n    // inserted content.\n    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, contents: &[C::Item], new_userlen: usize) {\n        // println!(\"Insert_node_at {} len {}\", contents.len(), self.num_bytes);\n        debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n        assert!(contents.len() <= NODE_NUM_ITEMS);\n\n        let new_node = Node::alloc(&mut self.rng);\n        (*new_node).num_items = contents.len() as u8;\n        (*new_node).items[..contents.len()].copy_from_slice(contents);\n        let new_height = (*new_node).height;\n\n        let mut head_height = self.head.height as usize;\n        let new_height_usize = new_height as usize;\n        while head_height < new_height_usize {\n            // This seems weird given we're about to overwrite these values\n            // below. What we're doing is retroactively setting up the cursor\n            // and head pointers *as if* the height had been this high all\n            // along. This way we only have to populate the higher head values\n            // lazily.\n            let total_userlen = self.num_usercount;\n            let nexts = self.heads_mut();\n            nexts[head_height].skip_usersize = total_userlen;\n            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n            head_height += 1; // This is ugly.\n            self.head.height += 1;\n        }\n\n        for i in 0..new_height_usize {\n            let prev_skip = &mut (*cursor.entries[i].node).nexts_mut()[i];\n            let new_nexts = (*new_node).nexts_mut();\n\n            // The new node points to the successor (or null)\n            new_nexts[i] = SkipEntry {\n                node: prev_skip.node,\n                skip_usersize: new_userlen + prev_skip.skip_usersize - cursor.entries[i].skip_usersize\n            };\n\n            // The previous node points to the new node\n            *prev_skip = SkipEntry {\n                node: new_node,\n                skip_usersize: cursor.entries[i].skip_usersize\n            };\n\n            // Move the iterator to the end of the newly inserted node.\n            cursor.entries[i] = SkipEntry {\n                node: new_node,\n                skip_usersize: new_userlen\n            };\n        }\n\n        for i in new_height_usize..head_height {\n            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += new_userlen;\n            cursor.entries[i].skip_usersize += new_userlen;\n        }\n\n        self.num_items += contents.len();\n        self.num_usercount += new_userlen;\n        cursor.userpos += new_userlen;\n    }\n\n    unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, mut item_idx: usize, contents: &[C::Item]) {\n        // iter specifies where to insert.\n\n        let mut e = cursor.here_ptr();\n        // The insertion offset into the destination node.\n        assert!(cursor.userpos <= self.num_usercount);\n        assert!(item_idx <= (*e).num_items as usize);\n\n        // We might be able to insert the new data into the current node, depending on\n        // how big it is.\n        let num_inserted_items = contents.len();\n        let num_inserted_usercount = C::userlen_of_slice(contents);\n\n        // Can we insert into the current node?\n        let mut insert_here = (*e).num_items as usize + num_inserted_items <= NODE_NUM_ITEMS;\n\n        // Can we insert into the start of the successor node?\n        if !insert_here && item_idx == (*e).num_items as usize && num_inserted_items <= NODE_NUM_ITEMS {\n            // We can insert into the subsequent node if:\n            // - We can't insert into the current node\n            // - There _is_ a next node to insert into\n            // - The insert would be at the start of the next node\n            // - There's room in the next node\n            if let Some(next) = (*e).first_skip_entry_mut().node.as_mut() {\n                if next.num_items as usize + num_inserted_items <= NODE_NUM_ITEMS {\n                    item_idx = 0;\n                    cursor.advance_node();\n                    e = next;\n\n                    insert_here = true;\n                }\n            }\n        }\n\n        let e_num_items = (*e).num_items as usize; // convenience.\n\n        if insert_here {\n            // println!(\"insert_here {}\", contents);\n            // First push the current items later in the array\n            let c = &mut (*e).items;\n            if item_idx < e_num_items {\n                c[..].copy_within(item_idx..e_num_items,\n                    item_idx + num_inserted_items);\n            }\n\n            // Then copy in the new items\n            c[item_idx..item_idx + num_inserted_items].copy_from_slice(contents);\n\n            (*e).num_items += num_inserted_items as u8;\n            self.num_items += num_inserted_items;\n            self.num_usercount += num_inserted_usercount;\n\n            // .... aaaand update all the offset amounts.\n            cursor.update_offsets(self.head.height as usize, num_inserted_usercount as isize);\n\n            // TODO: For consistency we might want to think about updating the\n            // iterator here.\n        } else {\n            // There isn't room. We'll need to add at least one new node to the\n            // list. We could be a bit more careful here and copy as much as\n            // possible into the current node - that would decrease the number\n            // of new nodes in some cases, but I don't think the performance\n            // difference will be large enough to justify the complexity.\n\n            // If we're not at the end of the current node, we'll need to remove\n            // the end of the current node's data and reinsert it later.\n            let num_end_items = e_num_items - item_idx;\n\n            let (end_items, end_usercount) = if num_end_items > 0 {\n                // We'll mark the items as deleted from the node, while leaving\n                // the data itself there for now to avoid a copy.\n\n                // Note that if we wanted to, it would also be correct (and\n                // slightly more space efficient) to pack some of the new\n                // string's characters into this node after trimming it.\n                let end_items = &(*e).items[item_idx..e_num_items];\n                (*e).num_items = item_idx as u8;\n                let end_usercount = (*e).get_userlen() - cursor.entries[0].skip_usersize;\n\n                cursor.update_offsets(self.head.height as usize, -(end_usercount as isize));\n\n                // We need to trim the size off because we'll add the characters\n                // back with insert_node_at.\n                self.num_usercount -= end_usercount;\n                self.num_items -= num_end_items;\n\n                (Some(end_items), end_usercount)\n            } else {\n                (None, 0)\n            };\n\n            // Now we insert new nodes containing the new character data. The\n            // data is broken into pieces with a maximum size of NODE_NUM_ITEMS.\n            // As further optimization, we could try and fit the last piece into\n            // the start of the subsequent node. That optimization hasn't been\n            // added.\n            \n            for chunk in contents.chunks(NODE_NUM_ITEMS) {\n                let userlen = C::userlen_of_slice(chunk);\n                self.insert_node_at(cursor, chunk, userlen);\n            }\n\n            // TODO: Consider recursively calling insert_at_iter() here instead\n            // of making a whole new node for the remaining content.\n            if let Some(end_items) = end_items {\n                self.insert_node_at(cursor, end_items, end_usercount);\n            }\n        }\n    }\n\n    /// Interestingly unlike the original, here we only care about specifying\n    /// the number of removed items by counting them. We do not use usersize in\n    /// the deleted item count.\n    ///\n    /// If the deleted content occurs at the start of a node, the cursor passed\n    /// here must point to the end of the previous node, not the start of the\n    /// current node.\n    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut item_idx: usize, mut num_deleted_items: usize) {\n        if num_deleted_items == 0 { return; }\n\n        let mut e = cursor.here_ptr();\n        while num_deleted_items > 0 {\n            if item_idx == (*e).num_items as usize {\n                let entry = (*e).first_skip_entry();\n                // End of current node. Skip to the start of the next one. We're\n                // intentionally not updating the iterator because if we delete\n                // a whole node we need the iterator to point to the previous\n                // element. And if we only delete here, the iterator doesn't\n                // need to be moved.\n                e = entry.node;\n                if e.is_null() { panic!(\"Cannot delete past the end of the list\"); }\n                item_idx = 0;\n            }\n\n            let e_num_items = (*e).num_items as usize;\n            let removed_here = min(num_deleted_items, e_num_items - item_idx);\n            \n            let height = (*e).height as usize;\n            let removed_userlen;\n\n            if removed_here < e_num_items || e as *const _ == &self.head as *const _ {\n                // Just trim the node down.\n                let trailing_items = e_num_items - item_idx - removed_here;\n                \n                let c = &mut (*e).items;\n                removed_userlen = C::userlen_of_slice(&c[item_idx..item_idx + removed_here]);\n                if trailing_items > 0 {\n                    c[..].copy_within(item_idx + removed_here..e_num_items, item_idx);\n                }\n\n                (*e).num_items -= removed_here as u8;\n                self.num_items -= removed_here;\n                self.num_usercount -= removed_userlen;\n\n                for s in (*e).nexts_mut() {\n                    s.skip_usersize -= removed_userlen;\n                }\n            } else {\n                // Remove the node from the skip list entirely. e should be the\n                // next node after the position of the iterator.\n                assert_ne!(cursor.here_ptr(), e);\n\n                removed_userlen = (*e).get_userlen();\n                let next = (*e).first_skip_entry().node;\n\n                for i in 0..(*e).height as usize {\n                    let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n                    s.node = (*e).nexts_mut()[i].node;\n                    s.skip_usersize += (*e).nexts()[i].skip_usersize - removed_userlen;\n                }\n\n                self.num_items -= (*e).num_items as usize;\n                self.num_usercount -= removed_userlen;\n\n                Node::free(e);\n                e = next;\n            }\n\n            for i in height..self.head.height as usize {\n                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n                s.skip_usersize -= removed_userlen;\n            }\n\n            num_deleted_items -= removed_here;\n        }\n    }\n\n    pub fn replace_at(&mut self, mut start_userpos: usize, mut removed_items: usize, mut inserted_content: &[C::Item]) {\n        if removed_items == 0 && inserted_content.len() == 0 { return; }\n\n        // For validation. This is where the cursor should end up.\n        // let expected_final_position = start_userpos + inserted_content.len() - removed_items;\n\n        start_userpos = min(start_userpos, self.get_userlen());\n\n        let mut cursor = self.iter_at_userpos(start_userpos);\n        let (mut index, offset) = unsafe { &*cursor.here_ptr() }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n        // Replace as many items from removed_items as we can with inserted_content.\n        unsafe {\n            let mut replaced_items = min(removed_items, inserted_content.len());\n            removed_items -= replaced_items;\n\n            while replaced_items > 0 {\n                let mut e = cursor.here_ptr();\n                if index == (*e).num_items as usize {\n                    // Move to the next item.\n                    e = cursor.advance_node();\n                    if e.is_null() { panic!(\"Cannot replace past the end of the list\"); }\n                    index = 0;\n                }\n\n                let e_num_items = (*e).num_items as usize;\n                let replaced_items_here = min(replaced_items, e_num_items - index);\n\n                let old_items = &mut (*e).items[index..index + replaced_items_here];\n                let new_items = &inserted_content[0..replaced_items_here];\n\n                // Replace the items themselves.\n                old_items.copy_from_slice(new_items);\n\n                // And bookkeeping. Bookkeeping forever.\n                let new_usersize = C::userlen_of_slice(new_items);\n                let usersize_delta = new_usersize as isize - C::userlen_of_slice(old_items) as isize;\n                if usersize_delta != 0 {\n                    cursor.update_offsets(self.head.height as usize, usersize_delta)\n                }\n\n                inserted_content = &inserted_content[replaced_items_here..];\n                replaced_items -= replaced_items_here;\n                // We'll hop to the next Node at the start of the next loop\n                // iteration if needed.\n                index += replaced_items_here;\n\n                for i in 0..self.head.height as usize {\n                    cursor.entries[i].skip_usersize += new_usersize;\n                }\n                cursor.userpos += new_usersize;\n            }\n\n            // Ok now one of two things must be true. Either we've run out of\n            // items to remove, or we've run out of items to insert.\n            if inserted_content.len() > 0 {\n                // Insert!\n                debug_assert!(removed_items == 0);\n                self.insert_at_iter(&mut cursor, index, inserted_content);\n            } else if removed_items > 0 {\n                self.del_at_iter(&mut cursor, index, removed_items);\n            }\n        }\n\n        // TODO: Assert that the iterator is after replaced content.\n        // #[cfg(debug_assertions)] {\n        //     let c2 = self.iter_at_userpos(expected_final_position);\n        //     if &cursor != &c2 { panic!(\"Invalid cursor after replace\"); }\n        // }\n    }\n\n    pub fn insert_at(&mut self, mut userpos: usize, contents: &[C::Item]) {\n        if contents.len() == 0 { return; }\n        \n        userpos = min(userpos, self.get_userlen());\n        let mut cursor = self.iter_at_userpos(userpos);\n        let (index, offset) = unsafe { &*cursor.here_ptr() }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n        unsafe { self.insert_at_iter(&mut cursor, index, contents); }\n\n        #[cfg(debug_assertions)] {\n            let c2 = self.iter_at_userpos(userpos + C::userlen_of_slice(contents));\n            if &cursor != &c2 { panic!(\"Invalid cursor after insert\"); }\n        }\n        // TODO: Assert that the iterator now points after removed content.\n    }\n\n    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n        userpos = min(userpos, self.get_userlen());\n        // We can't easily trim num_items.\n        // num_items = min(length, self.num_chars() - pos);\n        if num_items == 0 { return; }\n\n        let mut cursor = self.iter_at_userpos(userpos);\n        let (index, offset) = unsafe { &*cursor.here_ptr() }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n        unsafe { self.del_at_iter(&mut cursor, index, num_items); }\n        // TODO: Assert that the iterator remains where it was.\n    }\n}\n\n\nimpl<C: ListConfig> SkipList<C> where C::Item: PartialEq {\n    pub fn eq_list(&self, other: &[C::Item]) -> bool {\n        let mut pos = 0;\n        let other_len = other.len();\n\n        for node in self.iter() {\n            let my_data = node.content_slice();\n            let my_len = my_data.len();\n\n            if pos + my_len > other_len || my_data != &other[pos..pos + my_data.len()] {\n                return false\n            }\n            pos += my_data.len();\n        }\n\n        return pos == other_len;\n    }\n}\n\nimpl<C: ListConfig> Drop for SkipList<C> {\n    fn drop(&mut self) {\n        let mut node = self.head.first_skip_entry().node;\n        unsafe {\n            while !node.is_null() {\n                let next = (*node).first_skip_entry().node;\n                Node::free(node);\n                node = next;\n            }\n        }\n    }\n}\n\n\nimpl<C: ListConfig> From<&[C::Item]> for SkipList<C> {\n    fn from(s: &[C::Item]) -> SkipList<C> {\n        SkipList::new_from_slice(s)\n    }\n}\n\nimpl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> {\n    fn from(s: Vec<C::Item>) -> SkipList<C> {\n        SkipList::new_from_slice(s.as_slice())\n    }\n}\n\nimpl<C: ListConfig> Into<Vec<C::Item>> for &SkipList<C> {\n    fn into(self) -> Vec<C::Item> {\n        let mut content = Vec::with_capacity(self.num_items);\n\n        for node in self.iter() {\n            content.extend(node.content_slice().iter());\n        }\n\n        content\n    }\n}\n\nimpl<C: ListConfig> SkipList<C> where C::Item: std::fmt::Debug {\n    // TODO: Don't export this.\n    pub fn print(&self) {\n        println!(\"items: {}\\tuserlen: {}, height: {}\", self.num_items, self.get_userlen(), self.head.height);\n\n        print!(\"HEAD:\");\n        for s in self.head.nexts() {\n            print!(\" |{} \", s.skip_usersize);\n        }\n        println!(\"\");\n\n        for (i, node) in self.iter().enumerate() {\n            print!(\"{}:\", i);\n            for s in node.nexts() {\n                print!(\" |{} \", s.skip_usersize);\n            }\n            println!(\"      : {:?}\", node.content_slice());\n        }\n    }\n}\n\n// impl<T: Default + Copy, F: Fn(&T) -> usize> PartialEq for SkipList<T, F> {\n//     // This is quite complicated. It would be cleaner to just write a bytes\n//     // iterator, then iterate over the bytes of both strings comparing along the\n//     // way.\n//     // However, this should be faster because it can memcmp().\n\n//     // Another way to implement this would be to rewrite it as a comparison with\n//     // an iterator over &str. Then the rope vs rope comparison would be trivial,\n//     // but also we could add comparison functions with a single &str and stuff\n//     // very easily.\n//     fn eq(&self, other: &SkipList<T, F>) -> bool {\n//         if self.num_items != other.num_items\n//                 || self.num_chars() != other.num_chars() {\n//             return false\n//         }\n\n//         let mut other_iter = other.iter().map(|n| { n.as_str() });\n\n//         let mut os = other_iter.next();\n//         let mut opos: usize = 0; // Byte offset in os.\n//         for n in self.iter() {\n//             let s = n.as_str();\n//             let mut pos: usize = 0; // Current byte offset in s\n//             debug_assert_eq!(s.len(), n.num_bytes as usize);\n\n//             // Walk s.len() bytes through the other rope\n//             while pos < n.num_bytes as usize {\n//                 if let Some(oss) = os {\n//                     let amt = min(s.len() - pos, oss.len() - opos);\n//                     // println!(\"iter slen {} pos {} osslen {} amt {}\", s.len(), pos, oss.len(), amt);\n\n//                     if &s[pos..pos+amt] != &oss[opos..opos+amt] {\n//                         return false\n//                     }\n\n//                     pos += amt;\n//                     opos += amt;\n//                     debug_assert!(opos <= oss.len());\n\n//                     if opos == oss.len() {\n//                         os = other_iter.next();\n//                         opos = 0;\n//                     }\n//                 } else {\n//                     panic!(\"Internal string length does not match\");\n//                 }\n//             }\n//         }\n\n//         true\n//     }\n// }\n// impl<T: Default + Copy, F: Fn(&T) -> usize> Eq for SkipList<T, F> {}\n\n// impl<T: Default + Copy, F> Clone for SkipList<T, F> where F: Fn(&T) -> usize {\n//     fn clone(&self) -> Self {\n//         let mut r = SkipList::new(self.get_usersize);\n//         r.num_items = self.num_items;\n//         let head_str = self.head.as_str();\n//         r.head.items[..head_str.len()].copy_from_slice(head_str.as_bytes());\n//         r.head.num_bytes = self.head.num_bytes;\n//         r.head.height = self.head.height;\n        \n//         {\n//             // I could just edit the overflow memory directly, but this is safer\n//             // because of aliasing rules.\n//             let head_nexts = r.head.nexts_mut();\n//             for i in 0..self.head.height as usize {\n//                 head_nexts[i].skip_items = self.nexts[i].skip_items;\n//             }\n//         }\n\n//         let mut nodes = [&mut r.head as *mut Node; MAX_HEIGHT];\n\n//         // The first node the iterator will return is the head. Ignore it.\n//         let mut iter = self.iter();\n//         iter.next();\n//         for other in iter {\n//             // This also sets height.\n//             let height = other.height;\n//             let node = Node::alloc_with_height(height);\n//             unsafe {\n//                 (*node).num_bytes = other.num_bytes;\n//                 let len = other.num_bytes as usize;\n//                 (*node).items[..len].copy_from_slice(&other.items[..len]);\n\n//                 let other_nexts = other.nexts();\n//                 let nexts = (*node).nexts_mut();\n//                 for i in 0..height as usize {\n//                     nexts[i].skip_items = other_nexts[i].skip_items;\n//                     (*nodes[i]).nexts_mut()[i].node = node;\n//                     nodes[i] = node;\n//                 }\n//             }\n//         }\n\n//         r\n//     }\n// }\n");
  (25738, 108, "");
  (25738, 0, "\n            ");
  (25747, 4, "");
  (25743, 4, "");
  (25739, 4, "");
  (25738, 1, "");
  (25737, 1, "");
  (25737, 0, "\n            ");
  (25750, 0, "/");
  (25751, 0, "/");
  (25752, 0, " ");
  (25753, 0, "T");
  (25754, 0, "h");
  (25755, 0, "i");
  (25756, 0, "s");
  (25757, 0, " ");
  (25758, 0, "i");
  (25759, 0, "s");
  (25760, 0, " ");
  (25761, 0, "s");
  (25762, 0, "u");
  (25762, 1, "");
  (25761, 1, "");
  (25761, 0, "u");
  (25762, 0, "s");
  (25763, 0, "u");
  (25764, 0, "a");
  (25765, 0, "l");
  (25766, 0, "l");
  (25767, 0, "y");
  (25768, 0, " ");
  (25769, 0, "n");
  (25770, 0, "o");
  (25771, 0, "t");
  (25772, 0, " ");
  (25773, 0, "n");
  (25774, 0, "e");
  (25775, 0, "e");
  (25776, 0, "d");
  (25777, 0, "e");
  (25778, 0, "d");
  (25779, 0, ",");
  (25780, 0, " ");
  (25781, 0, "s");
  (25782, 0, "o");
  (25783, 0, " ");
  (25784, 0, "i");
  (25785, 0, "t");
  (25786, 0, " ");
  (25787, 0, "f");
  (25788, 0, "e");
  (25789, 0, "e");
  (25790, 0, "l");
  (25791, 0, "s");
  (25792, 0, " ");
  (25793, 0, "l");
  (25794, 0, "i");
  (25795, 0, "k");
  (25796, 0, "e");
  (25797, 0, " ");
  (25798, 0, "a");
  (25799, 0, " ");
  (25800, 0, "b");
  (25801, 0, "i");
  (25802, 0, "t");
  (25803, 0, " ");
  (25804, 0, "o");
  (25805, 0, "f");
  (25806, 0, " ");
  (25807, 0, "a");
  (25808, 0, " ");
  (25809, 0, "w");
  (25810, 0, "a");
  (25811, 0, "s");
  (25812, 0, "t");
  (25813, 0, "e");
  (25814, 0, " ");
  (25815, 0, "o");
  (25816, 0, "f");
  (25817, 0, " ");
  (25818, 0, "C");
  (25819, 0, "P");
  (25820, 0, "U");
  (25821, 0, " ");
  (25822, 0, "a");
  (25823, 0, "n");
  (25824, 0, "d");
  (25825, 0, " ");
  (25826, 0, "c");
  (25827, 0, "o");
  (25828, 0, "m");
  (25829, 0, "p");
  (25830, 0, "l");
  (25831, 0, "e");
  (25832, 0, "x");
  (25833, 0, "i");
  (25821, 13, ",");
  (25822, 0, " ");
  (25823, 0, "b");
  (25824, 0, "u");
  (25753, 72, "U");
  (25754, 0, "p");
  (25755, 0, "d");
  (25756, 0, "a");
  (25757, 0, "t");
  (25758, 0, "i");
  (25759, 0, "n");
  (25760, 0, "g");
  (25761, 0, " ");
  (25762, 0, "t");
  (25763, 0, "h");
  (25764, 0, "e");
  (25765, 0, " ");
  (25766, 0, "c");
  (25767, 0, "u");
  (25768, 0, "r");
  (25769, 0, "s");
  (25770, 0, "o");
  (25771, 0, "r");
  (25772, 0, " ");
  (25773, 0, "a");
  (25774, 0, "f");
  (25775, 0, "t");
  (25776, 0, "e");
  (25777, 0, "r");
  (25778, 0, " ");
  (25779, 0, "t");
  (25780, 0, "h");
  (25781, 0, "e");
  (25782, 0, " ");
  (25783, 0, "o");
  (25784, 0, "p");
  (25785, 0, "e");
  (25786, 0, "r");
  (25787, 0, "a");
  (25788, 0, "t");
  (25789, 0, "i");
  (25790, 0, "o");
  (25791, 0, "n");
  (25792, 0, " ");
  (25793, 0, "d");
  (25793, 1, "");
  (25793, 0, "f");
  (25794, 0, "e");
  (25795, 0, "e");
  (25796, 0, "l");
  (25797, 0, "s");
  (25798, 0, " ");
  (25799, 0, "a");
  (25800, 0, " ");
  (25801, 0, "b");
  (25802, 0, "i");
  (25803, 0, "t");
  (25804, 0, " ");
  (25805, 0, "e");
  (25806, 0, "x");
  (25807, 0, "c");
  (25808, 0, "e");
  (25809, 0, "s");
  (25810, 0, "s");
  (25811, 0, "i");
  (25812, 0, "v");
  (25813, 0, "e");
  (25814, 0, ",");
  (25815, 0, " ");
  (25816, 0, "b");
  (25817, 0, "u");
  (25818, 0, "t");
  (25819, 0, " ");
  (25820, 0, "i");
  (25821, 0, "t");
  (25822, 0, "s");
  (25823, 0, " ");
  (25824, 0, "i");
  (25825, 0, "m");
  (25826, 0, "p");
  (25827, 0, "o");
  (25828, 0, "r");
  (25829, 0, "t");
  (25830, 0, "a");
  (25831, 0, "n");
  (25832, 0, "t");
  (25833, 0, " ");
  (25752, 82, " ");
  (25753, 0, "U");
  (25754, 0, "s");
  (25755, 0, "u");
  (25756, 0, "a");
  (25757, 0, "l");
  (25758, 0, "l");
  (25759, 0, "y");
  (25760, 0, " ");
  (25761, 0, "t");
  (25762, 0, "h");
  (25763, 0, "e");
  (25764, 0, " ");
  (25765, 0, "c");
  (25766, 0, "u");
  (25767, 0, "r");
  (25768, 0, "s");
  (25769, 0, "o");
  (25770, 0, "r");
  (25771, 0, " ");
  (25772, 0, "w");
  (25773, 0, "i");
  (25774, 0, "l");
  (25775, 0, "l");
  (25776, 0, " ");
  (25777, 0, "b");
  (25778, 0, "e");
  (25779, 0, " ");
  (25780, 0, "d");
  (25781, 0, "i");
  (25782, 0, "s");
  (25783, 0, "c");
  (25784, 0, "a");
  (25785, 0, "r");
  (25786, 0, "d");
  (25787, 0, "e");
  (25788, 0, "d");
  (25789, 0, " ");
  (25790, 0, "a");
  (25791, 0, "f");
  (25792, 0, "t");
  (25793, 0, "e");
  (25794, 0, "r");
  (25795, 0, " ");
  (25796, 0, "o");
  (25797, 0, "n");
  (25798, 0, "e");
  (25799, 0, " ");
  (25800, 0, "c");
  (25801, 0, "h");
  (25802, 0, "a");
  (25803, 0, "n");
  (25804, 0, "g");
  (25805, 0, "e");
  (25806, 0, ",");
  (25807, 0, " ");
  (25808, 0, "b");
  (25809, 0, "u");
  (25810, 0, "t");
  (25811, 0, " ");
  (25812, 0, "f");
  (25813, 0, "o");
  (25814, 0, "r");
  (25815, 0, " ");
  (25816, 0, "c");
  (25817, 0, "o");
  (25818, 0, "m");
  (25819, 0, "p");
  (25820, 0, "o");
  (25821, 0, "u");
  (25822, 0, "n");
  (25823, 0, "d");
  (25824, 0, " ");
  (25825, 0, "e");
  (25826, 0, "d");
  (25827, 0, "i");
  (25828, 0, "t");
  (25829, 0, "s");
  (25830, 0, " ");
  (25831, 0, "i");
  (25832, 0, "t");
  (25833, 0, "s");
  (25834, 0, " ");
  (25835, 0, "i");
  (25836, 0, "m");
  (25837, 0, "p");
  (25838, 0, "o");
  (25839, 0, "r");
  (25840, 0, "t");
  (25841, 0, "a");
  (25842, 0, "n");
  (25843, 0, "t");
  (25844, 0, " ");
  (25845, 0, "t");
  (25846, 0, "h");
  (25847, 0, "e");
  (25848, 0, " ");
  (25849, 0, "p");
  (25850, 0, "a");
  (25851, 0, "s");
  (25852, 0, "s");
  (25853, 0, "e");
  (25854, 0, "d");
  (25855, 0, " ");
  (25856, 0, "c");
  (25857, 0, "u");
  (25858, 0, "r");
  (25859, 0, "s");
  (25860, 0, "o");
  (25861, 0, "r");
  (25812, 50, "f");
  (25813, 0, "o");
  (25814, 0, "r");
  (25815, 0, " ");
  (25816, 0, "c");
  (25817, 0, "o");
  (25818, 0, "n");
  (25819, 0, "s");
  (25820, 0, "i");
  (25821, 0, "s");
  (25822, 0, "t");
  (25823, 0, "e");
  (25824, 0, "n");
  (25825, 0, "c");
  (25826, 0, "y");
  (25827, 0, " ");
  (25828, 0, "o");
  (25829, 0, "f");
  (25830, 0, " ");
  (25831, 0, "c");
  (25832, 0, "o");
  (25833, 0, "m");
  (25834, 0, "p");
  (25835, 0, "o");
  (25836, 0, "u");
  (25837, 0, "n");
  (25838, 0, "d");
  (25839, 0, " ");
  (25840, 0, "e");
  (25841, 0, "d");
  (25842, 0, "i");
  (25843, 0, "r");
  (25844, 0, "s");
  (25845, 0, " ");
  (25845, 1, "");
  (25844, 1, "");
  (25843, 1, "");
  (25843, 0, "t");
  (25844, 0, "s");
  (25845, 0, " ");
  (25846, 0, "w");
  (25847, 0, "e");
  (25848, 0, " ");
  (25848, 1, "");
  (25848, 0, " ");
  (25849, 0, "k");
  (25850, 0, "e");
  (25851, 0, "e");
  (25852, 0, "p");
  (25853, 0, " ");
  (25854, 0, "t");
  (25855, 0, "h");
  (25856, 0, "e");
  (25857, 0, " ");
  (25858, 0, "c");
  (25859, 0, "u");
  (25860, 0, "r");
  (25861, 0, "s");
  (25862, 0, "o");
  (25846, 17, "w");
  (25847, 0, "e");
  (25848, 0, "'");
  (25849, 0, "l");
  (25850, 0, "l");
  (25851, 0, " ");
  (25852, 0, "u");
  (25853, 0, "p");
  (25854, 0, "d");
  (25855, 0, "a");
  (25856, 0, "t");
  (25857, 0, "e");
  (25858, 0, " ");
  (25859, 0, "t");
  (25860, 0, "h");
  (25861, 0, "e");
  (25862, 0, " ");
  (25863, 0, "c");
  (25864, 0, "u");
  (25865, 0, "r");
  (25866, 0, "s");
  (25867, 0, "o");
  (25868, 0, "r");
  (25869, 0, " ");
  (25870, 0, "t");
  (25871, 0, "o");
  (25872, 0, " ");
  (25873, 0, "p");
  (25874, 0, "o");
  (25875, 0, "i");
  (25876, 0, "n");
  (25877, 0, "t");
  (25878, 0, " ");
  (25879, 0, "t");
  (25880, 0, "o");
  (25881, 0, "t");
  (25882, 0, " ");
  (25882, 1, "");
  (25881, 1, "");
  (25881, 0, " ");
  (25882, 0, "t");
  (25883, 0, "h");
  (25884, 0, "e");
  (25885, 0, " ");
  (25886, 0, "e");
  (25887, 0, "n");
  (25888, 0, "d");
  (25889, 0, " ");
  (25890, 0, "o");
  (25891, 0, "f");
  (25892, 0, " ");
  (25893, 0, "t");
  (25894, 0, "h");
  (25895, 0, "e");
  (25896, 0, " ");
  (25897, 0, "n");
  (25898, 0, "o");
  (25899, 0, "e");
  (25899, 1, "");
  (25898, 1, "");
  (25898, 0, "e");
  (25899, 0, "w");
  (25900, 0, " ");
  (25901, 0, "c");
  (25902, 0, "o");
  (25903, 0, "n");
  (25904, 0, "t");
  (25905, 0, "e");
  (25906, 0, "n");
  (25907, 0, "t");
  (25908, 0, ".");
  (25738, 171, "            // Usually the cursor will be discarded after one change, but for\n            // consistency of compound edits we'll update the cursor to point to\n            // the end of the new content.");
  (25939, 0, "\n            ");
  (25952, 0, "c");
  (25953, 0, "u");
  (25954, 0, "r");
  (25955, 0, "s");
  (25956, 0, "o");
  (25957, 0, "r");
  (25958, 0, ".");
  (25952, 7, "");
  (25952, 0, "c");
  (25953, 0, "u");
  (25954, 0, "r");
  (25955, 0, "s");
  (25956, 0, "o");
  (25957, 0, "r");
  (25958, 0, ".");
  (25959, 0, "userpos");
  (25966, 0, " ");
  (25967, 0, "+");
  (25968, 0, "=");
  (25969, 0, " ");
  (25970, 0, "n");
  (25971, 0, "u");
  (25972, 0, "m");
  (25973, 0, "_");
  (25970, 4, "num_inserted_usercount");
  (25992, 0, ";");
  (25939, 0, "\n            ");
  (25952, 0, "f");
  (25953, 0, "o");
  (25954, 0, "r");
  (25955, 0, " ");
  (25956, 0, "_");
  (25957, 0, " ");
  (25958, 0, "i");
  (25959, 0, "n");
  (25960, 0, " ");
  (25956, 5, "e");
  (25957, 0, "n");
  (25958, 0, "t");
  (25959, 0, "r");
  (25960, 0, "y");
  (25956, 0, "&");
  (25957, 0, "m");
  (25958, 0, "u");
  (25959, 0, "t");
  (25960, 0, " ");
  (25966, 0, " ");
  (25967, 0, "i");
  (25968, 0, "n");
  (25969, 0, " ");
  (25970, 0, "c");
  (25971, 0, "u");
  (25972, 0, "r");
  (25973, 0, "s");
  (25974, 0, "o");
  (25975, 0, "r");
  (25976, 0, ".");
  (25977, 0, "entries");
  (25984, 0, " ");
  (25985, 0, "{");
  (25986, 0, "\n                ");
  (26003, 0, "\n                ");
  (25987, 16, "");
  (25988, 16, "            }");
  (25984, 0, "[");
  (25985, 0, "0");
  (25986, 0, ".");
  (25987, 0, ".");
  (25988, 0, "s");
  (25989, 0, "e");
  (25990, 0, "l");
  (25991, 0, "f");
  (25992, 0, ".");
  (25993, 0, "h");
  (25994, 0, "e");
  (25994, 1, "");
  (25993, 1, "");
  (25993, 0, "h");
  (25994, 0, "e");
  (25995, 0, "a");
  (25996, 0, "d");
  (25997, 0, ".");
  (25998, 0, "h");
  (25999, 0, "e");
  (26000, 0, "i");
  (26001, 0, "g");
  (26002, 0, "h");
  (26003, 0, "t");
  (26004, 0, " ");
  (26005, 0, "a");
  (26006, 0, "s");
  (26007, 0, " ");
  (26008, 0, "u");
  (26009, 0, "s");
  (26010, 0, "i");
  (26011, 0, "z");
  (26012, 0, "e");
  (26013, 0, ")");
  (26013, 1, "");
  (26013, 0, "]");
  (26017, 0, "                ");
  (26017, 16, "");
  (26014, 0, ".");
  (26015, 0, "i");
  (26016, 0, "t");
  (26017, 0, "e");
  (26018, 0, "r");
  (26019, 0, "(");
  (26020, 0, ")");
  (26019, 0, "_");
  (26020, 0, "m");
  (26021, 0, "u");
  (26022, 0, "t");
  (26028, 0, "                ");
  (26044, 0, "e");
  (26045, 0, "n");
  (26046, 0, "t");
  (26047, 0, "r");
  (26048, 0, "y");
  (26049, 0, ".");
  (26050, 0, "s");
  (26051, 0, "k");
  (26052, 0, "i");
  (26053, 0, "p");
  (26054, 0, "_");
  (26055, 0, "u");
  (26050, 6, "skip_usersize");
  (26063, 0, " ");
  (26064, 0, "+");
  (26065, 0, "=");
  (26066, 0, " ");
  (26067, 0, "num_inserted_usercount");
  (26089, 0, ";");
  (25956, 5, "");
  (1150, 3, "1");
  (1449, 2, "1");
  (1150, 1, "");
  (1150, 0, "2");
  (20926, 0, ",");
  (20927, 0, " ");
  (20928, 0, "m");
  (20929, 0, "o");
  (20930, 0, "v");
  (20931, 0, "e");
  (20932, 0, "_");
  (20933, 0, "c");
  (20934, 0, "u");
  (20935, 0, "r");
  (20936, 0, "s");
  (20937, 0, "o");
  (20938, 0, "r");
  (20939, 0, ":");
  (20940, 0, " ");
  (20941, 0, "b");
  (20942, 0, "o");
  (20943, 0, "o");
  (20944, 0, "l");
  (20941, 4, "bool");
  (22884, 0, "\n            ");
  (22897, 0, "f");
  (22897, 1, "");
  (22897, 0, "i");
  (22898, 0, "f");
  (22899, 0, " ");
  (22900, 0, "m");
  (22901, 0, "o");
  (22902, 0, "v");
  (22903, 0, "e");
  (22904, 0, "_");
  (22900, 5, "move_cursor");
  (22911, 0, " ");
  (22912, 0, "{");
  (23033, 12, "                ");
  (22990, 16, "                    ");
  (22958, 16, "                    ");
  (22914, 12, "                ");
  (23063, 0, "\n                ");
  (23064, 16, "            }");
  (23088, 0, "\n        ");
  (23097, 0, "i");
  (23098, 0, "f");
  (23099, 0, " ");
  (23100, 0, "m");
  (23101, 0, "o");
  (23102, 0, "v");
  (23103, 0, "e");
  (23100, 4, "move_cursor");
  (23111, 0, " ");
  (23112, 0, "{");
  (23306, 8, "            ");
  (23246, 12, "                ");
  (23163, 12, "                ");
  (23114, 8, "            ");
  (23331, 0, "\n            ");
  (23332, 12, "        }");
  (23113, 53, "");
  (23089, 8, "            ");
  (23089, 0, "        for i in new_height_usize..head_height {\n");
  (23166, 87, "");
  (23138, 12, "                ");
  (23138, 0, "            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += new_userlen;\n");
  (23341, 0, "\n            }");
  (23332, 8, "            ");
  (23318, 14, "");
  (23221, 16, "            ");
  (23328, 12, "        ");
  (28502, 0, ",");
  (28503, 0, " ");
  (28504, 0, "t");
  (28505, 0, "r");
  (28506, 0, "u");
  (28507, 0, "e");
  (28503, 5, "");
  (28502, 1, "");
  (28502, 0, ",");
  (28503, 0, " true");
  (28792, 0, ",");
  (28793, 0, " ");
  (28794, 0, "f");
  (28795, 0, "a");
  (28796, 0, "l");
  (28797, 0, "s");
  (28798, 0, "e");
  (28674, 0, "\n            ");
  (28687, 0, "/");
  (28688, 0, "/");
  (28689, 0, " ");
  (28675, 15, "");
  (28674, 1, "");
  (28723, 0, "\n                ");
  (28740, 0, "/");
  (28741, 0, "/");
  (28742, 0, " ");
  (28743, 0, "P");
  (28744, 0, "a");
  (28745, 0, "s");
  (28746, 0, "s");
  (28747, 0, "i");
  (28748, 0, "n");
  (28749, 0, "g");
  (28750, 0, " ");
  (28751, 0, "f");
  (28752, 0, "a");
  (28753, 0, "l");
  (28754, 0, "s");
  (28755, 0, "e");
  (28756, 0, " ");
  (28757, 0, "t");
  (28758, 0, "o");
  (28759, 0, " ");
  (28760, 0, "i");
  (28761, 0, "n");
  (28762, 0, "d");
  (28763, 0, "i");
  (28764, 0, "c");
  (28765, 0, "a");
  (28766, 0, "t");
  (28767, 0, "e");
  (28768, 0, " ");
  (28769, 0, "w");
  (28770, 0, "e");
  (28771, 0, " ");
  (28772, 0, "d");
  (28773, 0, "o");
  (28774, 0, "n");
  (28775, 0, "'");
  (28776, 0, "t");
  (28777, 0, " ");
  (28778, 0, "w");
  (28779, 0, "a");
  (28780, 0, "n");
  (28781, 0, "t");
  (28782, 0, " ");
  (28783, 0, "t");
  (28784, 0, "o");
  (28785, 0, " ");
  (28783, 3, "t");
  (28784, 0, "h");
  (28785, 0, "e");
  (28786, 0, " ");
  (28787, 0, "c");
  (28788, 0, "u");
  (28789, 0, "r");
  (28790, 0, "s");
  (28791, 0, "o");
  (28792, 0, "r");
  (28793, 0, " ");
  (28794, 0, "u");
  (28795, 0, "p");
  (28796, 0, "d");
  (28797, 0, "a");
  (28798, 0, "t");
  (28799, 0, "e");
  (28800, 0, "d");
  (28801, 0, " ");
  (28802, 0, "a");
  (28803, 0, "f");
  (28804, 0, "t");
  (28805, 0, "e");
  (28806, 0, " ");
  (28807, 0, "t");
  (28807, 1, "");
  (28806, 1, "");
  (28806, 0, "r");
  (28807, 0, " ");
  (28808, 0, "t");
  (28809, 0, "h");
  (28810, 0, "i");
  (28811, 0, "s");
  (28812, 0, " ");
  (28813, 0, "-");
  (28814, 0, " ");
  (28815, 0, "i");
  (28816, 0, "t");
  (28817, 0, " ");
  (28818, 0, "s");
  (28819, 0, "h");
  (28820, 0, "o");
  (28821, 0, "u");
  (28822, 0, "l");
  (28823, 0, "d");
  (28824, 0, " ");
  (28825, 0, "r");
  (28826, 0, "e");
  (28827, 0, "m");
  (28828, 0, "a");
  (28829, 0, "i");
  (28830, 0, "n");
  (28831, 0, " ");
  (28832, 0, "a");
  (28833, 0, "t");
  (28834, 0, " ");
  (28835, 0, "t");
  (28836, 0, "h");
  (28837, 0, "e");
  (28838, 0, " ");
  (28839, 0, "e");
  (28840, 0, "n");
  (28841, 0, "d");
  (28842, 0, " ");
  (28843, 0, "o");
  (28844, 0, "f");
  (28845, 0, " ");
  (28846, 0, "t");
  (28847, 0, "h");
  (28848, 0, "e");
  (28849, 0, " ");
  (28850, 0, "n");
  (28851, 0, "e");
  (28852, 0, "w");
  (28853, 0, "l");
  (28854, 0, "y");
  (28855, 0, " ");
  (28856, 0, "i");
  (28857, 0, "n");
  (28858, 0, "s");
  (28859, 0, "e");
  (28860, 0, "r");
  (28861, 0, "t");
  (28862, 0, "e");
  (28863, 0, "d");
  (28864, 0, " ");
  (28865, 0, "c");
  (28866, 0, "o");
  (28867, 0, "n");
  (28868, 0, "t");
  (28869, 0, "e");
  (28870, 0, "n");
  (28871, 0, "t");
  (28872, 0, ",");
  (28873, 0, " ");
  (28874, 0, "w");
  (28875, 0, "h");
  (28876, 0, "i");
  (28877, 0, "c");
  (28878, 0, "h");
  (28879, 0, " ");
  (28880, 0, "i");
  (28881, 0, "s");
  (28882, 0, " ");
  (28883, 0, "b");
  (28884, 0, "e");
  (28885, 0, "f");
  (28886, 0, "o");
  (28887, 0, "r");
  (28888, 0, "e");
  (28883, 0, "*");
  (28890, 0, "*");
  (28891, 0, " ");
  (28892, 0, "t");
  (28893, 0, "h");
  (28894, 0, "i");
  (28895, 0, "s");
  (28896, 0, " ");
  (28897, 0, "a");
  (28898, 0, "e");
  (28898, 1, "");
  (28897, 1, "");
  (28897, 0, "e");
  (28898, 0, "n");
  (28899, 0, "d");
  (28900, 0, " ");
  (28901, 0, "b");
  (28902, 0, "i");
  (28903, 0, "t");
  (28904, 0, ".");
  (28724, 181, "                // Passing false to indicate we don't want the cursor updated\n                // after this - it should remain at the end of the newly\n                // inserted content, which is *before* this end bit.");
  (23221, 0, "            if move_cursor {\n");
  (23278, 64, "");
  (23250, 12, "                ");
  (23250, 0, "                cursor.entries[i].skip_usersize += new_userlen;\n");
  (23346, 14, "");
  (23314, 16, "                    ");
  (23314, 0, "            }\n");
  (23364, 10, "");
  (23328, 20, "                        ");
  (23328, 0, "        }\n");
  (23378, 1, "");
  (23338, 24, "        ");
  (23338, 0, "        \n");
  (23371, 42, "");
  (23347, 8, "            ");
  (23347, 0, "        self.num_items += contents.len();\n");
  (23417, 43, "");
  (23389, 12, "                ");
  (23389, 0, "        self.num_usercount += new_userlen;\n");
  (23432, 16, "            ");
  (23432, 12, "        ");
  (23465, 0, "    ");
  (23499, 0, "\n            ");
  (23500, 12, "        }");
  (12303, 0, "\n    ");
  (12320, 0, " ");
  (12304, 4, "");
  (12317, 0, "f");
  (12318, 0, "i");
  (12319, 0, "e");
  (12320, 0, "l");
  (12321, 0, "d");
  (12347, 1, " ");
  (12348, 0, "-");
  (12350, 1, "");
  (12350, 0, "e");
  (12305, 162, "    // This field isn't strictly necessary - earlier versions tacked this on to\n    // the last item in entries... I'm still not sure the cleanest way to do\n    // this.");
  (12468, 0, "/");
  (12391, 0, "/");
  (12311, 0, "/");
  (12304, 0, "\n    ");
  (12309, 0, "/");
  (12310, 0, "/");
  (12311, 0, "/");
  (12312, 0, " ");
  (12313, 0, "T");
  (12314, 0, "h");
  (12315, 0, "e");
  (12316, 0, " ");
  (12317, 0, "g");
  (12318, 0, "l");
  (12319, 0, "o");
  (12320, 0, "a");
  (12320, 1, "");
  (12320, 0, "b");
  (12321, 0, "a");
  (12322, 0, "l");
  (12323, 0, " ");
  (12324, 0, "u");
  (12325, 0, "s");
  (12326, 0, "e");
  (12327, 0, "r");
  (12328, 0, " ");
  (12329, 0, "p");
  (12330, 0, "o");
  (12331, 0, "s");
  (12332, 0, "i");
  (12333, 0, "t");
  (12334, 0, "i");
  (12335, 0, "o");
  (12336, 0, "n");
  (12337, 0, " ");
  (12338, 0, "i");
  (12339, 0, "n");
  (12340, 0, " ");
  (12341, 0, "t");
  (12342, 0, "h");
  (12343, 0, "e");
  (12344, 0, " ");
  (12345, 0, "l");
  (12346, 0, "i");
  (12347, 0, "s");
  (12348, 0, "t");
  (12338, 0, "o");
  (12339, 0, "f");
  (12340, 0, " ");
  (12341, 0, "t");
  (12342, 0, "h");
  (12343, 0, "e");
  (12344, 0, " ");
  (12345, 0, "c");
  (12346, 0, "u");
  (12347, 0, "r");
  (12348, 0, "s");
  (12349, 0, "o");
  (12350, 0, " ");
  (12351, 0, "r");
  (12362, 1, "");
  (12361, 1, "");
  (12360, 1, "");
  (12359, 1, "");
  (12358, 1, "");
  (12357, 1, "");
  (12356, 1, "");
  (12355, 1, "");
  (12354, 1, "");
  (12353, 1, "");
  (12352, 1, "");
  (12351, 1, "");
  (12350, 1, "");
  (12350, 0, "r");
  (12351, 0, " ");
  (12352, 0, "i");
  (12353, 0, "n");
  (12354, 0, " ");
  (12355, 0, "t");
  (12356, 0, "h");
  (12357, 0, "e");
  (12358, 0, " ");
  (12359, 0, "e");
  (12360, 0, "n");
  (12361, 0, "t");
  (12362, 0, "i");
  (12363, 0, "r");
  (12364, 0, "e");
  (12365, 0, " ");
  (12366, 0, "l");
  (12367, 0, "i");
  (12368, 0, "s");
  (12369, 0, "t");
  (12370, 0, ".");
  (12371, 0, " ");
  (12372, 0, "T");
  (12373, 0, "i");
  (12374, 0, "s");
  (12375, 0, " ");
  (12375, 1, "");
  (12374, 1, "");
  (12373, 1, "");
  (12373, 0, "h");
  (12374, 0, "i");
  (12375, 0, "s");
  (12376, 0, " ");
  (12377, 0, "i");
  (12378, 0, "s");
  (12379, 0, " ");
  (12380, 0, "u");
  (12381, 0, "s");
  (12382, 0, "e");
  (12383, 0, "d");
  (12384, 0, " ");
  (12385, 0, "f");
  (12386, 0, "o");
  (12387, 0, "r");
  (12388, 0, " ");
  (12389, 0, "h");
  (12389, 1, "");
  (12389, 0, "w");
  (12390, 0, "h");
  (12391, 0, "e");
  (12392, 0, "n");
  (12393, 0, " ");
  (12394, 0, "t");
  (12395, 0, "h");
  (12396, 0, "e");
  (12397, 0, " ");
  (12398, 0, "h");
  (12399, 0, "e");
  (12400, 0, "i");
  (12401, 0, "g");
  (12402, 0, "h");
  (12403, 0, "t");
  (12404, 0, " ");
  (12398, 7, "m");
  (12399, 0, "a");
  (12400, 0, "x");
  (12401, 0, " ");
  (12402, 0, "s");
  (12403, 0, "e");
  (12404, 0, "e");
  (12405, 0, "n");
  (12406, 0, " ");
  (12407, 0, "h");
  (12408, 0, "e");
  (12409, 0, "i");
  (12410, 0, "g");
  (12411, 0, "h");
  (12412, 0, "t");
  (12413, 0, " ");
  (12414, 0, "i");
  (12415, 0, "n");
  (12416, 0, "c");
  (12417, 0, "r");
  (12418, 0, "e");
  (12419, 0, "a");
  (12420, 0, "s");
  (12421, 0, "e");
  (12422, 0, "s");
  (12423, 0, ",");
  (12424, 0, " ");
  (12425, 0, "s");
  (12426, 0, "o");
  (12427, 0, " ");
  (12428, 0, "w");
  (12429, 0, "e");
  (12430, 0, " ");
  (12431, 0, "c");
  (12432, 0, "a");
  (12433, 0, "n");
  (12434, 0, " ");
  (12435, 0, "p");
  (12436, 0, "o");
  (12437, 0, "p");
  (12438, 0, "u");
  (12439, 0, "l");
  (12440, 0, "a");
  (12441, 0, "t");
  (12442, 0, "e");
  (12443, 0, " ");
  (12444, 0, "f");
  (12445, 0, "i");
  (12446, 0, "e");
  (12447, 0, "l");
  (12448, 0, "d");
  (12449, 0, "s");
  (12450, 0, " ");
  (12451, 0, "i");
  (12452, 0, "n");
  (12453, 0, " ");
  (12454, 0, "t");
  (12455, 0, "h");
  (12456, 0, "e");
  (12457, 0, " ");
  (12458, 0, "c");
  (12459, 0, "u");
  (12460, 0, "r");
  (12461, 0, "s");
  (12462, 0, "o");
  (12463, 0, "r");
  (12464, 0, " ");
  (12465, 0, "a");
  (12466, 0, "n");
  (12467, 0, "d");
  (12468, 0, " ");
  (12469, 0, "i");
  (12470, 0, "n");
  (12471, 0, " ");
  (12444, 7, "p");
  (12445, 0, "r");
  (12446, 0, "e");
  (12447, 0, "v");
  (12448, 0, "i");
  (12449, 0, "u");
  (12450, 0, "s");
  (12451, 0, "l");
  (12451, 1, "");
  (12450, 1, "");
  (12449, 1, "");
  (12448, 1, "");
  (12448, 0, "i");
  (12449, 0, "o");
  (12450, 0, "u");
  (12451, 0, "s");
  (12452, 0, "l");
  (12453, 0, "y");
  (12454, 0, " ");
  (12455, 0, "u");
  (12456, 0, "n");
  (12457, 0, "u");
  (12458, 0, "s");
  (12459, 0, "e");
  (12460, 0, "d");
  (12461, 0, " ");
  (12462, 0, "e");
  (12463, 0, "n");
  (12464, 0, "t");
  (12465, 0, "r");
  (12466, 0, "i");
  (12467, 0, "e");
  (12468, 0, "s");
  (12469, 0, " ");
  (12484, 7, "a");
  (12485, 0, "n");
  (12486, 0, "d");
  (12487, 0, " ");
  (12488, 0, "i");
  (12489, 0, "n");
  (12490, 0, " ");
  (12491, 0, "t");
  (12492, 0, "h");
  (12493, 0, "e");
  (12494, 0, " ");
  (12495, 0, "h");
  (12496, 0, "e");
  (12497, 0, "a");
  (12498, 0, "d");
  (12499, 0, " ");
  (12500, 0, "n");
  (12501, 0, "o");
  (12502, 0, "d");
  (12503, 0, "e");
  (12504, 0, "'");
  (12505, 0, "s");
  (12506, 0, " ");
  (12507, 0, "h");
  (12508, 0, "e");
  (12509, 0, "i");
  (12510, 0, "g");
  (12511, 0, "h");
  (12512, 0, "t");
  (12504, 9, ".");
  (12505, 0, "assert_eq!");
  (12505, 10, "");
  (12505, 0, "\n    /// ");
  (12305, 209, "    /// The global user position of the cursor in the entire list. This is used\n    /// for when the max seen height increases, so we can populate previously\n    /// unused entries in the cursor and in the head node.\n    ///");
  (12722, 0, "\n    ");
  (12727, 0, "\n    ");
  (12723, 4, "");
  (12728, 0, "l");
  (12729, 0, "o");
  (12730, 0, "c");
  (12731, 0, "a");
  (12732, 0, "l");
  (12733, 0, "_");
  (12734, 0, "i");
  (12735, 0, "n");
  (12736, 0, "d");
  (12737, 0, "e");
  (12738, 0, ":");
  (12738, 1, "");
  (12738, 0, "x");
  (12739, 0, ":");
  (12740, 0, " ");
  (12741, 0, "u");
  (12742, 0, "s");
  (12743, 0, "i");
  (12744, 0, "z");
  (12745, 0, "e");
  (12746, 0, ",");
  (12723, 0, "\n    ");
  (12728, 0, "/");
  (12729, 0, "/");
  (12730, 0, "/");
  (12731, 0, " ");
  (12732, 0, "T");
  (12733, 0, "h");
  (12734, 0, "i");
  (12735, 0, "s");
  (12736, 0, " ");
  (12737, 0, "i");
  (12738, 0, "s");
  (12739, 0, " ");
  (12740, 0, "n");
  (12741, 0, "e");
  (12742, 0, "e");
  (12743, 0, "d");
  (12744, 0, "e");
  (12745, 0, "d");
  (12746, 0, " ");
  (12747, 0, "e");
  (12748, 0, "b");
  (12749, 0, "c");
  (12750, 0, "a");
  (12732, 19, "W");
  (12733, 0, "h");
  (12734, 0, "e");
  (12735, 0, "n");
  (12736, 0, " ");
  (12737, 0, "t");
  (12738, 0, "h");
  (12739, 0, "e");
  (12740, 0, " ");
  (12741, 0, "u");
  (12742, 0, "s");
  (12743, 0, "e");
  (12744, 0, "r");
  (12745, 0, "p");
  (12746, 0, "o");
  (12747, 0, "s");
  (12748, 0, " ");
  (12749, 0, "o");
  (12750, 0, "f");
  (12751, 0, " ");
  (12752, 0, "a");
  (12753, 0, "n");
  (12754, 0, " ");
  (12755, 0, "e");
  (12756, 0, "n");
  (12757, 0, "t");
  (12758, 0, "r");
  (12759, 0, "y");
  (12760, 0, " ");
  (12761, 0, "i");
  (12762, 0, "s");
  (12763, 0, " ");
  (12764, 0, "0");
  (12765, 0, " ");
  (12766, 0, "(");
  (12767, 0, "t");
  (12768, 0, "o");
  (12769, 0, "t");
  (12770, 0, "a");
  (12771, 0, "l");
  (12772, 0, "l");
  (12773, 0, "y");
  (12774, 0, " ");
  (12775, 0, "v");
  (12776, 0, "a");
  (12777, 0, "l");
  (12778, 0, "i");
  (12779, 0, "d");
  (12780, 0, " ");
  (12781, 0, "a");
  (12782, 0, "n");
  (12783, 0, "d");
  (12784, 0, " ");
  (12785, 0, "u");
  (12786, 0, "s");
  (12787, 0, "e");
  (12788, 0, "f");
  (12789, 0, "u");
  (12790, 0, "l");
  (12791, 0, ")");
  (12792, 0, ",");
  (12793, 0, " ");
  (12794, 0, "t");
  (12795, 0, "h");
  (12796, 0, "e");
  (12797, 0, " ");
  (12794, 4, "a");
  (12795, 0, " ");
  (12796, 0, "c");
  (12797, 0, "u");
  (12798, 0, "r");
  (12799, 0, "s");
  (12800, 0, "o");
  (12801, 0, "r");
  (12802, 0, " ");
  (12803, 0, "b");
  (12804, 0, "e");
  (12805, 0, "c");
  (12806, 0, "o");
  (12807, 0, "m");
  (12808, 0, "e");
  (12809, 0, "s");
  (12810, 0, " ");
  (12811, 0, "a");
  (12812, 0, "m");
  (12813, 0, "b");
  (12814, 0, "i");
  (12815, 0, "g");
  (12816, 0, "u");
  (12817, 0, "o");
  (12818, 0, "u");
  (12819, 0, "s");
  (12820, 0, " ");
  (12821, 0, "i");
  (12822, 0, "n");
  (12823, 0, " ");
  (12824, 0, "w");
  (12825, 0, "h");
  (12826, 0, "e");
  (12827, 0, "r");
  (12828, 0, "e");
  (12829, 0, " ");
  (12830, 0, "i");
  (12831, 0, "t");
  (12832, 0, "s");
  (12833, 0, " ");
  (12834, 0, "p");
  (12835, 0, "o");
  (12836, 0, "i");
  (12837, 0, "n");
  (12838, 0, "t");
  (12839, 0, "i");
  (12840, 0, "n");
  (12841, 0, "g");
  (12842, 0, ".");
  (12724, 119, "    /// When the userpos of an entry is 0 (totally valid and useful), a cursor\n    /// becomes ambiguous in where its pointing.");
  (12829, 2, "a");
  (12830, 0, "b");
  (12831, 0, "o");
  (12832, 0, "u");
  (12833, 0, "t");
  (12854, 0, " ");
  (12855, 0, "T");
  (12856, 0, "h");
  (12857, 0, "i");
  (12858, 0, "s");
  (12859, 0, " ");
  (12860, 0, "i");
  (12861, 0, "s");
  (12862, 0, " ");
  (12863, 0, "u");
  (12864, 0, "s");
  (12865, 0, "e");
  (12866, 0, "d");
  (12829, 5, "w");
  (12830, 0, "i");
  (12831, 0, "t");
  (12832, 0, "h");
  (12833, 0, " ");
  (12834, 0, "r");
  (12835, 0, "e");
  (12836, 0, "g");
  (12837, 0, "a");
  (12838, 0, "r");
  (12839, 0, "d");
  (12840, 0, " ");
  (12841, 0, "t");
  (12842, 0, "o");
  (12849, 0, " ");
  (12850, 0, "e");
  (12851, 0, "x");
  (12852, 0, "a");
  (12853, 0, "c");
  (12854, 0, "t");
  (12855, 0, "l");
  (12856, 0, "y");
  (12870, 0, " ");
  (12871, 0, "i");
  (12872, 0, "n");
  (12873, 0, " ");
  (12874, 0, "t");
  (12875, 0, "h");
  (12876, 0, "e");
  (12877, 0, " ");
  (12878, 0, "c");
  (12879, 0, "u");
  (12880, 0, "r");
  (12881, 0, "r");
  (12882, 0, "e");
  (12883, 0, "n");
  (12884, 0, "t");
  (12885, 0, " ");
  (12886, 0, "e");
  (12887, 0, "n");
  (12888, 0, "t");
  (12889, 0, "r");
  (12890, 0, "y");
  (12803, 102, "    /// becomes ambiguous with regard to where exactly its pointing in the\n    /// current entry. This is used");
  (12913, 0, "t");
  (12914, 0, " ");
  (12914, 1, "");
  (12913, 1, "");
  (12913, 0, " ");
  (12914, 0, "t");
  (12915, 0, "o");
  (12916, 0, " ");
  (12917, 0, "r");
  (12918, 0, "e");
  (12919, 0, "s");
  (12920, 0, "o");
  (12921, 0, "v");
  (12922, 0, "l");
  (12923, 0, "e");
  (12924, 0, " ");
  (12925, 0, "t");
  (12926, 0, "a");
  (12917, 10, "r");
  (12918, 0, "e");
  (12919, 0, "s");
  (12920, 0, "o");
  (12921, 0, "l");
  (12922, 0, "v");
  (12923, 0, "e");
  (12924, 0, " ");
  (12925, 0, "t");
  (12926, 0, "h");
  (12927, 0, "a");
  (12928, 0, "t");
  (12929, 0, " ");
  (12930, 0, "a");
  (12931, 0, "m");
  (12932, 0, "b");
  (12933, 0, "u");
  (12933, 1, "");
  (12933, 0, "i");
  (12934, 0, "g");
  (12935, 0, "u");
  (12936, 0, "i");
  (12937, 0, "t");
  (12938, 0, "y");
  (12939, 0, ".");
  (19299, 0, "(");
  (19309, 0, ",");
  (19310, 0, " ");
  (19311, 0, "u");
  (19312, 0, "s");
  (19313, 0, "i");
  (19314, 0, "z");
  (19315, 0, "e");
  (19316, 0, ")");
  (18943, 4, "c");
  (18944, 0, "o");
  (18945, 0, "n");
  (18946, 0, "t");
  (18947, 0, "a");
  (18948, 0, "i");
  (18949, 0, "n");
  (18950, 0, "s");
  (18905, 213, "    /// skiplist. The returned cursor contains list of nodes which point past\n    /// the specified position, as well as offsets of how far into their\n    /// character lists the specified characters are.\n    ///");
  (19126, 70, "B");
  (19127, 0, "y");
  (19128, 0, " ");
  (19129, 0, "d");
  (19130, 0, "e");
  (19126, 5, "T");
  (19127, 0, "h");
  (19127, 1, "");
  (19126, 1, "");
  (19126, 0, "i");
  (19127, 0, "t");
  (19128, 0, "e");
  (19129, 0, "r");
  (19130, 0, "_");
  (19131, 0, "a");
  (19132, 0, "t");
  (19133, 0, "_");
  (19134, 0, "u");
  (19135, 0, "s");
  (19136, 0, "e");
  (19137, 0, "r");
  (19138, 0, "p");
  (19139, 0, "o");
  (19140, 0, "s");
  (19141, 0, " ");
  (19142, 0, "c");
  (19143, 0, "u");
  (19144, 0, "r");
  (19145, 0, "r");
  (19146, 0, "e");
  (19147, 0, "n");
  (19148, 0, "t");
  (19149, 0, "l");
  (19150, 0, "y");
  (19151, 0, " ");
  (19152, 0, "r");
  (19153, 0, "e");
  (19154, 0, "t");
  (19155, 0, "u");
  (19156, 0, "r");
  (19157, 0, "n");
  (19158, 0, "s");
  (19159, 0, " ");
  (19160, 0, "t");
  (19161, 0, "h");
  (19162, 0, "e");
  (19163, 0, " ");
  (19164, 0, "l");
  (19165, 0, "a");
  (19166, 0, "s");
  (19167, 0, "t");
  (19168, 0, " ");
  (19126, 43, "S");
  (19127, 0, "o");
  (19128, 0, "m");
  (19129, 0, "e");
  (19130, 0, "t");
  (19131, 0, "i");
  (19132, 0, "m");
  (19133, 0, "e");
  (19134, 0, "s");
  (19135, 0, " ");
  (19136, 0, "a");
  (19137, 0, " ");
  (19138, 0, "c");
  (19139, 0, "a");
  (19140, 0, "l");
  (19141, 0, "l");
  (19142, 0, " ");
  (19143, 0, "t");
  (19144, 0, "o");
  (19145, 0, " ");
  (19146, 0, "i");
  (19147, 0, "t");
  (19148, 0, "e");
  (19149, 0, "r");
  (19150, 0, "_");
  (19151, 0, "a");
  (19152, 0, "t");
  (19153, 0, "_");
  (19154, 0, "u");
  (19155, 0, "s");
  (19156, 0, "e");
  (19157, 0, "r");
  (19158, 0, "p");
  (19159, 0, "o");
  (19160, 0, "s");
  (19161, 0, " ");
  (19162, 0, "i");
  (19163, 0, "s");
  (19164, 0, " ");
  (19165, 0, "a");
  (19166, 0, "m");
  (19167, 0, "b");
  (19168, 0, "i");
  (19169, 0, "g");
  (19170, 0, "u");
  (19171, 0, "o");
  (19172, 0, "u");
  (19173, 0, "s");
  (19174, 0, ":");
  (19175, 0, "assert_eq!");
  (19185, 0, "\n    /// ");
  (19194, 0, "-");
  (19185, 10, "");
  (19175, 10, "");
  (19175, 0, "\n    /// ");
  (19184, 0, "\n    /// ");
  (19193, 0, "-");
  (19194, 0, " ");
  (19195, 0, "T");
  (19196, 0, "h");
  (19197, 0, "e");
  (19198, 0, " ");
  (19199, 0, "u");
  (19200, 0, "s");
  (19201, 0, "e");
  (19202, 0, "r");
  (19199, 4, "");
  (19199, 0, "i");
  (19200, 0, "t");
  (19201, 0, "e");
  (19202, 0, "m");
  (19203, 0, " ");
  (19204, 0, "c");
  (19205, 0, "a");
  (19206, 0, "n");
  (19207, 0, " ");
  (19208, 0, "c");
  (19209, 0, "o");
  (19210, 0, "n");
  (19211, 0, "t");
  (19212, 0, "a");
  (19213, 0, "i");
  (19214, 0, "n");
  (19215, 0, " ");
  (19216, 0, "z");
  (19217, 0, "e");
  (19218, 0, "r");
  (19219, 0, "o");
  (19220, 0, "-");
  (19221, 0, "s");
  (19222, 0, "i");
  (19223, 0, "z");
  (19224, 0, "e");
  (19225, 0, "d");
  (19220, 6, "i");
  (19216, 5, "i");
  (19217, 0, "t");
  (19218, 0, "e");
  (19219, 0, "m");
  (19220, 0, "s");
  (19221, 0, " ");
  (19222, 0, "w");
  (19223, 0, "i");
  (19224, 0, "t");
  (19225, 0, "h");
  (19226, 0, " ");
  (19227, 0, "z");
  (19228, 0, "e");
  (19229, 0, "r");
  (19230, 0, "o");
  (19231, 0, " ");
  (19232, 0, "u");
  (19233, 0, "s");
  (19234, 0, "e");
  (19235, 0, "r");
  (19236, 0, "s");
  (19237, 0, "i");
  (19238, 0, "z");
  (19239, 0, "e");
  (19240, 0, ".");
  (19241, 0, " ");
  (19242, 0, "T");
  (19243, 0, "h");
  (19244, 0, "e");
  (19245, 0, " ");
  (19246, 0, "c");
  (19247, 0, "u");
  (19248, 0, "r");
  (19249, 0, "s");
  (19250, 0, "o");
  (19251, 0, "r");
  (19252, 0, " ");
  (19253, 0, "c");
  (19254, 0, "o");
  (19255, 0, "u");
  (19256, 0, "l");
  (19257, 0, "d");
  (19258, 0, " ");
  (19259, 0, "p");
  (19260, 0, "o");
  (19261, 0, "i");
  (19262, 0, "n");
  (19263, 0, "t");
  (19264, 0, " ");
  (19265, 0, "t");
  (19266, 0, "o");
  (19267, 0, " ");
  (19268, 0, "t");
  (19268, 1, "");
  (19268, 0, "a");
  (19269, 0, "n");
  (19270, 0, "y");
  (19271, 0, " ");
  (19272, 0, "o");
  (19273, 0, "f");
  (19274, 0, " ");
  (19275, 0, "t");
  (19276, 0, "h");
  (19277, 0, "e");
  (19278, 0, "m");
  (19279, 0, ".");
  (19280, 0, "assert_eq!");
  (19280, 10, "");
  (19280, 0, "\n    /// ");
  (19289, 0, "/");
  (19289, 1, "");
  (19289, 0, "-");
  (19290, 0, " ");
  (19291, 0, "T");
  (19292, 0, "h");
  (19293, 0, "e");
  (19294, 0, " ");
  (19295, 0, "c");
  (19296, 0, "u");
  (19297, 0, "r");
  (19298, 0, "s");
  (19299, 0, "o");
  (19300, 0, "r");
  (19301, 0, " ");
  (19302, 0, "c");
  (19303, 0, "o");
  (19304, 0, "u");
  (19305, 0, "l");
  (19306, 0, "d");
  (19307, 0, " ");
  (19308, 0, "o");
  (19308, 1, "");
  (19280, 0, " ");
  (19281, 0, "F");
  (19282, 0, "o");
  (19283, 0, "r");
  (19284, 0, " ");
  (19285, 0, "n");
  (19286, 0, "o");
  (19287, 0, "w");
  (19288, 0, " ");
  (19289, 0, "w");
  (19289, 1, "");
  (19289, 0, "t");
  (19290, 0, "h");
  (19291, 0, "i");
  (19292, 0, "s");
  (19293, 0, " ");
  (19294, 0, "m");
  (19295, 0, "e");
  (19296, 0, "t");
  (19297, 0, "h");
  (19298, 0, "o");
  (19299, 0, "d");
  (19300, 0, " ");
  (19301, 0, "a");
  (19302, 0, "l");
  (19303, 0, "w");
  (19304, 0, "a");
  (19305, 0, "y");
  (19306, 0, "s");
  (19307, 0, " ");
  (19308, 0, "r");
  (19309, 0, "e");
  (19310, 0, "t");
  (19311, 0, "u");
  (19312, 0, "r");
  (19280, 33, "");
  (19295, 0, "r");
  (19296, 0, "e");
  (19297, 0, "t");
  (19298, 0, "u");
  (19299, 0, "r");
  (19300, 0, "n");
  (19301, 0, "e");
  (19302, 0, "d");
  (19303, 0, " ");
  (19317, 0, "b");
  (19318, 0, "e");
  (19319, 0, " ");
  (19320, 0, "e");
  (19321, 0, "i");
  (19322, 0, "t");
  (19323, 0, "h");
  (19324, 0, "e");
  (19325, 0, "r");
  (19326, 0, " ");
  (19327, 0, "a");
  (19328, 0, "t");
  (19329, 0, " ");
  (19330, 0, "t");
  (19331, 0, "h");
  (19332, 0, "e");
  (19333, 0, "e");
  (19333, 1, "");
  (19333, 0, " ");
  (19334, 0, "e");
  (19335, 0, "n");
  (19336, 0, "d");
  (19337, 0, " ");
  (19338, 0, "o");
  (19339, 0, "f");
  (19340, 0, " ");
  (19341, 0, "t");
  (19342, 0, "h");
  (19343, 0, "e");
  (19344, 0, " ");
  (19338, 0, "o");
  (19339, 0, "f");
  (19340, 0, " ");
  (19291, 57, "I");
  (19292, 0, "f");
  (19293, 0, " ");
  (19294, 0, "t");
  (19295, 0, "h");
  (19296, 0, "e");
  (19297, 0, " ");
  (19298, 0, "l");
  (19299, 0, "o");
  (19300, 0, "c");
  (19301, 0, "a");
  (19302, 0, "t");
  (19303, 0, "i");
  (19304, 0, "o");
  (19305, 0, "n");
  (19306, 0, " ");
  (19307, 0, "i");
  (19308, 0, "s");
  (19309, 0, " ");
  (19310, 0, "a");
  (19311, 0, "t");
  (19312, 0, " ");
  (19313, 0, "t");
  (19314, 0, "h");
  (19315, 0, "e");
  (19316, 0, " ");
  (19317, 0, "e");
  (19318, 0, "n");
  (19319, 0, "d");
  (19320, 0, " ");
  (19321, 0, "o");
  (19322, 0, "f");
  (19323, 0, " ");
  (19324, 0, "a");
  (19325, 0, " ");
  (19326, 0, "n");
  (19327, 0, "o");
  (19328, 0, "d");
  (19329, 0, "e");
  (19330, 0, ",");
  (19331, 0, " ");
  (19332, 0, "i");
  (19333, 0, "t");
  (19334, 0, " ");
  (19335, 0, "i");
  (19336, 0, "s");
  (19337, 0, " ");
  (19338, 0, "e");
  (19339, 0, "q");
  (19340, 0, "u");
  (19341, 0, "a");
  (19342, 0, "l");
  (19343, 0, "l");
  (19344, 0, "y");
  (19345, 0, " ");
  (19346, 0, "v");
  (19347, 0, "a");
  (19348, 0, "l");
  (19349, 0, "i");
  (19350, 0, "d");
  (19351, 0, " ");
  (19352, 0, "t");
  (19353, 0, "o");
  (19354, 0, " ");
  (19355, 0, "r");
  (19356, 0, "e");
  (19357, 0, "t");
  (19358, 0, "u");
  (19359, 0, "r");
  (19360, 0, "n");
  (19361, 0, " ");
  (19362, 0, "a");
  (19363, 0, " ");
  (19364, 0, "p");
  (19365, 0, "o");
  (19366, 0, "s");
  (19367, 0, "i");
  (19368, 0, "t");
  (19369, 0, "i");
  (19370, 0, "o");
  (19371, 0, "n");
  (19372, 0, " ");
  (19373, 0, "a");
  (19374, 0, "t");
  (19375, 0, " ");
  (19376, 0, "t");
  (19377, 0, "h");
  (19378, 0, "e");
  (19379, 0, " ");
  (19380, 0, "e");
  (19380, 1, "");
  (19380, 0, "s");
  (19381, 0, "t");
  (19382, 0, "a");
  (19383, 0, "r");
  (19384, 0, "t");
  (19385, 0, " ");
  (19386, 0, "o");
  (19387, 0, " ");
  (19387, 1, "");
  (19387, 0, "f");
  (19388, 0, " ");
  (19389, 0, "t");
  (19390, 0, " ");
  (19390, 1, "");
  (19390, 0, "h");
  (19391, 0, "e");
  (19392, 0, " ");
  (19393, 0, "n");
  (19394, 0, "e");
  (19395, 0, "x");
  (19396, 0, "t");
  (19397, 0, " ");
  (19398, 0, "n");
  (19399, 0, "o");
  (19400, 0, "d");
  (19401, 0, "e");
  (19402, 0, ".");
  (19176, 227, "    ///\n    /// - The item can contain items with zero usersize. The cursor could point\n    ///   to any of them.\n    /// - If the location is at the end of a node, it is equally valid to return\n    ///   a position at the start of the next node.");
  (19422, 0, "\n    /// ");
  (19431, 0, "\n    /// ");
  (19440, 0, "B");
  (19441, 0, "e");
  (19442, 0, "c");
  (19443, 0, "a");
  (19444, 0, "u");
  (19445, 0, "s");
  (19446, 0, "e");
  (19447, 0, " ");
  (19448, 0, "i");
  (19449, 0, "t");
  (19450, 0, "s");
  (19451, 0, " ");
  (19452, 0, "i");
  (19453, 0, "m");
  (19454, 0, "p");
  (19455, 0, "o");
  (19456, 0, "s");
  (19457, 0, "s");
  (19458, 0, "i");
  (19459, 0, "b");
  (19460, 0, "l");
  (19461, 0, "e");
  (19462, 0, " ");
  (19463, 0, "m");
  (19464, 0, "t");
  (19464, 1, "");
  (19463, 1, "");
  (19463, 0, "t");
  (19464, 0, "o");
  (19465, 0, " ");
  (19466, 0, "m");
  (19467, 0, "v");
  (19468, 0, "o");
  (19468, 1, "");
  (19467, 1, "");
  (19467, 0, "o");
  (19468, 0, "v");
  (19469, 0, "e");
  (19470, 0, " ");
  (19471, 0, "b");
  (19472, 0, "a");
  (19473, 0, "c");
  (19474, 0, "k");
  (19475, 0, "w");
  (19476, 0, "a");
  (19477, 0, "r");
  (19478, 0, "d");
  (19479, 0, "s");
  (19480, 0, " ");
  (19481, 0, "i");
  (19482, 0, "n");
  (19483, 0, " ");
  (19484, 0, "t");
  (19485, 0, "h");
  (19486, 0, "e");
  (19487, 0, " ");
  (19488, 0, "l");
  (19489, 0, "i");
  (19490, 0, "s");
  (19491, 0, "t");
  (19492, 0, ",");
  (19493, 0, " ");
  (19494, 0, "w");
  (19495, 0, "e");
  (19496, 0, " ");
  (19497, 0, "r");
  (19498, 0, "e");
  (19499, 0, "t");
  (19500, 0, "u");
  (19501, 0, "r");
  (19502, 0, "n");
  (19503, 0, " ");
  (19504, 0, "t");
  (19505, 0, "h");
  (19506, 0, "e");
  (19507, 0, " ");
  (19508, 0, "f");
  (19509, 0, "i");
  (19510, 0, "r");
  (19511, 0, "s");
  (19512, 0, "t");
  (19513, 0, " ");
  (19514, 0, "v");
  (19515, 0, "a");
  (19516, 0, "l");
  (19517, 0, "i");
  (19518, 0, "d");
  (19519, 0, " ");
  (19520, 0, "l");
  (19521, 0, "o");
  (19522, 0, "c");
  (19523, 0, "a");
  (19524, 0, "t");
  (19525, 0, "i");
  (19526, 0, "o");
  (19527, 0, "n");
  (19494, 2, "i");
  (19495, 0, "t");
  (19496, 0, "e");
  (19497, 0, "r");
  (19498, 0, "_");
  (19499, 0, "a");
  (19500, 0, "t");
  (19501, 0, "_");
  (19502, 0, "u");
  (19503, 0, "s");
  (19504, 0, "e");
  (19505, 0, "r");
  (19506, 0, "p");
  (19507, 0, "o");
  (19508, 0, "s");
  (19516, 0, "s");
  (19528, 0, "*");
  (19534, 0, "*");
  (19534, 1, "");
  (19528, 1, "");
  (19528, 5, "a");
  (19528, 1, "");
  (19528, 0, "a");
  (19529, 0, "d");
  (19530, 0, "m");
  (19531, 0, "i");
  (19532, 0, "s");
  (19533, 0, "s");
  (19534, 0, "i");
  (19535, 0, "o");
  (19536, 0, "n");
  (19536, 1, "");
  (19535, 1, "");
  (19535, 0, "b");
  (19536, 0, "l");
  (19537, 0, "e");
  (19547, 0, " ");
  (19548, 0, "w");
  (19549, 0, "i");
  (19550, 0, "t");
  (19551, 0, "h");
  (19552, 0, " ");
  (19553, 0, "t");
  (19554, 0, "h");
  (19555, 0, "e");
  (19556, 0, " ");
  (19557, 0, "s");
  (19558, 0, "p");
  (19559, 0, "e");
  (19560, 0, "c");
  (19561, 0, "i");
  (19562, 0, "f");
  (19563, 0, "i");
  (19564, 0, "e");
  (19565, 0, "d");
  (19566, 0, " ");
  (19567, 0, "u");
  (19568, 0, "s");
  (19569, 0, "e");
  (19570, 0, "r");
  (19571, 0, "p");
  (19572, 0, "o");
  (19573, 0, "s");
  (19574, 0, ".");
  (19423, 152, "    ///\n    /// Because its impossible to move backwards in the list, iter_at_userpos\n    /// returns the first admissible location with the specified userpos.");
  (19582, 0, "\n    /// ");
  (19591, 0, "\n    /// ");
  (19600, 0, "@");
  (19601, 0, "r");
  (19602, 0, "e");
  (19603, 0, "t");
  (19604, 0, "u");
  (19605, 0, "r");
  (19600, 6, "R");
  (19601, 0, "e");
  (19602, 0, "t");
  (19603, 0, "u");
  (19604, 0, "r");
  (19605, 0, "n");
  (19606, 0, "s");
  (19607, 0, " ");
  (19608, 0, "c");
  (19609, 0, "u");
  (19610, 0, "r");
  (19611, 0, "s");
  (19612, 0, "o");
  (19613, 0, "r");
  (19614, 0, ",");
  (19615, 0, " ");
  (19608, 0, "(");
  (19617, 0, "l");
  (19618, 0, "e");
  (19619, 0, "n");
  (19620, 0, "g");
  (19621, 0, "t");
  (19622, 0, "h");
  (19617, 6, "o");
  (19618, 0, "f");
  (19619, 0, "f");
  (19620, 0, "s");
  (19621, 0, "e");
  (19622, 0, "t");
  (19623, 0, " ");
  (19624, 0, "i");
  (19625, 0, "n");
  (19626, 0, "t");
  (19627, 0, "o");
  (19628, 0, " ");
  (19629, 0, "t");
  (19630, 0, "h");
  (19631, 0, "e");
  (19632, 0, " ");
  (19633, 0, "c");
  (19634, 0, "u");
  (19635, 0, "r");
  (19636, 0, "r");
  (19637, 0, "e");
  (19638, 0, "n");
  (19639, 0, "t");
  (19640, 0, " ");
  (19641, 0, "i");
  (19642, 0, "t");
  (19643, 0, "e");
  (19644, 0, "m");
  (19645, 0, ")");
  (19633, 7, "");
  (19632, 1, "");
  (19632, 0, " ");
  (19633, 0, "p");
  (19634, 0, "o");
  (19635, 0, "i");
  (19636, 0, "n");
  (19637, 0, "t");
  (19638, 0, "e");
  (19639, 0, "d");
  (19633, 7, "i");
  (19633, 1, "");
  (19632, 1, "");
  (19632, 0, " ");
  (19633, 0, "s");
  (19634, 0, "p");
  (19635, 0, "e");
  (19636, 0, "c");
  (19637, 0, "i");
  (19638, 0, "f");
  (19639, 0, "i");
  (19640, 0, "e");
  (19641, 0, "d");
  (19648, 0, ".");
  (21345, 0, "\n        ");
  (21354, 0, "\n        ");
  (21346, 8, "");
  (21355, 0, "/");
  (21356, 0, "/");
  (21357, 0, " ");
  (21358, 0, "W");
  (21359, 0, "e");
  (21360, 0, "'");
  (21361, 0, "v");
  (21362, 0, "e");
  (21363, 0, " ");
  (21364, 0, "f");
  (21365, 0, "o");
  (21366, 0, "u");
  (21367, 0, "n");
  (21368, 0, "d");
  (21369, 0, " ");
  (21370, 0, "t");
  (21371, 0, "h");
  (21372, 0, "e");
  (21373, 0, " ");
  (21374, 0, "n");
  (21375, 0, "o");
  (21376, 0, "d");
  (21377, 0, "e");
  (21378, 0, ".");
  (21379, 0, " ");
  (21380, 0, "N");
  (21381, 0, "o");
  (21382, 0, "w");
  (21383, 0, " ");
  (21384, 0, "w");
  (21385, 0, "e");
  (21386, 0, " ");
  (21387, 0, "n");
  (21388, 0, "e");
  (21389, 0, "e");
  (21390, 0, "d");
  (21391, 0, " ");
  (21392, 0, "t");
  (21393, 0, "o");
  (21394, 0, " ");
  (21395, 0, "f");
  (21396, 0, "i");
  (21397, 0, "n");
  (21398, 0, "d");
  (21399, 0, " ");
  (21400, 0, "t");
  (21401, 0, "h");
  (21402, 0, "e");
  (21403, 0, " ");
  (21404, 0, "l");
  (21405, 0, "o");
  (21406, 0, "c");
  (21407, 0, "a");
  (21408, 0, "t");
  (21409, 0, "i");
  (21410, 0, "o");
  (21411, 0, " ");
  (21412, 0, "n");
  (21413, 0, "w");
  (21414, 0, "i");
  (21415, 0, "t");
  (21416, 0, "h");
  (21417, 0, "i");
  (21418, 0, "n");
  (21384, 35, "l");
  (21385, 0, "o");
  (21386, 0, "o");
  (21387, 0, "k");
  (21388, 0, " ");
  (21389, 0, "f");
  (21390, 0, "o");
  (21391, 0, "r");
  (21392, 0, " ");
  (21393, 0, "t");
  (21394, 0, "h");
  (21395, 0, "e");
  (21396, 0, " ");
  (21397, 0, "i");
  (21398, 0, "n");
  (21399, 0, "d");
  (21400, 0, "e");
  (21401, 0, "x");
  (21402, 0, " ");
  (21403, 0, "w");
  (21404, 0, "i");
  (21405, 0, "t");
  (21406, 0, "h");
  (21407, 0, "i");
  (21408, 0, "n");
  (21409, 0, " ");
  (21410, 0, "t");
  (21411, 0, "h");
  (21412, 0, "e");
  (21413, 0, " ");
  (21414, 0, "n");
  (21415, 0, "o");
  (21416, 0, "d");
  (21417, 0, "e");
  (21418, 0, ".");
  (10048, 966, "");
  (10047, 1, "");
  (20452, 0, "\n        ");
  (20461, 0, "\n    /// I dunno where this logic should live, but we want to get the index of\n    /// the item at the specified offset into the node (and the offset into the\n    /// item).\n    /// \n    /// If the offset lands between items, we could return either the previous or next item.\n    /// \n    /// Returns (index, item_offset).\n    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) -> (usize, usize) {\n        if usersize_offset == 0 { return (0, 0); }\n\n        for (i, item) in self.content_slice().iter().enumerate() {\n            let usersize = C::get_usersize(item);\n            if usersize > usersize_offset {\n                return (i, usersize_offset);\n            } else if usersize == usersize_offset {\n                return if stick_end { (i, usersize_offset) } else { (i+1, 0) }\n            } else {\n                usersize_offset -= usersize;\n            }\n        }\n        panic!(\"Could not find requested offset within the node\");\n    }");
  (20453, 8, "");
  (20453, 323, "");
  (20453, 92, "");
  (20999, 5, "");
  (20998, 1, "");
  (20932, 66, "");
  (20931, 1, "");
  (20931, 0, "\n        ");
  (20931, 9, "");
  (20931, 0, "\n");
  (20932, 0, "        panic!(\"Could not find requested offset within the node\");");
  (20998, 0, "\n");
  (20999, 0, "    }");
  (20453, 0, "    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) -> (usize, usize) {\n");
  (20457, 0, "// ");
  (20453, 0, "    ");
  (21098, 5, "");
  (21097, 1, "");
  (21039, 0, "// ");
  (20629, 4, "c");
  (20630, 0, "u");
  (20631, 0, "r");
  (20632, 0, "s");
  (20633, 0, "o");
  (20634, 0, "r");
  (20629, 6, "self");
  (20560, 0, "// ");
  (20560, 3, "");
  (20551, 0, "\n            ");
  (20560, 4, "");
  (20560, 0, "l");
  (20561, 0, "e");
  (20562, 0, "t");
  (20563, 0, " ");
  (20564, 0, "e");
  (20565, 0, " ");
  (20566, 0, "=");
  (20567, 0, " ");
  (20560, 8, "");
  (20572, 15, "o");
  (20573, 0, "f");
  (20574, 0, "f");
  (20575, 0, "s");
  (20576, 0, "e");
  (20577, 0, "t");
  (20552, 8, "");
  (20551, 1, "");
  (20585, 1, "");
  (20585, 0, "c");
  (20586, 0, "r");
  (20586, 1, "");
  (20586, 0, "u");
  (20587, 0, "r");
  (20588, 0, "s");
  (20589, 0, "o");
  (20590, 0, "r");
  (19538, 0, "\n            ");
  (19551, 0, "i");
  (19552, 0, "n");
  (19553, 0, "d");
  (19551, 3, "");
  (19551, 0, "l");
  (19552, 0, "o");
  (19553, 0, "c");
  (19554, 0, "a");
  (19555, 0, "l");
  (19556, 0, "_");
  (19557, 0, "i");
  (19558, 0, "n");
  (19559, 0, "d");
  (19560, 0, "e");
  (19561, 0, "x");
  (19562, 0, ":");
  (19563, 0, " ");
  (19564, 0, "0");
  (19565, 0, ",");
  (20653, 4, "");
  (20653, 0, "(");
  (20654, 0, "*");
  (20655, 0, "e");
  (20656, 0, ")");
  (20771, 15, "o");
  (20772, 0, "f");
  (20773, 0, "f");
  (20774, 0, "s");
  (20775, 0, "e");
  (20776, 0, "t");
  (20779, 0, "\n                ");
  (20796, 0, "c");
  (20797, 0, "u");
  (20798, 0, "r");
  (20799, 0, "s");
  (20800, 0, "o");
  (20801, 0, "r");
  (20802, 0, ".");
  (20803, 0, "l");
  (20804, 0, "o");
  (20805, 0, "c");
  (20806, 0, "a");
  (20807, 0, "l");
  (20803, 5, "local_index");
  (20814, 0, " ");
  (20815, 0, " ");
  (20815, 1, "");
  (20815, 0, "=");
  (20816, 0, " ");
  (20817, 0, "i");
  (20818, 0, ";");
  (20836, 28, "b");
  (20836, 1, "return (i, usersize_offset);");
  (20977, 18, "");
  (20940, 13, "");
  (20770, 0, "=");
  (20866, 100, "");
  (20837, 28, "b");
  (20838, 0, "r");
  (20839, 0, "e");
  (20840, 0, "a");
  (20841, 0, "k");
  (20842, 0, ";");
  (20627, 0, "\n        ");
  (20636, 0, "l");
  (20637, 0, "e");
  (20638, 0, "t");
  (20639, 0, " ");
  (20640, 0, "m");
  (20641, 0, "u");
  (20642, 0, "t");
  (20643, 0, " ");
  (20644, 0, "f");
  (20645, 0, "o");
  (20646, 0, "u");
  (20647, 0, "n");
  (20648, 0, "d");
  (20649, 0, " ");
  (20650, 0, "=");
  (20651, 0, " ");
  (20652, 0, "f");
  (20653, 0, "a");
  (20654, 0, "l");
  (20655, 0, "s");
  (20656, 0, "e");
  (20657, 0, ";");
  (20851, 0, "\n                ");
  (20868, 0, "f");
  (20869, 0, "o");
  (20870, 0, "u");
  (20871, 0, "n");
  (20872, 0, "d");
  (20873, 0, " ");
  (20874, 0, "=");
  (20875, 0, " ");
  (20876, 0, "t");
  (20877, 0, "r");
  (20878, 0, "u");
  (20879, 0, "e");
  (20880, 0, ";");
  (20994, 0, "\n        ");
  (21003, 0, "a");
  (21004, 0, "s");
  (21005, 0, "s");
  (21006, 0, "e");
  (21007, 0, "r");
  (21008, 0, "t");
  (21009, 0, "!");
  (21010, 0, "(");
  (21011, 0, "f");
  (21012, 0, "o");
  (21013, 0, "u");
  (21014, 0, "n");
  (21015, 0, "d");
  (21016, 0, ")");
  (21017, 0, ";");
  (20994, 0, "\n        ");
  (21027, 0, "\n        ");
  (20995, 8, "");
  (21020, 8, "");
  (20942, 15, "o");
  (20943, 0, "f");
  (20944, 0, "f");
  (20945, 0, "s");
  (20946, 0, "e");
  (20947, 0, "t");
  (21238, 0, "(");
  (21245, 0, ",");
  (21246, 0, " ");
  (21247, 0, "o");
  (21248, 0, "f");
  (21249, 0, "f");
  (21250, 0, "s");
  (21251, 0, "e");
  (21252, 0, "t");
  (21253, 0, ")");
  (37472, 0, "(");
  (37479, 0, ",");
  (37480, 0, " ");
  (37481, 0, "o");
  (37482, 0, "f");
  (37483, 0, "f");
  (37484, 0, "s");
  (37485, 0, "e");
  (37486, 0, "t");
  (37487, 0, ")");
  (37468, 4, "");
  (37469, 0, "m");
  (37470, 0, "u");
  (37471, 0, "t");
  (37472, 0, " ");
  (37522, 115, "");
  (37636, 7, "");
  (30233, 21, "");
  (30313, 0, "\n        ");
  (30322, 0, ", mut item_idx: usize");
  (30322, 1, "l");
  (30323, 0, "e");
  (30324, 0, "t");
  (30338, 7, " ");
  (30339, 0, "=");
  (30340, 0, " ");
  (30341, 0, "c");
  (30342, 0, "u");
  (30343, 0, "r");
  (30344, 0, "s");
  (30345, 0, "o");
  (30346, 0, "r");
  (30347, 0, ".");
  (30348, 0, ".");
  (30349, 0, "l");
  (30349, 1, "");
  (30348, 1, "");
  (30348, 0, "l");
  (30349, 0, "o");
  (30350, 0, "c");
  (30351, 0, "a");
  (30352, 0, "l");
  (30348, 5, "local_index");
  (30359, 0, ";");
  (36635, 44, "(mut cursor, offset) = self.iter_at_userpos(userpos);");
  (36635, 0, " ");
  (36690, 115, "");
  (36806, 7, "");
  (24277, 19, "");
  (24276, 1, "");
  (24275, 1, "");
  (24383, 0, "\n        ");
  (24392, 0, "l");
  (24393, 0, "e");
  (24394, 0, " ");
  (24394, 1, "");
  (24394, 0, "t");
  (24395, 0, " ");
  (24396, 0, "mut item_idx: usize");
  (24408, 7, " ");
  (24409, 0, "=");
  (24410, 0, " ");
  (24411, 0, "c");
  (24412, 0, "u");
  (24413, 0, "r");
  (24414, 0, "s");
  (24415, 0, "o");
  (24416, 0, "r");
  (24417, 0, ".");
  (24418, 0, "l");
  (24419, 0, "o");
  (24420, 0, "c");
  (24421, 0, "a");
  (24418, 4, "local_index");
  (24429, 0, ";");
  (24430, 0, "\n        ");
  (24431, 8, "");
  (13610, 0, "\n            ");
  (13623, 0, "s");
  (13624, 0, "e");
  (13625, 0, "l");
  (13626, 0, "f");
  (13627, 0, ".");
  (13628, 0, "l");
  (13629, 0, "o");
  (13630, 0, "c");
  (13631, 0, "a");
  (13632, 0, "l");
  (13628, 5, "local_index");
  (13639, 0, " ");
  (13640, 0, "=");
  (13641, 0, " ");
  (13642, 0, "0");
  (13643, 0, ";");
  (24426, 0, "// ");
  (24599, 8, "cursor.local_index");
  (25112, 8, "cursor.local_index");
  (25642, 33, "");
  (25641, 1, "");
  (25798, 0, "\n        ");
  (25807, 0, "let mut item_idx = cursor.local_index;");
  (25810, 4, "");
  (24417, 50, "");
  (13898, 0, "\n        ");
  (13907, 0, "/");
  (13908, 0, "/");
  (13909, 0, " ");
  (13910, 0, "N");
  (13911, 0, "o");
  (13912, 0, "t");
  (13913, 0, "e");
  (13899, 15, "");
  (13898, 1, "");
  (13857, 0, "\n    ");
  (13862, 0, "/");
  (13863, 0, "/");
  (13864, 0, "/");
  (13865, 0, " ");
  (13866, 0, "W");
  (13867, 0, "a");
  (13868, 0, "r");
  (13869, 0, "n");
  (13870, 0, "i");
  (13871, 0, "n");
  (13872, 0, "g");
  (13873, 0, ":");
  (13874, 0, " ");
  (13875, 0, "T");
  (13876, 0, "h");
  (13877, 0, "i");
  (13878, 0, "s");
  (13879, 0, " ");
  (13880, 0, "r");
  (13881, 0, "e");
  (13882, 0, "t");
  (13883, 0, "u");
  (13884, 0, "r");
  (13885, 0, "n");
  (13886, 0, "s");
  (13887, 0, " ");
  (13888, 0, "f");
  (13889, 0, "a");
  (13890, 0, "l");
  (13891, 0, "s");
  (13892, 0, "e");
  (13893, 0, " ");
  (13894, 0, "i");
  (13895, 0, "f");
  (13896, 0, " ");
  (13897, 0, "o");
  (13898, 0, "n");
  (13899, 0, "e");
  (13900, 0, " ");
  (13901, 0, "c");
  (13902, 0, "u");
  (13903, 0, "r");
  (13904, 0, "s");
  (13905, 0, "o");
  (13906, 0, "r");
  (13907, 0, " ");
  (13908, 0, "i");
  (13909, 0, "s");
  (13910, 0, " ");
  (13911, 0, "a");
  (13912, 0, "t");
  (13913, 0, " ");
  (13914, 0, "t");
  (13915, 0, "h");
  (13916, 0, "e");
  (13917, 0, "e");
  (13918, 0, " ");
  (13918, 1, "");
  (13917, 1, "");
  (13917, 0, " ");
  (13918, 0, "e");
  (13919, 0, "n");
  (13920, 0, "d");
  (13921, 0, " ");
  (13922, 0, "f");
  (13922, 1, "");
  (13922, 0, "o");
  (13923, 0, "f");
  (13924, 0, " ");
  (13925, 0, "a");
  (13926, 0, " ");
  (13927, 0, "n");
  (13928, 0, "o");
  (13929, 0, "d");
  (13930, 0, "e");
  (13931, 0, ",");
  (13932, 0, " ");
  (13933, 0, "a");
  (13934, 0, "n");
  (13935, 0, "d");
  (13936, 0, " ");
  (13937, 0, "t");
  (13938, 0, "h");
  (13939, 0, "e");
  (13940, 0, " ");
  (13941, 0, "o");
  (13942, 0, "t");
  (13943, 0, "h");
  (13944, 0, "e");
  (13945, 0, "r");
  (13946, 0, " ");
  (13947, 0, "a");
  (13948, 0, "t");
  (13949, 0, " ");
  (13950, 0, "t");
  (13951, 0, "h");
  (13952, 0, "e");
  (13953, 0, " ");
  (13954, 0, "s");
  (13955, 0, "t");
  (13956, 0, "a");
  (13957, 0, "r");
  (13958, 0, "t");
  (13959, 0, " ");
  (13960, 0, "o");
  (13961, 0, "f");
  (13962, 0, " ");
  (13963, 0, "t");
  (13964, 0, "h");
  (13965, 0, "e");
  (13966, 0, " ");
  (13967, 0, "n");
  (13968, 0, "e");
  (13969, 0, "x");
  (13970, 0, "t");
  (13971, 0, " ");
  (13972, 0, "n");
  (13973, 0, "o");
  (13974, 0, "d");
  (13975, 0, "e");
  (13976, 0, ".");
  (13977, 0, " ");
  (13978, 0, "A");
  (13979, 0, "l");
  (13980, 0, "m");
  (13981, 0, "o");
  (13982, 0, "s");
  (13983, 0, "t");
  (13984, 0, " ");
  (13985, 0, "a");
  (13986, 0, "l");
  (13987, 0, "l");
  (13988, 0, " ");
  (13989, 0, "c");
  (13990, 0, "o");
  (13991, 0, "d");
  (13992, 0, "e");
  (13993, 0, " ");
  (13994, 0, "b");
  (13995, 0, "e");
  (13995, 1, "");
  (13995, 0, "i");
  (13995, 1, "");
  (13994, 1, "");
  (13994, 0, "i");
  (13995, 0, "n");
  (13996, 0, " ");
  (13997, 0, "t");
  (13998, 0, "h");
  (13999, 0, "i");
  (14000, 0, "s");
  (14001, 0, " ");
  (14002, 0, "l");
  (14003, 0, "i");
  (14004, 0, "b");
  (14005, 0, "r");
  (14006, 0, "a");
  (14007, 0, "r");
  (14008, 0, "y");
  (14009, 0, " ");
  (14010, 0, "l");
  (14011, 0, "e");
  (14012, 0, "a");
  (14013, 0, "v");
  (14014, 0, "e");
  (14015, 0, "s");
  (14016, 0, " ");
  (14017, 0, "c");
  (14018, 0, "u");
  (14019, 0, "r");
  (14020, 0, "s");
  (14021, 0, "o");
  (14022, 0, "r");
  (14023, 0, "s");
  (14024, 0, " ");
  (14025, 0, "a");
  (14026, 0, "t");
  (14027, 0, " ");
  (14028, 0, "t");
  (14029, 0, "h");
  (14030, 0, "e");
  (14031, 0, "e");
  (14032, 0, "n");
  (14032, 1, "");
  (14031, 1, "");
  (14031, 0, " ");
  (14032, 0, "e");
  (14033, 0, "n");
  (14034, 0, "d");
  (14035, 0, " ");
  (14036, 0, "o");
  (14037, 0, "f");
  (14038, 0, " ");
  (14039, 0, "n");
  (14040, 0, "o");
  (14041, 0, "d");
  (14042, 0, "e");
  (14043, 0, "s");
  (14044, 0, ",");
  (14045, 0, " ");
  (14046, 0, "s");
  (14047, 0, "o");
  (14048, 0, " ");
  (14049, 0, "t");
  (14050, 0, "h");
  (14051, 0, "i");
  (14052, 0, "s");
  (14053, 0, " ");
  (14054, 0, "s");
  (14055, 0, "h");
  (14056, 0, "o");
  (14057, 0, "u");
  (14058, 0, "l");
  (14059, 0, "d");
  (14060, 0, "n");
  (14061, 0, "'");
  (14062, 0, "t");
  (14063, 0, " ");
  (14064, 0, "m");
  (14065, 0, "a");
  (14066, 0, "t");
  (14067, 0, "t");
  (14068, 0, "e");
  (14069, 0, "r");
  (14070, 0, " ");
  (14071, 0, "o");
  (14071, 1, "");
  (14071, 0, "t");
  (14072, 0, "o");
  (14073, 0, "o");
  (14074, 0, " ");
  (14075, 0, "m");
  (14076, 0, "u");
  (14077, 0, "c");
  (14078, 0, "h");
  (14079, 0, " ");
  (14080, 0, "i");
  (14081, 0, "n");
  (14082, 0, " ");
  (14083, 0, "p");
  (14084, 0, "r");
  (14085, 0, "a");
  (14086, 0, "c");
  (14087, 0, "t");
  (14088, 0, "i");
  (14089, 0, "c");
  (14090, 0, "e");
  (14091, 0, " ");
  (14092, 0, "n");
  (14093, 0, "b");
  (14094, 0, "u");
  (14094, 1, "");
  (14093, 1, "");
  (14092, 1, "");
  (14091, 1, "");
  (14091, 0, ".");
  (13858, 234, "    /// Warning: This returns false if one cursor is at the end of a node, and\n    /// the other at the start of the next node. Almost all code in this library\n    /// leaves cursors at the end of nodes, so this shouldn't matter too much in\n    /// practice.");
  (14158, 0, "        if self.userpos != other.userpos { return false; }\n");
  (14158, 59, "");
  (14198, 0, " ");
  (14199, 0, "|");
  (14200, 0, "|");
  (14201, 0, " ");
  (14202, 0, "s");
  (14203, 0, "e");
  (14204, 0, "l");
  (14205, 0, "f");
  (14206, 0, ".");
  (14207, 0, "l");
  (14208, 0, "o");
  (14209, 0, "c");
  (14210, 0, "a");
  (14211, 0, "l");
  (14207, 5, "local_index");
  (14218, 0, " ");
  (14219, 0, "!");
  (14220, 0, "=");
  (14221, 0, " ");
  (14222, 0, "s");
  (14223, 0, "e");
  (14223, 1, "");
  (14222, 1, "");
  (14222, 0, "o");
  (14223, 0, "t");
  (14224, 0, "h");
  (14225, 0, "e");
  (14226, 0, "r");
  (14227, 0, ".");
  (14228, 0, "u");
  (14229, 0, "s");
  (14230, 0, "e");
  (14231, 0, "r");
  (14231, 1, "");
  (14230, 1, "");
  (14229, 1, "");
  (14228, 1, "");
  (14228, 0, "l");
  (14229, 0, "c");
  (14230, 0, "a");
  (14228, 3, "local_index");
  (14198, 1, "");
  (14198, 0, "\n        ");
  (14207, 0, "    ");
  (14253, 1, "");
  (14253, 0, "\n                ");
  (14253, 17, "");
  (14268, 0, "\n            ");
  (14269, 12, "");
  (14199, 12, "        ");
  (14199, 8, "            ");
  (33923, 0, "(");
  (33934, 0, ",");
  (33935, 0, " ");
  (33936, 0, "o");
  (33937, 0, "f");
  (33938, 0, "f");
  (33939, 0, "s");
  (33940, 0, "e");
  (33941, 0, "t");
  (33942, 0, ")");
  (33991, 0, "// ");
  (34508, 0, "c");
  (34509, 0, "u");
  (34510, 0, "r");
  (34511, 0, "s");
  (34512, 0, "o");
  (34513, 0, "r");
  (34514, 0, ".");
  (34515, 0, "l");
  (34516, 0, "o");
  (34517, 0, "c");
  (34518, 0, "a");
  (34515, 4, "local_index");
  (34526, 5, "");
  (34739, 30, "");
  (34738, 1, "");
  (34756, 0, "\n                ");
  (34773, 0, "\n                ");
  (34757, 16, "");
  (34774, 0, "l");
  (34775, 0, "e");
  (34776, 0, "t");
  (34777, 0, " ");
  (34778, 0, "i");
  (34779, 0, "n");
  (34780, 0, "d");
  (34781, 0, "e");
  (34782, 0, "x");
  (34783, 0, " ");
  (34784, 0, "=");
  (34785, 0, " ");
  (34786, 0, "c");
  (34787, 0, "u");
  (34788, 0, "r");
  (34789, 0, "s");
  (34790, 0, "o");
  (34791, 0, "r");
  (34792, 0, ".");
  (34793, 0, "l");
  (34793, 1, "local_index");
  (34804, 0, ";");
  (36404, 7, "");
  (36511, 7, "");
  (35851, 0, "c");
  (35852, 0, "r");
  (35852, 1, "");
  (35852, 0, "u");
  (35853, 0, "r");
  (35854, 0, "s");
  (35855, 0, "o");
  (35856, 0, "r");
  (35857, 0, ".");
  (35858, 0, "l");
  (35859, 0, "o");
  (35860, 0, "c");
  (35861, 0, "a");
  (35862, 0, "l");
  (35863, 0, "_");
  (37271, 0, "(");
  (37274, 0, ",");
  (37275, 0, " ");
  (37276, 0, "_");
  (37277, 0, ")");
  (21030, 1, "");
  (21030, 0, "u");
  (21031, 0, "n");
  (21032, 0, "s");
  (21033, 0, "a");
  (21034, 0, "f");
  (21035, 0, "e");
  (21036, 0, " ");
  (21037, 0, "{");
  (21040, 1, "");
  (21040, 0, "}");
  (21038, 0, "&");
  (21038, 0, " ");
  (21042, 0, " ");
  (27383, 0, "\n            ");
  (27396, 0, "c");
  (27397, 0, "u");
  (27398, 0, "r");
  (27399, 0, "s");
  (27400, 0, "o");
  (27401, 0, "r");
  (27402, 0, ".");
  (27403, 0, "l");
  (27404, 0, "o");
  (27405, 0, "c");
  (27406, 0, "a");
  (27407, 0, "l");
  (27403, 5, "local_index");
  (27414, 0, " ");
  (27415, 0, "+");
  (27416, 0, "=");
  (27417, 0, " ");
  (27418, 0, "n");
  (27419, 0, "u");
  (27420, 0, "m");
  (27421, 0, "_");
  (27422, 0, "i");
  (27423, 0, "n");
  (27418, 6, "num_inserted_items");
  (27436, 0, ";");
  (24551, 0, "\n            ");
  (24564, 0, "c");
  (24565, 0, "u");
  (24566, 0, "r");
  (24567, 0, "s");
  (24568, 0, "o");
  (24569, 0, "r");
  (24570, 0, ".");
  (24571, 0, "l");
  (24572, 0, "o");
  (24573, 0, "c");
  (24574, 0, "a");
  (24571, 4, "local_index");
  (24582, 0, " ");
  (24583, 0, "=");
  (24584, 0, " ");
  (24585, 0, " += contents.len();");
  (24588, 1, "");
  (24587, 1, "");
  (24586, 1, "");
  (24585, 1, "");
  (21157, 1, "");
  (21259, 0, "\n                ");
  (21260, 16, "            }");
  (21273, 0, " ");
  (21274, 0, "if usersize > offset {");
  (21274, 0, "e");
  (21275, 0, "l");
  (21276, 0, "s");
  (21277, 0, "e");
  (21278, 0, " ");
  (21291, 1, "");
  (21291, 0, "=");
  (21292, 0, "=");
  (21302, 0, "\n                ");
  (21319, 0, "                cursor.local_index = i;\n                found = true;\n                break;");
  (21303, 32, "                ");
  (21341, 0, "+");
  (21342, 0, "1");
  (21454, 0, "\n                offset -= usersize;");
  (21454, 0, "\n            } else {");
  (21398, 21, "");
  (21433, 0, "\n                break;");
  (21375, 23, "");
  (21410, 0, "\n                found = true;");
  (21345, 30, "");
  (21380, 0, "\n                cursor.local_index = i+1;");
  (21303, 42, "");
  (21326, 1, "");
  (21328, 8, "0");
  (21369, 0, " ");
  (21371, 0, " ");
  (21005, 0, "        for (i, item) in unsafe { &*e }.content_slice().iter().enumerate() {\n            let usersize = C::get_usersize(item);\n            if usersize > offset {\n                cursor.local_index = i;\n                found = true;\n                break;\n            } else if usersize == offset {\n                offset = 0;\n                cursor.local_index = i + 1;\n                found = true;\n                break;\n            } else {\n                offset -= usersize;\n            }\n        }\n");
  (22011, 0, "// ");
  (21997, 0, "// ");
  (21961, 0, "// ");
  (21940, 0, "// ");
  (21917, 0, "// ");
  (21887, 0, "// ");
  (21843, 0, "// ");
  (21815, 0, "// ");
  (21772, 0, "// ");
  (21749, 0, "// ");
  (21719, 0, "// ");
  (21679, 0, "// ");
  (21644, 0, "// ");
  (21594, 0, "// ");
  (21517, 0, "// ");
  (20974, 30, "");
  (20973, 1, "");
  (20982, 66, "");
  (20982, 0, "w");
  (20983, 0, "h");
  (20984, 0, "i");
  (20985, 0, "l");
  (20986, 0, " ");
  (20986, 1, "");
  (20986, 0, "e");
  (20987, 0, " ");
  (20982, 6, "");
  (20982, 0, "l");
  (20983, 0, "e");
  (20984, 0, "t");
  (20984, 1, "");
  (20983, 1, "");
  (20982, 1, "");
  (20982, 0, "f");
  (20983, 0, "o");
  (20984, 0, "r");
  (20985, 0, " ");
  (20986, 0, "i");
  (20987, 0, "n");
  (20988, 0, "d");
  (20989, 0, "e");
  (20990, 0, "x");
  (20991, 0, " ");
  (20992, 0, "i");
  (20993, 0, "n");
  (20994, 0, " ");
  (20995, 0, "[");
  (20996, 0, "0");
  (20997, 0, ".");
  (20998, 0, ".");
  (20995, 1, "");
  (20998, 0, "=");
  (20973, 0, "\n        ");
  (20982, 0, "l");
  (20983, 0, "e");
  (20984, 0, "t");
  (20985, 0, " ");
  (20986, 0, "e");
  (20987, 0, "n");
  (20988, 0, " ");
  (20989, 0, "=");
  (20990, 0, " ");
  (20991, 0, "unsafe { &*e }");
  (21005, 0, ";");
  (21032, 0, "e");
  (21033, 0, "n");
  (21034, 0, ".");
  (21035, 0, "n");
  (21036, 0, "u");
  (21037, 0, "m");
  (21035, 3, "num_items");
  (21044, 0, " ");
  (21045, 0, "a");
  (21046, 0, "s");
  (21047, 0, " ");
  (21048, 0, "u");
  (21049, 0, "s");
  (21050, 0, "i");
  (21051, 0, "z");
  (21052, 0, "e");
  (21055, 0, "\n        for index in 0..=en.num_items as usize {");
  (21015, 0, "// ");
  (21067, 38, "w");
  (21068, 0, "h");
  (21069, 0, "i");
  (21070, 0, "l");
  (21071, 0, "e");
  (21072, 0, " ");
  (21073, 0, "o");
  (21074, 0, "f");
  (21075, 0, "f");
  (21076, 0, "s");
  (21077, 0, "e");
  (21078, 0, "t");
  (21079, 0, " ");
  (21080, 0, ">");
  (21081, 0, " ");
  (21082, 0, "0");
  (21058, 0, "\n            ");
  (21071, 0, "l");
  (21072, 0, "e");
  (21073, 0, "t");
  (21073, 1, "");
  (21072, 1, "");
  (21071, 1, "");
  (21067, 4, "");
  (21067, 0, "l");
  (21068, 0, "e");
  (21069, 0, "t");
  (21070, 0, " ");
  (21071, 0, "m");
  (21072, 0, "u");
  (21073, 0, "t");
  (21074, 0, " ");
  (21075, 0, "i");
  (21076, 0, "n");
  (21077, 0, "d");
  (21078, 0, "e");
  (21079, 0, "x");
  (21080, 0, " ");
  (21081, 0, "=");
  (21082, 0, " ");
  (21083, 0, "0");
  (21084, 0, ";");
  (21156, 4, "e");
  (21157, 0, "n");
  (21158, 0, ".");
  (21159, 0, "i");
  (21160, 0, "t");
  (21161, 0, "e");
  (21162, 0, "m");
  (21163, 0, "s");
  (21164, 0, "[");
  (21165, 0, "i");
  (21166, 0, "n");
  (21167, 0, "d");
  (21168, 0, "e");
  (21169, 0, "x");
  (21170, 0, "]");
  (21156, 0, "&");
  (21190, 17, "o");
  (21191, 0, "f");
  (21192, 0, "f");
  (21193, 0, "s");
  (21194, 0, "e");
  (21195, 0, "t");
  (21196, 0, " ");
  (21197, 0, "<");
  (21198, 0, "=");
  (21199, 0, " ");
  (21200, 0, "u");
  (21201, 0, "s");
  (21202, 0, "e");
  (21203, 0, "r");
  (21204, 0, "s");
  (21205, 0, "i");
  (21200, 6, "usersize");
  (21198, 1, "");
  (21197, 1, "");
  (21197, 0, ">");
  (21197, 1, "");
  (21197, 0, "<=");
  (21200, 8, "usersi");
  (21199, 7, "");
  (21196, 3, "");
  (21190, 6, "usersize > offset");
  (21174, 0, "\n            ");
  (21187, 0, "i");
  (21188, 0, "f");
  (21189, 0, " ");
  (21190, 0, "u");
  (21191, 0, "s");
  (21192, 0, "e");
  (21193, 0, "r");
  (21194, 0, "s");
  (21195, 0, "i");
  (21190, 6, "usersize");
  (21198, 0, " ");
  (21199, 0, "<");
  (21200, 0, "=");
  (21201, 0, " ");
  (21202, 0, "o");
  (21203, 0, "f");
  (21204, 0, "f");
  (21205, 0, "s");
  (21206, 0, "e");
  (21207, 0, "t");
  (21208, 0, " ");
  (21209, 0, "{");
  (21210, 0, "\n                ");
  (21227, 0, "o");
  (21228, 0, "f");
  (21229, 0, "f");
  (21230, 0, "s");
  (21231, 0, "e");
  (21232, 0, "t");
  (21233, 0, " ");
  (21234, 0, "-");
  (21235, 0, "=");
  (21236, 0, " ");
  (21237, 0, "u");
  (21238, 0, "s");
  (21239, 0, "e");
  (21240, 0, "r");
  (21241, 0, "z");
  (21242, 0, "i");
  (21237, 6, "usersize");
  (21245, 0, ";");
  (21246, 0, "\n                ");
  (21247, 16, "            }");
  (21260, 0, " ");
  (21261, 0, "e");
  (21262, 0, "l");
  (21263, 0, "s");
  (21264, 0, "e");
  (21265, 0, " ");
  (21266, 0, "{");
  (21267, 0, "\n                ");
  (21284, 0, "\n                ");
  (21268, 16, "");
  (21269, 16, "            }");
  (21268, 0, "                ");
  (21284, 0, "/");
  (21285, 0, "/");
  (21286, 0, " ");
  (21287, 0, "T");
  (21288, 0, "o");
  (21289, 0, "o");
  (21290, 0, " ");
  (21291, 0, "b");
  (21292, 0, "i");
  (21293, 0, "g");
  (21294, 0, "!");
  (21295, 0, " ");
  (21296, 0, "W");
  (21297, 0, "e");
  (21298, 0, "'");
  (21299, 0, "r");
  (21300, 0, "e");
  (21284, 17, "");
  (21284, 0, "b");
  (21285, 0, "r");
  (21286, 0, "e");
  (21287, 0, "a");
  (21288, 0, "k");
  (21289, 0, ";");
  (21305, 366, "");
  (21304, 1, "");
  (21112, 0, "\n            ");
  (21125, 0, "a");
  (21126, 0, "s");
  (21127, 0, "s");
  (21128, 0, "e");
  (21129, 0, "r");
  (21125, 5, "assert_eq!");
  (21134, 1, "");
  (21133, 1, "");
  (21132, 1, "");
  (21131, 1, "");
  (21131, 0, "!");
  (21132, 0, "(");
  (21133, 0, "i");
  (21134, 0, "n");
  (21135, 0, "d");
  (21136, 0, "e");
  (21137, 0, "x");
  (21138, 0, " ");
  (21139, 0, "<");
  (21140, 0, " ");
  (21141, 0, "e");
  (21142, 0, "n");
  (21143, 0, ".");
  (21144, 0, "i");
  (21145, 0, "t");
  (21146, 0, "e");
  (21147, 0, "m");
  (21148, 0, "s");
  (21149, 0, ".");
  (21144, 6, "n");
  (21145, 0, "u");
  (21146, 0, "m");
  (21147, 0, "_");
  (21148, 0, "i");
  (21149, 0, "t");
  (21144, 6, "num_items");
  (21153, 0, " ");
  (21154, 0, "a");
  (21155, 0, "s");
  (21156, 0, " ");
  (21157, 0, "u");
  (21158, 0, "s");
  (21159, 0, "i");
  (21160, 0, "z");
  (21161, 0, "e");
  (21162, 0, ")");
  (21163, 0, ";");
  (21164, 0, "\n            ");
  (21165, 12, "");
  (21153, 9, "");
  (21156, 0, "            ");
  (21153, 0, " as usize");
  (21007, 51, "");
  (21877, 1, "");
  (21886, 0, "// ");
  (21213, 2, ">");
  (21223, 0, " ");
  (21224, 0, "b");
  (21225, 0, "r");
  (21226, 0, "e");
  (21227, 0, "a");
  (21228, 0, "k");
  (21229, 0, ";");
  (21230, 0, " ");
  (21231, 0, "}");
  (21233, 16, "            ");
  (21265, 58, "");
  (21264, 0, "\n            ");
  (21277, 0, "i");
  (21278, 0, "n");
  (21279, 0, "d");
  (21280, 0, "e");
  (21281, 0, "x");
  (21282, 0, " ");
  (21283, 0, "+");
  (21284, 0, "=");
  (21285, 0, " ");
  (21286, 0, "1");
  (21287, 0, ";");
  (21232, 0, " ");
  (21232, 1, "");
  (21232, 0, " ");
  (21232, 1, "");
  (21232, 0, " ");
  (21233, 0, "/");
  (21234, 0, "/");
  (21235, 0, " ");
  (21236, 0, "F");
  (21236, 1, "");
  (21235, 1, "");
  (21234, 1, "");
  (21233, 1, "");
  (21232, 1, "");
  (21232, 0, " ");
  (21233, 0, "/");
  (21234, 0, "/");
  (21235, 0, " ");
  (21236, 0, "W");
  (21237, 0, "e");
  (21238, 0, "'");
  (21239, 0, "r");
  (21240, 0, "e");
  (21241, 0, " ");
  (21242, 0, "p");
  (21243, 0, "a");
  (21244, 0, "r");
  (21245, 0, "t");
  (21246, 0, "w");
  (21247, 0, "a");
  (21248, 0, "y");
  (21249, 0, " ");
  (21250, 0, "t");
  (21251, 0, "h");
  (21252, 0, "r");
  (21253, 0, "o");
  (21254, 0, "u");
  (21242, 13, "i");
  (21243, 0, "n");
  (21244, 0, " ");
  (21245, 0, "t");
  (21246, 0, "h");
  (21247, 0, "e");
  (21248, 0, " ");
  (21249, 0, "m");
  (21250, 0, "i");
  (21251, 0, "d");
  (21252, 0, "d");
  (21253, 0, "l");
  (21254, 0, "e");
  (21255, 0, " ");
  (21256, 0, "o");
  (21257, 0, "f");
  (21258, 0, " ");
  (21259, 0, "a");
  (21260, 0, "n");
  (21261, 0, " ");
  (21262, 0, "i");
  (21263, 0, "t");
  (21264, 0, "e");
  (21265, 0, "m");
  (21266, 0, ".");
  (21333, 0, "\n        ");
  (21342, 0, "c");
  (21343, 0, "u");
  (21344, 0, "r");
  (21345, 0, "s");
  (21346, 0, "o");
  (21347, 0, "r");
  (21348, 0, ".");
  (21349, 0, "i");
  (21350, 0, "n");
  (21351, 0, "d");
  (21352, 0, "e");
  (21353, 0, "x");
  (21354, 0, " ");
  (21354, 1, "");
  (21349, 5, "l");
  (21350, 0, "o");
  (21351, 0, "c");
  (21352, 0, "a");
  (21353, 0, "l");
  (21349, 5, "local_index");
  (21360, 0, " ");
  (21361, 0, "=");
  (21362, 0, " ");
  (21363, 0, "i");
  (21364, 0, "n");
  (21365, 0, "d");
  (21366, 0, "e");
  (21367, 0, "x");
  (21368, 0, ";");
  (21370, 575, "");
  (21369, 1, "");
  (21371, 69, "");
  (21370, 1, "");
  (21369, 1, "");
  (21371, 147, "");
  (20753, 0, "        // We should always land within the node we're pointing to.\n        debug_assert!(offset <= unsafe { &*cursor.here_ptr() }.get_userlen());\n");
  (20753, 8, "\n        ");
  (20975, 99, "");
  (20975, 47, "");
  (20974, 1, "");
  (21007, 1, "");
  (21034, 0, "\n        ");
  (21035, 8, "");
  (13678, 0, "\n    ");
  (13683, 0, "\n    ");
  (13679, 4, "");
  (13684, 0, "f");
  (13685, 0, "n");
  (13686, 0, " ");
  (13687, 0, "a");
  (13688, 0, "d");
  (13689, 0, "v");
  (13690, 0, "a");
  (13691, 0, "n");
  (13692, 0, "c");
  (13693, 0, "e");
  (13694, 0, "_");
  (13695, 0, "i");
  (13696, 0, "t");
  (13697, 0, "e");
  (13698, 0, "m");
  (13699, 0, "(");
  (13700, 0, "*");
  (13700, 1, "");
  (13700, 0, "&");
  (13701, 0, "m");
  (13702, 0, "u");
  (13703, 0, "t");
  (13704, 0, " ");
  (13705, 0, "s");
  (13706, 0, "e");
  (13707, 0, "l");
  (13708, 0, "f");
  (13709, 0, ")");
  (13710, 0, " ");
  (13711, 0, "{");
  (13712, 0, "\n        ");
  (13721, 0, "\n        ");
  (13713, 8, "");
  (13714, 8, "    }");
  (13713, 0, "        ");
  (13721, 0, "if cursor.local_index == (*e).num_items as usize {");
  (13721, 0, "// ");
  (13678, 0, "\n    ");
  (13683, 0, "\n    ");
  (13679, 4, "");
  (13684, 0, "f");
  (13685, 0, "n");
  (13686, 0, " ");
  (13687, 0, "i");
  (13688, 0, "s");
  (13689, 0, "_");
  (13690, 0, "a");
  (13691, 0, "t");
  (13692, 0, "_");
  (13693, 0, "n");
  (13694, 0, "o");
  (13695, 0, "d");
  (13696, 0, "e");
  (13697, 0, "_");
  (13698, 0, "e");
  (13699, 0, "n");
  (13700, 0, "d");
  (13701, 0, "(");
  (13702, 0, "&");
  (13703, 0, "s");
  (13704, 0, "e");
  (13705, 0, "l");
  (13706, 0, "f");
  (13707, 0, ")");
  (13708, 0, " ");
  (13709, 0, "-");
  (13710, 0, ">");
  (13711, 0, " ");
  (13712, 0, "b");
  (13713, 0, "o");
  (13714, 0, "o");
  (13715, 0, "l");
  (13716, 0, " ");
  (13717, 0, "{");
  (13718, 0, "\n        ");
  (13727, 0, "\n        ");
  (13719, 8, "");
  (13720, 8, "    }");
  (13719, 0, "if cursor.local_index == (*e).num_items as usize {");
  (13719, 0, "        ");
  (13727, 2, "");
  (13727, 1, "");
  (13727, 6, "s");
  (13728, 0, "e");
  (13729, 0, "l");
  (13730, 0, "f");
  (13749, 1, "");
  (13749, 0, "self.entries[0].node");
  (13790, 1, "");
  (13789, 1, "");
  (13747, 0, "n");
  (13747, 1, "");
  (13747, 0, "u");
  (13748, 0, "n");
  (13749, 0, "s");
  (13750, 0, "a");
  (13751, 0, "f");
  (13752, 0, "e");
  (13753, 0, " ");
  (13754, 0, "{");
  (13755, 0, " ");
  (13756, 1, "");
  (13756, 0, "(");
  (13789, 0, " ");
  (13790, 0, "}");
  (13840, 0, "\n        ");
  (13849, 0, "i");
  (13850, 0, "f");
  (13851, 0, " ");
  (13852, 0, "s");
  (13853, 0, "e");
  (13854, 0, "l");
  (13855, 0, "f");
  (13856, 0, ".");
  (13857, 0, "i");
  (13858, 0, "s");
  (13859, 0, "_");
  (13857, 3, "is_at_node_end()");
  (13873, 0, " ");
  (13874, 0, "{");
  (13875, 0, " ");
  (13876, 0, "a");
  (13877, 0, "d");
  (13878, 0, "v");
  (13879, 0, "a");
  (13876, 4, "advance_by");
  (13885, 1, "");
  (13884, 1, "");
  (13883, 1, "");
  (13876, 7, "advance_node");
  (13888, 0, "(");
  (13889, 0, ")");
  (13890, 0, ";");
  (13891, 0, " ");
  (13892, 0, "}");
  (13893, 0, "\n        ");
  (13894, 8, "");
  (13876, 0, "s");
  (13877, 0, "e");
  (13878, 0, "l");
  (13879, 0, "f");
  (13880, 0, ".");
  (13849, 2, "s");
  (13849, 1, "");
  (13849, 0, "w");
  (13850, 0, "h");
  (13851, 0, "i");
  (13852, 0, "l");
  (13853, 0, "e");
  (13902, 0, "        ");
  (17086, 0, "                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n");
  (13902, 8, "");
  (17179, 26, ">");
  (17180, 0, " ");
  (17181, 0, "0");
  (17184, 0, " ");
  (17185, 0, "/");
  (17186, 0, "/");
  (17187, 0, " ");
  (17188, 0, "e");
  (17189, 0, "m");
  (17190, 0, "p");
  (17191, 0, "t");
  (17192, 0, "y");
  (17193, 0, " ");
  (17194, 0, "n");
  (17195, 0, "o");
  (17196, 0, "d");
  (17197, 0, "d");
  (17198, 0, "e");
  (17199, 0, "s");
  (17184, 16, "");
  (17182, 0, ",");
  (17183, 0, " ");
  (17184, 0, "\"");
  (17185, 0, "E");
  (17186, 0, "m");
  (17187, 0, "p");
  (17188, 0, "t");
  (17189, 0, "y");
  (17190, 0, " ");
  (17191, 0, "n");
  (17192, 0, "o");
  (17193, 0, "t");
  (17193, 1, "");
  (17193, 0, "d");
  (17194, 0, "e");
  (17195, 0, "s");
  (17196, 0, " ");
  (17197, 0, "n");
  (17198, 0, "o");
  (17199, 0, "t");
  (17200, 0, " ");
  (17201, 0, "a");
  (17202, 0, "l");
  (17203, 0, "l");
  (17204, 0, "o");
  (17205, 0, "w");
  (17206, 0, "e");
  (17207, 0, "d");
  (17208, 0, "\"");
  (13849, 5, "i");
  (13850, 0, "f");
  (13898, 0, "\n        ");
  (13907, 0, "/");
  (13908, 0, "/");
  (13909, 0, " ");
  (13910, 0, "T");
  (13911, 0, "e");
  (13912, 0, "h");
  (13913, 0, " ");
  (13914, 0, "n");
  (13915, 0, "o");
  (13916, 0, "d");
  (13917, 0, "e");
  (13910, 8, "");
  (13910, 0, "T");
  (13911, 0, "h");
  (13912, 0, "e");
  (13913, 0, " ");
  (13913, 1, "");
  (13907, 6, "");
  (13907, 0, "s");
  (13908, 0, "e");
  (13909, 0, "l");
  (13910, 0, "f");
  (13911, 0, ".");
  (13912, 0, "l");
  (13913, 0, "o");
  (13914, 0, "c");
  (13915, 0, "a");
  (13916, 0, "l");
  (13912, 5, "local_index");
  (13923, 0, " ");
  (13924, 0, "+");
  (13925, 0, "=");
  (13926, 0, " ");
  (13927, 0, "1");
  (13928, 0, ";");
  (13930, 63, "");
  (13935, 0, "\n    ");
  (13940, 0, "\n    ");
  (13936, 4, "");
  (13941, 0, "f");
  (13942, 0, "n");
  (13943, 0, " ");
  (13944, 0, "a");
  (13945, 0, "d");
  (13946, 0, "v");
  (13947, 0, "a");
  (13948, 0, "n");
  (13949, 0, "c");
  (13950, 0, "e");
  (13951, 0, "_");
  (13952, 0, "b");
  (13953, 0, "y");
  (13954, 0, "_");
  (13955, 0, "i");
  (13956, 0, "t");
  (13957, 0, "e");
  (13958, 0, "m");
  (13959, 0, "s");
  (13960, 0, "(");
  (13961, 0, "&");
  (13962, 0, "m");
  (13963, 0, "u");
  (13964, 0, "s");
  (13965, 0, "t");
  (13966, 0, " ");
  (13966, 1, "");
  (13965, 1, "");
  (13964, 1, "");
  (13964, 0, "t");
  (13965, 0, " ");
  (13966, 0, "s");
  (13967, 0, "e");
  (13968, 0, "l");
  (13969, 0, "f");
  (13970, 0, ")");
  (13971, 0, " ");
  (13972, 0, "{");
  (13973, 0, "\n        ");
  (13982, 0, "\n        ");
  (13974, 8, "");
  (13975, 8, "    }");
  (13974, 0, "        ");
  (13982, 0, "f");
  (13983, 0, "o");
  (13984, 0, "r");
  (13985, 0, " ");
  (13986, 0, "0");
  (13986, 1, "");
  (13986, 0, "_");
  (13987, 0, " ");
  (13987, 1, "");
  (13986, 1, "");
  (13986, 0, "0");
  (13987, 0, ".");
  (13988, 0, ".");
  (13970, 0, " ");
  (13970, 1, "");
  (13970, 0, ",");
  (13971, 0, " ");
  (13972, 0, "n");
  (13973, 0, "u");
  (13974, 0, "m");
  (13975, 0, ":");
  (13976, 0, " ");
  (13977, 0, "u");
  (13978, 0, "s");
  (13979, 0, "i");
  (13980, 0, "z");
  (13981, 0, "e");
  (14001, 0, "n");
  (14002, 0, "u");
  (14003, 0, "m");
  (14004, 0, " ");
  (14005, 0, "{");
  (14006, 0, " ");
  (14007, 0, "s");
  (14008, 0, "e");
  (14009, 0, "l");
  (14010, 0, "f");
  (14011, 0, ".");
  (14012, 0, "a");
  (14013, 0, "d");
  (14014, 0, "v");
  (14012, 3, "advance_item()");
  (14026, 0, ";");
  (14027, 0, " ");
  (14028, 0, "}");
  (13997, 0, " ");
  (13998, 0, "_");
  (13999, 0, " ");
  (14000, 0, "i");
  (14001, 0, "n");
  (37673, 0, "\n            let (c2, _) = self.iter_at_userpos(userpos + C::userlen_of_slice(contents));");
  (37597, 0, "// ");
  (37731, 32, "");
  (37733, 0, "\n            ");
  (37746, 0, "c");
  (37747, 0, "2");
  (37748, 0, ".");
  (37749, 0, "a");
  (37750, 0, "d");
  (37751, 0, "v");
  (37749, 3, "advance_by_items(num: usize)");
  (37766, 10, "c");
  (37767, 0, "o");
  (37768, 0, "n");
  (37769, 0, "t");
  (37770, 0, "e");
  (37771, 0, "n");
  (37772, 0, "t");
  (37773, 0, "s");
  (37774, 0, ".");
  (37775, 0, "l");
  (37776, 0, "e");
  (37777, 0, "n");
  (37778, 0, "(");
  (37779, 1, ")");
  (37780, 0, ")");
  (37781, 0, ";");
  (37694, 0, "m");
  (37695, 0, "u");
  (37696, 0, "t");
  (37697, 0, " ");
  (16996, 0, "\n                ");
  (17013, 0, "e");
  (17014, 0, "t");
  (17015, 0, " ");
  (17015, 1, "");
  (17014, 1, "");
  (17013, 1, "");
  (17013, 0, "l");
  (17014, 0, "e");
  (17015, 0, "t");
  (17016, 0, " ");
  (17017, 0, "i");
  (17018, 0, "s");
  (17019, 0, "_");
  (17020, 0, "h");
  (17021, 0, "e");
  (17022, 0, "a");
  (17023, 0, "d");
  (17024, 0, " ");
  (17025, 0, "=");
  (17026, 0, " ");
  (17052, 53, "");
  (17027, 0, "(n as *const Node<C> == &self.head as *const Node<C>)");
  (17079, 1, "");
  (17027, 1, "");
  (17071, 7, "_");
  (17039, 7, "_");
  (17066, 0, ";");
  (17092, 0, "i");
  (17093, 0, "s");
  (17094, 0, "_");
  (17095, 0, "h");
  (17096, 0, "e");
  (17097, 0, "a");
  (17098, 0, "d");
  (17238, 69, "");
  (17084, 0, "i");
  (17085, 0, "f");
  (17086, 0, " ");
  (17087, 0, "!");
  (17088, 0, "i");
  (17089, 0, "s");
  (17090, 0, "_");
  (17091, 0, "h");
  (17092, 0, "e");
  (17093, 0, "a");
  (17094, 0, "d");
  (17095, 0, " ");
  (17104, 11, "");
  (17121, 0, "}");
  (17096, 0, "{");
  (17097, 0, " ");
  (17123, 0, " ");
  (17125, 0, "\n                ");
  (17126, 16, "");
  (17125, 1, "");
  (13898, 0, "\n        ");
  (13907, 0, "l");
  (13908, 0, "e");
  (13909, 0, "t");
  (13910, 0, " ");
  (13911, 0, "s");
  (13912, 0, "i");
  (13913, 0, "z");
  (13914, 0, "e");
  (13915, 0, " ");
  (13916, 0, "=");
  (13917, 0, " ");
  (13907, 11, "");
  (13907, 0, "l");
  (13908, 0, "e");
  (13909, 0, "t");
  (13910, 0, " ");
  (13758, 20, "h");
  (13759, 0, "e");
  (13760, 0, "r");
  (13761, 0, "e");
  (13758, 4, "s");
  (13759, 0, "e");
  (13760, 0, "l");
  (13761, 0, "f");
  (13762, 0, ".");
  (13763, 0, "h");
  (13764, 0, "e");
  (13765, 0, "r");
  (13766, 0, "e");
  (13763, 4, "here_ptr()");
  (13832, 0, ",");
  (13833, 0, " ");
  (13834, 0, "h");
  (13835, 0, "e");
  (13836, 0, "i");
  (13837, 0, "g");
  (13838, 0, "h");
  (13839, 0, "t");
  (13840, 0, ":");
  (13841, 0, " ");
  (13842, 0, "s");
  (13843, 0, "z");
  (13843, 1, "");
  (13843, 0, "i");
  (13844, 0, "z");
  (13845, 0, "e");
  (13846, 0, "-");
  (13846, 1, "");
  (13842, 4, "u");
  (13843, 0, "s");
  (13844, 0, "i");
  (13845, 0, "z");
  (13846, 0, "e");
  (14005, 0, ",");
  (14006, 0, " ");
  (14007, 0, "h");
  (14008, 0, "e");
  (14009, 0, "i");
  (14010, 0, "g");
  (14011, 0, "h");
  (14012, 0, "t");
  (14013, 0, ":");
  (14014, 0, " ");
  (14015, 0, "u");
  (14016, 0, "s");
  (14017, 0, "i");
  (14018, 0, "z");
  (14019, 0, "e");
  (14068, 0, "h");
  (14069, 0, "e");
  (14070, 0, "i");
  (14071, 0, "g");
  (14072, 0, "h");
  (14073, 0, "t");
  (13921, 0, "u");
  (13922, 0, "s");
  (13923, 0, "e");
  (13924, 0, "r");
  (13925, 0, "s");
  (13926, 0, "i");
  (13927, 0, "z");
  (13928, 0, "e");
  (13929, 0, " ");
  (13930, 0, "=");
  (13931, 0, " ");
  (13932, 0, "s");
  (13933, 0, "e");
  (13934, 0, "l");
  (13935, 0, "f");
  (13936, 0, ".");
  (13937, 0, "h");
  (13938, 0, "e");
  (13939, 0, "r");
  (13940, 0, "e");
  (13937, 4, "here_ptr()");
  (13932, 0, "u");
  (13933, 0, "n");
  (13934, 0, "s");
  (13935, 0, "a");
  (13936, 0, "f");
  (13937, 0, "e");
  (13938, 0, " ");
  (13939, 0, "{");
  (13940, 0, " ");
  (13941, 0, "*");
  (13941, 0, "(");
  (13958, 0, ")");
  (13959, 0, ".");
  (13960, 0, "i");
  (13961, 0, "t");
  (13962, 0, "e");
  (13963, 0, "m");
  (13964, 0, "s");
  (13965, 0, "[");
  (13966, 0, "self.local_index");
  (13982, 0, "]");
  (13983, 0, " ");
  (13984, 0, "}");
  (13985, 0, ";");
  (13908, 0, "\n        ");
  (13917, 0, "l");
  (13918, 0, "e");
  (13919, 0, "t");
  (13920, 0, " ");
  (13921, 0, "f");
  (13922, 0, "i");
  (13923, 0, "r");
  (13924, 0, "s");
  (13925, 0, "t");
  (13926, 0, "_");
  (13927, 0, "i");
  (13928, 0, "t");
  (13929, 0, "e");
  (13930, 0, "m");
  (13931, 0, " ");
  (13932, 0, "=");
  (13933, 0, " ");
  (13958, 54, "");
  (13934, 0, "unsafe { (*self.here_ptr()).items[self.local_index] };");
  (13921, 10, "c");
  (13922, 0, "u");
  (13923, 0, "r");
  (13924, 0, "r");
  (13925, 0, "e");
  (13926, 0, "n");
  (13927, 0, "t");
  (13928, 0, "_");
  (13929, 0, "i");
  (13930, 0, "t");
  (13931, 0, "e");
  (13932, 0, "m");
  (14177, 0, "\n    ");
  (14182, 0, "\n    ");
  (14178, 4, "");
  (14183, 0, "f");
  (14184, 0, "n");
  (14185, 0, " ");
  (14186, 0, "c");
  (14187, 0, "u");
  (14188, 0, "r");
  (14189, 0, "r");
  (14190, 0, "e");
  (14191, 0, "n");
  (14192, 0, "t");
  (14193, 0, "_");
  (14194, 0, "i");
  (14195, 0, "t");
  (14196, 0, "e");
  (14197, 0, "m");
  (14183, 0, "u");
  (14184, 0, "n");
  (14185, 0, "s");
  (14186, 0, "a");
  (14187, 0, "f");
  (14188, 0, "e");
  (14189, 0, " ");
  (14205, 0, "(");
  (14206, 0, "&");
  (14207, 0, "u");
  (14207, 1, "");
  (14207, 0, "m");
  (14208, 0, "u");
  (14209, 0, "t");
  (14210, 0, " ");
  (14211, 0, "s");
  (14212, 0, "e");
  (14213, 0, "l");
  (14214, 0, "f");
  (14215, 0, ")");
  (14216, 0, " ");
  (14217, 0, "{");
  (14218, 0, "\n        ");
  (14227, 0, "\n        ");
  (14219, 8, "");
  (14220, 8, "    }");
  (14219, 0, "(*self.here_ptr()).items[self.local_index]");
  (14219, 0, "        ");
  (14227, 1, "");
  (14243, 1, "");
  (14227, 0, "(");
  (14244, 0, ")");
  (14216, 0, " ");
  (14217, 0, "-");
  (14218, 0, ">");
  (14219, 0, " ");
  (14220, 0, "&");
  (14221, 0, "T");
  (14221, 1, "");
  (14221, 0, "C");
  (14222, 0, ":");
  (14223, 0, ":");
  (14224, 0, "I");
  (14225, 0, "t");
  (14226, 0, "e");
  (14227, 0, "m");
  (14239, 0, "&");
  (14014, 0, "u");
  (14015, 0, "n");
  (14016, 0, "s");
  (14017, 0, "a");
  (14018, 0, "f");
  (14019, 0, "e");
  (14020, 0, " ");
  (14021, 0, "{");
  (14022, 0, " ");
  (14023, 0, "s");
  (14024, 0, "e");
  (14025, 0, "l");
  (14026, 0, "f");
  (14027, 0, ".");
  (14028, 0, "c");
  (14029, 0, "u");
  (14030, 0, "r");
  (14031, 0, "r");
  (14028, 4, "Current");
  (14028, 7, "c");
  (14029, 0, "u");
  (14030, 0, "r");
  (14031, 0, "r");
  (14032, 0, "e");
  (14033, 0, "n");
  (14034, 0, "t");
  (14035, 0, "_");
  (14036, 0, "i");
  (14028, 9, "current_item");
  (14040, 0, "(");
  (14041, 0, ")");
  (14042, 0, " ");
  (14043, 0, "}");
  (14013, 0, " ");
  (14014, 0, "C");
  (14015, 0, ":");
  (14016, 0, ":");
  (14017, 0, "get_usersize(_item: &Self::Item)");
  (14030, 18, "");
  (14030, 1, "");
  (14030, 1, "");
  (14060, 0, ")");
  (14061, 0, ";");
  (13909, 81, "");
  (13908, 1, "");
  (13980, 0, "\n        ");
  (13989, 0, "\n        ");
  (13981, 8, "");
  (13990, 0, "f");
  (13991, 0, "o");
  (13992, 0, "r");
  (13993, 0, " ");
  (13994, 0, "_");
  (13995, 0, " ");
  (13996, 0, "i");
  (13997, 0, " ");
  (13997, 1, "");
  (13997, 0, "n");
  (13998, 0, " ");
  (13999, 0, "0");
  (14000, 0, ".");
  (14001, 0, ".");
  (14002, 0, "h");
  (14003, 0, "e");
  (14004, 0, "i");
  (14005, 0, "g");
  (14006, 0, "h");
  (14007, 0, "t");
  (14008, 0, " ");
  (14009, 0, "{");
  (14010, 0, "\n            ");
  (14023, 0, "\n            ");
  (14011, 12, "");
  (14012, 12, "        }");
  (14011, 0, "            ");
  (14023, 0, "e");
  (14024, 0, "s");
  (14025, 0, "l");
  (14026, 0, "f");
  (14026, 1, "");
  (14025, 1, "");
  (14024, 1, "");
  (14023, 1, "");
  (14023, 0, "s");
  (14024, 0, "e");
  (14025, 0, "l");
  (14026, 0, "f");
  (14027, 0, ".");
  (14028, 0, "e");
  (14029, 0, "n");
  (14030, 0, "t");
  (14028, 3, "entries");
  (14035, 0, "[");
  (14036, 0, "i");
  (14037, 0, "]");
  (14038, 0, ".");
  (14039, 0, "s");
  (14040, 0, "k");
  (14041, 0, "i");
  (14042, 0, "p");
  (14043, 0, "_");
  (14044, 0, "u");
  (14045, 0, "s");
  (14039, 7, "skip_usersize");
  (14052, 0, " ");
  (14053, 0, "+");
  (14054, 0, "=");
  (14055, 0, " ");
  (14056, 0, "u");
  (14057, 0, "s");
  (14058, 0, "e");
  (14059, 0, "r");
  (14060, 0, "s");
  (14061, 0, "i");
  (14062, 0, "z");
  (14063, 0, "e");
  (14064, 0, ";");
  (14075, 0, "\n        ");
  (14084, 0, "s");
  (14085, 0, "e");
  (14086, 0, "l");
  (14087, 0, "f");
  (14088, 0, ".");
  (14089, 0, "g");
  (14090, 0, "l");
  (14091, 0, "o");
  (14089, 3, "u");
  (14090, 0, "s");
  (14091, 0, "e");
  (14092, 0, "r");
  (14089, 4, "userpos");
  (14096, 0, " ");
  (14097, 0, "+");
  (14098, 0, " ");
  (14098, 1, "");
  (14098, 0, "=");
  (14099, 0, " ");
  (14100, 0, "u");
  (14101, 0, "s");
  (14102, 0, "e");
  (14103, 0, "r");
  (14104, 0, "s");
  (14105, 0, "i");
  (14106, 0, "z");
  (14107, 0, "e");
  (14108, 0, ";");
  (13994, 1, "");
  (13994, 0, "e");
  (13995, 0, "n");
  (13996, 0, "t");
  (13997, 0, "r");
  (13998, 0, "y");
  (14003, 0, "s");
  (14004, 0, "e");
  (14005, 0, "l");
  (14006, 0, "f");
  (14007, 0, ".");
  (14008, 0, "e");
  (14009, 0, "n");
  (14010, 0, "t");
  (14011, 0, "r");
  (14012, 0, "i");
  (14013, 0, "e");
  (14014, 0, "s");
  (14015, 0, "[");
  (14025, 0, "]");
  (14041, 15, "e");
  (14042, 0, "n");
  (14043, 0, "t");
  (14044, 0, "r");
  (14045, 0, "y");
  (14026, 0, ".");
  (14027, 0, "i");
  (14028, 0, "t");
  (14029, 0, "e");
  (14030, 0, "r");
  (14031, 0, "9");
  (14031, 1, "");
  (14031, 0, "(");
  (14032, 0, ")");
  (14026, 7, "");
  (14003, 0, "&");
  (14004, 0, "m");
  (14005, 0, "u");
  (14006, 0, "t");
  (14007, 0, " ");
  (14004, 3, "");
  (14004, 1, "");
  (38097, 0, ",");
  (38098, 0, " ");
  (38099, 0, "s");
  (38100, 0, "e");
  (38101, 0, "l");
  (38102, 0, "f");
  (38103, 0, ".");
  (38104, 0, "h");
  (38105, 0, "e");
  (38106, 0, "i");
  (38107, 0, "\n        ");
  (38108, 8, "");
  (38107, 1, "");
  (38106, 1, "");
  (38106, 0, "i");
  (38107, 0, "g");
  (38108, 0, "h");
  (38109, 0, "t");
  (38104, 0, "e");
  (38105, 0, "a");
  (38105, 1, "");
  (38104, 1, "");
  (38104, 0, "h");
  (38105, 0, "e");
  (38106, 0, "a");
  (38107, 0, "d");
  (38108, 0, ".");
  (38115, 0, " ");
  (38116, 0, "a");
  (38117, 0, "s");
  (38118, 0, " ");
  (38119, 0, "u");
  (38120, 0, "s");
  (38121, 0, "z");
  (38119, 3, "usize");
  (14212, 5, "u");
  (14213, 0, "8");
  (13842, 5, "u");
  (13843, 0, "8");
  (14023, 0, " ");
  (14024, 0, "a");
  (14025, 0, "s");
  (14026, 0, " ");
  (14027, 0, "u");
  (14028, 0, "s");
  (14029, 0, "i");
  (14030, 0, "z");
  (14031, 0, "e");
  (38118, 9, "");
  (14001, 0, "m");
  (14002, 0, "u");
  (14003, 0, "t");
  (14004, 0, " ");
  (38208, 76, "");
  (37905, 92, "");
  (38582, 63, "\n        ");
  (38591, 0, "        #[cfg(debug_assertions)] {\n            let (mut c2, _) = self.iter_at_userpos(userpos);\n            c2.advance_by_items(contents.len(), self.head.height);\n            if &cursor != &c2 { panic!(\"Invalid cursor after insert\"); }\n        }\n");
  (38583, 16, "        ");
  (38828, 1, "");
  (38679, 67, "");
  (38740, 6, "d");
  (38741, 0, "e");
  (38742, 0, "l");
  (38743, 0, "e");
  (38744, 0, "t");
  (38745, 0, "e");
  (38635, 3, "");
  (38635, 1, "");
  (37480, 3, "");
  (37403, 3, "");
  (37332, 3, "");
  (37294, 3, "");
  (34406, 3, "");
  (34410, 23, "a");
  (34411, 0, "d");
  (34412, 0, "v");
  (34413, 0, "a");
  (34414, 0, "n");
  (34415, 0, "c");
  (34416, 0, "e");
  (34417, 0, "d");
  (34418, 0, "_");
  (34419, 0, "b");
  (34420, 0, "y");
  (34424, 16, "");
  (37357, 0, "\n            ");
  (37370, 0, "c2.advance_by_items(contents.len(), self.head.height);");
  (37332, 23, "c2.advance_by_items(contents.len(), self.head.height);");
  (37332, 54, "expected_final_position");
  (37332, 23, "s");
  (37333, 0, "t");
  (37334, 0, "a");
  (37335, 0, "r");
  (37332, 4, "start_userpos");
  (37380, 14, "");
  (37380, 0, "a");
  (37381, 0, "d");
  (37382, 0, "v");
  (37383, 0, "a");
  (37380, 4, "advanced_by");
  (37306, 0, "m");
  (37307, 0, "u");
  (37308, 0, "t");
  (37309, 0, " ");
  (37306, 0, "(");
  (37313, 0, ",");
  (37314, 0, " ");
  (37315, 0, "_");
  (37316, 0, ")");
  (34446, 0, ";");
  (34447, 0, "/");
  (34448, 0, "/");
  (34447, 19, "");
  (1150, 1, "");
  (1150, 0, "1");
  (1150, 1, "");
  (1150, 0, "1");
  (1151, 0, "0");
  (1152, 0, "0");
  (1150, 3, "");
  (1150, 0, "1");
  (1449, 1, "");
  (1449, 0, "2");
  (1449, 1, "");
  (1449, 0, "1");
  (1450, 0, "0");
  (1119, 0, "\n");
  (1120, 0, "#[cfg(test)]");
  (1094, 0, "");
  (1094, 1, "");
  (1082, 3, "");
  (1116, 13, "");
  (1082, 0, "#[cfg(test)]\n");

  |]
