let data =
  [|
    ( 0,
      0,
      "/// This is an implementation of a general purpose skip list. It was \
       originally\n\
       /// ported from a version of skiplists intended for efficient string \
       handling\n\
       /// found here - https://github.com/josephg/rustrope\n\n\
       /// This implementation is not optimized for strings (there's some string\n\
       /// specific features like unicode handling which have been intentionally\n\
       /// removed for simplicity). But it does have another somewhat unusual \
       feature -\n\
       /// users can specify their own size function, and lookups, inserts and \
       deletes\n\
       /// can use their custom length property to specify offsets.\n\n\
       /// Unlike other rust rope implementations, this implementation should \
       be very\n\
       /// fast; but it manages that through heavy use of unsafe pointers and \
       C-style\n\
       /// dynamic arrays.\n\n\
       use std::{mem, ptr};\n\
       use std::alloc::{alloc, dealloc, Layout};\n\
       use std::cmp::min;\n\n\
       use rand::{RngCore, Rng, SeedableRng};\n\
       use rand::rngs::SmallRng;\n\n\
       /// The likelyhood a node will have height (n+1) instead of n\n\
       const BIAS: u8 = 100; // out of 256.\n\n\
       /// The number of items in each node. Must fit in a u8 thanks to Node.\n\
       // const NODE_NUM_ITEMS: usize = 100;\n\
       const NODE_NUM_ITEMS: usize = 100;\n\n\
       /// Rope operations will move to linear time after NODE_STR_SIZE * 2 ^\n\
       /// MAX_HEIGHT length. (With a smaller constant the higher this is). On \
       the flip\n\
       /// side, cursors grow linearly with this number; so smaller is \
       marginally\n\
       /// better when the contents are smaller.\n\
       const MAX_HEIGHT: usize = 20;\n\n\
       const MAX_HEIGHT_U8: u8 = MAX_HEIGHT as u8; // convenience.\n\n\
       /// The whole list is configured through a single generic trait parameter\n\
       pub trait ListConfig {\n\
      \    type Item: Default + Copy;\n\n\
      \    /// Applications which have custom sizes (or do their own\n\
      \    /// run-length-encoding) can define their own size function for \
       items. When\n\
      \    /// items are inserted or replaced, the position is specified using \
       the\n\
      \    /// custom size defined here.\n\
      \    fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\n\
      \    fn userlen_of_slice(items: &[Self::Item]) -> usize {\n\
      \        items.iter().fold(0, |acc, item| {\n\
      \            acc + Self::get_usersize(item)\n\
      \        })\n\
      \    }\n\n\
      \    fn split_item(_item: Self::Item) -> (Self::Item, Self::Item) {\n\
      \        unimplemented!(\"Cannot insert in the middle of an item - \
       split_item is not defined in trait\");\n\
      \    }\n\n\
      \    // type RngType: rand::RngCore = rand::rngs::SmallRng;\n\
      \    // fn get_rng() -> Self::RngType {\n\
      \    //     use rand::SeedableRng;\n\
      \    //     // \
       rand::rngs::SmallRng::from_seed(SeedableRng::seed_from_u64(10))\n\
      \    //     rand::rngs::SmallRng::from_entropy()\n\
      \    // }\n\
       }\n\n\
       /// This represents a single entry in either the nexts pointers list or \
       in an\n\
       /// iterator.\n\
       #[derive(Debug, PartialEq, Eq)]\n\
       struct SkipEntry<C: ListConfig> {\n\
      \    /// The node being pointed to.\n\
      \    node: *mut Node<C>,\n\n\
      \    /// The number of *items* between the start of the current node and \
       the\n\
      \    /// start of the next node. That means nexts entry 0 contains the \
       length of\n\
      \    /// the current node.\n\
      \    skip_usersize: usize,\n\
       }\n\n\
       // We can't use #[derive()] here for Copy and Clone due to a bug in the \
       rust\n\
       // compiler: https://github.com/rust-lang/rust/issues/26925\n\
       impl<C: ListConfig> Copy for SkipEntry<C> {}\n\
       impl<C: ListConfig> Clone for SkipEntry<C> {\n\
      \    fn clone(&self) -> Self { *self }\n\
       }\n\n\
       impl<C: ListConfig> SkipEntry<C> {\n\
      \    fn new_null() -> Self {\n\
      \        SkipEntry { node: ptr::null_mut(), skip_usersize: 0 }\n\
      \    }\n\
       }\n\n\n\
       /// The node structure is designed in a very fancy way which would be \
       more at\n\
       /// home in C or something like that. The basic idea is that the node \
       structure\n\
       /// is fixed size in memory, but the proportion of that space taken up by\n\
       /// characters and by the height differ depending on a node's height. \
       This\n\
       /// results in a lot of `unsafe` blocks. I think the tradeoff is worth \
       it but I\n\
       /// could be wrong here. You probably wouldn't lose much performance in \
       practice\n\
       /// by replacing the inline structure with a smallvec - but that would \
       waste\n\
       /// memory in small nodes, and require extra pointer indirection on \
       large nodes.\n\
       /// It also wouldn't remove all the unsafe here.\n\
       ///\n\
       /// A different representation (which might be better or worse - I \
       can't tell)\n\
       /// would be to have the nodes all be the same size in memory and \
       change the\n\
       /// *proportion* of the node's memory that is used by the string field \
       vs the\n\
       /// next pointers. That might be lighter weight for the allocator \
       because the\n\
       /// struct itself would be a fixed size; but I'm not sure if it would \
       be better.\n\
       #[repr(C)] // Prevent parameter reordering.\n\
       struct Node<C: ListConfig> {\n\
      \    /// We start with the items themselves. Only the first `num_items` \
       of this\n\
      \    /// list is in use. The user specified length of the items in the \
       node is\n\
      \    /// stored in nexts[0].skip_items. This is initialized with\n\
      \    /// Default::default() for the type, but when MaybeUninit \
       completely lands,\n\
      \    /// it will be possible to make this a tiny bit faster by leaving \
       the list\n\
      \    /// initially uninitialized.\n\
      \    items: [C::Item; NODE_NUM_ITEMS],\n\n\
      \    /// Number of items in `items` in use / filled.\n\
      \    num_items: u8,\n\n\
      \    /// Height of nexts array.\n\
      \    height: u8,\n\n\
      \    // #[repr(align(std::align_of::<SkipEntry>()))]\n\
      \    \n\
      \    /// In reality this array has the size of height, allocated using \
       more or\n\
      \    /// less direct calls to malloc() at runtime based on the randomly \
       generated\n\
      \    /// size. The size is always at least 1.\n\
      \    nexts: [SkipEntry<C>; 0],\n\
       }\n\n\
       // Make sure nexts uses correct alignment. This should be guaranteed by \
       repr(C)\n\
       // This test will fail if this ever stops being true.\n\
       #[test]\n\
       fn test_align() {\n\
      \    struct TestConfig;\n\
      \    impl ListConfig for TestConfig {\n\
      \        type Item = u8;\n\
      \        fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\
      \    }\n\
      \    #[repr(C)] struct Check([SkipEntry<TestConfig>; 0]);\n\
      \    assert!(mem::align_of::<Check>() >= \
       mem::align_of::<SkipEntry<TestConfig>>());\n\
      \    // TODO: It'd be good to also check the alignment of the nexts \
       field in Node.\n\
       }\n\n\
       fn random_height<R: RngCore>(rng: &mut R) -> u8 {\n\
      \    let mut h: u8 = 1;\n\
      \    // Should I use a csrng here? Does it matter?\n\
      \    while h < MAX_HEIGHT_U8 && rng.gen::<u8>() < BIAS { h+=1; }\n\
      \    h\n\
       }\n\n\
       #[repr(C)]\n\
       pub struct SkipList<C: ListConfig> {\n\
      \    // TODO: Consider putting the head item on the heap. For the use \
       case here\n\
      \    // its almost certainly fine either way. The code feels a bit \
       cleaner if its\n\
      \    // on the heap (and then iterators will be able to outlast a move \
       of the\n\
      \    // skiplist parent). But its also very nice having the code run \
       fast for\n\
      \    // small lists. Most lists are small, and it makes sense to \
       optimize for\n\
      \    // that.\n\n\
      \    // TODO: For safety, pointers in to this structure should be Pin<> \
       if we\n\
      \    // ever want to hold on to iterators.\n\n\
      \    /// The total number of items in the skip list. This is not used \
       internally -\n\
      \    /// just here for bookkeeping.\n\
      \    num_items: usize,\n\
      \    /// Size of the list in user specified units.\n\
      \    num_usercount: usize,\n\n\
      \    /// The RNG we use to generate node heights. Specifying it \
       explicitly allows\n\
      \    /// unit tests and randomizer runs to be predictable, which is very \
       helpful\n\
      \    /// during debugging. I'm still not sure how the type of this \
       should be\n\
      \    /// specified. Should it be a generic parameter? Box<dyn *>?\n\
      \    /// ??\n\
      \    rng: SmallRng,\n\n\
      \    /// The first node is inline. The height is 1 more than the max \
       height we've\n\
      \    /// ever used. The highest next entry points to {null, total \
       usersize}.\n\
      \    head: Node<C>,\n\n\
      \    /// This is so dirty. The first node is embedded in SkipList; but \
       we need to\n\
      \    /// allocate enough room for height to get arbitrarily large. I \
       could insist\n\
      \    /// on SkipList always getting allocated on the heap, but for small \
       lists its\n\
      \    /// much better to be on the stack.\n\
      \    ///\n\
      \    /// So this struct is repr(C) and I'm just padding out the struct \
       directly.\n\
      \    /// All accesses should go through head because otherwise I think \
       we violate\n\
      \    /// aliasing rules.\n\
      \    _nexts_padding: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\n\n\
       impl<C: ListConfig> Node<C> {\n\
      \    // Do I need to be explicit about the lifetime of the references \
       being tied\n\
      \    // to the lifetime of the node?\n\
      \    fn nexts(&self) -> &[SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts(self.nexts.as_ptr(), self.height \
       as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn nexts_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts_mut(self.nexts.as_mut_ptr(), \
       self.height as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn layout_with_height(height: u8) -> Layout {\n\
      \        Layout::from_size_align(\n\
      \            mem::size_of::<Node<C>>() + mem::size_of::<SkipEntry<C>>() \
       * (height as usize),\n\
      \            mem::align_of::<Node<C>>()).unwrap()\n\
      \    }\n\n\
      \    fn alloc_with_height(height: u8) -> *mut Node<C> {\n\
      \        assert!(height >= 1 && height <= MAX_HEIGHT_U8);\n\n\
      \        unsafe {\n\
      \            let node = alloc(Self::layout_with_height(height)) as *mut \
       Node<C>;\n\
      \            (*node) = Node {\n\
      \                items: [C::Item::default(); NODE_NUM_ITEMS],\n\
      \                num_items: 0,\n\
      \                height: height,\n\
      \                nexts: [],\n\
      \            };\n\n\
      \            for next in (*node).nexts_mut() {\n\
      \                *next = SkipEntry::new_null();\n\
      \            }\n\n\
      \            node\n\
      \        }\n\
      \    }\n\n\
      \    fn alloc<R: RngCore>(rng: &mut R) -> *mut Node<C> {\n\
      \        Self::alloc_with_height(random_height(rng))\n\
      \    }\n\n\
      \    unsafe fn free(p: *mut Node<C>) {\n\
      \        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n\
      \    }\n\n\
      \    fn content_slice(&self) -> &[C::Item] {\n\
      \        &self.items[..self.num_items as usize]\n\
      \    }\n\n\
      \    // The height is at least 1, so this is always valid.\n\
      \    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n\
      \        unsafe { &*self.nexts.as_ptr() }\n\
      \    }\n\n\
      \    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n\
      \        unsafe { &mut *self.nexts.as_mut_ptr() }\n\
      \    }\n\n\
      \    // TODO: Rename to len() ?\n\
      \    fn get_userlen(&self) -> usize {\n\
      \        self.first_skip_entry().skip_usersize\n\
      \    }\n\
      \    \n\
      \    fn get_next_ptr(&self) -> *mut Node<C> {\n\
      \        self.first_skip_entry().node\n\
      \    }\n\n\
      \    /// I dunno where this logic should live, but we want to get the \
       index of\n\
      \    /// the item at the specified offset into the node (and the offset \
       into the\n\
      \    /// item).\n\
      \    /// \n\
      \    /// If the offset lands between items, we could return either the \
       previous or next item.\n\
      \    /// \n\
      \    /// Returns (index, item_offset).\n\
      \    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) \
       -> (usize, usize) {\n\
      \        if usersize_offset == 0 { return (0, 0); }\n\n\
      \        for (i, item) in self.content_slice().iter().enumerate() {\n\
      \            let usersize = C::get_usersize(item);\n\
      \            if usersize > usersize_offset {\n\
      \                return (i, usersize_offset);\n\
      \            } else if usersize == usersize_offset {\n\
      \                return if stick_end { (i, usersize_offset) } else { \
       (i+1, 0) }\n\
      \            } else {\n\
      \                usersize_offset -= usersize;\n\
      \            }\n\
      \        }\n\
      \        panic!(\"Could not find requested offset within the node\");\n\
      \    }\n\
       }\n\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone, Debug)]\n\
       struct Cursor<C: ListConfig> {\n\
      \    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\n\
      \    // This isn't strictly necessary. Earlier versions tacked this on \
       to the\n\
      \    // last item in entries... I'm still not sure the cleanest way to \
       do this.\n\
      \    userpos: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\
       impl<C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos { return false; }\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new() -> Self {\n\
      \        SkipList::<C> {\n\
      \            num_items: 0,\n\
      \            num_usercount: 0,\n\
      \            rng: SmallRng::seed_from_u64(123),\n\
      \            head: Node {\n\
      \                items: [C::Item::default(); NODE_NUM_ITEMS],\n\
      \                num_items: 0,\n\
      \                height: 1, // Stores max height of list nodes\n\
      \                nexts: [],\n\
      \            },\n\
      \            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n\
      \        }\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, s);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn get_userlen(&self) -> usize {\n\
      \        self.num_usercount\n\
      \    }\n\n\
      \    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn len_items(&self) -> usize {\n\
      \        self.num_items as usize\n\
      \    }\n\n\
      \    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            \
       std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), \
       self._nexts_padding.len())\n\
      \        }\n\
      \    }\n\n\
      \    /// Walk the list and validate internal constraints. This is used for\n\
      \    /// testing the structure itself, and should generally not be \
       called by\n\
      \    /// users.\n\
      \    pub fn check(&self) {\n\
      \        // #[cfg(test)]\n\
      \        {\n\
      \            assert!(self.head.height >= 1);\n\
      \            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n\
      \            // let skip_over = self.get_top_entry();\n\
      \            // println!(\"Skip over skip chars {}, num bytes {}\", \
       skip_over.skip_items, self.num_bytes);\n\n\
      \            let mut iter = [SkipEntry {\n\
      \                // Bleh.\n\
      \                node: &self.head as *const Node<C> as *mut Node<C>,\n\
      \                // The skips will store the total distance travelled \
       since the\n\
      \                // start of this traversal at each height. All the \
       entries above\n\
      \                // head.height are ignored though.\n\
      \                skip_usersize: 0\n\
      \            }; MAX_HEIGHT];\n\n\
      \            let mut num_items = 0;\n\
      \            let mut num_usercount = 0;\n\n\
      \            for n in self.iter() {\n\
      \                // println!(\"visiting {:?}\", n.as_str());\n\
      \                assert!((n as *const Node<C> == &self.head as *const \
       Node<C>) || n.num_items > 0);\n\
      \                assert!(n.height <= MAX_HEIGHT_U8);\n\
      \                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n\
      \                // Make sure the number of items matches the count\n\
      \                let local_count = \
       C::userlen_of_slice(&n.items[0..n.num_items as usize]);\n\
      \                assert_eq!(local_count, n.get_userlen());\n\n\
      \                // assert_eq!(n.as_str().chars().count(), n.num_chars());\n\
      \                for (i, entry) in iter[0..n.height as \
       usize].iter_mut().enumerate() {\n\
      \                    assert_eq!(entry.node as *const Node<C>, n as \
       *const Node<C>);\n\
      \                    assert_eq!(entry.skip_usersize, num_usercount);\n\n\
      \                    // println!(\"replacing entry {:?} with {:?}\", \
       entry, n.nexts()[i].node);\n\
      \                    entry.node = n.nexts()[i].node;\n\
      \                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n\
      \                }\n\n\
      \                num_items += n.num_items as usize;\n\
      \                num_usercount += n.get_userlen();\n\
      \            }\n\n\
      \            for entry in iter[0..self.head.height as usize].iter() {\n\
      \                // println!(\"{:?}\", entry);\n\
      \                assert!(entry.node.is_null());\n\
      \                assert_eq!(entry.skip_usersize, num_usercount);\n\
      \            }\n\
      \            \n\
      \            // println!(\"self bytes: {}, count bytes {}\", \
       self.num_bytes, num_bytes);\n\
      \            assert_eq!(self.num_items, num_items);\n\
      \            assert_eq!(self.get_userlen(), num_usercount);\n\
      \        }\n\
      \    }\n\
      \    \n\
      \    \n\
      \    /// Internal function for creating a cursor at a particular \
       location in the\n\
      \    /// skiplist. The returned cursor is a list of nodes which point \
       past the\n\
      \    /// specified position, as well as offsets of how far into their \
       character\n\
      \    /// lists the specified characters are.\n\
      \    /// \n\
      \    /// Note this does not calculate the index and offset in the \
       current node.\n\
      \    ///\n\
      \    /// TODO: This should be Pin<&self>.\n\
      \    fn iter_at_userpos(&self, target_userpos: usize) -> Cursor<C> {\n\
      \        assert!(target_userpos <= self.get_userlen());\n\n\
      \        let mut e: *const Node<C> = &self.head;\n\
      \        let mut height = self.head.height as usize - 1;\n\
      \        \n\
      \        let mut offset = target_userpos; // How many more items to skip\n\n\
      \        // We're populating the head node pointer to simplify the case \
       when the\n\
      \        // iterator grows. We could put offset into the skip_usersize \
       but it\n\
      \        // would only be *mostly* correct, not always correct. (Since \
       cursor\n\
      \        // entries above height are not updated by insert.)\n\
      \        let mut cursor = Cursor {\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \            userpos: target_userpos,\n\
      \        };\n\n\
      \        loop { // while height >= 0\n\
      \            let en = unsafe { &*e };\n\
      \            let next = en.nexts()[height];\n\
      \            let skip = next.skip_usersize;\n\
      \            if offset > skip {\n\
      \                // Go right.\n\
      \                debug_assert!(e == &self.head || en.num_items > 0);\n\
      \                offset -= skip;\n\
      \                e = next.node;\n\
      \                assert!(!e.is_null(), \"Internal constraint violation: \
       Reached rope end prematurely\");\n\
      \            } else {\n\
      \                // Record this and go down.\n\
      \                cursor.entries[height] = SkipEntry {\n\
      \                    skip_usersize: offset,\n\
      \                    node: e as *mut Node<C>, // This is pretty gross\n\
      \                };\n\n\
      \                if height == 0 { break; } else { height -= 1; }\n\
      \            }\n\
      \        };\n\n\
      \        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n\
      \        cursor\n\
      \    }\n\n\
      \    // Internal fn to create a new node at the specified iterator \
       filled with\n\
      \    // the specified content. The passed cursor should point at the end \
       of the\n\
      \    // previous node. It will be updated to point to the end of the newly\n\
      \    // inserted content.\n\
      \    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize) {\n\
      \        // println!(\"Insert_node_at {} len {}\", contents.len(), \
       self.num_bytes);\n\
      \        debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n\
      \        assert!(contents.len() <= NODE_NUM_ITEMS);\n\n\
      \        let new_node = Node::alloc(&mut self.rng);\n\
      \        (*new_node).num_items = contents.len() as u8;\n\
      \        (*new_node).items[..contents.len()].copy_from_slice(contents);\n\
      \        let new_height = (*new_node).height;\n\n\
      \        let mut head_height = self.head.height as usize;\n\
      \        let new_height_usize = new_height as usize;\n\
      \        while head_height < new_height_usize {\n\
      \            // This seems weird given we're about to overwrite these \
       values\n\
      \            // below. What we're doing is retroactively setting up the \
       cursor\n\
      \            // and head pointers *as if* the height had been this high \
       all\n\
      \            // along. This way we only have to populate the higher head \
       values\n\
      \            // lazily.\n\
      \            let total_userlen = self.num_usercount;\n\
      \            let nexts = self.heads_mut();\n\
      \            nexts[head_height].skip_usersize = total_userlen;\n\
      \            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n\
      \            head_height += 1; // This is ugly.\n\
      \            self.head.height += 1;\n\
      \        }\n\n\
      \        for i in 0..new_height_usize {\n\
      \            let prev_skip = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \            let new_nexts = (*new_node).nexts_mut();\n\n\
      \            // The new node points to the successor (or null)\n\
      \            new_nexts[i] = SkipEntry {\n\
      \                node: prev_skip.node,\n\
      \                skip_usersize: new_userlen + prev_skip.skip_usersize - \
       cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // The previous node points to the new node\n\
      \            *prev_skip = SkipEntry {\n\
      \                node: new_node,\n\
      \                skip_usersize: cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // Move the iterator to the end of the newly inserted node.\n\
      \            cursor.entries[i] = SkipEntry {\n\
      \                node: new_node,\n\
      \                skip_usersize: new_userlen\n\
      \            };\n\
      \        }\n\n\
      \        for i in new_height_usize..head_height {\n\
      \            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n\
      \            cursor.entries[i].skip_usersize += new_userlen;\n\
      \        }\n\n\
      \        self.num_items += contents.len();\n\
      \        self.num_usercount += new_userlen;\n\
      \        cursor.userpos += new_userlen;\n\
      \    }\n\n\
      \    unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       item_idx: usize, contents: &[C::Item]) {\n\
      \        // iter specifies where to insert.\n\n\
      \        let mut e = cursor.here_ptr();\n\
      \        // The insertion offset into the destination node.\n\
      \        assert!(cursor.userpos <= self.num_usercount);\n\
      \        assert!(item_idx <= (*e).num_items as usize);\n\n\
      \        // We might be able to insert the new data into the current \
       node, depending on\n\
      \        // how big it is.\n\
      \        let num_inserted_items = contents.len();\n\
      \        let num_inserted_usercount = C::userlen_of_slice(contents);\n\n\
      \        // Can we insert into the current node?\n\
      \        let mut insert_here = (*e).num_items as usize + \
       num_inserted_items <= NODE_NUM_ITEMS;\n\n\
      \        // Can we insert into the start of the successor node?\n\
      \        if !insert_here && item_idx == (*e).num_items as usize && \
       num_inserted_items <= NODE_NUM_ITEMS {\n\
      \            // We can insert into the subsequent node if:\n\
      \            // - We can't insert into the current node\n\
      \            // - There _is_ a next node to insert into\n\
      \            // - The insert would be at the start of the next node\n\
      \            // - There's room in the next node\n\
      \            if let Some(next) = \
       (*e).first_skip_entry_mut().node.as_mut() {\n\
      \                if next.num_items as usize + num_inserted_items <= \
       NODE_NUM_ITEMS {\n\
      \                    item_idx = 0;\n\
      \                    cursor.advance_node();\n\
      \                    e = next;\n\n\
      \                    insert_here = true;\n\
      \                }\n\
      \            }\n\
      \        }\n\n\
      \        let e_num_items = (*e).num_items as usize; // convenience.\n\n\
      \        if insert_here {\n\
      \            // println!(\"insert_here {}\", contents);\n\
      \            // First push the current items later in the array\n\
      \            let c = &mut (*e).items;\n\
      \            if item_idx < e_num_items {\n\
      \                c[..].copy_within(item_idx..e_num_items,\n\
      \                    item_idx + num_inserted_items);\n\
      \            }\n\n\
      \            // Then copy in the new items\n\
      \            c[item_idx..item_idx + \
       num_inserted_items].copy_from_slice(contents);\n\n\
      \            (*e).num_items += num_inserted_items as u8;\n\
      \            self.num_items += num_inserted_items;\n\
      \            self.num_usercount += num_inserted_usercount;\n\n\
      \            // .... aaaand update all the offset amounts.\n\
      \            cursor.update_offsets(self.head.height as usize, \
       num_inserted_usercount as isize);\n\n\
      \            // TODO: For consistency we might want to think about \
       updating the\n\
      \            // iterator here.\n\
      \        } else {\n\
      \            // There isn't room. We'll need to add at least one new \
       node to the\n\
      \            // list. We could be a bit more careful here and copy as \
       much as\n\
      \            // possible into the current node - that would decrease the \
       number\n\
      \            // of new nodes in some cases, but I don't think the \
       performance\n\
      \            // difference will be large enough to justify the \
       complexity.\n\n\
      \            // If we're not at the end of the current node, we'll need \
       to remove\n\
      \            // the end of the current node's data and reinsert it later.\n\
      \            let num_end_items = e_num_items - item_idx;\n\n\
      \            let (end_items, end_usercount) = if num_end_items > 0 {\n\
      \                // We'll mark the items as deleted from the node, while \
       leaving\n\
      \                // the data itself there for now to avoid a copy.\n\n\
      \                // Note that if we wanted to, it would also be correct \
       (and\n\
      \                // slightly more space efficient) to pack some of the new\n\
      \                // string's characters into this node after trimming it.\n\
      \                let end_items = &(*e).items[item_idx..e_num_items];\n\
      \                (*e).num_items = item_idx as u8;\n\
      \                let end_usercount = (*e).get_userlen() - \
       cursor.entries[0].skip_usersize;\n\n\
      \                cursor.update_offsets(self.head.height as usize, \
       -(end_usercount as isize));\n\n\
      \                // We need to trim the size off because we'll add the \
       characters\n\
      \                // back with insert_node_at.\n\
      \                self.num_usercount -= end_usercount;\n\
      \                self.num_items -= num_end_items;\n\n\
      \                (Some(end_items), end_usercount)\n\
      \            } else {\n\
      \                (None, 0)\n\
      \            };\n\n\
      \            // Now we insert new nodes containing the new character \
       data. The\n\
      \            // data is broken into pieces with a maximum size of \
       NODE_NUM_ITEMS.\n\
      \            // As further optimization, we could try and fit the last \
       piece into\n\
      \            // the start of the subsequent node. That optimization \
       hasn't been\n\
      \            // added.\n\
      \            \n\
      \            for chunk in contents.chunks(NODE_NUM_ITEMS) {\n\
      \                let userlen = C::userlen_of_slice(chunk);\n\
      \                self.insert_node_at(cursor, chunk, userlen);\n\
      \            }\n\n\
      \            // TODO: Consider recursively calling insert_at_iter() here \
       instead\n\
      \            // of making a whole new node for the remaining content.\n\
      \            if let Some(end_items) = end_items {\n\
      \                self.insert_node_at(cursor, end_items, end_usercount);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Interestingly unlike the original, here we only care about \
       specifying\n\
      \    /// the number of removed items by counting them. We do not use \
       usersize in\n\
      \    /// the deleted item count.\n\
      \    ///\n\
      \    /// If the deleted content occurs at the start of a node, the \
       cursor passed\n\
      \    /// here must point to the end of the previous node, not the start \
       of the\n\
      \    /// current node.\n\
      \    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       item_idx: usize, mut num_deleted_items: usize) {\n\
      \        if num_deleted_items == 0 { return; }\n\n\
      \        let mut e = cursor.here_ptr();\n\
      \        while num_deleted_items > 0 {\n\
      \            if item_idx == (*e).num_items as usize {\n\
      \                let entry = (*e).first_skip_entry();\n\
      \                // End of current node. Skip to the start of the next \
       one. We're\n\
      \                // intentionally not updating the iterator because if \
       we delete\n\
      \                // a whole node we need the iterator to point to the \
       previous\n\
      \                // element. And if we only delete here, the iterator \
       doesn't\n\
      \                // need to be moved.\n\
      \                e = entry.node;\n\
      \                if e.is_null() { panic!(\"Cannot delete past the end of \
       the list\"); }\n\
      \                item_idx = 0;\n\
      \            }\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let removed_here = min(num_deleted_items, e_num_items - \
       item_idx);\n\
      \            \n\
      \            let height = (*e).height as usize;\n\
      \            let removed_userlen;\n\n\
      \            if removed_here < e_num_items || e as *const _ == \
       &self.head as *const _ {\n\
      \                // Just trim the node down.\n\
      \                let trailing_items = e_num_items - item_idx - \
       removed_here;\n\
      \                \n\
      \                let c = &mut (*e).items;\n\
      \                removed_userlen = \
       C::userlen_of_slice(&c[item_idx..item_idx + removed_here]);\n\
      \                if trailing_items > 0 {\n\
      \                    c[..].copy_within(item_idx + \
       removed_here..e_num_items, item_idx);\n\
      \                }\n\n\
      \                (*e).num_items -= removed_here as u8;\n\
      \                self.num_items -= removed_here;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                for s in (*e).nexts_mut() {\n\
      \                    s.skip_usersize -= removed_userlen;\n\
      \                }\n\
      \            } else {\n\
      \                // Remove the node from the skip list entirely. e \
       should be the\n\
      \                // next node after the position of the iterator.\n\
      \                assert_ne!(cursor.here_ptr(), e);\n\n\
      \                removed_userlen = (*e).get_userlen();\n\
      \                let next = (*e).first_skip_entry().node;\n\n\
      \                for i in 0..(*e).height as usize {\n\
      \                    let s = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                    s.node = (*e).nexts_mut()[i].node;\n\
      \                    s.skip_usersize += (*e).nexts()[i].skip_usersize - \
       removed_userlen;\n\
      \                }\n\n\
      \                self.num_items -= (*e).num_items as usize;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                Node::free(e);\n\
      \                e = next;\n\
      \            }\n\n\
      \            for i in height..self.head.height as usize {\n\
      \                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                s.skip_usersize -= removed_userlen;\n\
      \            }\n\n\
      \            num_deleted_items -= removed_here;\n\
      \        }\n\
      \    }\n\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, mut \
       removed_items: usize, mut inserted_content: &[C::Item]) {\n\
      \        if removed_items == 0 && inserted_content.len() == 0 { return; \
       }\n\n\
      \        // For validation. This is where the cursor should end up.\n\
      \        // let expected_final_position = start_userpos + \
       inserted_content.len() - removed_items;\n\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let mut cursor = self.iter_at_userpos(start_userpos);\n\
      \        let (mut index, offset) = unsafe { &*cursor.here_ptr() \
       }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        unsafe {\n\
      \            let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \            removed_items -= replaced_items;\n\n\
      \            while replaced_items > 0 {\n\
      \                let mut e = cursor.here_ptr();\n\
      \                if index == (*e).num_items as usize {\n\
      \                    // Move to the next item.\n\
      \                    e = cursor.advance_node();\n\
      \                    if e.is_null() { panic!(\"Cannot replace past the \
       end of the list\"); }\n\
      \                    index = 0;\n\
      \                }\n\n\
      \                let e_num_items = (*e).num_items as usize;\n\
      \                let replaced_items_here = min(replaced_items, \
       e_num_items - index);\n\n\
      \                let old_items = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \                let new_items = \
       &inserted_content[0..replaced_items_here];\n\n\
      \                // Replace the items themselves.\n\
      \                old_items.copy_from_slice(new_items);\n\n\
      \                // And bookkeeping. Bookkeeping forever.\n\
      \                let new_usersize = C::userlen_of_slice(new_items);\n\
      \                let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\
      \                if usersize_delta != 0 {\n\
      \                    cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \                }\n\n\
      \                inserted_content = \
       &inserted_content[replaced_items_here..];\n\
      \                replaced_items -= replaced_items_here;\n\
      \                // We'll hop to the next Node at the start of the next \
       loop\n\
      \                // iteration if needed.\n\
      \                index += replaced_items_here;\n\n\
      \                for i in 0..self.head.height as usize {\n\
      \                    cursor.entries[i].skip_usersize += new_usersize;\n\
      \                }\n\
      \                cursor.userpos += new_usersize;\n\
      \            }\n\n\
      \            // Ok now one of two things must be true. Either we've run \
       out of\n\
      \            // items to remove, or we've run out of items to insert.\n\
      \            if inserted_content.len() > 0 {\n\
      \                // Insert!\n\
      \                debug_assert!(removed_items == 0);\n\
      \                self.insert_at_iter(&mut cursor, index, \
       inserted_content);\n\
      \            } else if removed_items > 0 {\n\
      \                self.del_at_iter(&mut cursor, index, removed_items);\n\
      \            }\n\
      \        }\n\n\
      \        // TODO: Assert that the iterator is after replaced content.\n\
      \        // #[cfg(debug_assertions)] {\n\
      \        //     let c2 = self.iter_at_userpos(expected_final_position);\n\
      \        //     if &cursor != &c2 { panic!(\"Invalid cursor after \
       replace\"); }\n\
      \        // }\n\
      \    }\n\n\
      \    pub fn insert_at(&mut self, mut userpos: usize, contents: \
       &[C::Item]) {\n\
      \        if contents.len() == 0 { return; }\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let mut cursor = self.iter_at_userpos(userpos);\n\
      \        let (index, offset) = unsafe { &*cursor.here_ptr() \
       }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\
      \        unsafe { self.insert_at_iter(&mut cursor, index, contents); }\n\n\
      \        #[cfg(debug_assertions)] {\n\
      \            let c2 = self.iter_at_userpos(userpos + \
       C::userlen_of_slice(contents));\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       insert\"); }\n\
      \        }\n\
      \        // TODO: Assert that the iterator now points after removed \
       content.\n\
      \    }\n\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let mut cursor = self.iter_at_userpos(userpos);\n\
      \        let (index, offset) = unsafe { &*cursor.here_ptr() \
       }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, index, num_items); }\n\
      \        // TODO: Assert that the iterator remains where it was.\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> where C::Item: PartialEq {\n\
      \    pub fn eq_list(&self, other: &[C::Item]) -> bool {\n\
      \        let mut pos = 0;\n\
      \        let other_len = other.len();\n\n\
      \        for node in self.iter() {\n\
      \            let my_data = node.content_slice();\n\
      \            let my_len = my_data.len();\n\n\
      \            if pos + my_len > other_len || my_data != &other[pos..pos + \
       my_data.len()] {\n\
      \                return false\n\
      \            }\n\
      \            pos += my_data.len();\n\
      \        }\n\n\
      \        return pos == other_len;\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Drop for SkipList<C> {\n\
      \    fn drop(&mut self) {\n\
      \        let mut node = self.head.first_skip_entry().node;\n\
      \        unsafe {\n\
      \            while !node.is_null() {\n\
      \                let next = (*node).first_skip_entry().node;\n\
      \                Node::free(node);\n\
      \                node = next;\n\
      \            }\n\
      \        }\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> From<&[C::Item]> for SkipList<C> {\n\
      \    fn from(s: &[C::Item]) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s)\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> {\n\
      \    fn from(s: Vec<C::Item>) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s.as_slice())\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Into<Vec<C::Item>> for &SkipList<C> {\n\
      \    fn into(self) -> Vec<C::Item> {\n\
      \        let mut content = Vec::with_capacity(self.num_items);\n\n\
      \        for node in self.iter() {\n\
      \            content.extend(node.content_slice().iter());\n\
      \        }\n\n\
      \        content\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> SkipList<C> where C::Item: std::fmt::Debug {\n\
      \    // TODO: Don't export this.\n\
      \    pub fn print(&self) {\n\
      \        println!(\"items: {}\\tuserlen: {}, height: {}\", \
       self.num_items, self.get_userlen(), self.head.height);\n\n\
      \        print!(\"HEAD:\");\n\
      \        for s in self.head.nexts() {\n\
      \            print!(\" |{} \", s.skip_usersize);\n\
      \        }\n\
      \        println!(\"\");\n\n\
      \        for (i, node) in self.iter().enumerate() {\n\
      \            print!(\"{}:\", i);\n\
      \            for s in node.nexts() {\n\
      \                print!(\" |{} \", s.skip_usersize);\n\
      \            }\n\
      \            println!(\"      : {:?}\", node.content_slice());\n\
      \        }\n\
      \    }\n\
       }\n\n\
       // impl<T: Default + Copy, F: Fn(&T) -> usize> PartialEq for \
       SkipList<T, F> {\n\
       //     // This is quite complicated. It would be cleaner to just write \
       a bytes\n\
       //     // iterator, then iterate over the bytes of both strings \
       comparing along the\n\
       //     // way.\n\
       //     // However, this should be faster because it can memcmp().\n\n\
       //     // Another way to implement this would be to rewrite it as a \
       comparison with\n\
       //     // an iterator over &str. Then the rope vs rope comparison would \
       be trivial,\n\
       //     // but also we could add comparison functions with a single &str \
       and stuff\n\
       //     // very easily.\n\
       //     fn eq(&self, other: &SkipList<T, F>) -> bool {\n\
       //         if self.num_items != other.num_items\n\
       //                 || self.num_chars() != other.num_chars() {\n\
       //             return false\n\
       //         }\n\n\
       //         let mut other_iter = other.iter().map(|n| { n.as_str() });\n\n\
       //         let mut os = other_iter.next();\n\
       //         let mut opos: usize = 0; // Byte offset in os.\n\
       //         for n in self.iter() {\n\
       //             let s = n.as_str();\n\
       //             let mut pos: usize = 0; // Current byte offset in s\n\
       //             debug_assert_eq!(s.len(), n.num_bytes as usize);\n\n\
       //             // Walk s.len() bytes through the other rope\n\
       //             while pos < n.num_bytes as usize {\n\
       //                 if let Some(oss) = os {\n\
       //                     let amt = min(s.len() - pos, oss.len() - opos);\n\
       //                     // println!(\"iter slen {} pos {} osslen {} amt \
       {}\", s.len(), pos, oss.len(), amt);\n\n\
       //                     if &s[pos..pos+amt] != &oss[opos..opos+amt] {\n\
       //                         return false\n\
       //                     }\n\n\
       //                     pos += amt;\n\
       //                     opos += amt;\n\
       //                     debug_assert!(opos <= oss.len());\n\n\
       //                     if opos == oss.len() {\n\
       //                         os = other_iter.next();\n\
       //                         opos = 0;\n\
       //                     }\n\
       //                 } else {\n\
       //                     panic!(\"Internal string length does not match\");\n\
       //                 }\n\
       //             }\n\
       //         }\n\n\
       //         true\n\
       //     }\n\
       // }\n\
       // impl<T: Default + Copy, F: Fn(&T) -> usize> Eq for SkipList<T, F> {}\n\n\
       // impl<T: Default + Copy, F> Clone for SkipList<T, F> where F: Fn(&T) \
       -> usize {\n\
       //     fn clone(&self) -> Self {\n\
       //         let mut r = SkipList::new(self.get_usersize);\n\
       //         r.num_items = self.num_items;\n\
       //         let head_str = self.head.as_str();\n\
       //         \
       r.head.items[..head_str.len()].copy_from_slice(head_str.as_bytes());\n\
       //         r.head.num_bytes = self.head.num_bytes;\n\
       //         r.head.height = self.head.height;\n\
      \        \n\
       //         {\n\
       //             // I could just edit the overflow memory directly, but \
       this is safer\n\
       //             // because of aliasing rules.\n\
       //             let head_nexts = r.head.nexts_mut();\n\
       //             for i in 0..self.head.height as usize {\n\
       //                 head_nexts[i].skip_items = self.nexts[i].skip_items;\n\
       //             }\n\
       //         }\n\n\
       //         let mut nodes = [&mut r.head as *mut Node; MAX_HEIGHT];\n\n\
       //         // The first node the iterator will return is the head. \
       Ignore it.\n\
       //         let mut iter = self.iter();\n\
       //         iter.next();\n\
       //         for other in iter {\n\
       //             // This also sets height.\n\
       //             let height = other.height;\n\
       //             let node = Node::alloc_with_height(height);\n\
       //             unsafe {\n\
       //                 (*node).num_bytes = other.num_bytes;\n\
       //                 let len = other.num_bytes as usize;\n\
       //                 \
       (*node).items[..len].copy_from_slice(&other.items[..len]);\n\n\
       //                 let other_nexts = other.nexts();\n\
       //                 let nexts = (*node).nexts_mut();\n\
       //                 for i in 0..height as usize {\n\
       //                     nexts[i].skip_items = other_nexts[i].skip_items;\n\
       //                     (*nodes[i]).nexts_mut()[i].node = node;\n\
       //                     nodes[i] = node;\n\
       //                 }\n\
       //             }\n\
       //         }\n\n\
       //         r\n\
       //     }\n\
       // }\n" );
    (25738, 108, "");
    (25738, 0, "\n            ");
    (25747, 4, "");
    (25743, 4, "");
    (25739, 4, "");
    (25738, 1, "");
    (25737, 1, "");
    (25737, 0, "\n            ");
    (25750, 0, "/");
    (25751, 0, "/");
    (25752, 0, " ");
    (25753, 0, "T");
    (25754, 0, "h");
    (25755, 0, "i");
    (25756, 0, "s");
    (25757, 0, " ");
    (25758, 0, "i");
    (25759, 0, "s");
    (25760, 0, " ");
    (25761, 0, "s");
    (25762, 0, "u");
    (25762, 1, "");
    (25761, 1, "");
    (25761, 0, "u");
    (25762, 0, "s");
    (25763, 0, "u");
    (25764, 0, "a");
    (25765, 0, "l");
    (25766, 0, "l");
    (25767, 0, "y");
    (25768, 0, " ");
    (25769, 0, "n");
    (25770, 0, "o");
    (25771, 0, "t");
    (25772, 0, " ");
    (25773, 0, "n");
    (25774, 0, "e");
    (25775, 0, "e");
    (25776, 0, "d");
    (25777, 0, "e");
    (25778, 0, "d");
    (25779, 0, ",");
    (25780, 0, " ");
    (25781, 0, "s");
    (25782, 0, "o");
    (25783, 0, " ");
    (25784, 0, "i");
    (25785, 0, "t");
    (25786, 0, " ");
    (25787, 0, "f");
    (25788, 0, "e");
    (25789, 0, "e");
    (25790, 0, "l");
    (25791, 0, "s");
    (25792, 0, " ");
    (25793, 0, "l");
    (25794, 0, "i");
    (25795, 0, "k");
    (25796, 0, "e");
    (25797, 0, " ");
    (25798, 0, "a");
    (25799, 0, " ");
    (25800, 0, "b");
    (25801, 0, "i");
    (25802, 0, "t");
    (25803, 0, " ");
    (25804, 0, "o");
    (25805, 0, "f");
    (25806, 0, " ");
    (25807, 0, "a");
    (25808, 0, " ");
    (25809, 0, "w");
    (25810, 0, "a");
    (25811, 0, "s");
    (25812, 0, "t");
    (25813, 0, "e");
    (25814, 0, " ");
    (25815, 0, "o");
    (25816, 0, "f");
    (25817, 0, " ");
    (25818, 0, "C");
    (25819, 0, "P");
    (25820, 0, "U");
    (25821, 0, " ");
    (25822, 0, "a");
    (25823, 0, "n");
    (25824, 0, "d");
    (25825, 0, " ");
    (25826, 0, "c");
    (25827, 0, "o");
    (25828, 0, "m");
    (25829, 0, "p");
    (25830, 0, "l");
    (25831, 0, "e");
    (25832, 0, "x");
    (25833, 0, "i");
    (25821, 13, ",");
    (25822, 0, " ");
    (25823, 0, "b");
    (25824, 0, "u");
    (25753, 72, "U");
    (25754, 0, "p");
    (25755, 0, "d");
    (25756, 0, "a");
    (25757, 0, "t");
    (25758, 0, "i");
    (25759, 0, "n");
    (25760, 0, "g");
    (25761, 0, " ");
    (25762, 0, "t");
    (25763, 0, "h");
    (25764, 0, "e");
    (25765, 0, " ");
    (25766, 0, "c");
    (25767, 0, "u");
    (25768, 0, "r");
    (25769, 0, "s");
    (25770, 0, "o");
    (25771, 0, "r");
    (25772, 0, " ");
    (25773, 0, "a");
    (25774, 0, "f");
    (25775, 0, "t");
    (25776, 0, "e");
    (25777, 0, "r");
    (25778, 0, " ");
    (25779, 0, "t");
    (25780, 0, "h");
    (25781, 0, "e");
    (25782, 0, " ");
    (25783, 0, "o");
    (25784, 0, "p");
    (25785, 0, "e");
    (25786, 0, "r");
    (25787, 0, "a");
    (25788, 0, "t");
    (25789, 0, "i");
    (25790, 0, "o");
    (25791, 0, "n");
    (25792, 0, " ");
    (25793, 0, "d");
    (25793, 1, "");
    (25793, 0, "f");
    (25794, 0, "e");
    (25795, 0, "e");
    (25796, 0, "l");
    (25797, 0, "s");
    (25798, 0, " ");
    (25799, 0, "a");
    (25800, 0, " ");
    (25801, 0, "b");
    (25802, 0, "i");
    (25803, 0, "t");
    (25804, 0, " ");
    (25805, 0, "e");
    (25806, 0, "x");
    (25807, 0, "c");
    (25808, 0, "e");
    (25809, 0, "s");
    (25810, 0, "s");
    (25811, 0, "i");
    (25812, 0, "v");
    (25813, 0, "e");
    (25814, 0, ",");
    (25815, 0, " ");
    (25816, 0, "b");
    (25817, 0, "u");
    (25818, 0, "t");
    (25819, 0, " ");
    (25820, 0, "i");
    (25821, 0, "t");
    (25822, 0, "s");
    (25823, 0, " ");
    (25824, 0, "i");
    (25825, 0, "m");
    (25826, 0, "p");
    (25827, 0, "o");
    (25828, 0, "r");
    (25829, 0, "t");
    (25830, 0, "a");
    (25831, 0, "n");
    (25832, 0, "t");
    (25833, 0, " ");
    (25752, 82, " ");
    (25753, 0, "U");
    (25754, 0, "s");
    (25755, 0, "u");
    (25756, 0, "a");
    (25757, 0, "l");
    (25758, 0, "l");
    (25759, 0, "y");
    (25760, 0, " ");
    (25761, 0, "t");
    (25762, 0, "h");
    (25763, 0, "e");
    (25764, 0, " ");
    (25765, 0, "c");
    (25766, 0, "u");
    (25767, 0, "r");
    (25768, 0, "s");
    (25769, 0, "o");
    (25770, 0, "r");
    (25771, 0, " ");
    (25772, 0, "w");
    (25773, 0, "i");
    (25774, 0, "l");
    (25775, 0, "l");
    (25776, 0, " ");
    (25777, 0, "b");
    (25778, 0, "e");
    (25779, 0, " ");
    (25780, 0, "d");
    (25781, 0, "i");
    (25782, 0, "s");
    (25783, 0, "c");
    (25784, 0, "a");
    (25785, 0, "r");
    (25786, 0, "d");
    (25787, 0, "e");
    (25788, 0, "d");
    (25789, 0, " ");
    (25790, 0, "a");
    (25791, 0, "f");
    (25792, 0, "t");
    (25793, 0, "e");
    (25794, 0, "r");
    (25795, 0, " ");
    (25796, 0, "o");
    (25797, 0, "n");
    (25798, 0, "e");
    (25799, 0, " ");
    (25800, 0, "c");
    (25801, 0, "h");
    (25802, 0, "a");
    (25803, 0, "n");
    (25804, 0, "g");
    (25805, 0, "e");
    (25806, 0, ",");
    (25807, 0, " ");
    (25808, 0, "b");
    (25809, 0, "u");
    (25810, 0, "t");
    (25811, 0, " ");
    (25812, 0, "f");
    (25813, 0, "o");
    (25814, 0, "r");
    (25815, 0, " ");
    (25816, 0, "c");
    (25817, 0, "o");
    (25818, 0, "m");
    (25819, 0, "p");
    (25820, 0, "o");
    (25821, 0, "u");
    (25822, 0, "n");
    (25823, 0, "d");
    (25824, 0, " ");
    (25825, 0, "e");
    (25826, 0, "d");
    (25827, 0, "i");
    (25828, 0, "t");
    (25829, 0, "s");
    (25830, 0, " ");
    (25831, 0, "i");
    (25832, 0, "t");
    (25833, 0, "s");
    (25834, 0, " ");
    (25835, 0, "i");
    (25836, 0, "m");
    (25837, 0, "p");
    (25838, 0, "o");
    (25839, 0, "r");
    (25840, 0, "t");
    (25841, 0, "a");
    (25842, 0, "n");
    (25843, 0, "t");
    (25844, 0, " ");
    (25845, 0, "t");
    (25846, 0, "h");
    (25847, 0, "e");
    (25848, 0, " ");
    (25849, 0, "p");
    (25850, 0, "a");
    (25851, 0, "s");
    (25852, 0, "s");
    (25853, 0, "e");
    (25854, 0, "d");
    (25855, 0, " ");
    (25856, 0, "c");
    (25857, 0, "u");
    (25858, 0, "r");
    (25859, 0, "s");
    (25860, 0, "o");
    (25861, 0, "r");
    (25812, 50, "f");
    (25813, 0, "o");
    (25814, 0, "r");
    (25815, 0, " ");
    (25816, 0, "c");
    (25817, 0, "o");
    (25818, 0, "n");
    (25819, 0, "s");
    (25820, 0, "i");
    (25821, 0, "s");
    (25822, 0, "t");
    (25823, 0, "e");
    (25824, 0, "n");
    (25825, 0, "c");
    (25826, 0, "y");
    (25827, 0, " ");
    (25828, 0, "o");
    (25829, 0, "f");
    (25830, 0, " ");
    (25831, 0, "c");
    (25832, 0, "o");
    (25833, 0, "m");
    (25834, 0, "p");
    (25835, 0, "o");
    (25836, 0, "u");
    (25837, 0, "n");
    (25838, 0, "d");
    (25839, 0, " ");
    (25840, 0, "e");
    (25841, 0, "d");
    (25842, 0, "i");
    (25843, 0, "r");
    (25844, 0, "s");
    (25845, 0, " ");
    (25845, 1, "");
    (25844, 1, "");
    (25843, 1, "");
    (25843, 0, "t");
    (25844, 0, "s");
    (25845, 0, " ");
    (25846, 0, "w");
    (25847, 0, "e");
    (25848, 0, " ");
    (25848, 1, "");
    (25848, 0, " ");
    (25849, 0, "k");
    (25850, 0, "e");
    (25851, 0, "e");
    (25852, 0, "p");
    (25853, 0, " ");
    (25854, 0, "t");
    (25855, 0, "h");
    (25856, 0, "e");
    (25857, 0, " ");
    (25858, 0, "c");
    (25859, 0, "u");
    (25860, 0, "r");
    (25861, 0, "s");
    (25862, 0, "o");
    (25846, 17, "w");
    (25847, 0, "e");
    (25848, 0, "'");
    (25849, 0, "l");
    (25850, 0, "l");
    (25851, 0, " ");
    (25852, 0, "u");
    (25853, 0, "p");
    (25854, 0, "d");
    (25855, 0, "a");
    (25856, 0, "t");
    (25857, 0, "e");
    (25858, 0, " ");
    (25859, 0, "t");
    (25860, 0, "h");
    (25861, 0, "e");
    (25862, 0, " ");
    (25863, 0, "c");
    (25864, 0, "u");
    (25865, 0, "r");
    (25866, 0, "s");
    (25867, 0, "o");
    (25868, 0, "r");
    (25869, 0, " ");
    (25870, 0, "t");
    (25871, 0, "o");
    (25872, 0, " ");
    (25873, 0, "p");
    (25874, 0, "o");
    (25875, 0, "i");
    (25876, 0, "n");
    (25877, 0, "t");
    (25878, 0, " ");
    (25879, 0, "t");
    (25880, 0, "o");
    (25881, 0, "t");
    (25882, 0, " ");
    (25882, 1, "");
    (25881, 1, "");
    (25881, 0, " ");
    (25882, 0, "t");
    (25883, 0, "h");
    (25884, 0, "e");
    (25885, 0, " ");
    (25886, 0, "e");
    (25887, 0, "n");
    (25888, 0, "d");
    (25889, 0, " ");
    (25890, 0, "o");
    (25891, 0, "f");
    (25892, 0, " ");
    (25893, 0, "t");
    (25894, 0, "h");
    (25895, 0, "e");
    (25896, 0, " ");
    (25897, 0, "n");
    (25898, 0, "o");
    (25899, 0, "e");
    (25899, 1, "");
    (25898, 1, "");
    (25898, 0, "e");
    (25899, 0, "w");
    (25900, 0, " ");
    (25901, 0, "c");
    (25902, 0, "o");
    (25903, 0, "n");
    (25904, 0, "t");
    (25905, 0, "e");
    (25906, 0, "n");
    (25907, 0, "t");
    (25908, 0, ".");
    ( 25738,
      171,
      "            // Usually the cursor will be discarded after one change, \
       but for\n\
      \            // consistency of compound edits we'll update the cursor to \
       point to\n\
      \            // the end of the new content." );
    (25939, 0, "\n            ");
    (25952, 0, "c");
    (25953, 0, "u");
    (25954, 0, "r");
    (25955, 0, "s");
    (25956, 0, "o");
    (25957, 0, "r");
    (25958, 0, ".");
    (25952, 7, "");
    (25952, 0, "c");
    (25953, 0, "u");
    (25954, 0, "r");
    (25955, 0, "s");
    (25956, 0, "o");
    (25957, 0, "r");
    (25958, 0, ".");
    (25959, 0, "userpos");
    (25966, 0, " ");
    (25967, 0, "+");
    (25968, 0, "=");
    (25969, 0, " ");
    (25970, 0, "n");
    (25971, 0, "u");
    (25972, 0, "m");
    (25973, 0, "_");
    (25970, 4, "num_inserted_usercount");
    (25992, 0, ";");
    (25939, 0, "\n            ");
    (25952, 0, "f");
    (25953, 0, "o");
    (25954, 0, "r");
    (25955, 0, " ");
    (25956, 0, "_");
    (25957, 0, " ");
    (25958, 0, "i");
    (25959, 0, "n");
    (25960, 0, " ");
    (25956, 5, "e");
    (25957, 0, "n");
    (25958, 0, "t");
    (25959, 0, "r");
    (25960, 0, "y");
    (25956, 0, "&");
    (25957, 0, "m");
    (25958, 0, "u");
    (25959, 0, "t");
    (25960, 0, " ");
    (25966, 0, " ");
    (25967, 0, "i");
    (25968, 0, "n");
    (25969, 0, " ");
    (25970, 0, "c");
    (25971, 0, "u");
    (25972, 0, "r");
    (25973, 0, "s");
    (25974, 0, "o");
    (25975, 0, "r");
    (25976, 0, ".");
    (25977, 0, "entries");
    (25984, 0, " ");
    (25985, 0, "{");
    (25986, 0, "\n                ");
    (26003, 0, "\n                ");
    (25987, 16, "");
    (25988, 16, "            }");
    (25984, 0, "[");
    (25985, 0, "0");
    (25986, 0, ".");
    (25987, 0, ".");
    (25988, 0, "s");
    (25989, 0, "e");
    (25990, 0, "l");
    (25991, 0, "f");
    (25992, 0, ".");
    (25993, 0, "h");
    (25994, 0, "e");
    (25994, 1, "");
    (25993, 1, "");
    (25993, 0, "h");
    (25994, 0, "e");
    (25995, 0, "a");
    (25996, 0, "d");
    (25997, 0, ".");
    (25998, 0, "h");
    (25999, 0, "e");
    (26000, 0, "i");
    (26001, 0, "g");
    (26002, 0, "h");
    (26003, 0, "t");
    (26004, 0, " ");
    (26005, 0, "a");
    (26006, 0, "s");
    (26007, 0, " ");
    (26008, 0, "u");
    (26009, 0, "s");
    (26010, 0, "i");
    (26011, 0, "z");
    (26012, 0, "e");
    (26013, 0, ")");
    (26013, 1, "");
    (26013, 0, "]");
    (26017, 0, "                ");
    (26017, 16, "");
    (26014, 0, ".");
    (26015, 0, "i");
    (26016, 0, "t");
    (26017, 0, "e");
    (26018, 0, "r");
    (26019, 0, "(");
    (26020, 0, ")");
    (26019, 0, "_");
    (26020, 0, "m");
    (26021, 0, "u");
    (26022, 0, "t");
    (26028, 0, "                ");
    (26044, 0, "e");
    (26045, 0, "n");
    (26046, 0, "t");
    (26047, 0, "r");
    (26048, 0, "y");
    (26049, 0, ".");
    (26050, 0, "s");
    (26051, 0, "k");
    (26052, 0, "i");
    (26053, 0, "p");
    (26054, 0, "_");
    (26055, 0, "u");
    (26050, 6, "skip_usersize");
    (26063, 0, " ");
    (26064, 0, "+");
    (26065, 0, "=");
    (26066, 0, " ");
    (26067, 0, "num_inserted_usercount");
    (26089, 0, ";");
    (25956, 5, "");
    (1150, 3, "1");
    (1449, 2, "1");
    (1150, 1, "");
    (1150, 0, "2");
    (20926, 0, ",");
    (20927, 0, " ");
    (20928, 0, "m");
    (20929, 0, "o");
    (20930, 0, "v");
    (20931, 0, "e");
    (20932, 0, "_");
    (20933, 0, "c");
    (20934, 0, "u");
    (20935, 0, "r");
    (20936, 0, "s");
    (20937, 0, "o");
    (20938, 0, "r");
    (20939, 0, ":");
    (20940, 0, " ");
    (20941, 0, "b");
    (20942, 0, "o");
    (20943, 0, "o");
    (20944, 0, "l");
    (20941, 4, "bool");
    (22884, 0, "\n            ");
    (22897, 0, "f");
    (22897, 1, "");
    (22897, 0, "i");
    (22898, 0, "f");
    (22899, 0, " ");
    (22900, 0, "m");
    (22901, 0, "o");
    (22902, 0, "v");
    (22903, 0, "e");
    (22904, 0, "_");
    (22900, 5, "move_cursor");
    (22911, 0, " ");
    (22912, 0, "{");
    (23033, 12, "                ");
    (22990, 16, "                    ");
    (22958, 16, "                    ");
    (22914, 12, "                ");
    (23063, 0, "\n                ");
    (23064, 16, "            }");
    (23088, 0, "\n        ");
    (23097, 0, "i");
    (23098, 0, "f");
    (23099, 0, " ");
    (23100, 0, "m");
    (23101, 0, "o");
    (23102, 0, "v");
    (23103, 0, "e");
    (23100, 4, "move_cursor");
    (23111, 0, " ");
    (23112, 0, "{");
    (23306, 8, "            ");
    (23246, 12, "                ");
    (23163, 12, "                ");
    (23114, 8, "            ");
    (23331, 0, "\n            ");
    (23332, 12, "        }");
    (23113, 53, "");
    (23089, 8, "            ");
    (23089, 0, "        for i in new_height_usize..head_height {\n");
    (23166, 87, "");
    (23138, 12, "                ");
    ( 23138,
      0,
      "            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n" );
    (23341, 0, "\n            }");
    (23332, 8, "            ");
    (23318, 14, "");
    (23221, 16, "            ");
    (23328, 12, "        ");
    (28502, 0, ",");
    (28503, 0, " ");
    (28504, 0, "t");
    (28505, 0, "r");
    (28506, 0, "u");
    (28507, 0, "e");
    (28503, 5, "");
    (28502, 1, "");
    (28502, 0, ",");
    (28503, 0, " true");
    (28792, 0, ",");
    (28793, 0, " ");
    (28794, 0, "f");
    (28795, 0, "a");
    (28796, 0, "l");
    (28797, 0, "s");
    (28798, 0, "e");
    (28674, 0, "\n            ");
    (28687, 0, "/");
    (28688, 0, "/");
    (28689, 0, " ");
    (28675, 15, "");
    (28674, 1, "");
    (28723, 0, "\n                ");
    (28740, 0, "/");
    (28741, 0, "/");
    (28742, 0, " ");
    (28743, 0, "P");
    (28744, 0, "a");
    (28745, 0, "s");
    (28746, 0, "s");
    (28747, 0, "i");
    (28748, 0, "n");
    (28749, 0, "g");
    (28750, 0, " ");
    (28751, 0, "f");
    (28752, 0, "a");
    (28753, 0, "l");
    (28754, 0, "s");
    (28755, 0, "e");
    (28756, 0, " ");
    (28757, 0, "t");
    (28758, 0, "o");
    (28759, 0, " ");
    (28760, 0, "i");
    (28761, 0, "n");
    (28762, 0, "d");
    (28763, 0, "i");
    (28764, 0, "c");
    (28765, 0, "a");
    (28766, 0, "t");
    (28767, 0, "e");
    (28768, 0, " ");
    (28769, 0, "w");
    (28770, 0, "e");
    (28771, 0, " ");
    (28772, 0, "d");
    (28773, 0, "o");
    (28774, 0, "n");
    (28775, 0, "'");
    (28776, 0, "t");
    (28777, 0, " ");
    (28778, 0, "w");
    (28779, 0, "a");
    (28780, 0, "n");
    (28781, 0, "t");
    (28782, 0, " ");
    (28783, 0, "t");
    (28784, 0, "o");
    (28785, 0, " ");
    (28783, 3, "t");
    (28784, 0, "h");
    (28785, 0, "e");
    (28786, 0, " ");
    (28787, 0, "c");
    (28788, 0, "u");
    (28789, 0, "r");
    (28790, 0, "s");
    (28791, 0, "o");
    (28792, 0, "r");
    (28793, 0, " ");
    (28794, 0, "u");
    (28795, 0, "p");
    (28796, 0, "d");
    (28797, 0, "a");
    (28798, 0, "t");
    (28799, 0, "e");
    (28800, 0, "d");
    (28801, 0, " ");
    (28802, 0, "a");
    (28803, 0, "f");
    (28804, 0, "t");
    (28805, 0, "e");
    (28806, 0, " ");
    (28807, 0, "t");
    (28807, 1, "");
    (28806, 1, "");
    (28806, 0, "r");
    (28807, 0, " ");
    (28808, 0, "t");
    (28809, 0, "h");
    (28810, 0, "i");
    (28811, 0, "s");
    (28812, 0, " ");
    (28813, 0, "-");
    (28814, 0, " ");
    (28815, 0, "i");
    (28816, 0, "t");
    (28817, 0, " ");
    (28818, 0, "s");
    (28819, 0, "h");
    (28820, 0, "o");
    (28821, 0, "u");
    (28822, 0, "l");
    (28823, 0, "d");
    (28824, 0, " ");
    (28825, 0, "r");
    (28826, 0, "e");
    (28827, 0, "m");
    (28828, 0, "a");
    (28829, 0, "i");
    (28830, 0, "n");
    (28831, 0, " ");
    (28832, 0, "a");
    (28833, 0, "t");
    (28834, 0, " ");
    (28835, 0, "t");
    (28836, 0, "h");
    (28837, 0, "e");
    (28838, 0, " ");
    (28839, 0, "e");
    (28840, 0, "n");
    (28841, 0, "d");
    (28842, 0, " ");
    (28843, 0, "o");
    (28844, 0, "f");
    (28845, 0, " ");
    (28846, 0, "t");
    (28847, 0, "h");
    (28848, 0, "e");
    (28849, 0, " ");
    (28850, 0, "n");
    (28851, 0, "e");
    (28852, 0, "w");
    (28853, 0, "l");
    (28854, 0, "y");
    (28855, 0, " ");
    (28856, 0, "i");
    (28857, 0, "n");
    (28858, 0, "s");
    (28859, 0, "e");
    (28860, 0, "r");
    (28861, 0, "t");
    (28862, 0, "e");
    (28863, 0, "d");
    (28864, 0, " ");
    (28865, 0, "c");
    (28866, 0, "o");
    (28867, 0, "n");
    (28868, 0, "t");
    (28869, 0, "e");
    (28870, 0, "n");
    (28871, 0, "t");
    (28872, 0, ",");
    (28873, 0, " ");
    (28874, 0, "w");
    (28875, 0, "h");
    (28876, 0, "i");
    (28877, 0, "c");
    (28878, 0, "h");
    (28879, 0, " ");
    (28880, 0, "i");
    (28881, 0, "s");
    (28882, 0, " ");
    (28883, 0, "b");
    (28884, 0, "e");
    (28885, 0, "f");
    (28886, 0, "o");
    (28887, 0, "r");
    (28888, 0, "e");
    (28883, 0, "*");
    (28890, 0, "*");
    (28891, 0, " ");
    (28892, 0, "t");
    (28893, 0, "h");
    (28894, 0, "i");
    (28895, 0, "s");
    (28896, 0, " ");
    (28897, 0, "a");
    (28898, 0, "e");
    (28898, 1, "");
    (28897, 1, "");
    (28897, 0, "e");
    (28898, 0, "n");
    (28899, 0, "d");
    (28900, 0, " ");
    (28901, 0, "b");
    (28902, 0, "i");
    (28903, 0, "t");
    (28904, 0, ".");
    ( 28724,
      181,
      "                // Passing false to indicate we don't want the cursor \
       updated\n\
      \                // after this - it should remain at the end of the newly\n\
      \                // inserted content, which is *before* this end bit." );
    (23221, 0, "            if move_cursor {\n");
    (23278, 64, "");
    (23250, 12, "                ");
    ( 23250,
      0,
      "                cursor.entries[i].skip_usersize += new_userlen;\n" );
    (23346, 14, "");
    (23314, 16, "                    ");
    (23314, 0, "            }\n");
    (23364, 10, "");
    (23328, 20, "                        ");
    (23328, 0, "        }\n");
    (23378, 1, "");
    (23338, 24, "        ");
    (23338, 0, "        \n");
    (23371, 42, "");
    (23347, 8, "            ");
    (23347, 0, "        self.num_items += contents.len();\n");
    (23417, 43, "");
    (23389, 12, "                ");
    (23389, 0, "        self.num_usercount += new_userlen;\n");
    (23432, 16, "            ");
    (23432, 12, "        ");
    (23465, 0, "    ");
    (23499, 0, "\n            ");
    (23500, 12, "        }");
    (12303, 0, "\n    ");
    (12320, 0, " ");
    (12304, 4, "");
    (12317, 0, "f");
    (12318, 0, "i");
    (12319, 0, "e");
    (12320, 0, "l");
    (12321, 0, "d");
    (12347, 1, " ");
    (12348, 0, "-");
    (12350, 1, "");
    (12350, 0, "e");
    ( 12305,
      162,
      "    // This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    // the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    // this." );
    (12468, 0, "/");
    (12391, 0, "/");
    (12311, 0, "/");
    (12304, 0, "\n    ");
    (12309, 0, "/");
    (12310, 0, "/");
    (12311, 0, "/");
    (12312, 0, " ");
    (12313, 0, "T");
    (12314, 0, "h");
    (12315, 0, "e");
    (12316, 0, " ");
    (12317, 0, "g");
    (12318, 0, "l");
    (12319, 0, "o");
    (12320, 0, "a");
    (12320, 1, "");
    (12320, 0, "b");
    (12321, 0, "a");
    (12322, 0, "l");
    (12323, 0, " ");
    (12324, 0, "u");
    (12325, 0, "s");
    (12326, 0, "e");
    (12327, 0, "r");
    (12328, 0, " ");
    (12329, 0, "p");
    (12330, 0, "o");
    (12331, 0, "s");
    (12332, 0, "i");
    (12333, 0, "t");
    (12334, 0, "i");
    (12335, 0, "o");
    (12336, 0, "n");
    (12337, 0, " ");
    (12338, 0, "i");
    (12339, 0, "n");
    (12340, 0, " ");
    (12341, 0, "t");
    (12342, 0, "h");
    (12343, 0, "e");
    (12344, 0, " ");
    (12345, 0, "l");
    (12346, 0, "i");
    (12347, 0, "s");
    (12348, 0, "t");
    (12338, 0, "o");
    (12339, 0, "f");
    (12340, 0, " ");
    (12341, 0, "t");
    (12342, 0, "h");
    (12343, 0, "e");
    (12344, 0, " ");
    (12345, 0, "c");
    (12346, 0, "u");
    (12347, 0, "r");
    (12348, 0, "s");
    (12349, 0, "o");
    (12350, 0, " ");
    (12351, 0, "r");
    (12362, 1, "");
    (12361, 1, "");
    (12360, 1, "");
    (12359, 1, "");
    (12358, 1, "");
    (12357, 1, "");
    (12356, 1, "");
    (12355, 1, "");
    (12354, 1, "");
    (12353, 1, "");
    (12352, 1, "");
    (12351, 1, "");
    (12350, 1, "");
    (12350, 0, "r");
    (12351, 0, " ");
    (12352, 0, "i");
    (12353, 0, "n");
    (12354, 0, " ");
    (12355, 0, "t");
    (12356, 0, "h");
    (12357, 0, "e");
    (12358, 0, " ");
    (12359, 0, "e");
    (12360, 0, "n");
    (12361, 0, "t");
    (12362, 0, "i");
    (12363, 0, "r");
    (12364, 0, "e");
    (12365, 0, " ");
    (12366, 0, "l");
    (12367, 0, "i");
    (12368, 0, "s");
    (12369, 0, "t");
    (12370, 0, ".");
    (12371, 0, " ");
    (12372, 0, "T");
    (12373, 0, "i");
    (12374, 0, "s");
    (12375, 0, " ");
    (12375, 1, "");
    (12374, 1, "");
    (12373, 1, "");
    (12373, 0, "h");
    (12374, 0, "i");
    (12375, 0, "s");
    (12376, 0, " ");
    (12377, 0, "i");
    (12378, 0, "s");
    (12379, 0, " ");
    (12380, 0, "u");
    (12381, 0, "s");
    (12382, 0, "e");
    (12383, 0, "d");
    (12384, 0, " ");
    (12385, 0, "f");
    (12386, 0, "o");
    (12387, 0, "r");
    (12388, 0, " ");
    (12389, 0, "h");
    (12389, 1, "");
    (12389, 0, "w");
    (12390, 0, "h");
    (12391, 0, "e");
    (12392, 0, "n");
    (12393, 0, " ");
    (12394, 0, "t");
    (12395, 0, "h");
    (12396, 0, "e");
    (12397, 0, " ");
    (12398, 0, "h");
    (12399, 0, "e");
    (12400, 0, "i");
    (12401, 0, "g");
    (12402, 0, "h");
    (12403, 0, "t");
    (12404, 0, " ");
    (12398, 7, "m");
    (12399, 0, "a");
    (12400, 0, "x");
    (12401, 0, " ");
    (12402, 0, "s");
    (12403, 0, "e");
    (12404, 0, "e");
    (12405, 0, "n");
    (12406, 0, " ");
    (12407, 0, "h");
    (12408, 0, "e");
    (12409, 0, "i");
    (12410, 0, "g");
    (12411, 0, "h");
    (12412, 0, "t");
    (12413, 0, " ");
    (12414, 0, "i");
    (12415, 0, "n");
    (12416, 0, "c");
    (12417, 0, "r");
    (12418, 0, "e");
    (12419, 0, "a");
    (12420, 0, "s");
    (12421, 0, "e");
    (12422, 0, "s");
    (12423, 0, ",");
    (12424, 0, " ");
    (12425, 0, "s");
    (12426, 0, "o");
    (12427, 0, " ");
    (12428, 0, "w");
    (12429, 0, "e");
    (12430, 0, " ");
    (12431, 0, "c");
    (12432, 0, "a");
    (12433, 0, "n");
    (12434, 0, " ");
    (12435, 0, "p");
    (12436, 0, "o");
    (12437, 0, "p");
    (12438, 0, "u");
    (12439, 0, "l");
    (12440, 0, "a");
    (12441, 0, "t");
    (12442, 0, "e");
    (12443, 0, " ");
    (12444, 0, "f");
    (12445, 0, "i");
    (12446, 0, "e");
    (12447, 0, "l");
    (12448, 0, "d");
    (12449, 0, "s");
    (12450, 0, " ");
    (12451, 0, "i");
    (12452, 0, "n");
    (12453, 0, " ");
    (12454, 0, "t");
    (12455, 0, "h");
    (12456, 0, "e");
    (12457, 0, " ");
    (12458, 0, "c");
    (12459, 0, "u");
    (12460, 0, "r");
    (12461, 0, "s");
    (12462, 0, "o");
    (12463, 0, "r");
    (12464, 0, " ");
    (12465, 0, "a");
    (12466, 0, "n");
    (12467, 0, "d");
    (12468, 0, " ");
    (12469, 0, "i");
    (12470, 0, "n");
    (12471, 0, " ");
    (12444, 7, "p");
    (12445, 0, "r");
    (12446, 0, "e");
    (12447, 0, "v");
    (12448, 0, "i");
    (12449, 0, "u");
    (12450, 0, "s");
    (12451, 0, "l");
    (12451, 1, "");
    (12450, 1, "");
    (12449, 1, "");
    (12448, 1, "");
    (12448, 0, "i");
    (12449, 0, "o");
    (12450, 0, "u");
    (12451, 0, "s");
    (12452, 0, "l");
    (12453, 0, "y");
    (12454, 0, " ");
    (12455, 0, "u");
    (12456, 0, "n");
    (12457, 0, "u");
    (12458, 0, "s");
    (12459, 0, "e");
    (12460, 0, "d");
    (12461, 0, " ");
    (12462, 0, "e");
    (12463, 0, "n");
    (12464, 0, "t");
    (12465, 0, "r");
    (12466, 0, "i");
    (12467, 0, "e");
    (12468, 0, "s");
    (12469, 0, " ");
    (12484, 7, "a");
    (12485, 0, "n");
    (12486, 0, "d");
    (12487, 0, " ");
    (12488, 0, "i");
    (12489, 0, "n");
    (12490, 0, " ");
    (12491, 0, "t");
    (12492, 0, "h");
    (12493, 0, "e");
    (12494, 0, " ");
    (12495, 0, "h");
    (12496, 0, "e");
    (12497, 0, "a");
    (12498, 0, "d");
    (12499, 0, " ");
    (12500, 0, "n");
    (12501, 0, "o");
    (12502, 0, "d");
    (12503, 0, "e");
    (12504, 0, "'");
    (12505, 0, "s");
    (12506, 0, " ");
    (12507, 0, "h");
    (12508, 0, "e");
    (12509, 0, "i");
    (12510, 0, "g");
    (12511, 0, "h");
    (12512, 0, "t");
    (12504, 9, ".");
    (12505, 0, "assert_eq!");
    (12505, 10, "");
    (12505, 0, "\n    /// ");
    ( 12305,
      209,
      "    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///" );
    (12722, 0, "\n    ");
    (12727, 0, "\n    ");
    (12723, 4, "");
    (12728, 0, "l");
    (12729, 0, "o");
    (12730, 0, "c");
    (12731, 0, "a");
    (12732, 0, "l");
    (12733, 0, "_");
    (12734, 0, "i");
    (12735, 0, "n");
    (12736, 0, "d");
    (12737, 0, "e");
    (12738, 0, ":");
    (12738, 1, "");
    (12738, 0, "x");
    (12739, 0, ":");
    (12740, 0, " ");
    (12741, 0, "u");
    (12742, 0, "s");
    (12743, 0, "i");
    (12744, 0, "z");
    (12745, 0, "e");
    (12746, 0, ",");
    (12723, 0, "\n    ");
    (12728, 0, "/");
    (12729, 0, "/");
    (12730, 0, "/");
    (12731, 0, " ");
    (12732, 0, "T");
    (12733, 0, "h");
    (12734, 0, "i");
    (12735, 0, "s");
    (12736, 0, " ");
    (12737, 0, "i");
    (12738, 0, "s");
    (12739, 0, " ");
    (12740, 0, "n");
    (12741, 0, "e");
    (12742, 0, "e");
    (12743, 0, "d");
    (12744, 0, "e");
    (12745, 0, "d");
    (12746, 0, " ");
    (12747, 0, "e");
    (12748, 0, "b");
    (12749, 0, "c");
    (12750, 0, "a");
    (12732, 19, "W");
    (12733, 0, "h");
    (12734, 0, "e");
    (12735, 0, "n");
    (12736, 0, " ");
    (12737, 0, "t");
    (12738, 0, "h");
    (12739, 0, "e");
    (12740, 0, " ");
    (12741, 0, "u");
    (12742, 0, "s");
    (12743, 0, "e");
    (12744, 0, "r");
    (12745, 0, "p");
    (12746, 0, "o");
    (12747, 0, "s");
    (12748, 0, " ");
    (12749, 0, "o");
    (12750, 0, "f");
    (12751, 0, " ");
    (12752, 0, "a");
    (12753, 0, "n");
    (12754, 0, " ");
    (12755, 0, "e");
    (12756, 0, "n");
    (12757, 0, "t");
    (12758, 0, "r");
    (12759, 0, "y");
    (12760, 0, " ");
    (12761, 0, "i");
    (12762, 0, "s");
    (12763, 0, " ");
    (12764, 0, "0");
    (12765, 0, " ");
    (12766, 0, "(");
    (12767, 0, "t");
    (12768, 0, "o");
    (12769, 0, "t");
    (12770, 0, "a");
    (12771, 0, "l");
    (12772, 0, "l");
    (12773, 0, "y");
    (12774, 0, " ");
    (12775, 0, "v");
    (12776, 0, "a");
    (12777, 0, "l");
    (12778, 0, "i");
    (12779, 0, "d");
    (12780, 0, " ");
    (12781, 0, "a");
    (12782, 0, "n");
    (12783, 0, "d");
    (12784, 0, " ");
    (12785, 0, "u");
    (12786, 0, "s");
    (12787, 0, "e");
    (12788, 0, "f");
    (12789, 0, "u");
    (12790, 0, "l");
    (12791, 0, ")");
    (12792, 0, ",");
    (12793, 0, " ");
    (12794, 0, "t");
    (12795, 0, "h");
    (12796, 0, "e");
    (12797, 0, " ");
    (12794, 4, "a");
    (12795, 0, " ");
    (12796, 0, "c");
    (12797, 0, "u");
    (12798, 0, "r");
    (12799, 0, "s");
    (12800, 0, "o");
    (12801, 0, "r");
    (12802, 0, " ");
    (12803, 0, "b");
    (12804, 0, "e");
    (12805, 0, "c");
    (12806, 0, "o");
    (12807, 0, "m");
    (12808, 0, "e");
    (12809, 0, "s");
    (12810, 0, " ");
    (12811, 0, "a");
    (12812, 0, "m");
    (12813, 0, "b");
    (12814, 0, "i");
    (12815, 0, "g");
    (12816, 0, "u");
    (12817, 0, "o");
    (12818, 0, "u");
    (12819, 0, "s");
    (12820, 0, " ");
    (12821, 0, "i");
    (12822, 0, "n");
    (12823, 0, " ");
    (12824, 0, "w");
    (12825, 0, "h");
    (12826, 0, "e");
    (12827, 0, "r");
    (12828, 0, "e");
    (12829, 0, " ");
    (12830, 0, "i");
    (12831, 0, "t");
    (12832, 0, "s");
    (12833, 0, " ");
    (12834, 0, "p");
    (12835, 0, "o");
    (12836, 0, "i");
    (12837, 0, "n");
    (12838, 0, "t");
    (12839, 0, "i");
    (12840, 0, "n");
    (12841, 0, "g");
    (12842, 0, ".");
    ( 12724,
      119,
      "    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous in where its pointing." );
    (12829, 2, "a");
    (12830, 0, "b");
    (12831, 0, "o");
    (12832, 0, "u");
    (12833, 0, "t");
    (12854, 0, " ");
    (12855, 0, "T");
    (12856, 0, "h");
    (12857, 0, "i");
    (12858, 0, "s");
    (12859, 0, " ");
    (12860, 0, "i");
    (12861, 0, "s");
    (12862, 0, " ");
    (12863, 0, "u");
    (12864, 0, "s");
    (12865, 0, "e");
    (12866, 0, "d");
    (12829, 5, "w");
    (12830, 0, "i");
    (12831, 0, "t");
    (12832, 0, "h");
    (12833, 0, " ");
    (12834, 0, "r");
    (12835, 0, "e");
    (12836, 0, "g");
    (12837, 0, "a");
    (12838, 0, "r");
    (12839, 0, "d");
    (12840, 0, " ");
    (12841, 0, "t");
    (12842, 0, "o");
    (12849, 0, " ");
    (12850, 0, "e");
    (12851, 0, "x");
    (12852, 0, "a");
    (12853, 0, "c");
    (12854, 0, "t");
    (12855, 0, "l");
    (12856, 0, "y");
    (12870, 0, " ");
    (12871, 0, "i");
    (12872, 0, "n");
    (12873, 0, " ");
    (12874, 0, "t");
    (12875, 0, "h");
    (12876, 0, "e");
    (12877, 0, " ");
    (12878, 0, "c");
    (12879, 0, "u");
    (12880, 0, "r");
    (12881, 0, "r");
    (12882, 0, "e");
    (12883, 0, "n");
    (12884, 0, "t");
    (12885, 0, " ");
    (12886, 0, "e");
    (12887, 0, "n");
    (12888, 0, "t");
    (12889, 0, "r");
    (12890, 0, "y");
    ( 12803,
      102,
      "    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used" );
    (12913, 0, "t");
    (12914, 0, " ");
    (12914, 1, "");
    (12913, 1, "");
    (12913, 0, " ");
    (12914, 0, "t");
    (12915, 0, "o");
    (12916, 0, " ");
    (12917, 0, "r");
    (12918, 0, "e");
    (12919, 0, "s");
    (12920, 0, "o");
    (12921, 0, "v");
    (12922, 0, "l");
    (12923, 0, "e");
    (12924, 0, " ");
    (12925, 0, "t");
    (12926, 0, "a");
    (12917, 10, "r");
    (12918, 0, "e");
    (12919, 0, "s");
    (12920, 0, "o");
    (12921, 0, "l");
    (12922, 0, "v");
    (12923, 0, "e");
    (12924, 0, " ");
    (12925, 0, "t");
    (12926, 0, "h");
    (12927, 0, "a");
    (12928, 0, "t");
    (12929, 0, " ");
    (12930, 0, "a");
    (12931, 0, "m");
    (12932, 0, "b");
    (12933, 0, "u");
    (12933, 1, "");
    (12933, 0, "i");
    (12934, 0, "g");
    (12935, 0, "u");
    (12936, 0, "i");
    (12937, 0, "t");
    (12938, 0, "y");
    (12939, 0, ".");
    (19299, 0, "(");
    (19309, 0, ",");
    (19310, 0, " ");
    (19311, 0, "u");
    (19312, 0, "s");
    (19313, 0, "i");
    (19314, 0, "z");
    (19315, 0, "e");
    (19316, 0, ")");
    (18943, 4, "c");
    (18944, 0, "o");
    (18945, 0, "n");
    (18946, 0, "t");
    (18947, 0, "a");
    (18948, 0, "i");
    (18949, 0, "n");
    (18950, 0, "s");
    ( 18905,
      213,
      "    /// skiplist. The returned cursor contains list of nodes which \
       point past\n\
      \    /// the specified position, as well as offsets of how far into their\n\
      \    /// character lists the specified characters are.\n\
      \    ///" );
    (19126, 70, "B");
    (19127, 0, "y");
    (19128, 0, " ");
    (19129, 0, "d");
    (19130, 0, "e");
    (19126, 5, "T");
    (19127, 0, "h");
    (19127, 1, "");
    (19126, 1, "");
    (19126, 0, "i");
    (19127, 0, "t");
    (19128, 0, "e");
    (19129, 0, "r");
    (19130, 0, "_");
    (19131, 0, "a");
    (19132, 0, "t");
    (19133, 0, "_");
    (19134, 0, "u");
    (19135, 0, "s");
    (19136, 0, "e");
    (19137, 0, "r");
    (19138, 0, "p");
    (19139, 0, "o");
    (19140, 0, "s");
    (19141, 0, " ");
    (19142, 0, "c");
    (19143, 0, "u");
    (19144, 0, "r");
    (19145, 0, "r");
    (19146, 0, "e");
    (19147, 0, "n");
    (19148, 0, "t");
    (19149, 0, "l");
    (19150, 0, "y");
    (19151, 0, " ");
    (19152, 0, "r");
    (19153, 0, "e");
    (19154, 0, "t");
    (19155, 0, "u");
    (19156, 0, "r");
    (19157, 0, "n");
    (19158, 0, "s");
    (19159, 0, " ");
    (19160, 0, "t");
    (19161, 0, "h");
    (19162, 0, "e");
    (19163, 0, " ");
    (19164, 0, "l");
    (19165, 0, "a");
    (19166, 0, "s");
    (19167, 0, "t");
    (19168, 0, " ");
    (19126, 43, "S");
    (19127, 0, "o");
    (19128, 0, "m");
    (19129, 0, "e");
    (19130, 0, "t");
    (19131, 0, "i");
    (19132, 0, "m");
    (19133, 0, "e");
    (19134, 0, "s");
    (19135, 0, " ");
    (19136, 0, "a");
    (19137, 0, " ");
    (19138, 0, "c");
    (19139, 0, "a");
    (19140, 0, "l");
    (19141, 0, "l");
    (19142, 0, " ");
    (19143, 0, "t");
    (19144, 0, "o");
    (19145, 0, " ");
    (19146, 0, "i");
    (19147, 0, "t");
    (19148, 0, "e");
    (19149, 0, "r");
    (19150, 0, "_");
    (19151, 0, "a");
    (19152, 0, "t");
    (19153, 0, "_");
    (19154, 0, "u");
    (19155, 0, "s");
    (19156, 0, "e");
    (19157, 0, "r");
    (19158, 0, "p");
    (19159, 0, "o");
    (19160, 0, "s");
    (19161, 0, " ");
    (19162, 0, "i");
    (19163, 0, "s");
    (19164, 0, " ");
    (19165, 0, "a");
    (19166, 0, "m");
    (19167, 0, "b");
    (19168, 0, "i");
    (19169, 0, "g");
    (19170, 0, "u");
    (19171, 0, "o");
    (19172, 0, "u");
    (19173, 0, "s");
    (19174, 0, ":");
    (19175, 0, "assert_eq!");
    (19185, 0, "\n    /// ");
    (19194, 0, "-");
    (19185, 10, "");
    (19175, 10, "");
    (19175, 0, "\n    /// ");
    (19184, 0, "\n    /// ");
    (19193, 0, "-");
    (19194, 0, " ");
    (19195, 0, "T");
    (19196, 0, "h");
    (19197, 0, "e");
    (19198, 0, " ");
    (19199, 0, "u");
    (19200, 0, "s");
    (19201, 0, "e");
    (19202, 0, "r");
    (19199, 4, "");
    (19199, 0, "i");
    (19200, 0, "t");
    (19201, 0, "e");
    (19202, 0, "m");
    (19203, 0, " ");
    (19204, 0, "c");
    (19205, 0, "a");
    (19206, 0, "n");
    (19207, 0, " ");
    (19208, 0, "c");
    (19209, 0, "o");
    (19210, 0, "n");
    (19211, 0, "t");
    (19212, 0, "a");
    (19213, 0, "i");
    (19214, 0, "n");
    (19215, 0, " ");
    (19216, 0, "z");
    (19217, 0, "e");
    (19218, 0, "r");
    (19219, 0, "o");
    (19220, 0, "-");
    (19221, 0, "s");
    (19222, 0, "i");
    (19223, 0, "z");
    (19224, 0, "e");
    (19225, 0, "d");
    (19220, 6, "i");
    (19216, 5, "i");
    (19217, 0, "t");
    (19218, 0, "e");
    (19219, 0, "m");
    (19220, 0, "s");
    (19221, 0, " ");
    (19222, 0, "w");
    (19223, 0, "i");
    (19224, 0, "t");
    (19225, 0, "h");
    (19226, 0, " ");
    (19227, 0, "z");
    (19228, 0, "e");
    (19229, 0, "r");
    (19230, 0, "o");
    (19231, 0, " ");
    (19232, 0, "u");
    (19233, 0, "s");
    (19234, 0, "e");
    (19235, 0, "r");
    (19236, 0, "s");
    (19237, 0, "i");
    (19238, 0, "z");
    (19239, 0, "e");
    (19240, 0, ".");
    (19241, 0, " ");
    (19242, 0, "T");
    (19243, 0, "h");
    (19244, 0, "e");
    (19245, 0, " ");
    (19246, 0, "c");
    (19247, 0, "u");
    (19248, 0, "r");
    (19249, 0, "s");
    (19250, 0, "o");
    (19251, 0, "r");
    (19252, 0, " ");
    (19253, 0, "c");
    (19254, 0, "o");
    (19255, 0, "u");
    (19256, 0, "l");
    (19257, 0, "d");
    (19258, 0, " ");
    (19259, 0, "p");
    (19260, 0, "o");
    (19261, 0, "i");
    (19262, 0, "n");
    (19263, 0, "t");
    (19264, 0, " ");
    (19265, 0, "t");
    (19266, 0, "o");
    (19267, 0, " ");
    (19268, 0, "t");
    (19268, 1, "");
    (19268, 0, "a");
    (19269, 0, "n");
    (19270, 0, "y");
    (19271, 0, " ");
    (19272, 0, "o");
    (19273, 0, "f");
    (19274, 0, " ");
    (19275, 0, "t");
    (19276, 0, "h");
    (19277, 0, "e");
    (19278, 0, "m");
    (19279, 0, ".");
    (19280, 0, "assert_eq!");
    (19280, 10, "");
    (19280, 0, "\n    /// ");
    (19289, 0, "/");
    (19289, 1, "");
    (19289, 0, "-");
    (19290, 0, " ");
    (19291, 0, "T");
    (19292, 0, "h");
    (19293, 0, "e");
    (19294, 0, " ");
    (19295, 0, "c");
    (19296, 0, "u");
    (19297, 0, "r");
    (19298, 0, "s");
    (19299, 0, "o");
    (19300, 0, "r");
    (19301, 0, " ");
    (19302, 0, "c");
    (19303, 0, "o");
    (19304, 0, "u");
    (19305, 0, "l");
    (19306, 0, "d");
    (19307, 0, " ");
    (19308, 0, "o");
    (19308, 1, "");
    (19280, 0, " ");
    (19281, 0, "F");
    (19282, 0, "o");
    (19283, 0, "r");
    (19284, 0, " ");
    (19285, 0, "n");
    (19286, 0, "o");
    (19287, 0, "w");
    (19288, 0, " ");
    (19289, 0, "w");
    (19289, 1, "");
    (19289, 0, "t");
    (19290, 0, "h");
    (19291, 0, "i");
    (19292, 0, "s");
    (19293, 0, " ");
    (19294, 0, "m");
    (19295, 0, "e");
    (19296, 0, "t");
    (19297, 0, "h");
    (19298, 0, "o");
    (19299, 0, "d");
    (19300, 0, " ");
    (19301, 0, "a");
    (19302, 0, "l");
    (19303, 0, "w");
    (19304, 0, "a");
    (19305, 0, "y");
    (19306, 0, "s");
    (19307, 0, " ");
    (19308, 0, "r");
    (19309, 0, "e");
    (19310, 0, "t");
    (19311, 0, "u");
    (19312, 0, "r");
    (19280, 33, "");
    (19295, 0, "r");
    (19296, 0, "e");
    (19297, 0, "t");
    (19298, 0, "u");
    (19299, 0, "r");
    (19300, 0, "n");
    (19301, 0, "e");
    (19302, 0, "d");
    (19303, 0, " ");
    (19317, 0, "b");
    (19318, 0, "e");
    (19319, 0, " ");
    (19320, 0, "e");
    (19321, 0, "i");
    (19322, 0, "t");
    (19323, 0, "h");
    (19324, 0, "e");
    (19325, 0, "r");
    (19326, 0, " ");
    (19327, 0, "a");
    (19328, 0, "t");
    (19329, 0, " ");
    (19330, 0, "t");
    (19331, 0, "h");
    (19332, 0, "e");
    (19333, 0, "e");
    (19333, 1, "");
    (19333, 0, " ");
    (19334, 0, "e");
    (19335, 0, "n");
    (19336, 0, "d");
    (19337, 0, " ");
    (19338, 0, "o");
    (19339, 0, "f");
    (19340, 0, " ");
    (19341, 0, "t");
    (19342, 0, "h");
    (19343, 0, "e");
    (19344, 0, " ");
    (19338, 0, "o");
    (19339, 0, "f");
    (19340, 0, " ");
    (19291, 57, "I");
    (19292, 0, "f");
    (19293, 0, " ");
    (19294, 0, "t");
    (19295, 0, "h");
    (19296, 0, "e");
    (19297, 0, " ");
    (19298, 0, "l");
    (19299, 0, "o");
    (19300, 0, "c");
    (19301, 0, "a");
    (19302, 0, "t");
    (19303, 0, "i");
    (19304, 0, "o");
    (19305, 0, "n");
    (19306, 0, " ");
    (19307, 0, "i");
    (19308, 0, "s");
    (19309, 0, " ");
    (19310, 0, "a");
    (19311, 0, "t");
    (19312, 0, " ");
    (19313, 0, "t");
    (19314, 0, "h");
    (19315, 0, "e");
    (19316, 0, " ");
    (19317, 0, "e");
    (19318, 0, "n");
    (19319, 0, "d");
    (19320, 0, " ");
    (19321, 0, "o");
    (19322, 0, "f");
    (19323, 0, " ");
    (19324, 0, "a");
    (19325, 0, " ");
    (19326, 0, "n");
    (19327, 0, "o");
    (19328, 0, "d");
    (19329, 0, "e");
    (19330, 0, ",");
    (19331, 0, " ");
    (19332, 0, "i");
    (19333, 0, "t");
    (19334, 0, " ");
    (19335, 0, "i");
    (19336, 0, "s");
    (19337, 0, " ");
    (19338, 0, "e");
    (19339, 0, "q");
    (19340, 0, "u");
    (19341, 0, "a");
    (19342, 0, "l");
    (19343, 0, "l");
    (19344, 0, "y");
    (19345, 0, " ");
    (19346, 0, "v");
    (19347, 0, "a");
    (19348, 0, "l");
    (19349, 0, "i");
    (19350, 0, "d");
    (19351, 0, " ");
    (19352, 0, "t");
    (19353, 0, "o");
    (19354, 0, " ");
    (19355, 0, "r");
    (19356, 0, "e");
    (19357, 0, "t");
    (19358, 0, "u");
    (19359, 0, "r");
    (19360, 0, "n");
    (19361, 0, " ");
    (19362, 0, "a");
    (19363, 0, " ");
    (19364, 0, "p");
    (19365, 0, "o");
    (19366, 0, "s");
    (19367, 0, "i");
    (19368, 0, "t");
    (19369, 0, "i");
    (19370, 0, "o");
    (19371, 0, "n");
    (19372, 0, " ");
    (19373, 0, "a");
    (19374, 0, "t");
    (19375, 0, " ");
    (19376, 0, "t");
    (19377, 0, "h");
    (19378, 0, "e");
    (19379, 0, " ");
    (19380, 0, "e");
    (19380, 1, "");
    (19380, 0, "s");
    (19381, 0, "t");
    (19382, 0, "a");
    (19383, 0, "r");
    (19384, 0, "t");
    (19385, 0, " ");
    (19386, 0, "o");
    (19387, 0, " ");
    (19387, 1, "");
    (19387, 0, "f");
    (19388, 0, " ");
    (19389, 0, "t");
    (19390, 0, " ");
    (19390, 1, "");
    (19390, 0, "h");
    (19391, 0, "e");
    (19392, 0, " ");
    (19393, 0, "n");
    (19394, 0, "e");
    (19395, 0, "x");
    (19396, 0, "t");
    (19397, 0, " ");
    (19398, 0, "n");
    (19399, 0, "o");
    (19400, 0, "d");
    (19401, 0, "e");
    (19402, 0, ".");
    ( 19176,
      227,
      "    ///\n\
      \    /// - The item can contain items with zero usersize. The cursor \
       could point\n\
      \    ///   to any of them.\n\
      \    /// - If the location is at the end of a node, it is equally valid \
       to return\n\
      \    ///   a position at the start of the next node." );
    (19422, 0, "\n    /// ");
    (19431, 0, "\n    /// ");
    (19440, 0, "B");
    (19441, 0, "e");
    (19442, 0, "c");
    (19443, 0, "a");
    (19444, 0, "u");
    (19445, 0, "s");
    (19446, 0, "e");
    (19447, 0, " ");
    (19448, 0, "i");
    (19449, 0, "t");
    (19450, 0, "s");
    (19451, 0, " ");
    (19452, 0, "i");
    (19453, 0, "m");
    (19454, 0, "p");
    (19455, 0, "o");
    (19456, 0, "s");
    (19457, 0, "s");
    (19458, 0, "i");
    (19459, 0, "b");
    (19460, 0, "l");
    (19461, 0, "e");
    (19462, 0, " ");
    (19463, 0, "m");
    (19464, 0, "t");
    (19464, 1, "");
    (19463, 1, "");
    (19463, 0, "t");
    (19464, 0, "o");
    (19465, 0, " ");
    (19466, 0, "m");
    (19467, 0, "v");
    (19468, 0, "o");
    (19468, 1, "");
    (19467, 1, "");
    (19467, 0, "o");
    (19468, 0, "v");
    (19469, 0, "e");
    (19470, 0, " ");
    (19471, 0, "b");
    (19472, 0, "a");
    (19473, 0, "c");
    (19474, 0, "k");
    (19475, 0, "w");
    (19476, 0, "a");
    (19477, 0, "r");
    (19478, 0, "d");
    (19479, 0, "s");
    (19480, 0, " ");
    (19481, 0, "i");
    (19482, 0, "n");
    (19483, 0, " ");
    (19484, 0, "t");
    (19485, 0, "h");
    (19486, 0, "e");
    (19487, 0, " ");
    (19488, 0, "l");
    (19489, 0, "i");
    (19490, 0, "s");
    (19491, 0, "t");
    (19492, 0, ",");
    (19493, 0, " ");
    (19494, 0, "w");
    (19495, 0, "e");
    (19496, 0, " ");
    (19497, 0, "r");
    (19498, 0, "e");
    (19499, 0, "t");
    (19500, 0, "u");
    (19501, 0, "r");
    (19502, 0, "n");
    (19503, 0, " ");
    (19504, 0, "t");
    (19505, 0, "h");
    (19506, 0, "e");
    (19507, 0, " ");
    (19508, 0, "f");
    (19509, 0, "i");
    (19510, 0, "r");
    (19511, 0, "s");
    (19512, 0, "t");
    (19513, 0, " ");
    (19514, 0, "v");
    (19515, 0, "a");
    (19516, 0, "l");
    (19517, 0, "i");
    (19518, 0, "d");
    (19519, 0, " ");
    (19520, 0, "l");
    (19521, 0, "o");
    (19522, 0, "c");
    (19523, 0, "a");
    (19524, 0, "t");
    (19525, 0, "i");
    (19526, 0, "o");
    (19527, 0, "n");
    (19494, 2, "i");
    (19495, 0, "t");
    (19496, 0, "e");
    (19497, 0, "r");
    (19498, 0, "_");
    (19499, 0, "a");
    (19500, 0, "t");
    (19501, 0, "_");
    (19502, 0, "u");
    (19503, 0, "s");
    (19504, 0, "e");
    (19505, 0, "r");
    (19506, 0, "p");
    (19507, 0, "o");
    (19508, 0, "s");
    (19516, 0, "s");
    (19528, 0, "*");
    (19534, 0, "*");
    (19534, 1, "");
    (19528, 1, "");
    (19528, 5, "a");
    (19528, 1, "");
    (19528, 0, "a");
    (19529, 0, "d");
    (19530, 0, "m");
    (19531, 0, "i");
    (19532, 0, "s");
    (19533, 0, "s");
    (19534, 0, "i");
    (19535, 0, "o");
    (19536, 0, "n");
    (19536, 1, "");
    (19535, 1, "");
    (19535, 0, "b");
    (19536, 0, "l");
    (19537, 0, "e");
    (19547, 0, " ");
    (19548, 0, "w");
    (19549, 0, "i");
    (19550, 0, "t");
    (19551, 0, "h");
    (19552, 0, " ");
    (19553, 0, "t");
    (19554, 0, "h");
    (19555, 0, "e");
    (19556, 0, " ");
    (19557, 0, "s");
    (19558, 0, "p");
    (19559, 0, "e");
    (19560, 0, "c");
    (19561, 0, "i");
    (19562, 0, "f");
    (19563, 0, "i");
    (19564, 0, "e");
    (19565, 0, "d");
    (19566, 0, " ");
    (19567, 0, "u");
    (19568, 0, "s");
    (19569, 0, "e");
    (19570, 0, "r");
    (19571, 0, "p");
    (19572, 0, "o");
    (19573, 0, "s");
    (19574, 0, ".");
    ( 19423,
      152,
      "    ///\n\
      \    /// Because its impossible to move backwards in the list, \
       iter_at_userpos\n\
      \    /// returns the first admissible location with the specified \
       userpos." );
    (19582, 0, "\n    /// ");
    (19591, 0, "\n    /// ");
    (19600, 0, "@");
    (19601, 0, "r");
    (19602, 0, "e");
    (19603, 0, "t");
    (19604, 0, "u");
    (19605, 0, "r");
    (19600, 6, "R");
    (19601, 0, "e");
    (19602, 0, "t");
    (19603, 0, "u");
    (19604, 0, "r");
    (19605, 0, "n");
    (19606, 0, "s");
    (19607, 0, " ");
    (19608, 0, "c");
    (19609, 0, "u");
    (19610, 0, "r");
    (19611, 0, "s");
    (19612, 0, "o");
    (19613, 0, "r");
    (19614, 0, ",");
    (19615, 0, " ");
    (19608, 0, "(");
    (19617, 0, "l");
    (19618, 0, "e");
    (19619, 0, "n");
    (19620, 0, "g");
    (19621, 0, "t");
    (19622, 0, "h");
    (19617, 6, "o");
    (19618, 0, "f");
    (19619, 0, "f");
    (19620, 0, "s");
    (19621, 0, "e");
    (19622, 0, "t");
    (19623, 0, " ");
    (19624, 0, "i");
    (19625, 0, "n");
    (19626, 0, "t");
    (19627, 0, "o");
    (19628, 0, " ");
    (19629, 0, "t");
    (19630, 0, "h");
    (19631, 0, "e");
    (19632, 0, " ");
    (19633, 0, "c");
    (19634, 0, "u");
    (19635, 0, "r");
    (19636, 0, "r");
    (19637, 0, "e");
    (19638, 0, "n");
    (19639, 0, "t");
    (19640, 0, " ");
    (19641, 0, "i");
    (19642, 0, "t");
    (19643, 0, "e");
    (19644, 0, "m");
    (19645, 0, ")");
    (19633, 7, "");
    (19632, 1, "");
    (19632, 0, " ");
    (19633, 0, "p");
    (19634, 0, "o");
    (19635, 0, "i");
    (19636, 0, "n");
    (19637, 0, "t");
    (19638, 0, "e");
    (19639, 0, "d");
    (19633, 7, "i");
    (19633, 1, "");
    (19632, 1, "");
    (19632, 0, " ");
    (19633, 0, "s");
    (19634, 0, "p");
    (19635, 0, "e");
    (19636, 0, "c");
    (19637, 0, "i");
    (19638, 0, "f");
    (19639, 0, "i");
    (19640, 0, "e");
    (19641, 0, "d");
    (19648, 0, ".");
    (21345, 0, "\n        ");
    (21354, 0, "\n        ");
    (21346, 8, "");
    (21355, 0, "/");
    (21356, 0, "/");
    (21357, 0, " ");
    (21358, 0, "W");
    (21359, 0, "e");
    (21360, 0, "'");
    (21361, 0, "v");
    (21362, 0, "e");
    (21363, 0, " ");
    (21364, 0, "f");
    (21365, 0, "o");
    (21366, 0, "u");
    (21367, 0, "n");
    (21368, 0, "d");
    (21369, 0, " ");
    (21370, 0, "t");
    (21371, 0, "h");
    (21372, 0, "e");
    (21373, 0, " ");
    (21374, 0, "n");
    (21375, 0, "o");
    (21376, 0, "d");
    (21377, 0, "e");
    (21378, 0, ".");
    (21379, 0, " ");
    (21380, 0, "N");
    (21381, 0, "o");
    (21382, 0, "w");
    (21383, 0, " ");
    (21384, 0, "w");
    (21385, 0, "e");
    (21386, 0, " ");
    (21387, 0, "n");
    (21388, 0, "e");
    (21389, 0, "e");
    (21390, 0, "d");
    (21391, 0, " ");
    (21392, 0, "t");
    (21393, 0, "o");
    (21394, 0, " ");
    (21395, 0, "f");
    (21396, 0, "i");
    (21397, 0, "n");
    (21398, 0, "d");
    (21399, 0, " ");
    (21400, 0, "t");
    (21401, 0, "h");
    (21402, 0, "e");
    (21403, 0, " ");
    (21404, 0, "l");
    (21405, 0, "o");
    (21406, 0, "c");
    (21407, 0, "a");
    (21408, 0, "t");
    (21409, 0, "i");
    (21410, 0, "o");
    (21411, 0, " ");
    (21412, 0, "n");
    (21413, 0, "w");
    (21414, 0, "i");
    (21415, 0, "t");
    (21416, 0, "h");
    (21417, 0, "i");
    (21418, 0, "n");
    (21384, 35, "l");
    (21385, 0, "o");
    (21386, 0, "o");
    (21387, 0, "k");
    (21388, 0, " ");
    (21389, 0, "f");
    (21390, 0, "o");
    (21391, 0, "r");
    (21392, 0, " ");
    (21393, 0, "t");
    (21394, 0, "h");
    (21395, 0, "e");
    (21396, 0, " ");
    (21397, 0, "i");
    (21398, 0, "n");
    (21399, 0, "d");
    (21400, 0, "e");
    (21401, 0, "x");
    (21402, 0, " ");
    (21403, 0, "w");
    (21404, 0, "i");
    (21405, 0, "t");
    (21406, 0, "h");
    (21407, 0, "i");
    (21408, 0, "n");
    (21409, 0, " ");
    (21410, 0, "t");
    (21411, 0, "h");
    (21412, 0, "e");
    (21413, 0, " ");
    (21414, 0, "n");
    (21415, 0, "o");
    (21416, 0, "d");
    (21417, 0, "e");
    (21418, 0, ".");
    (10048, 966, "");
    (10047, 1, "");
    (20452, 0, "\n        ");
    ( 20461,
      0,
      "\n\
      \    /// I dunno where this logic should live, but we want to get the \
       index of\n\
      \    /// the item at the specified offset into the node (and the offset \
       into the\n\
      \    /// item).\n\
      \    /// \n\
      \    /// If the offset lands between items, we could return either the \
       previous or next item.\n\
      \    /// \n\
      \    /// Returns (index, item_offset).\n\
      \    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) \
       -> (usize, usize) {\n\
      \        if usersize_offset == 0 { return (0, 0); }\n\n\
      \        for (i, item) in self.content_slice().iter().enumerate() {\n\
      \            let usersize = C::get_usersize(item);\n\
      \            if usersize > usersize_offset {\n\
      \                return (i, usersize_offset);\n\
      \            } else if usersize == usersize_offset {\n\
      \                return if stick_end { (i, usersize_offset) } else { \
       (i+1, 0) }\n\
      \            } else {\n\
      \                usersize_offset -= usersize;\n\
      \            }\n\
      \        }\n\
      \        panic!(\"Could not find requested offset within the node\");\n\
      \    }" );
    (20453, 8, "");
    (20453, 323, "");
    (20453, 92, "");
    (20999, 5, "");
    (20998, 1, "");
    (20932, 66, "");
    (20931, 1, "");
    (20931, 0, "\n        ");
    (20931, 9, "");
    (20931, 0, "\n");
    ( 20932,
      0,
      "        panic!(\"Could not find requested offset within the node\");" );
    (20998, 0, "\n");
    (20999, 0, "    }");
    ( 20453,
      0,
      "    fn get_iter_idx(&self, mut usersize_offset: usize, stick_end: bool) \
       -> (usize, usize) {\n" );
    (20457, 0, "// ");
    (20453, 0, "    ");
    (21098, 5, "");
    (21097, 1, "");
    (21039, 0, "// ");
    (20629, 4, "c");
    (20630, 0, "u");
    (20631, 0, "r");
    (20632, 0, "s");
    (20633, 0, "o");
    (20634, 0, "r");
    (20629, 6, "self");
    (20560, 0, "// ");
    (20560, 3, "");
    (20551, 0, "\n            ");
    (20560, 4, "");
    (20560, 0, "l");
    (20561, 0, "e");
    (20562, 0, "t");
    (20563, 0, " ");
    (20564, 0, "e");
    (20565, 0, " ");
    (20566, 0, "=");
    (20567, 0, " ");
    (20560, 8, "");
    (20572, 15, "o");
    (20573, 0, "f");
    (20574, 0, "f");
    (20575, 0, "s");
    (20576, 0, "e");
    (20577, 0, "t");
    (20552, 8, "");
    (20551, 1, "");
    (20585, 1, "");
    (20585, 0, "c");
    (20586, 0, "r");
    (20586, 1, "");
    (20586, 0, "u");
    (20587, 0, "r");
    (20588, 0, "s");
    (20589, 0, "o");
    (20590, 0, "r");
    (19538, 0, "\n            ");
    (19551, 0, "i");
    (19552, 0, "n");
    (19553, 0, "d");
    (19551, 3, "");
    (19551, 0, "l");
    (19552, 0, "o");
    (19553, 0, "c");
    (19554, 0, "a");
    (19555, 0, "l");
    (19556, 0, "_");
    (19557, 0, "i");
    (19558, 0, "n");
    (19559, 0, "d");
    (19560, 0, "e");
    (19561, 0, "x");
    (19562, 0, ":");
    (19563, 0, " ");
    (19564, 0, "0");
    (19565, 0, ",");
    (20653, 4, "");
    (20653, 0, "(");
    (20654, 0, "*");
    (20655, 0, "e");
    (20656, 0, ")");
    (20771, 15, "o");
    (20772, 0, "f");
    (20773, 0, "f");
    (20774, 0, "s");
    (20775, 0, "e");
    (20776, 0, "t");
    (20779, 0, "\n                ");
    (20796, 0, "c");
    (20797, 0, "u");
    (20798, 0, "r");
    (20799, 0, "s");
    (20800, 0, "o");
    (20801, 0, "r");
    (20802, 0, ".");
    (20803, 0, "l");
    (20804, 0, "o");
    (20805, 0, "c");
    (20806, 0, "a");
    (20807, 0, "l");
    (20803, 5, "local_index");
    (20814, 0, " ");
    (20815, 0, " ");
    (20815, 1, "");
    (20815, 0, "=");
    (20816, 0, " ");
    (20817, 0, "i");
    (20818, 0, ";");
    (20836, 28, "b");
    (20836, 1, "return (i, usersize_offset);");
    (20977, 18, "");
    (20940, 13, "");
    (20770, 0, "=");
    (20866, 100, "");
    (20837, 28, "b");
    (20838, 0, "r");
    (20839, 0, "e");
    (20840, 0, "a");
    (20841, 0, "k");
    (20842, 0, ";");
    (20627, 0, "\n        ");
    (20636, 0, "l");
    (20637, 0, "e");
    (20638, 0, "t");
    (20639, 0, " ");
    (20640, 0, "m");
    (20641, 0, "u");
    (20642, 0, "t");
    (20643, 0, " ");
    (20644, 0, "f");
    (20645, 0, "o");
    (20646, 0, "u");
    (20647, 0, "n");
    (20648, 0, "d");
    (20649, 0, " ");
    (20650, 0, "=");
    (20651, 0, " ");
    (20652, 0, "f");
    (20653, 0, "a");
    (20654, 0, "l");
    (20655, 0, "s");
    (20656, 0, "e");
    (20657, 0, ";");
    (20851, 0, "\n                ");
    (20868, 0, "f");
    (20869, 0, "o");
    (20870, 0, "u");
    (20871, 0, "n");
    (20872, 0, "d");
    (20873, 0, " ");
    (20874, 0, "=");
    (20875, 0, " ");
    (20876, 0, "t");
    (20877, 0, "r");
    (20878, 0, "u");
    (20879, 0, "e");
    (20880, 0, ";");
    (20994, 0, "\n        ");
    (21003, 0, "a");
    (21004, 0, "s");
    (21005, 0, "s");
    (21006, 0, "e");
    (21007, 0, "r");
    (21008, 0, "t");
    (21009, 0, "!");
    (21010, 0, "(");
    (21011, 0, "f");
    (21012, 0, "o");
    (21013, 0, "u");
    (21014, 0, "n");
    (21015, 0, "d");
    (21016, 0, ")");
    (21017, 0, ";");
    (20994, 0, "\n        ");
    (21027, 0, "\n        ");
    (20995, 8, "");
    (21020, 8, "");
    (20942, 15, "o");
    (20943, 0, "f");
    (20944, 0, "f");
    (20945, 0, "s");
    (20946, 0, "e");
    (20947, 0, "t");
    (21238, 0, "(");
    (21245, 0, ",");
    (21246, 0, " ");
    (21247, 0, "o");
    (21248, 0, "f");
    (21249, 0, "f");
    (21250, 0, "s");
    (21251, 0, "e");
    (21252, 0, "t");
    (21253, 0, ")");
    (37472, 0, "(");
    (37479, 0, ",");
    (37480, 0, " ");
    (37481, 0, "o");
    (37482, 0, "f");
    (37483, 0, "f");
    (37484, 0, "s");
    (37485, 0, "e");
    (37486, 0, "t");
    (37487, 0, ")");
    (37468, 4, "");
    (37469, 0, "m");
    (37470, 0, "u");
    (37471, 0, "t");
    (37472, 0, " ");
    (37522, 115, "");
    (37636, 7, "");
    (30233, 21, "");
    (30313, 0, "\n        ");
    (30322, 0, ", mut item_idx: usize");
    (30322, 1, "l");
    (30323, 0, "e");
    (30324, 0, "t");
    (30338, 7, " ");
    (30339, 0, "=");
    (30340, 0, " ");
    (30341, 0, "c");
    (30342, 0, "u");
    (30343, 0, "r");
    (30344, 0, "s");
    (30345, 0, "o");
    (30346, 0, "r");
    (30347, 0, ".");
    (30348, 0, ".");
    (30349, 0, "l");
    (30349, 1, "");
    (30348, 1, "");
    (30348, 0, "l");
    (30349, 0, "o");
    (30350, 0, "c");
    (30351, 0, "a");
    (30352, 0, "l");
    (30348, 5, "local_index");
    (30359, 0, ";");
    (36635, 44, "(mut cursor, offset) = self.iter_at_userpos(userpos);");
    (36635, 0, " ");
    (36690, 115, "");
    (36806, 7, "");
    (24277, 19, "");
    (24276, 1, "");
    (24275, 1, "");
    (24383, 0, "\n        ");
    (24392, 0, "l");
    (24393, 0, "e");
    (24394, 0, " ");
    (24394, 1, "");
    (24394, 0, "t");
    (24395, 0, " ");
    (24396, 0, "mut item_idx: usize");
    (24408, 7, " ");
    (24409, 0, "=");
    (24410, 0, " ");
    (24411, 0, "c");
    (24412, 0, "u");
    (24413, 0, "r");
    (24414, 0, "s");
    (24415, 0, "o");
    (24416, 0, "r");
    (24417, 0, ".");
    (24418, 0, "l");
    (24419, 0, "o");
    (24420, 0, "c");
    (24421, 0, "a");
    (24418, 4, "local_index");
    (24429, 0, ";");
    (24430, 0, "\n        ");
    (24431, 8, "");
    (13610, 0, "\n            ");
    (13623, 0, "s");
    (13624, 0, "e");
    (13625, 0, "l");
    (13626, 0, "f");
    (13627, 0, ".");
    (13628, 0, "l");
    (13629, 0, "o");
    (13630, 0, "c");
    (13631, 0, "a");
    (13632, 0, "l");
    (13628, 5, "local_index");
    (13639, 0, " ");
    (13640, 0, "=");
    (13641, 0, " ");
    (13642, 0, "0");
    (13643, 0, ";");
    (24426, 0, "// ");
    (24599, 8, "cursor.local_index");
    (25112, 8, "cursor.local_index");
    (25642, 33, "");
    (25641, 1, "");
    (25798, 0, "\n        ");
    (25807, 0, "let mut item_idx = cursor.local_index;");
    (25810, 4, "");
    (24417, 50, "");
    (13898, 0, "\n        ");
    (13907, 0, "/");
    (13908, 0, "/");
    (13909, 0, " ");
    (13910, 0, "N");
    (13911, 0, "o");
    (13912, 0, "t");
    (13913, 0, "e");
    (13899, 15, "");
    (13898, 1, "");
    (13857, 0, "\n    ");
    (13862, 0, "/");
    (13863, 0, "/");
    (13864, 0, "/");
    (13865, 0, " ");
    (13866, 0, "W");
    (13867, 0, "a");
    (13868, 0, "r");
    (13869, 0, "n");
    (13870, 0, "i");
    (13871, 0, "n");
    (13872, 0, "g");
    (13873, 0, ":");
    (13874, 0, " ");
    (13875, 0, "T");
    (13876, 0, "h");
    (13877, 0, "i");
    (13878, 0, "s");
    (13879, 0, " ");
    (13880, 0, "r");
    (13881, 0, "e");
    (13882, 0, "t");
    (13883, 0, "u");
    (13884, 0, "r");
    (13885, 0, "n");
    (13886, 0, "s");
    (13887, 0, " ");
    (13888, 0, "f");
    (13889, 0, "a");
    (13890, 0, "l");
    (13891, 0, "s");
    (13892, 0, "e");
    (13893, 0, " ");
    (13894, 0, "i");
    (13895, 0, "f");
    (13896, 0, " ");
    (13897, 0, "o");
    (13898, 0, "n");
    (13899, 0, "e");
    (13900, 0, " ");
    (13901, 0, "c");
    (13902, 0, "u");
    (13903, 0, "r");
    (13904, 0, "s");
    (13905, 0, "o");
    (13906, 0, "r");
    (13907, 0, " ");
    (13908, 0, "i");
    (13909, 0, "s");
    (13910, 0, " ");
    (13911, 0, "a");
    (13912, 0, "t");
    (13913, 0, " ");
    (13914, 0, "t");
    (13915, 0, "h");
    (13916, 0, "e");
    (13917, 0, "e");
    (13918, 0, " ");
    (13918, 1, "");
    (13917, 1, "");
    (13917, 0, " ");
    (13918, 0, "e");
    (13919, 0, "n");
    (13920, 0, "d");
    (13921, 0, " ");
    (13922, 0, "f");
    (13922, 1, "");
    (13922, 0, "o");
    (13923, 0, "f");
    (13924, 0, " ");
    (13925, 0, "a");
    (13926, 0, " ");
    (13927, 0, "n");
    (13928, 0, "o");
    (13929, 0, "d");
    (13930, 0, "e");
    (13931, 0, ",");
    (13932, 0, " ");
    (13933, 0, "a");
    (13934, 0, "n");
    (13935, 0, "d");
    (13936, 0, " ");
    (13937, 0, "t");
    (13938, 0, "h");
    (13939, 0, "e");
    (13940, 0, " ");
    (13941, 0, "o");
    (13942, 0, "t");
    (13943, 0, "h");
    (13944, 0, "e");
    (13945, 0, "r");
    (13946, 0, " ");
    (13947, 0, "a");
    (13948, 0, "t");
    (13949, 0, " ");
    (13950, 0, "t");
    (13951, 0, "h");
    (13952, 0, "e");
    (13953, 0, " ");
    (13954, 0, "s");
    (13955, 0, "t");
    (13956, 0, "a");
    (13957, 0, "r");
    (13958, 0, "t");
    (13959, 0, " ");
    (13960, 0, "o");
    (13961, 0, "f");
    (13962, 0, " ");
    (13963, 0, "t");
    (13964, 0, "h");
    (13965, 0, "e");
    (13966, 0, " ");
    (13967, 0, "n");
    (13968, 0, "e");
    (13969, 0, "x");
    (13970, 0, "t");
    (13971, 0, " ");
    (13972, 0, "n");
    (13973, 0, "o");
    (13974, 0, "d");
    (13975, 0, "e");
    (13976, 0, ".");
    (13977, 0, " ");
    (13978, 0, "A");
    (13979, 0, "l");
    (13980, 0, "m");
    (13981, 0, "o");
    (13982, 0, "s");
    (13983, 0, "t");
    (13984, 0, " ");
    (13985, 0, "a");
    (13986, 0, "l");
    (13987, 0, "l");
    (13988, 0, " ");
    (13989, 0, "c");
    (13990, 0, "o");
    (13991, 0, "d");
    (13992, 0, "e");
    (13993, 0, " ");
    (13994, 0, "b");
    (13995, 0, "e");
    (13995, 1, "");
    (13995, 0, "i");
    (13995, 1, "");
    (13994, 1, "");
    (13994, 0, "i");
    (13995, 0, "n");
    (13996, 0, " ");
    (13997, 0, "t");
    (13998, 0, "h");
    (13999, 0, "i");
    (14000, 0, "s");
    (14001, 0, " ");
    (14002, 0, "l");
    (14003, 0, "i");
    (14004, 0, "b");
    (14005, 0, "r");
    (14006, 0, "a");
    (14007, 0, "r");
    (14008, 0, "y");
    (14009, 0, " ");
    (14010, 0, "l");
    (14011, 0, "e");
    (14012, 0, "a");
    (14013, 0, "v");
    (14014, 0, "e");
    (14015, 0, "s");
    (14016, 0, " ");
    (14017, 0, "c");
    (14018, 0, "u");
    (14019, 0, "r");
    (14020, 0, "s");
    (14021, 0, "o");
    (14022, 0, "r");
    (14023, 0, "s");
    (14024, 0, " ");
    (14025, 0, "a");
    (14026, 0, "t");
    (14027, 0, " ");
    (14028, 0, "t");
    (14029, 0, "h");
    (14030, 0, "e");
    (14031, 0, "e");
    (14032, 0, "n");
    (14032, 1, "");
    (14031, 1, "");
    (14031, 0, " ");
    (14032, 0, "e");
    (14033, 0, "n");
    (14034, 0, "d");
    (14035, 0, " ");
    (14036, 0, "o");
    (14037, 0, "f");
    (14038, 0, " ");
    (14039, 0, "n");
    (14040, 0, "o");
    (14041, 0, "d");
    (14042, 0, "e");
    (14043, 0, "s");
    (14044, 0, ",");
    (14045, 0, " ");
    (14046, 0, "s");
    (14047, 0, "o");
    (14048, 0, " ");
    (14049, 0, "t");
    (14050, 0, "h");
    (14051, 0, "i");
    (14052, 0, "s");
    (14053, 0, " ");
    (14054, 0, "s");
    (14055, 0, "h");
    (14056, 0, "o");
    (14057, 0, "u");
    (14058, 0, "l");
    (14059, 0, "d");
    (14060, 0, "n");
    (14061, 0, "'");
    (14062, 0, "t");
    (14063, 0, " ");
    (14064, 0, "m");
    (14065, 0, "a");
    (14066, 0, "t");
    (14067, 0, "t");
    (14068, 0, "e");
    (14069, 0, "r");
    (14070, 0, " ");
    (14071, 0, "o");
    (14071, 1, "");
    (14071, 0, "t");
    (14072, 0, "o");
    (14073, 0, "o");
    (14074, 0, " ");
    (14075, 0, "m");
    (14076, 0, "u");
    (14077, 0, "c");
    (14078, 0, "h");
    (14079, 0, " ");
    (14080, 0, "i");
    (14081, 0, "n");
    (14082, 0, " ");
    (14083, 0, "p");
    (14084, 0, "r");
    (14085, 0, "a");
    (14086, 0, "c");
    (14087, 0, "t");
    (14088, 0, "i");
    (14089, 0, "c");
    (14090, 0, "e");
    (14091, 0, " ");
    (14092, 0, "n");
    (14093, 0, "b");
    (14094, 0, "u");
    (14094, 1, "");
    (14093, 1, "");
    (14092, 1, "");
    (14091, 1, "");
    (14091, 0, ".");
    ( 13858,
      234,
      "    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice." );
    (14158, 0, "        if self.userpos != other.userpos { return false; }\n");
    (14158, 59, "");
    (14198, 0, " ");
    (14199, 0, "|");
    (14200, 0, "|");
    (14201, 0, " ");
    (14202, 0, "s");
    (14203, 0, "e");
    (14204, 0, "l");
    (14205, 0, "f");
    (14206, 0, ".");
    (14207, 0, "l");
    (14208, 0, "o");
    (14209, 0, "c");
    (14210, 0, "a");
    (14211, 0, "l");
    (14207, 5, "local_index");
    (14218, 0, " ");
    (14219, 0, "!");
    (14220, 0, "=");
    (14221, 0, " ");
    (14222, 0, "s");
    (14223, 0, "e");
    (14223, 1, "");
    (14222, 1, "");
    (14222, 0, "o");
    (14223, 0, "t");
    (14224, 0, "h");
    (14225, 0, "e");
    (14226, 0, "r");
    (14227, 0, ".");
    (14228, 0, "u");
    (14229, 0, "s");
    (14230, 0, "e");
    (14231, 0, "r");
    (14231, 1, "");
    (14230, 1, "");
    (14229, 1, "");
    (14228, 1, "");
    (14228, 0, "l");
    (14229, 0, "c");
    (14230, 0, "a");
    (14228, 3, "local_index");
    (14198, 1, "");
    (14198, 0, "\n        ");
    (14207, 0, "    ");
    (14253, 1, "");
    (14253, 0, "\n                ");
    (14253, 17, "");
    (14268, 0, "\n            ");
    (14269, 12, "");
    (14199, 12, "        ");
    (14199, 8, "            ");
    (33923, 0, "(");
    (33934, 0, ",");
    (33935, 0, " ");
    (33936, 0, "o");
    (33937, 0, "f");
    (33938, 0, "f");
    (33939, 0, "s");
    (33940, 0, "e");
    (33941, 0, "t");
    (33942, 0, ")");
    (33991, 0, "// ");
    (34508, 0, "c");
    (34509, 0, "u");
    (34510, 0, "r");
    (34511, 0, "s");
    (34512, 0, "o");
    (34513, 0, "r");
    (34514, 0, ".");
    (34515, 0, "l");
    (34516, 0, "o");
    (34517, 0, "c");
    (34518, 0, "a");
    (34515, 4, "local_index");
    (34526, 5, "");
    (34739, 30, "");
    (34738, 1, "");
    (34756, 0, "\n                ");
    (34773, 0, "\n                ");
    (34757, 16, "");
    (34774, 0, "l");
    (34775, 0, "e");
    (34776, 0, "t");
    (34777, 0, " ");
    (34778, 0, "i");
    (34779, 0, "n");
    (34780, 0, "d");
    (34781, 0, "e");
    (34782, 0, "x");
    (34783, 0, " ");
    (34784, 0, "=");
    (34785, 0, " ");
    (34786, 0, "c");
    (34787, 0, "u");
    (34788, 0, "r");
    (34789, 0, "s");
    (34790, 0, "o");
    (34791, 0, "r");
    (34792, 0, ".");
    (34793, 0, "l");
    (34793, 1, "local_index");
    (34804, 0, ";");
    (36404, 7, "");
    (36511, 7, "");
    (35851, 0, "c");
    (35852, 0, "r");
    (35852, 1, "");
    (35852, 0, "u");
    (35853, 0, "r");
    (35854, 0, "s");
    (35855, 0, "o");
    (35856, 0, "r");
    (35857, 0, ".");
    (35858, 0, "l");
    (35859, 0, "o");
    (35860, 0, "c");
    (35861, 0, "a");
    (35862, 0, "l");
    (35863, 0, "_");
    (37271, 0, "(");
    (37274, 0, ",");
    (37275, 0, " ");
    (37276, 0, "_");
    (37277, 0, ")");
    (21030, 1, "");
    (21030, 0, "u");
    (21031, 0, "n");
    (21032, 0, "s");
    (21033, 0, "a");
    (21034, 0, "f");
    (21035, 0, "e");
    (21036, 0, " ");
    (21037, 0, "{");
    (21040, 1, "");
    (21040, 0, "}");
    (21038, 0, "&");
    (21038, 0, " ");
    (21042, 0, " ");
    (27383, 0, "\n            ");
    (27396, 0, "c");
    (27397, 0, "u");
    (27398, 0, "r");
    (27399, 0, "s");
    (27400, 0, "o");
    (27401, 0, "r");
    (27402, 0, ".");
    (27403, 0, "l");
    (27404, 0, "o");
    (27405, 0, "c");
    (27406, 0, "a");
    (27407, 0, "l");
    (27403, 5, "local_index");
    (27414, 0, " ");
    (27415, 0, "+");
    (27416, 0, "=");
    (27417, 0, " ");
    (27418, 0, "n");
    (27419, 0, "u");
    (27420, 0, "m");
    (27421, 0, "_");
    (27422, 0, "i");
    (27423, 0, "n");
    (27418, 6, "num_inserted_items");
    (27436, 0, ";");
    (24551, 0, "\n            ");
    (24564, 0, "c");
    (24565, 0, "u");
    (24566, 0, "r");
    (24567, 0, "s");
    (24568, 0, "o");
    (24569, 0, "r");
    (24570, 0, ".");
    (24571, 0, "l");
    (24572, 0, "o");
    (24573, 0, "c");
    (24574, 0, "a");
    (24571, 4, "local_index");
    (24582, 0, " ");
    (24583, 0, "=");
    (24584, 0, " ");
    (24585, 0, " += contents.len();");
    (24588, 1, "");
    (24587, 1, "");
    (24586, 1, "");
    (24585, 1, "");
    (21157, 1, "");
    (21259, 0, "\n                ");
    (21260, 16, "            }");
    (21273, 0, " ");
    (21274, 0, "if usersize > offset {");
    (21274, 0, "e");
    (21275, 0, "l");
    (21276, 0, "s");
    (21277, 0, "e");
    (21278, 0, " ");
    (21291, 1, "");
    (21291, 0, "=");
    (21292, 0, "=");
    (21302, 0, "\n                ");
    ( 21319,
      0,
      "                cursor.local_index = i;\n\
      \                found = true;\n\
      \                break;" );
    (21303, 32, "                ");
    (21341, 0, "+");
    (21342, 0, "1");
    (21454, 0, "\n                offset -= usersize;");
    (21454, 0, "\n            } else {");
    (21398, 21, "");
    (21433, 0, "\n                break;");
    (21375, 23, "");
    (21410, 0, "\n                found = true;");
    (21345, 30, "");
    (21380, 0, "\n                cursor.local_index = i+1;");
    (21303, 42, "");
    (21326, 1, "");
    (21328, 8, "0");
    (21369, 0, " ");
    (21371, 0, " ");
    ( 21005,
      0,
      "        for (i, item) in unsafe { &*e \
       }.content_slice().iter().enumerate() {\n\
      \            let usersize = C::get_usersize(item);\n\
      \            if usersize > offset {\n\
      \                cursor.local_index = i;\n\
      \                found = true;\n\
      \                break;\n\
      \            } else if usersize == offset {\n\
      \                offset = 0;\n\
      \                cursor.local_index = i + 1;\n\
      \                found = true;\n\
      \                break;\n\
      \            } else {\n\
      \                offset -= usersize;\n\
      \            }\n\
      \        }\n" );
    (22011, 0, "// ");
    (21997, 0, "// ");
    (21961, 0, "// ");
    (21940, 0, "// ");
    (21917, 0, "// ");
    (21887, 0, "// ");
    (21843, 0, "// ");
    (21815, 0, "// ");
    (21772, 0, "// ");
    (21749, 0, "// ");
    (21719, 0, "// ");
    (21679, 0, "// ");
    (21644, 0, "// ");
    (21594, 0, "// ");
    (21517, 0, "// ");
    (20974, 30, "");
    (20973, 1, "");
    (20982, 66, "");
    (20982, 0, "w");
    (20983, 0, "h");
    (20984, 0, "i");
    (20985, 0, "l");
    (20986, 0, " ");
    (20986, 1, "");
    (20986, 0, "e");
    (20987, 0, " ");
    (20982, 6, "");
    (20982, 0, "l");
    (20983, 0, "e");
    (20984, 0, "t");
    (20984, 1, "");
    (20983, 1, "");
    (20982, 1, "");
    (20982, 0, "f");
    (20983, 0, "o");
    (20984, 0, "r");
    (20985, 0, " ");
    (20986, 0, "i");
    (20987, 0, "n");
    (20988, 0, "d");
    (20989, 0, "e");
    (20990, 0, "x");
    (20991, 0, " ");
    (20992, 0, "i");
    (20993, 0, "n");
    (20994, 0, " ");
    (20995, 0, "[");
    (20996, 0, "0");
    (20997, 0, ".");
    (20998, 0, ".");
    (20995, 1, "");
    (20998, 0, "=");
    (20973, 0, "\n        ");
    (20982, 0, "l");
    (20983, 0, "e");
    (20984, 0, "t");
    (20985, 0, " ");
    (20986, 0, "e");
    (20987, 0, "n");
    (20988, 0, " ");
    (20989, 0, "=");
    (20990, 0, " ");
    (20991, 0, "unsafe { &*e }");
    (21005, 0, ";");
    (21032, 0, "e");
    (21033, 0, "n");
    (21034, 0, ".");
    (21035, 0, "n");
    (21036, 0, "u");
    (21037, 0, "m");
    (21035, 3, "num_items");
    (21044, 0, " ");
    (21045, 0, "a");
    (21046, 0, "s");
    (21047, 0, " ");
    (21048, 0, "u");
    (21049, 0, "s");
    (21050, 0, "i");
    (21051, 0, "z");
    (21052, 0, "e");
    (21055, 0, "\n        for index in 0..=en.num_items as usize {");
    (21015, 0, "// ");
    (21067, 38, "w");
    (21068, 0, "h");
    (21069, 0, "i");
    (21070, 0, "l");
    (21071, 0, "e");
    (21072, 0, " ");
    (21073, 0, "o");
    (21074, 0, "f");
    (21075, 0, "f");
    (21076, 0, "s");
    (21077, 0, "e");
    (21078, 0, "t");
    (21079, 0, " ");
    (21080, 0, ">");
    (21081, 0, " ");
    (21082, 0, "0");
    (21058, 0, "\n            ");
    (21071, 0, "l");
    (21072, 0, "e");
    (21073, 0, "t");
    (21073, 1, "");
    (21072, 1, "");
    (21071, 1, "");
    (21067, 4, "");
    (21067, 0, "l");
    (21068, 0, "e");
    (21069, 0, "t");
    (21070, 0, " ");
    (21071, 0, "m");
    (21072, 0, "u");
    (21073, 0, "t");
    (21074, 0, " ");
    (21075, 0, "i");
    (21076, 0, "n");
    (21077, 0, "d");
    (21078, 0, "e");
    (21079, 0, "x");
    (21080, 0, " ");
    (21081, 0, "=");
    (21082, 0, " ");
    (21083, 0, "0");
    (21084, 0, ";");
    (21156, 4, "e");
    (21157, 0, "n");
    (21158, 0, ".");
    (21159, 0, "i");
    (21160, 0, "t");
    (21161, 0, "e");
    (21162, 0, "m");
    (21163, 0, "s");
    (21164, 0, "[");
    (21165, 0, "i");
    (21166, 0, "n");
    (21167, 0, "d");
    (21168, 0, "e");
    (21169, 0, "x");
    (21170, 0, "]");
    (21156, 0, "&");
    (21190, 17, "o");
    (21191, 0, "f");
    (21192, 0, "f");
    (21193, 0, "s");
    (21194, 0, "e");
    (21195, 0, "t");
    (21196, 0, " ");
    (21197, 0, "<");
    (21198, 0, "=");
    (21199, 0, " ");
    (21200, 0, "u");
    (21201, 0, "s");
    (21202, 0, "e");
    (21203, 0, "r");
    (21204, 0, "s");
    (21205, 0, "i");
    (21200, 6, "usersize");
    (21198, 1, "");
    (21197, 1, "");
    (21197, 0, ">");
    (21197, 1, "");
    (21197, 0, "<=");
    (21200, 8, "usersi");
    (21199, 7, "");
    (21196, 3, "");
    (21190, 6, "usersize > offset");
    (21174, 0, "\n            ");
    (21187, 0, "i");
    (21188, 0, "f");
    (21189, 0, " ");
    (21190, 0, "u");
    (21191, 0, "s");
    (21192, 0, "e");
    (21193, 0, "r");
    (21194, 0, "s");
    (21195, 0, "i");
    (21190, 6, "usersize");
    (21198, 0, " ");
    (21199, 0, "<");
    (21200, 0, "=");
    (21201, 0, " ");
    (21202, 0, "o");
    (21203, 0, "f");
    (21204, 0, "f");
    (21205, 0, "s");
    (21206, 0, "e");
    (21207, 0, "t");
    (21208, 0, " ");
    (21209, 0, "{");
    (21210, 0, "\n                ");
    (21227, 0, "o");
    (21228, 0, "f");
    (21229, 0, "f");
    (21230, 0, "s");
    (21231, 0, "e");
    (21232, 0, "t");
    (21233, 0, " ");
    (21234, 0, "-");
    (21235, 0, "=");
    (21236, 0, " ");
    (21237, 0, "u");
    (21238, 0, "s");
    (21239, 0, "e");
    (21240, 0, "r");
    (21241, 0, "z");
    (21242, 0, "i");
    (21237, 6, "usersize");
    (21245, 0, ";");
    (21246, 0, "\n                ");
    (21247, 16, "            }");
    (21260, 0, " ");
    (21261, 0, "e");
    (21262, 0, "l");
    (21263, 0, "s");
    (21264, 0, "e");
    (21265, 0, " ");
    (21266, 0, "{");
    (21267, 0, "\n                ");
    (21284, 0, "\n                ");
    (21268, 16, "");
    (21269, 16, "            }");
    (21268, 0, "                ");
    (21284, 0, "/");
    (21285, 0, "/");
    (21286, 0, " ");
    (21287, 0, "T");
    (21288, 0, "o");
    (21289, 0, "o");
    (21290, 0, " ");
    (21291, 0, "b");
    (21292, 0, "i");
    (21293, 0, "g");
    (21294, 0, "!");
    (21295, 0, " ");
    (21296, 0, "W");
    (21297, 0, "e");
    (21298, 0, "'");
    (21299, 0, "r");
    (21300, 0, "e");
    (21284, 17, "");
    (21284, 0, "b");
    (21285, 0, "r");
    (21286, 0, "e");
    (21287, 0, "a");
    (21288, 0, "k");
    (21289, 0, ";");
    (21305, 366, "");
    (21304, 1, "");
    (21112, 0, "\n            ");
    (21125, 0, "a");
    (21126, 0, "s");
    (21127, 0, "s");
    (21128, 0, "e");
    (21129, 0, "r");
    (21125, 5, "assert_eq!");
    (21134, 1, "");
    (21133, 1, "");
    (21132, 1, "");
    (21131, 1, "");
    (21131, 0, "!");
    (21132, 0, "(");
    (21133, 0, "i");
    (21134, 0, "n");
    (21135, 0, "d");
    (21136, 0, "e");
    (21137, 0, "x");
    (21138, 0, " ");
    (21139, 0, "<");
    (21140, 0, " ");
    (21141, 0, "e");
    (21142, 0, "n");
    (21143, 0, ".");
    (21144, 0, "i");
    (21145, 0, "t");
    (21146, 0, "e");
    (21147, 0, "m");
    (21148, 0, "s");
    (21149, 0, ".");
    (21144, 6, "n");
    (21145, 0, "u");
    (21146, 0, "m");
    (21147, 0, "_");
    (21148, 0, "i");
    (21149, 0, "t");
    (21144, 6, "num_items");
    (21153, 0, " ");
    (21154, 0, "a");
    (21155, 0, "s");
    (21156, 0, " ");
    (21157, 0, "u");
    (21158, 0, "s");
    (21159, 0, "i");
    (21160, 0, "z");
    (21161, 0, "e");
    (21162, 0, ")");
    (21163, 0, ";");
    (21164, 0, "\n            ");
    (21165, 12, "");
    (21153, 9, "");
    (21156, 0, "            ");
    (21153, 0, " as usize");
    (21007, 51, "");
    (21877, 1, "");
    (21886, 0, "// ");
    (21213, 2, ">");
    (21223, 0, " ");
    (21224, 0, "b");
    (21225, 0, "r");
    (21226, 0, "e");
    (21227, 0, "a");
    (21228, 0, "k");
    (21229, 0, ";");
    (21230, 0, " ");
    (21231, 0, "}");
    (21233, 16, "            ");
    (21265, 58, "");
    (21264, 0, "\n            ");
    (21277, 0, "i");
    (21278, 0, "n");
    (21279, 0, "d");
    (21280, 0, "e");
    (21281, 0, "x");
    (21282, 0, " ");
    (21283, 0, "+");
    (21284, 0, "=");
    (21285, 0, " ");
    (21286, 0, "1");
    (21287, 0, ";");
    (21232, 0, " ");
    (21232, 1, "");
    (21232, 0, " ");
    (21232, 1, "");
    (21232, 0, " ");
    (21233, 0, "/");
    (21234, 0, "/");
    (21235, 0, " ");
    (21236, 0, "F");
    (21236, 1, "");
    (21235, 1, "");
    (21234, 1, "");
    (21233, 1, "");
    (21232, 1, "");
    (21232, 0, " ");
    (21233, 0, "/");
    (21234, 0, "/");
    (21235, 0, " ");
    (21236, 0, "W");
    (21237, 0, "e");
    (21238, 0, "'");
    (21239, 0, "r");
    (21240, 0, "e");
    (21241, 0, " ");
    (21242, 0, "p");
    (21243, 0, "a");
    (21244, 0, "r");
    (21245, 0, "t");
    (21246, 0, "w");
    (21247, 0, "a");
    (21248, 0, "y");
    (21249, 0, " ");
    (21250, 0, "t");
    (21251, 0, "h");
    (21252, 0, "r");
    (21253, 0, "o");
    (21254, 0, "u");
    (21242, 13, "i");
    (21243, 0, "n");
    (21244, 0, " ");
    (21245, 0, "t");
    (21246, 0, "h");
    (21247, 0, "e");
    (21248, 0, " ");
    (21249, 0, "m");
    (21250, 0, "i");
    (21251, 0, "d");
    (21252, 0, "d");
    (21253, 0, "l");
    (21254, 0, "e");
    (21255, 0, " ");
    (21256, 0, "o");
    (21257, 0, "f");
    (21258, 0, " ");
    (21259, 0, "a");
    (21260, 0, "n");
    (21261, 0, " ");
    (21262, 0, "i");
    (21263, 0, "t");
    (21264, 0, "e");
    (21265, 0, "m");
    (21266, 0, ".");
    (21333, 0, "\n        ");
    (21342, 0, "c");
    (21343, 0, "u");
    (21344, 0, "r");
    (21345, 0, "s");
    (21346, 0, "o");
    (21347, 0, "r");
    (21348, 0, ".");
    (21349, 0, "i");
    (21350, 0, "n");
    (21351, 0, "d");
    (21352, 0, "e");
    (21353, 0, "x");
    (21354, 0, " ");
    (21354, 1, "");
    (21349, 5, "l");
    (21350, 0, "o");
    (21351, 0, "c");
    (21352, 0, "a");
    (21353, 0, "l");
    (21349, 5, "local_index");
    (21360, 0, " ");
    (21361, 0, "=");
    (21362, 0, " ");
    (21363, 0, "i");
    (21364, 0, "n");
    (21365, 0, "d");
    (21366, 0, "e");
    (21367, 0, "x");
    (21368, 0, ";");
    (21370, 575, "");
    (21369, 1, "");
    (21371, 69, "");
    (21370, 1, "");
    (21369, 1, "");
    (21371, 147, "");
    ( 20753,
      0,
      "        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n" );
    (20753, 8, "\n        ");
    (20975, 99, "");
    (20975, 47, "");
    (20974, 1, "");
    (21007, 1, "");
    (21034, 0, "\n        ");
    (21035, 8, "");
    (13678, 0, "\n    ");
    (13683, 0, "\n    ");
    (13679, 4, "");
    (13684, 0, "f");
    (13685, 0, "n");
    (13686, 0, " ");
    (13687, 0, "a");
    (13688, 0, "d");
    (13689, 0, "v");
    (13690, 0, "a");
    (13691, 0, "n");
    (13692, 0, "c");
    (13693, 0, "e");
    (13694, 0, "_");
    (13695, 0, "i");
    (13696, 0, "t");
    (13697, 0, "e");
    (13698, 0, "m");
    (13699, 0, "(");
    (13700, 0, "*");
    (13700, 1, "");
    (13700, 0, "&");
    (13701, 0, "m");
    (13702, 0, "u");
    (13703, 0, "t");
    (13704, 0, " ");
    (13705, 0, "s");
    (13706, 0, "e");
    (13707, 0, "l");
    (13708, 0, "f");
    (13709, 0, ")");
    (13710, 0, " ");
    (13711, 0, "{");
    (13712, 0, "\n        ");
    (13721, 0, "\n        ");
    (13713, 8, "");
    (13714, 8, "    }");
    (13713, 0, "        ");
    (13721, 0, "if cursor.local_index == (*e).num_items as usize {");
    (13721, 0, "// ");
    (13678, 0, "\n    ");
    (13683, 0, "\n    ");
    (13679, 4, "");
    (13684, 0, "f");
    (13685, 0, "n");
    (13686, 0, " ");
    (13687, 0, "i");
    (13688, 0, "s");
    (13689, 0, "_");
    (13690, 0, "a");
    (13691, 0, "t");
    (13692, 0, "_");
    (13693, 0, "n");
    (13694, 0, "o");
    (13695, 0, "d");
    (13696, 0, "e");
    (13697, 0, "_");
    (13698, 0, "e");
    (13699, 0, "n");
    (13700, 0, "d");
    (13701, 0, "(");
    (13702, 0, "&");
    (13703, 0, "s");
    (13704, 0, "e");
    (13705, 0, "l");
    (13706, 0, "f");
    (13707, 0, ")");
    (13708, 0, " ");
    (13709, 0, "-");
    (13710, 0, ">");
    (13711, 0, " ");
    (13712, 0, "b");
    (13713, 0, "o");
    (13714, 0, "o");
    (13715, 0, "l");
    (13716, 0, " ");
    (13717, 0, "{");
    (13718, 0, "\n        ");
    (13727, 0, "\n        ");
    (13719, 8, "");
    (13720, 8, "    }");
    (13719, 0, "if cursor.local_index == (*e).num_items as usize {");
    (13719, 0, "        ");
    (13727, 2, "");
    (13727, 1, "");
    (13727, 6, "s");
    (13728, 0, "e");
    (13729, 0, "l");
    (13730, 0, "f");
    (13749, 1, "");
    (13749, 0, "self.entries[0].node");
    (13790, 1, "");
    (13789, 1, "");
    (13747, 0, "n");
    (13747, 1, "");
    (13747, 0, "u");
    (13748, 0, "n");
    (13749, 0, "s");
    (13750, 0, "a");
    (13751, 0, "f");
    (13752, 0, "e");
    (13753, 0, " ");
    (13754, 0, "{");
    (13755, 0, " ");
    (13756, 1, "");
    (13756, 0, "(");
    (13789, 0, " ");
    (13790, 0, "}");
    (13840, 0, "\n        ");
    (13849, 0, "i");
    (13850, 0, "f");
    (13851, 0, " ");
    (13852, 0, "s");
    (13853, 0, "e");
    (13854, 0, "l");
    (13855, 0, "f");
    (13856, 0, ".");
    (13857, 0, "i");
    (13858, 0, "s");
    (13859, 0, "_");
    (13857, 3, "is_at_node_end()");
    (13873, 0, " ");
    (13874, 0, "{");
    (13875, 0, " ");
    (13876, 0, "a");
    (13877, 0, "d");
    (13878, 0, "v");
    (13879, 0, "a");
    (13876, 4, "advance_by");
    (13885, 1, "");
    (13884, 1, "");
    (13883, 1, "");
    (13876, 7, "advance_node");
    (13888, 0, "(");
    (13889, 0, ")");
    (13890, 0, ";");
    (13891, 0, " ");
    (13892, 0, "}");
    (13893, 0, "\n        ");
    (13894, 8, "");
    (13876, 0, "s");
    (13877, 0, "e");
    (13878, 0, "l");
    (13879, 0, "f");
    (13880, 0, ".");
    (13849, 2, "s");
    (13849, 1, "");
    (13849, 0, "w");
    (13850, 0, "h");
    (13851, 0, "i");
    (13852, 0, "l");
    (13853, 0, "e");
    (13902, 0, "        ");
    ( 17086,
      0,
      "                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n" );
    (13902, 8, "");
    (17179, 26, ">");
    (17180, 0, " ");
    (17181, 0, "0");
    (17184, 0, " ");
    (17185, 0, "/");
    (17186, 0, "/");
    (17187, 0, " ");
    (17188, 0, "e");
    (17189, 0, "m");
    (17190, 0, "p");
    (17191, 0, "t");
    (17192, 0, "y");
    (17193, 0, " ");
    (17194, 0, "n");
    (17195, 0, "o");
    (17196, 0, "d");
    (17197, 0, "d");
    (17198, 0, "e");
    (17199, 0, "s");
    (17184, 16, "");
    (17182, 0, ",");
    (17183, 0, " ");
    (17184, 0, "\"");
    (17185, 0, "E");
    (17186, 0, "m");
    (17187, 0, "p");
    (17188, 0, "t");
    (17189, 0, "y");
    (17190, 0, " ");
    (17191, 0, "n");
    (17192, 0, "o");
    (17193, 0, "t");
    (17193, 1, "");
    (17193, 0, "d");
    (17194, 0, "e");
    (17195, 0, "s");
    (17196, 0, " ");
    (17197, 0, "n");
    (17198, 0, "o");
    (17199, 0, "t");
    (17200, 0, " ");
    (17201, 0, "a");
    (17202, 0, "l");
    (17203, 0, "l");
    (17204, 0, "o");
    (17205, 0, "w");
    (17206, 0, "e");
    (17207, 0, "d");
    (17208, 0, "\"");
    (13849, 5, "i");
    (13850, 0, "f");
    (13898, 0, "\n        ");
    (13907, 0, "/");
    (13908, 0, "/");
    (13909, 0, " ");
    (13910, 0, "T");
    (13911, 0, "e");
    (13912, 0, "h");
    (13913, 0, " ");
    (13914, 0, "n");
    (13915, 0, "o");
    (13916, 0, "d");
    (13917, 0, "e");
    (13910, 8, "");
    (13910, 0, "T");
    (13911, 0, "h");
    (13912, 0, "e");
    (13913, 0, " ");
    (13913, 1, "");
    (13907, 6, "");
    (13907, 0, "s");
    (13908, 0, "e");
    (13909, 0, "l");
    (13910, 0, "f");
    (13911, 0, ".");
    (13912, 0, "l");
    (13913, 0, "o");
    (13914, 0, "c");
    (13915, 0, "a");
    (13916, 0, "l");
    (13912, 5, "local_index");
    (13923, 0, " ");
    (13924, 0, "+");
    (13925, 0, "=");
    (13926, 0, " ");
    (13927, 0, "1");
    (13928, 0, ";");
    (13930, 63, "");
    (13935, 0, "\n    ");
    (13940, 0, "\n    ");
    (13936, 4, "");
    (13941, 0, "f");
    (13942, 0, "n");
    (13943, 0, " ");
    (13944, 0, "a");
    (13945, 0, "d");
    (13946, 0, "v");
    (13947, 0, "a");
    (13948, 0, "n");
    (13949, 0, "c");
    (13950, 0, "e");
    (13951, 0, "_");
    (13952, 0, "b");
    (13953, 0, "y");
    (13954, 0, "_");
    (13955, 0, "i");
    (13956, 0, "t");
    (13957, 0, "e");
    (13958, 0, "m");
    (13959, 0, "s");
    (13960, 0, "(");
    (13961, 0, "&");
    (13962, 0, "m");
    (13963, 0, "u");
    (13964, 0, "s");
    (13965, 0, "t");
    (13966, 0, " ");
    (13966, 1, "");
    (13965, 1, "");
    (13964, 1, "");
    (13964, 0, "t");
    (13965, 0, " ");
    (13966, 0, "s");
    (13967, 0, "e");
    (13968, 0, "l");
    (13969, 0, "f");
    (13970, 0, ")");
    (13971, 0, " ");
    (13972, 0, "{");
    (13973, 0, "\n        ");
    (13982, 0, "\n        ");
    (13974, 8, "");
    (13975, 8, "    }");
    (13974, 0, "        ");
    (13982, 0, "f");
    (13983, 0, "o");
    (13984, 0, "r");
    (13985, 0, " ");
    (13986, 0, "0");
    (13986, 1, "");
    (13986, 0, "_");
    (13987, 0, " ");
    (13987, 1, "");
    (13986, 1, "");
    (13986, 0, "0");
    (13987, 0, ".");
    (13988, 0, ".");
    (13970, 0, " ");
    (13970, 1, "");
    (13970, 0, ",");
    (13971, 0, " ");
    (13972, 0, "n");
    (13973, 0, "u");
    (13974, 0, "m");
    (13975, 0, ":");
    (13976, 0, " ");
    (13977, 0, "u");
    (13978, 0, "s");
    (13979, 0, "i");
    (13980, 0, "z");
    (13981, 0, "e");
    (14001, 0, "n");
    (14002, 0, "u");
    (14003, 0, "m");
    (14004, 0, " ");
    (14005, 0, "{");
    (14006, 0, " ");
    (14007, 0, "s");
    (14008, 0, "e");
    (14009, 0, "l");
    (14010, 0, "f");
    (14011, 0, ".");
    (14012, 0, "a");
    (14013, 0, "d");
    (14014, 0, "v");
    (14012, 3, "advance_item()");
    (14026, 0, ";");
    (14027, 0, " ");
    (14028, 0, "}");
    (13997, 0, " ");
    (13998, 0, "_");
    (13999, 0, " ");
    (14000, 0, "i");
    (14001, 0, "n");
    ( 37673,
      0,
      "\n\
      \            let (c2, _) = self.iter_at_userpos(userpos + \
       C::userlen_of_slice(contents));" );
    (37597, 0, "// ");
    (37731, 32, "");
    (37733, 0, "\n            ");
    (37746, 0, "c");
    (37747, 0, "2");
    (37748, 0, ".");
    (37749, 0, "a");
    (37750, 0, "d");
    (37751, 0, "v");
    (37749, 3, "advance_by_items(num: usize)");
    (37766, 10, "c");
    (37767, 0, "o");
    (37768, 0, "n");
    (37769, 0, "t");
    (37770, 0, "e");
    (37771, 0, "n");
    (37772, 0, "t");
    (37773, 0, "s");
    (37774, 0, ".");
    (37775, 0, "l");
    (37776, 0, "e");
    (37777, 0, "n");
    (37778, 0, "(");
    (37779, 1, ")");
    (37780, 0, ")");
    (37781, 0, ";");
    (37694, 0, "m");
    (37695, 0, "u");
    (37696, 0, "t");
    (37697, 0, " ");
    (16996, 0, "\n                ");
    (17013, 0, "e");
    (17014, 0, "t");
    (17015, 0, " ");
    (17015, 1, "");
    (17014, 1, "");
    (17013, 1, "");
    (17013, 0, "l");
    (17014, 0, "e");
    (17015, 0, "t");
    (17016, 0, " ");
    (17017, 0, "i");
    (17018, 0, "s");
    (17019, 0, "_");
    (17020, 0, "h");
    (17021, 0, "e");
    (17022, 0, "a");
    (17023, 0, "d");
    (17024, 0, " ");
    (17025, 0, "=");
    (17026, 0, " ");
    (17052, 53, "");
    (17027, 0, "(n as *const Node<C> == &self.head as *const Node<C>)");
    (17079, 1, "");
    (17027, 1, "");
    (17071, 7, "_");
    (17039, 7, "_");
    (17066, 0, ";");
    (17092, 0, "i");
    (17093, 0, "s");
    (17094, 0, "_");
    (17095, 0, "h");
    (17096, 0, "e");
    (17097, 0, "a");
    (17098, 0, "d");
    (17238, 69, "");
    (17084, 0, "i");
    (17085, 0, "f");
    (17086, 0, " ");
    (17087, 0, "!");
    (17088, 0, "i");
    (17089, 0, "s");
    (17090, 0, "_");
    (17091, 0, "h");
    (17092, 0, "e");
    (17093, 0, "a");
    (17094, 0, "d");
    (17095, 0, " ");
    (17104, 11, "");
    (17121, 0, "}");
    (17096, 0, "{");
    (17097, 0, " ");
    (17123, 0, " ");
    (17125, 0, "\n                ");
    (17126, 16, "");
    (17125, 1, "");
    (13898, 0, "\n        ");
    (13907, 0, "l");
    (13908, 0, "e");
    (13909, 0, "t");
    (13910, 0, " ");
    (13911, 0, "s");
    (13912, 0, "i");
    (13913, 0, "z");
    (13914, 0, "e");
    (13915, 0, " ");
    (13916, 0, "=");
    (13917, 0, " ");
    (13907, 11, "");
    (13907, 0, "l");
    (13908, 0, "e");
    (13909, 0, "t");
    (13910, 0, " ");
    (13758, 20, "h");
    (13759, 0, "e");
    (13760, 0, "r");
    (13761, 0, "e");
    (13758, 4, "s");
    (13759, 0, "e");
    (13760, 0, "l");
    (13761, 0, "f");
    (13762, 0, ".");
    (13763, 0, "h");
    (13764, 0, "e");
    (13765, 0, "r");
    (13766, 0, "e");
    (13763, 4, "here_ptr()");
    (13832, 0, ",");
    (13833, 0, " ");
    (13834, 0, "h");
    (13835, 0, "e");
    (13836, 0, "i");
    (13837, 0, "g");
    (13838, 0, "h");
    (13839, 0, "t");
    (13840, 0, ":");
    (13841, 0, " ");
    (13842, 0, "s");
    (13843, 0, "z");
    (13843, 1, "");
    (13843, 0, "i");
    (13844, 0, "z");
    (13845, 0, "e");
    (13846, 0, "-");
    (13846, 1, "");
    (13842, 4, "u");
    (13843, 0, "s");
    (13844, 0, "i");
    (13845, 0, "z");
    (13846, 0, "e");
    (14005, 0, ",");
    (14006, 0, " ");
    (14007, 0, "h");
    (14008, 0, "e");
    (14009, 0, "i");
    (14010, 0, "g");
    (14011, 0, "h");
    (14012, 0, "t");
    (14013, 0, ":");
    (14014, 0, " ");
    (14015, 0, "u");
    (14016, 0, "s");
    (14017, 0, "i");
    (14018, 0, "z");
    (14019, 0, "e");
    (14068, 0, "h");
    (14069, 0, "e");
    (14070, 0, "i");
    (14071, 0, "g");
    (14072, 0, "h");
    (14073, 0, "t");
    (13921, 0, "u");
    (13922, 0, "s");
    (13923, 0, "e");
    (13924, 0, "r");
    (13925, 0, "s");
    (13926, 0, "i");
    (13927, 0, "z");
    (13928, 0, "e");
    (13929, 0, " ");
    (13930, 0, "=");
    (13931, 0, " ");
    (13932, 0, "s");
    (13933, 0, "e");
    (13934, 0, "l");
    (13935, 0, "f");
    (13936, 0, ".");
    (13937, 0, "h");
    (13938, 0, "e");
    (13939, 0, "r");
    (13940, 0, "e");
    (13937, 4, "here_ptr()");
    (13932, 0, "u");
    (13933, 0, "n");
    (13934, 0, "s");
    (13935, 0, "a");
    (13936, 0, "f");
    (13937, 0, "e");
    (13938, 0, " ");
    (13939, 0, "{");
    (13940, 0, " ");
    (13941, 0, "*");
    (13941, 0, "(");
    (13958, 0, ")");
    (13959, 0, ".");
    (13960, 0, "i");
    (13961, 0, "t");
    (13962, 0, "e");
    (13963, 0, "m");
    (13964, 0, "s");
    (13965, 0, "[");
    (13966, 0, "self.local_index");
    (13982, 0, "]");
    (13983, 0, " ");
    (13984, 0, "}");
    (13985, 0, ";");
    (13908, 0, "\n        ");
    (13917, 0, "l");
    (13918, 0, "e");
    (13919, 0, "t");
    (13920, 0, " ");
    (13921, 0, "f");
    (13922, 0, "i");
    (13923, 0, "r");
    (13924, 0, "s");
    (13925, 0, "t");
    (13926, 0, "_");
    (13927, 0, "i");
    (13928, 0, "t");
    (13929, 0, "e");
    (13930, 0, "m");
    (13931, 0, " ");
    (13932, 0, "=");
    (13933, 0, " ");
    (13958, 54, "");
    (13934, 0, "unsafe { (*self.here_ptr()).items[self.local_index] };");
    (13921, 10, "c");
    (13922, 0, "u");
    (13923, 0, "r");
    (13924, 0, "r");
    (13925, 0, "e");
    (13926, 0, "n");
    (13927, 0, "t");
    (13928, 0, "_");
    (13929, 0, "i");
    (13930, 0, "t");
    (13931, 0, "e");
    (13932, 0, "m");
    (14177, 0, "\n    ");
    (14182, 0, "\n    ");
    (14178, 4, "");
    (14183, 0, "f");
    (14184, 0, "n");
    (14185, 0, " ");
    (14186, 0, "c");
    (14187, 0, "u");
    (14188, 0, "r");
    (14189, 0, "r");
    (14190, 0, "e");
    (14191, 0, "n");
    (14192, 0, "t");
    (14193, 0, "_");
    (14194, 0, "i");
    (14195, 0, "t");
    (14196, 0, "e");
    (14197, 0, "m");
    (14183, 0, "u");
    (14184, 0, "n");
    (14185, 0, "s");
    (14186, 0, "a");
    (14187, 0, "f");
    (14188, 0, "e");
    (14189, 0, " ");
    (14205, 0, "(");
    (14206, 0, "&");
    (14207, 0, "u");
    (14207, 1, "");
    (14207, 0, "m");
    (14208, 0, "u");
    (14209, 0, "t");
    (14210, 0, " ");
    (14211, 0, "s");
    (14212, 0, "e");
    (14213, 0, "l");
    (14214, 0, "f");
    (14215, 0, ")");
    (14216, 0, " ");
    (14217, 0, "{");
    (14218, 0, "\n        ");
    (14227, 0, "\n        ");
    (14219, 8, "");
    (14220, 8, "    }");
    (14219, 0, "(*self.here_ptr()).items[self.local_index]");
    (14219, 0, "        ");
    (14227, 1, "");
    (14243, 1, "");
    (14227, 0, "(");
    (14244, 0, ")");
    (14216, 0, " ");
    (14217, 0, "-");
    (14218, 0, ">");
    (14219, 0, " ");
    (14220, 0, "&");
    (14221, 0, "T");
    (14221, 1, "");
    (14221, 0, "C");
    (14222, 0, ":");
    (14223, 0, ":");
    (14224, 0, "I");
    (14225, 0, "t");
    (14226, 0, "e");
    (14227, 0, "m");
    (14239, 0, "&");
    (14014, 0, "u");
    (14015, 0, "n");
    (14016, 0, "s");
    (14017, 0, "a");
    (14018, 0, "f");
    (14019, 0, "e");
    (14020, 0, " ");
    (14021, 0, "{");
    (14022, 0, " ");
    (14023, 0, "s");
    (14024, 0, "e");
    (14025, 0, "l");
    (14026, 0, "f");
    (14027, 0, ".");
    (14028, 0, "c");
    (14029, 0, "u");
    (14030, 0, "r");
    (14031, 0, "r");
    (14028, 4, "Current");
    (14028, 7, "c");
    (14029, 0, "u");
    (14030, 0, "r");
    (14031, 0, "r");
    (14032, 0, "e");
    (14033, 0, "n");
    (14034, 0, "t");
    (14035, 0, "_");
    (14036, 0, "i");
    (14028, 9, "current_item");
    (14040, 0, "(");
    (14041, 0, ")");
    (14042, 0, " ");
    (14043, 0, "}");
    (14013, 0, " ");
    (14014, 0, "C");
    (14015, 0, ":");
    (14016, 0, ":");
    (14017, 0, "get_usersize(_item: &Self::Item)");
    (14030, 18, "");
    (14030, 1, "");
    (14030, 1, "");
    (14060, 0, ")");
    (14061, 0, ";");
    (13909, 81, "");
    (13908, 1, "");
    (13980, 0, "\n        ");
    (13989, 0, "\n        ");
    (13981, 8, "");
    (13990, 0, "f");
    (13991, 0, "o");
    (13992, 0, "r");
    (13993, 0, " ");
    (13994, 0, "_");
    (13995, 0, " ");
    (13996, 0, "i");
    (13997, 0, " ");
    (13997, 1, "");
    (13997, 0, "n");
    (13998, 0, " ");
    (13999, 0, "0");
    (14000, 0, ".");
    (14001, 0, ".");
    (14002, 0, "h");
    (14003, 0, "e");
    (14004, 0, "i");
    (14005, 0, "g");
    (14006, 0, "h");
    (14007, 0, "t");
    (14008, 0, " ");
    (14009, 0, "{");
    (14010, 0, "\n            ");
    (14023, 0, "\n            ");
    (14011, 12, "");
    (14012, 12, "        }");
    (14011, 0, "            ");
    (14023, 0, "e");
    (14024, 0, "s");
    (14025, 0, "l");
    (14026, 0, "f");
    (14026, 1, "");
    (14025, 1, "");
    (14024, 1, "");
    (14023, 1, "");
    (14023, 0, "s");
    (14024, 0, "e");
    (14025, 0, "l");
    (14026, 0, "f");
    (14027, 0, ".");
    (14028, 0, "e");
    (14029, 0, "n");
    (14030, 0, "t");
    (14028, 3, "entries");
    (14035, 0, "[");
    (14036, 0, "i");
    (14037, 0, "]");
    (14038, 0, ".");
    (14039, 0, "s");
    (14040, 0, "k");
    (14041, 0, "i");
    (14042, 0, "p");
    (14043, 0, "_");
    (14044, 0, "u");
    (14045, 0, "s");
    (14039, 7, "skip_usersize");
    (14052, 0, " ");
    (14053, 0, "+");
    (14054, 0, "=");
    (14055, 0, " ");
    (14056, 0, "u");
    (14057, 0, "s");
    (14058, 0, "e");
    (14059, 0, "r");
    (14060, 0, "s");
    (14061, 0, "i");
    (14062, 0, "z");
    (14063, 0, "e");
    (14064, 0, ";");
    (14075, 0, "\n        ");
    (14084, 0, "s");
    (14085, 0, "e");
    (14086, 0, "l");
    (14087, 0, "f");
    (14088, 0, ".");
    (14089, 0, "g");
    (14090, 0, "l");
    (14091, 0, "o");
    (14089, 3, "u");
    (14090, 0, "s");
    (14091, 0, "e");
    (14092, 0, "r");
    (14089, 4, "userpos");
    (14096, 0, " ");
    (14097, 0, "+");
    (14098, 0, " ");
    (14098, 1, "");
    (14098, 0, "=");
    (14099, 0, " ");
    (14100, 0, "u");
    (14101, 0, "s");
    (14102, 0, "e");
    (14103, 0, "r");
    (14104, 0, "s");
    (14105, 0, "i");
    (14106, 0, "z");
    (14107, 0, "e");
    (14108, 0, ";");
    (13994, 1, "");
    (13994, 0, "e");
    (13995, 0, "n");
    (13996, 0, "t");
    (13997, 0, "r");
    (13998, 0, "y");
    (14003, 0, "s");
    (14004, 0, "e");
    (14005, 0, "l");
    (14006, 0, "f");
    (14007, 0, ".");
    (14008, 0, "e");
    (14009, 0, "n");
    (14010, 0, "t");
    (14011, 0, "r");
    (14012, 0, "i");
    (14013, 0, "e");
    (14014, 0, "s");
    (14015, 0, "[");
    (14025, 0, "]");
    (14041, 15, "e");
    (14042, 0, "n");
    (14043, 0, "t");
    (14044, 0, "r");
    (14045, 0, "y");
    (14026, 0, ".");
    (14027, 0, "i");
    (14028, 0, "t");
    (14029, 0, "e");
    (14030, 0, "r");
    (14031, 0, "9");
    (14031, 1, "");
    (14031, 0, "(");
    (14032, 0, ")");
    (14026, 7, "");
    (14003, 0, "&");
    (14004, 0, "m");
    (14005, 0, "u");
    (14006, 0, "t");
    (14007, 0, " ");
    (14004, 3, "");
    (14004, 1, "");
    (38097, 0, ",");
    (38098, 0, " ");
    (38099, 0, "s");
    (38100, 0, "e");
    (38101, 0, "l");
    (38102, 0, "f");
    (38103, 0, ".");
    (38104, 0, "h");
    (38105, 0, "e");
    (38106, 0, "i");
    (38107, 0, "\n        ");
    (38108, 8, "");
    (38107, 1, "");
    (38106, 1, "");
    (38106, 0, "i");
    (38107, 0, "g");
    (38108, 0, "h");
    (38109, 0, "t");
    (38104, 0, "e");
    (38105, 0, "a");
    (38105, 1, "");
    (38104, 1, "");
    (38104, 0, "h");
    (38105, 0, "e");
    (38106, 0, "a");
    (38107, 0, "d");
    (38108, 0, ".");
    (38115, 0, " ");
    (38116, 0, "a");
    (38117, 0, "s");
    (38118, 0, " ");
    (38119, 0, "u");
    (38120, 0, "s");
    (38121, 0, "z");
    (38119, 3, "usize");
    (14212, 5, "u");
    (14213, 0, "8");
    (13842, 5, "u");
    (13843, 0, "8");
    (14023, 0, " ");
    (14024, 0, "a");
    (14025, 0, "s");
    (14026, 0, " ");
    (14027, 0, "u");
    (14028, 0, "s");
    (14029, 0, "i");
    (14030, 0, "z");
    (14031, 0, "e");
    (38118, 9, "");
    (14001, 0, "m");
    (14002, 0, "u");
    (14003, 0, "t");
    (14004, 0, " ");
    (38208, 76, "");
    (37905, 92, "");
    (38582, 63, "\n        ");
    ( 38591,
      0,
      "        #[cfg(debug_assertions)] {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(contents.len(), self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       insert\"); }\n\
      \        }\n" );
    (38583, 16, "        ");
    (38828, 1, "");
    (38679, 67, "");
    (38740, 6, "d");
    (38741, 0, "e");
    (38742, 0, "l");
    (38743, 0, "e");
    (38744, 0, "t");
    (38745, 0, "e");
    (38635, 3, "");
    (38635, 1, "");
    (37480, 3, "");
    (37403, 3, "");
    (37332, 3, "");
    (37294, 3, "");
    (34406, 3, "");
    (34410, 23, "a");
    (34411, 0, "d");
    (34412, 0, "v");
    (34413, 0, "a");
    (34414, 0, "n");
    (34415, 0, "c");
    (34416, 0, "e");
    (34417, 0, "d");
    (34418, 0, "_");
    (34419, 0, "b");
    (34420, 0, "y");
    (34424, 16, "");
    (37357, 0, "\n            ");
    (37370, 0, "c2.advance_by_items(contents.len(), self.head.height);");
    (37332, 23, "c2.advance_by_items(contents.len(), self.head.height);");
    (37332, 54, "expected_final_position");
    (37332, 23, "s");
    (37333, 0, "t");
    (37334, 0, "a");
    (37335, 0, "r");
    (37332, 4, "start_userpos");
    (37380, 14, "");
    (37380, 0, "a");
    (37381, 0, "d");
    (37382, 0, "v");
    (37383, 0, "a");
    (37380, 4, "advanced_by");
    (37306, 0, "m");
    (37307, 0, "u");
    (37308, 0, "t");
    (37309, 0, " ");
    (37306, 0, "(");
    (37313, 0, ",");
    (37314, 0, " ");
    (37315, 0, "_");
    (37316, 0, ")");
    (34446, 0, ";");
    (34447, 0, "/");
    (34448, 0, "/");
    (34447, 19, "");
    (1150, 1, "");
    (1150, 0, "1");
    (1150, 1, "");
    (1150, 0, "1");
    (1151, 0, "0");
    (1152, 0, "0");
    (1150, 3, "");
    (1150, 0, "1");
    (1449, 1, "");
    (1449, 0, "2");
    (1449, 1, "");
    (1449, 0, "1");
    (1450, 0, "0");
    (1119, 0, "\n");
    (1120, 0, "#[cfg(test)]");
    (1094, 0, "");
    (1094, 1, "");
    (1082, 3, "");
    (1116, 13, "");
    (1082, 0, "#[cfg(test)]\n");
    (1129, 33, "");
    (1095, 0, "const NODE_NUM_ITEMS: usize = 1;\n");
    (1082, 0, "#[cfg(test)]\n");
    (1107, 33, "");
    (1095, 0, "const NODE_NUM_ITEMS: usize = 1;\n");
    (1134, 0, "!");
    (1134, 1, "");
    (1130, 0, "!");
    (1130, 1, "");
    (1133, 0, "!");
    (1133, 1, "");
    (1133, 0, ")");
    (1134, 0, "n");
    (1135, 0, "o");
    (1135, 1, "");
    (1134, 1, "");
    (1133, 1, "");
    (1133, 0, "(");
    (1134, 0, "n");
    (1135, 0, "o");
    (1136, 0, "t");
    (1143, 0, ")");
    ( 1451,
      30,
      "#[cfg(test)]\n\
       const NODE_NUM_ITEMS: usize = 1;\n\
       #[cfg(not(test))]\n\
       const NODE_NUM_ITEMS: usize = 100;\n" );
    (1451, 99, "const MAX_HEIGHT: usize = 10;\n");
    (1451, 0, "\n");
    ( 1451,
      0,
      "#[cfg(test)]\n\
       const NODE_NUM_ITEMS: usize = 1;\n\
       #[cfg(not(test))]\n\
       const NODE_NUM_ITEMS: usize = 100;\n" );
    (1580, 0, "\n");
    (1550, 1, "");
    (1579, 0, "\nconst NODE_NUM_ITEMS: usize = 100;");
    (1515, 35, "");
    (1545, 35, "");
    (1544, 0, "\nconst MAX_HEIGHT: usize = 10;");
    (1544, 0, "\n#[cfg(not(test))]");
    (1497, 18, "");
    (1526, 0, "\nconst NODE_NUM_ITEMS: usize = 1;");
    (1464, 33, "");
    (1493, 33, "");
    (1464, 0, "const NODE_NUM_ITEMS: usize = 1;\n");
    (1464, 33, "");
    (1491, 1, "");
    (1490, 1, "");
    (1490, 0, "2");
    (1490, 1, "");
    (1490, 0, "1");
    (1490, 1, "");
    (1490, 0, "1");
    (1491, 0, "0");
    (1493, 0, "\n");
    (1128, 0, "\n");
    (1126, 0, "0");
    (1127, 0, "0");
    (1127, 1, "");
    (1126, 1, "");
    (1125, 1, "");
    (1125, 0, "2");
    (1491, 2, "2");
    (34678, 122, "");
    (1505, 4, "d");
    (1458, 4, "d");
    (1139, 4, "d");
    (1088, 4, "d");
    (1497, 0, "e");
    (1453, 0, "e");
    (1137, 0, "e");
    (1089, 0, "e");
    (1501, 0, "b");
    (1456, 0, "b");
    (1139, 0, "b");
    (1090, 0, "b");
    (1505, 0, "u");
    (1459, 0, "u");
    (1141, 0, "u");
    (1091, 0, "u");
    (1509, 0, "g");
    (1462, 0, "g");
    (1143, 0, "g");
    (1092, 0, "g");
    (1513, 0, "_");
    (1465, 0, "_");
    (1145, 0, "_");
    (1093, 0, "_");
    (1517, 0, "a");
    (1468, 0, "a");
    (1147, 0, "a");
    (1094, 0, "a");
    (1521, 0, "s");
    (1471, 0, "s");
    (1149, 0, "s");
    (1095, 0, "s");
    (1525, 0, "s");
    (1474, 0, "s");
    (1151, 0, "s");
    (1096, 0, "s");
    (1529, 0, "e");
    (1477, 0, "e");
    (1153, 0, "e");
    (1097, 0, "e");
    (1533, 0, "r");
    (1480, 0, "r");
    (1155, 0, "r");
    (1098, 0, "r");
    (1537, 0, "t");
    (1483, 0, "t");
    (1157, 0, "t");
    (1099, 0, "t");
    (1541, 0, "i");
    (1486, 0, "i");
    (1159, 0, "i");
    (1100, 0, "i");
    (1545, 0, "o");
    (1489, 0, "o");
    (1161, 0, "o");
    (1101, 0, "o");
    (1549, 0, "n");
    (1492, 0, "n");
    (1163, 0, "n");
    (1102, 0, "n");
    (1553, 0, "s");
    (1495, 0, "s");
    (1165, 0, "s");
    (1103, 0, "s");
    (13279, 0, "d");
    (13280, 0, "b");
    (13281, 0, "g");
    (13282, 0, "!");
    (13283, 0, "(");
    (13302, 0, ")");
    (35841, 1, "");
    (35788, 0, "                \n");
    (35858, 57, "");
    (35805, 0, "                // And bookkeeping. Bookkeeping forever.\n");
    (35915, 67, "");
    ( 35862,
      0,
      "                let new_usersize = C::userlen_of_slice(new_items);\n" );
    (35982, 102, "");
    ( 35929,
      0,
      "                let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n" );
    (36084, 41, "");
    (36031, 16, "                    ");
    (36031, 0, "                if usersize_delta != 0 {\n");
    (36129, 0, "\n                if usersize_delta != 0 {");
    (36072, 20, "                ");
    (36031, 41, "");
    (35787, 17, "");
    (35739, 0, "                \n");
    (35804, 57, "");
    (35756, 0, "                // And bookkeeping. Bookkeeping forever.\n");
    (35861, 67, "");
    ( 35813,
      0,
      "                let new_usersize = C::userlen_of_slice(new_items);\n" );
    (35928, 102, "");
    ( 35880,
      0,
      "                let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n" );
    (35981, 0, "\n                ");
    (35982, 16, "");
    (35739, 16, "");
    (35738, 1, "");
    (35738, 58, "");
    (35738, 16, "\n                ");
    (36011, 0, "\n                ");
    (36012, 16, "");
    (35957, 0, " ");
    (35958, 0, "E");
    (35959, 0, "v");
    (35960, 0, "e");
    (35961, 0, "r");
    (35962, 0, "y");
    (35963, 0, "t");
    (35964, 0, "h");
    (35965, 0, "i");
    (35966, 0, "n");
    (35967, 0, "g");
    (35968, 0, " ");
    (35969, 0, "e");
    (35970, 0, "l");
    (35971, 0, "s");
    (35972, 0, "e");
    (35973, 0, " ");
    (35974, 0, "i");
    (35975, 0, "s");
    (35976, 0, " ");
    (35977, 0, "c");
    (35978, 0, "o");
    (35979, 0, "m");
    (35980, 0, "m");
    (35981, 0, "e");
    (35982, 0, "n");
    (35983, 0, "t");
    (35984, 0, "a");
    (35985, 0, "r");
    (35986, 0, "y");
    (35987, 0, ".");
    (36187, 0, "\n                ");
    (36204, 0, "s");
    (36205, 0, "e");
    (36206, 0, "l");
    (36207, 0, "f");
    (36208, 0, ".");
    (36209, 0, "u");
    (36210, 0, "s");
    (36211, 0, "e");
    (36212, 0, "r");
    (36209, 4, "num_usercount");
    (36222, 0, " ");
    (36223, 0, "+");
    (36224, 0, "=");
    (36225, 0, " ");
    (36226, 0, "u");
    (36227, 0, "s");
    (36228, 0, "e");
    (36229, 0, "r");
    (36230, 0, "s");
    (36231, 0, "i");
    (36232, 0, "z");
    (36233, 0, "e");
    (36234, 0, "_");
    (36235, 0, "d");
    (36236, 0, "e");
    (36237, 0, "l");
    (36238, 0, "t");
    (36239, 0, "a");
    (36240, 0, ";");
    (36222, 0, " ");
    (36223, 0, "a");
    (36224, 0, "s");
    (36225, 0, " ");
    (36226, 0, "i");
    (36227, 0, "s");
    (36228, 0, "u");
    (36229, 0, "z");
    (36230, 0, "e");
    (36230, 1, "");
    (36229, 1, "");
    (36228, 1, "");
    (36228, 0, "i");
    (36229, 0, "z");
    (36230, 0, "e");
    (36204, 0, "(");
    (36232, 0, ")");
    (36232, 1, "");
    (36204, 1, "");
    (36228, 3, "");
    (36228, 0, "uze");
    (36225, 6, "");
    (36222, 3, "");
    (36222, 0, " ");
    (36223, 0, "=");
    (36224, 0, " ");
    (36225, 0, "s");
    (36226, 0, "e");
    (36227, 0, "l");
    (36228, 0, "f");
    (36229, 0, ".");
    (36230, 0, "u");
    (36231, 0, "s");
    (36232, 0, "e");
    (36233, 0, "r");
    (36230, 4, "num_usercount");
    (36243, 0, ".");
    (36244, 0, "w");
    (36245, 0, "r");
    (36246, 0, "a");
    (36247, 0, "p");
    (36244, 4, "wrapping_add");
    (36256, 0, "(");
    (36257, 1, "");
    (36257, 1, "");
    (36257, 1, "");
    (36257, 1, "");
    (36271, 0, " ");
    (36272, 0, "a");
    (36273, 0, "s");
    (36274, 0, " ");
    (36275, 0, "u");
    (36276, 0, "s");
    (36277, 0, "i");
    (36278, 0, "z");
    (36279, 0, "e");
    (36280, 0, ")");
    (36187, 0, "\n                ");
    (36204, 0, "/");
    (36205, 0, "/");
    (36206, 0, " ");
    (36207, 0, "I");
    (36208, 0, " ");
    (36209, 0, "h");
    (36210, 0, "a");
    (36211, 0, "t");
    (36212, 0, "e");
    (36213, 0, " ");
    (36214, 0, "t");
    (36215, 0, "h");
    (36216, 0, "i");
    (36217, 0, "s");
    (36218, 0, ".");
    (37399, 0, "\n        #[cfg(debug_assertions)] {");
    (37373, 0, "// ");
    (37411, 0, "i");
    (37412, 0, "f");
    (37413, 0, " ");
    (37414, 1, "");
    (37414, 1, "");
    (37417, 0, "!");
    (37438, 1, "");
    (37437, 1, "");
    (37436, 1, "");
    (37436, 0, " ");
    (37437, 0, "{");
    (37365, 37, "");
    (37364, 1, "");
    (38722, 26, "if cfg!(debug_assertions) {");
    (38009, 26, "if cfg!(debug_assertions) {");
    (13279, 5, "");
    (13297, 1, "");
    (37871, 0, "// ");
    (37862, 0, "\n        ");
    (37871, 0, "\n        ");
    (37863, 8, "");
    (37872, 0, "i");
    (37873, 0, "f");
    (37874, 0, " ");
    (37875, 0, "o");
    (37876, 0, "f");
    (37877, 0, "f");
    (37878, 0, "s");
    (37879, 0, "e");
    (37880, 0, "t");
    (37881, 0, " ");
    (37882, 0, "=");
    (37883, 0, "=");
    (37884, 0, " ");
    (37885, 0, "0");
    (37886, 0, " ");
    (37887, 0, "{");
    (37959, 0, "\n        if offset == 0 {");
    (37864, 25, "");
    (37934, 0, "\n");
    (37863, 1, "");
    (37968, 0, "    ");
    (38026, 0, "\n            ");
    (38027, 12, "        }");
    (38036, 0, " ");
    (38037, 0, "e");
    (38038, 0, "l");
    (38039, 0, "s");
    (38040, 0, "e");
    (38041, 0, " ");
    (38042, 0, "{");
    (38043, 0, "\n            ");
    (38056, 0, "\n            ");
    (38044, 12, "");
    (38045, 12, "        }");
    (38044, 0, "            ");
    (38056, 0, "l");
    (38057, 0, "e");
    (38058, 0, "t");
    (38059, 0, " ");
    (38060, 0, "c");
    (38061, 0, "u");
    (38062, 0, "r");
    (38063, 0, "r");
    (38064, 0, "e");
    (38065, 0, "n");
    (38066, 0, "t");
    (38067, 0, "_");
    (38068, 0, "i");
    (38069, 0, "t");
    (38070, 0, "e");
    (38071, 0, "m");
    (38072, 0, " ");
    (38073, 0, "=");
    (38074, 0, " ");
    (38075, 0, "c");
    (38076, 0, "u");
    (38077, 0, "r");
    (38078, 0, "s");
    (38079, 0, "o");
    (38080, 0, "r");
    (38081, 0, ".");
    (38082, 0, "g");
    (38083, 0, "e");
    (38084, 0, "t");
    (38085, 0, "_");
    (38086, 0, "c");
    (38087, 0, "u");
    (38088, 0, "r");
    (38089, 0, "r");
    (38082, 8, "");
    (38081, 1, "");
    (38081, 0, ".");
    (38082, 0, "current_item()");
    (38096, 0, ";");
    (38097, 0, "\n            ");
    (38098, 12, "");
    (37972, 9, "");
    (38016, 1, "");
    (38015, 1, "");
    (37934, 0, "\n        ");
    (37943, 0, "u");
    (37944, 0, "n");
    (37945, 0, "s");
    (37946, 0, "a");
    (37947, 0, "f");
    (37948, 0, "e");
    (37949, 0, " ");
    (37950, 0, "{");
    (38105, 8, "            ");
    (38050, 12, "                ");
    (38033, 8, "            ");
    (37977, 12, "                ");
    (37952, 8, "            ");
    (38134, 0, "\n            ");
    (38135, 12, "        }");
    (38120, 0, "                ");
    (38136, 0, "C");
    (38137, 0, ":");
    (38138, 0, ":");
    (38139, 0, "split_item(_item: Self::Item)");
    (38150, 17, "c");
    (38151, 0, "u");
    (38152, 0, "r");
    (38153, 0, "r");
    (38154, 0, "e");
    (38155, 0, "n");
    (38156, 0, "t");
    (38157, 0, "_");
    (38158, 0, "i");
    (38159, 0, "t");
    (38160, 0, "e");
    (38161, 0, "m");
    (38163, 0, ";");
    (2277, 0, "&");
    (38137, 0, "l");
    (38138, 0, "e");
    (38139, 0, "t");
    (38140, 0, " ");
    (38141, 0, "(");
    (38142, 0, "s");
    (38143, 0, "t");
    (38144, 0, "a");
    (38145, 0, "r");
    (38146, 0, "t");
    (38147, 0, ",");
    (38148, 0, " ");
    (38149, 0, "e");
    (38150, 0, "n");
    (38151, 0, "d");
    (38152, 0, ")");
    (38153, 0, " ");
    (38154, 0, "=");
    (38155, 0, " ");
    (38184, 0, "\n                ");
    (38201, 0, "s");
    (38202, 0, "e");
    (38203, 0, "l");
    (38204, 0, "f");
    (38205, 0, ".");
    (38206, 0, "r");
    (38207, 0, "e");
    (38208, 0, "p");
    (38209, 0, "l");
    (38201, 9, "");
    ( 34397,
      0,
      "\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, mut \
       removed_items: usize, mut inserted_content: &[C::Item]) {" );
    (34397, 0, "\n        ");
    (34406, 0, "\n        ");
    (34398, 8, "");
    (34399, 8, "    }");
    (34404, 0, "\n    ");
    (34405, 4, "");
    (34310, 24, "");
    (34310, 0, "cursor: &mut Cursor<C>, ");
    (34334, 1, "");
    (34334, 1, "");
    (34298, 0, "_");
    (34299, 0, "i");
    (34300, 0, "e");
    (34301, 0, "r");
    (34301, 1, "");
    (34300, 1, "");
    (34300, 0, "t");
    (34301, 0, "e");
    (34302, 0, "r");
    (34281, 0, "u");
    (34282, 0, "n");
    (34283, 0, "s");
    (34284, 0, "a");
    (34285, 0, "f");
    (34286, 0, "e");
    (34287, 0, " ");
    ( 34609,
      0,
      "\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, mut \
       removed_items: usize, mut inserted_content: &[C::Item]) {" );
    (34537, 8, "    ");
    (34416, 121, "");
    (34484, 0, "\n");
    (34415, 1, "");
    (34483, 0, "\n    }");
    (34415, 4, "        ");
    (34409, 6, "");
    (34481, 0, "\n");
    (34408, 1, "");
    (34281, 6, "");
    (34281, 1, "");
    (34284, 0, " ");
    (34285, 0, "u");
    (34286, 0, "n");
    (34287, 0, "s");
    (34288, 0, "a");
    (34289, 0, "f");
    (34290, 0, "e");
    (34281, 4, "");
    (34281, 0, "p");
    (34282, 0, "u");
    (34283, 0, "b");
    (34284, 0, " ");
    (34284, 1, "");
    (34281, 3, "");
    (34281, 0, "pub ");
    (34281, 4, "");
    (34606, 2818, "");
    ( 34477,
      0,
      "\n\
      \        // For validation. This is where the cursor should end up.\n\
      \        let advanced_by = inserted_content.len();\n\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        unsafe {\n\
      \            let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \            removed_items -= replaced_items;\n\n\
      \            while replaced_items > 0 {\n\
      \                let mut e = cursor.here_ptr();\n\
      \                if cursor.local_index == (*e).num_items as usize {\n\
      \                    // Move to the next item.\n\
      \                    e = cursor.advance_node();\n\
      \                    if e.is_null() { panic!(\"Cannot replace past the \
       end of the list\"); }\n\
      \                }\n\n\
      \                let index = cursor.local_index;\n\n\
      \                let e_num_items = (*e).num_items as usize;\n\
      \                let replaced_items_here = min(replaced_items, \
       e_num_items - index);\n\n\
      \                let old_items = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \                let new_items = \
       &inserted_content[0..replaced_items_here];\n\n\
      \                let new_usersize = C::userlen_of_slice(new_items);\n\
      \                let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\n\
      \                // Replace the items themselves. Everything else is \
       commentary.\n\
      \                old_items.copy_from_slice(new_items);\n\n\
      \                if usersize_delta != 0 {\n\
      \                    cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \                }\n\
      \                // I hate this.\n\
      \                self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\n\
      \                inserted_content = \
       &inserted_content[replaced_items_here..];\n\
      \                replaced_items -= replaced_items_here;\n\
      \                // We'll hop to the next Node at the start of the next \
       loop\n\
      \                // iteration if needed.\n\
      \                cursor.local_index += replaced_items_here;\n\n\
      \                for i in 0..self.head.height as usize {\n\
      \                    cursor.entries[i].skip_usersize += new_usersize;\n\
      \                }\n\
      \                cursor.userpos += new_usersize;\n\
      \            }\n\n\
      \            // Ok now one of two things must be true. Either we've run \
       out of\n\
      \            // items to remove, or we've run out of items to insert.\n\
      \            if inserted_content.len() > 0 {\n\
      \                // Insert!\n\
      \                debug_assert!(removed_items == 0);\n\
      \                self.insert_at_iter(&mut cursor, inserted_content);\n\
      \            } else if removed_items > 0 {\n\
      \                self.del_at_iter(&mut cursor, removed_items);\n\
      \            }\n\
      \        }" );
    (34596, 205, "");
    (34596, 0, "\n        ");
    (34605, 0, "\n        ");
    (34597, 8, "");
    (34606, 0, "\n        ");
    (34598, 8, "");
    ( 37230,
      0,
      "        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n"
    );
    (34599, 8, "");
    (37426, 1, "");
    (34478, 117, "");
    (37515, 11, "i");
    (37516, 0, "n");
    (37517, 0, "s");
    (37518, 0, "e");
    (37519, 0, "r");
    (37515, 5, "inserted_content");
    (37531, 0, ".");
    (37532, 0, "l");
    (37533, 0, "e");
    (37534, 0, "n");
    (37535, 0, "(");
    (37536, 0, ")");
    (37069, 4, "");
    (37017, 4, "");
    (37017, 0, "mut ");
    (37043, 4, "");
    (37302, 0, "\n        ");
    (37311, 0, "s");
    (37312, 0, "e");
    (37313, 0, "l");
    (37314, 0, "f");
    (37315, 0, ".");
    (37316, 0, "r");
    (37317, 0, "e");
    (37318, 0, "p");
    (37319, 0, "l");
    ( 37316,
      4,
      "replace_at_iter(cursor: &mut Cursor<C>, mut removed_items: usize, mut \
       inserted_content: &[C::Item])" );
    (37332, 22, "&");
    (37333, 0, "m");
    (37334, 0, "u");
    (37335, 0, "t");
    (37336, 0, " ");
    (37337, 0, "c");
    (37338, 0, "u");
    (37339, 0, "r");
    (37340, 0, "s");
    (37341, 0, "o");
    (37342, 0, "r");
    (37345, 24, "r");
    (37346, 0, "e");
    (37347, 0, "m");
    (37348, 0, "o");
    (37349, 0, "v");
    (37350, 0, "e");
    (37351, 0, "d");
    (37352, 0, "_");
    (37353, 0, "i");
    (37354, 0, "t");
    (37355, 0, "e");
    (37356, 0, "m");
    (37357, 0, "s");
    (37360, 32, "i");
    (37361, 0, "n");
    (37362, 0, "s");
    (37363, 0, "e");
    (37364, 0, "r");
    (37365, 0, "t");
    (37366, 0, "e");
    (37367, 0, "d");
    (37368, 0, "_");
    (37369, 0, "c");
    (37370, 0, "o");
    (37371, 0, "n");
    (37372, 0, "t");
    (37373, 0, "e");
    (37374, 0, "n");
    (37375, 0, "t");
    (37377, 0, ";");
    (37378, 0, "\n        ");
    (37388, 69, "");
    (37379, 8, "");
    (37311, 0, "u");
    (37312, 0, "n");
    (37313, 0, "s");
    (37314, 0, "a");
    (37315, 0, "f");
    (37316, 0, "e");
    (37317, 0, " ");
    (37318, 0, "{");
    (37319, 0, " ");
    (37387, 0, " ");
    (37388, 0, "}");
    (36924, 5, "");
    (36817, 5, "");
    (34481, 1, "");
    (34480, 1, "");
    (34479, 1, "");
    (34478, 1, "");
    (34477, 1, "");
    (34563, 16, "");
    (34562, 1, "");
    (36921, 12, "        ");
    (36864, 16, "            ");
    (36822, 12, "        ");
    (36759, 16, "            ");
    (36708, 16, "            ");
    (36681, 16, "            ");
    (36637, 12, "        ");
    (36568, 12, "        ");
    (36490, 12, "        ");
    (36475, 12, "        ");
    (36427, 16, "            ");
    (36409, 16, "            ");
    (36340, 20, "                ");
    (36284, 16, "            ");
    (36224, 16, "            ");
    (36184, 16, "            ");
    (36108, 16, "            ");
    (36053, 16, "            ");
    (35976, 16, "            ");
    (35880, 16, "            ");
    (35848, 16, "            ");
    (35830, 16, "            ");
    (35745, 20, "                ");
    (35704, 16, "            ");
    (35649, 16, "            ");
    (35569, 16, "            ");
    (35466, 16, "            ");
    (35399, 16, "            ");
    (35323, 16, "            ");
    (35238, 16, "            ");
    (35153, 16, "            ");
    (35094, 16, "            ");
    (35045, 16, "            ");
    (35026, 16, "            ");
    (34936, 20, "                ");
    (34889, 20, "                ");
    (34843, 20, "                ");
    (34776, 16, "            ");
    (34729, 16, "            ");
    (34690, 12, "        ");
    (34644, 12, "        ");
    (34563, 12, "        ");
    (36767, 9, "");
    (36766, 1, "");
    (37969, 0, "// ");
    (37911, 0, "// ");
    (37704, 3, "");
    (37969, 3, "");
    (37908, 3, "");
    (38030, 0, "s");
    (38031, 0, "e");
    (38032, 0, "l");
    (38033, 0, "f");
    (38034, 0, ".");
    (38035, 0, "r");
    (38036, 0, "e");
    ( 38035,
      2,
      "replace_at_iter(cursor: &mut Cursor<C>, mut removed_items: usize, mut \
       inserted_content: &[C::Item])" );
    (38051, 22, "&");
    (38052, 0, "m");
    (38053, 0, "u");
    (38054, 0, "t");
    (38055, 0, " ");
    (38056, 0, "c");
    (38057, 0, "u");
    (38058, 0, "r");
    (38059, 0, "s");
    (38060, 0, "o");
    (38061, 0, "r");
    (38064, 24, "1");
    (38030, 0, "// ");
    (38013, 0, "\n                ");
    (38030, 0, "p");
    (38031, 0, "a");
    (38032, 0, "n");
    (38033, 0, "i");
    (38030, 4, "panic!");
    (38036, 0, "(");
    (38037, 0, "'");
    (38038, 0, "n");
    (38039, 0, "o");
    (38040, 0, "t");
    (38041, 0, " ");
    (38042, 0, "i");
    (38043, 0, "m");
    (38044, 0, "p");
    (38045, 0, "l");
    (38046, 0, "e");
    (38047, 0, "m");
    (38030, 18, "u");
    (38031, 0, "n");
    (38032, 0, "i");
    (38033, 0, "m");
    (38034, 0, "p");
    (38035, 0, "l");
    (38030, 6, "unimplemented!");
    (38044, 0, "(");
    (38045, 0, ")");
    (38046, 0, ";");
    (38030, 17, "");
    (38030, 0, "s");
    (38031, 0, "e");
    (38032, 0, "l");
    (38033, 0, "f");
    (38034, 0, ":");
    (38035, 0, ":");
    (38035, 1, "");
    (38034, 1, "");
    (38034, 0, ".");
    (38035, 0, "r");
    (38036, 0, "e");
    (38037, 0, "p");
    (38038, 0, "l");
    (38039, 0, "a");
    ( 38035,
      5,
      "replace_at_iter(cursor: &mut Cursor<C>, mut removed_items: usize, mut \
       inserted_content: &[C::Item])" );
    (38051, 22, "c");
    (38052, 0, "u");
    (38053, 0, "r");
    (38054, 0, "s");
    (38055, 0, "o");
    (38056, 0, "r");
    (38059, 24, "1");
    (38062, 32, "&");
    (38063, 0, "[");
    (38064, 0, "s");
    (38065, 0, "t");
    (38066, 0, "a");
    (38067, 0, "r");
    (38068, 0, "t");
    (38069, 0, "]");
    (38071, 0, ";");
    (38014, 0, "                self.replace_at_iter(cursor, 1, &[start]);\n");
    (38014, 59, "");
    (37811, 0, "                self.insert_at_iter(&mut cursor, contents);\n");
    (37930, 21, "");
    (37871, 0, "            } else {\n");
    (37951, 58, "");
    (37892, 0, "                let current_item = cursor.current_item();\n");
    (38009, 64, "");
    ( 37950,
      0,
      "                let (start, end) = C::split_item(current_item);\n" );
    (38073, 59, "");
    (38014, 0, "                self.replace_at_iter(cursor, 1, &[start]);\n");
    (38051, 0, "&");
    (38052, 0, "m");
    (38053, 0, "u");
    (38054, 0, "t");
    (38055, 0, " ");
    (38078, 0, "                self.insert_at_iter(&mut cursor, contents);\n");
    (38187, 8, "&");
    (38188, 0, "[");
    (38189, 0, "e");
    (38190, 0, "n");
    (38191, 0, "d");
    (38192, 0, "]");
    (38013, 0, "\n                ");
    (38030, 0, "/");
    (38031, 0, "/");
    (38032, 0, " ");
    (38033, 0, "T");
    (38034, 0, "h");
    (38035, 0, "s");
    (38036, 0, " ");
    (38037, 0, "i");
    (38037, 1, "");
    (38036, 1, "");
    (38035, 1, "");
    (38035, 0, "i");
    (38036, 0, "s");
    (38037, 0, " ");
    (38038, 0, "i");
    (38039, 0, "s");
    (38040, 0, " ");
    (38041, 0, "p");
    (38042, 0, "r");
    (38043, 0, "e");
    (38044, 0, "t");
    (38038, 7, "f");
    (38039, 0, "e");
    (38040, 0, "e");
    (38041, 0, "l");
    (38042, 0, "s");
    (38043, 0, " ");
    (38044, 0, "p");
    (38045, 0, "r");
    (38046, 0, "e");
    (38047, 0, "t");
    (38048, 0, "t");
    (38049, 0, "y");
    (38050, 0, " ");
    (38051, 0, "i");
    (38052, 0, "n");
    (38053, 0, "e");
    (38054, 0, "f");
    (38055, 0, "f");
    (38056, 0, "i");
    (38057, 0, "c");
    (38058, 0, "i");
    (38059, 0, "e");
    (38060, 0, "n");
    (38061, 0, "t");
    (38062, 0, ".");
    (38063, 0, " ");
    (38064, 0, "I");
    (38065, 0, "'");
    (38066, 0, "m");
    (38067, 0, " ");
    (38067, 1, "");
    (38066, 1, "");
    (38065, 1, "");
    (38064, 1, "");
    (38063, 1, "");
    (38062, 1, "");
    (38062, 0, ";");
    (38063, 0, " ");
    (38064, 0, "b");
    (38065, 0, "u");
    (38066, 0, "t");
    (38067, 0, " ");
    (38068, 0, "I");
    (38069, 0, "'");
    (38069, 1, "");
    (38068, 1, "");
    (38067, 1, "");
    (38066, 1, "");
    (38066, 0, "t");
    (38067, 0, " ");
    (38068, 0, "i");
    (38069, 0, "t");
    (38070, 0, "s");
    (38071, 0, " ");
    (38072, 0, "p");
    (38073, 0, "r");
    (38074, 0, "o");
    (38075, 0, "b");
    (38076, 0, "a");
    (38077, 0, "b");
    (38078, 0, "l");
    (38079, 0, "y");
    (38080, 0, " ");
    (38081, 0, "f");
    (38082, 0, "i");
    (38083, 0, "n");
    (38084, 0, "e");
    (38085, 0, ".");
    (38269, 90, "");
    (37695, 68, "");
    (2288, 0, ",");
    (2289, 0, " ");
    (2290, 0, "p");
    (2291, 0, "o");
    (2292, 0, "s");
    (2293, 0, ":");
    (2294, 0, " ");
    (2295, 0, "u");
    (2296, 0, "s");
    (2297, 0, "i");
    (2298, 0, "z");
    (2299, 0, "e");
    (2290, 3, "a");
    (2291, 0, "t");
    (2290, 0, "_");
    (37955, 0, ",");
    (37956, 0, " ");
    (37957, 0, "o");
    (37958, 0, "f");
    (37959, 0, "f");
    (37960, 0, "s");
    (37961, 0, "e");
    (37962, 0, "t");
    (38038, 0, "\n                ");
    (38055, 0, "/");
    (38056, 0, "/");
    (38057, 0, " ");
    (38058, 0, "W");
    (38059, 0, "e");
    (38060, 0, " ");
    (38061, 0, "n");
    (38062, 0, "e");
    (38063, 0, "e");
    (38064, 0, "d");
    (38065, 0, " ");
    (38066, 0, "t");
    (38067, 0, "o");
    (38068, 0, " ");
    (38055, 14, "");
    (38055, 0, "c");
    (38056, 0, "j");
    (38057, 0, "r");
    (38058, 0, "s");
    (38058, 1, "");
    (38057, 1, "");
    (38056, 1, "");
    (38056, 0, "u");
    (38057, 0, "r");
    (38058, 0, "s");
    (38059, 0, "o");
    (38060, 0, "r");
    (38061, 0, ".");
    (38062, 0, "u");
    (38063, 0, "s");
    (38064, 0, "e");
    (38065, 0, "r");
    (38062, 4, "userpos");
    (38069, 0, " ");
    (38070, 0, "-");
    (38071, 0, "=");
    (38072, 0, " ");
    (38073, 0, "o");
    (38074, 0, "f");
    (38075, 0, "f");
    (38076, 0, "s");
    (38077, 0, "e");
    (38078, 0, "t");
    (38079, 0, ";");
    (38080, 0, " ");
    (38081, 0, "/");
    (38082, 0, "/");
    (38083, 0, " ");
    (38084, 0, "M");
    (38085, 0, "o");
    (38086, 0, "v");
    (38087, 0, "e");
    (38088, 0, " ");
    (38089, 0, "t");
    (38090, 0, "h");
    (38091, 0, "e");
    (38092, 0, " ");
    (38093, 0, "c");
    (38094, 0, "u");
    (38095, 0, "r");
    (38096, 0, "s");
    (38097, 0, "o");
    (38098, 0, "r");
    (38099, 0, " ");
    (38100, 0, "b");
    (38101, 0, "a");
    (38102, 0, "c");
    (38103, 0, "k");
    (38104, 0, " ");
    (38105, 0, "t");
    (38106, 0, "o");
    (38107, 0, " ");
    (38108, 0, "t");
    (38109, 0, "h");
    (38110, 0, "e");
    (38111, 0, " ");
    (38112, 0, "s");
    (38113, 0, "t");
    (38114, 0, "a");
    (38115, 0, "r");
    (38116, 0, "t");
    (38117, 0, " ");
    (38118, 0, "o");
    (38119, 0, "f");
    (38120, 0, " ");
    (38121, 0, "t");
    (38122, 0, "h");
    (38123, 0, "e");
    (38124, 0, " ");
    (38125, 0, "i");
    (38126, 0, "t");
    (38127, 0, "e");
    (38128, 0, "m");
    (38129, 0, " ");
    (38130, 0, "w");
    (38131, 0, "e");
    (38132, 0, "r");
    (38132, 1, "");
    (38132, 0, "'");
    (38133, 0, "r");
    (38134, 0, "e");
    (38135, 0, " ");
    (38136, 0, "s");
    (38137, 0, "p");
    (38138, 0, "l");
    (38139, 0, "i");
    (38140, 0, "t");
    (38141, 0, "t");
    (38142, 0, "i");
    (38143, 0, "n");
    (38144, 0, "g");
    (38145, 0, ".");
    (38080, 1, "");
    (38080, 0, "\n                ");
    (38080, 82, "");
    ( 38039,
      0,
      "                // Move the cursor back to the start of the item we're \
       splitting.\n" );
    (38038, 82, "");
    ( 37966,
      0,
      "                // Move the cursor back to the start of the item we're \
       splitting.\n" );
    (38120, 42, "");
    (38048, 0, "                cursor.userpos -= offset;\n");
    ( 37966,
      81,
      "                // Move the cursor back to the start of the item we're\n\
      \                // splitting." );
    (14441, 0, "\n    ");
    (14446, 0, "\n    ");
    (14442, 4, "");
    (14447, 0, "f");
    (14448, 0, "n");
    (14449, 0, " ");
    (14450, 0, "m");
    (14451, 0, "o");
    (14452, 0, "v");
    (14453, 0, "e");
    (14454, 0, "_");
    (14455, 0, "t");
    (14456, 0, "o");
    (14457, 0, "_");
    (14458, 0, "n");
    (14459, 0, "o");
    (14460, 0, "d");
    (14461, 0, "e");
    (14461, 1, "");
    (14460, 1, "");
    (14459, 1, "");
    (14458, 1, "");
    (14458, 0, "i");
    (14459, 0, "t");
    (14460, 0, "e");
    (14461, 0, "m");
    (14462, 0, "_");
    (14463, 0, "s");
    (14464, 0, "t");
    (14465, 0, "a");
    (14466, 0, "r");
    (14467, 0, "t");
    (14468, 0, "(");
    (14469, 0, "&");
    (14470, 0, "m");
    (14471, 0, "u");
    (14472, 0, "t");
    (14473, 0, " ");
    (14474, 0, "s");
    (14475, 0, "e");
    (14476, 0, "l");
    (14477, 0, "f");
    (14478, 0, ")");
    (14478, 0, ",");
    (14479, 0, " ");
    (14480, 0, "o");
    (14481, 0, "f");
    (14482, 0, "f");
    (14483, 0, "s");
    (14484, 0, "e");
    (14485, 0, "t");
    (14486, 0, ":");
    (14487, 0, " ");
    (14488, 0, "u");
    (14489, 0, "s");
    (14490, 0, "i");
    (14491, 0, "z");
    (14492, 0, "e");
    (14494, 0, " ");
    (14495, 0, "{");
    (14496, 0, "\n        ");
    (14505, 0, "\n        ");
    (14497, 8, "");
    (14498, 8, "    }");
    (14497, 0, "        ");
    (14505, 0, "s");
    (14506, 0, "e");
    (14507, 0, "l");
    (14508, 0, "f");
    (14509, 0, ".");
    (14510, 0, "u");
    (14511, 0, "s");
    (14512, 0, "e");
    (14513, 0, "r");
    (14510, 4, "userpos");
    (14517, 0, " ");
    (14518, 0, "-");
    (14519, 0, "=");
    (14520, 0, " ");
    (14521, 0, "o");
    (14522, 0, "f");
    (14523, 0, "s");
    (14523, 1, "");
    (14523, 0, "f");
    (14524, 0, "s");
    (14525, 0, "e");
    (14526, 0, "t");
    (14527, 0, ";");
    (14528, 0, "\n        ");
    ( 14537,
      0,
      "        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }" );
    (14529, 16, "        ");
    (14528, 61, "");
    (14497, 8, "            ");
    (14497, 0, "        for entry in &mut self.entries[0..height as usize] {\n");
    (14593, 45, "");
    (14558, 0, "            entry.skip_usersize += usersize;\n");
    (14638, 10, "");
    (14603, 12, "        ");
    (14603, 0, "        }\n");
    (14590, 1, "");
    (14590, 0, "-");
    (14479, 0, " ");
    (14480, 0, "h");
    (14481, 0, "e");
    (14482, 0, "i");
    (14483, 0, "g");
    (14484, 0, "h");
    (14485, 0, "t");
    (14486, 0, ":");
    (14487, 0, " ");
    (14488, 0, "8");
    (14488, 1, "");
    (14488, 0, "u");
    (14489, 0, "8");
    (14490, 0, ",");
    (14613, 0, " ");
    (14614, 0, "a");
    (14615, 0, "s");
    (14616, 0, " ");
    (14617, 0, "u");
    (14618, 0, "9");
    (14618, 1, "");
    (14618, 0, "8");
    (14605, 8, "o");
    (14606, 0, "f");
    (14607, 0, "f");
    (14608, 0, "s");
    (14609, 0, "e");
    (14610, 0, "t");
    (14611, 6, "");
    (38308, 0, ".");
    (38309, 0, "m");
    (38310, 0, "o");
    (38311, 0, "v");
    (38312, 0, "e");
    (38309, 4, "move_to_item_start(height: u8, offset: usize)");
    (38328, 10, "s");
    (38329, 0, "e");
    (38330, 0, "l");
    (38331, 0, "f");
    (38332, 0, ".");
    (38333, 0, "h");
    (38334, 0, "e");
    (38335, 0, "i");
    (38336, 0, "g");
    (38336, 1, "");
    (38335, 1, "");
    (38334, 1, "");
    (38333, 1, "");
    (38333, 0, "n");
    (38334, 0, "o");
    (38335, 0, "d");
    (38336, 0, "e");
    (38337, 0, ".");
    (38333, 5, "h");
    (38334, 0, "e");
    (38335, 0, "a");
    (38336, 0, "d");
    (38337, 0, ".");
    (38338, 0, "h");
    (38339, 0, "e");
    (38340, 0, "i");
    (38338, 3, "height");
    (38346, 33, "o");
    (38347, 0, "f");
    (38348, 0, "f");
    (38349, 0, "s");
    (38350, 0, "e");
    (38351, 0, "t");
    (38352, 0, ")");
    (38353, 0, ";");
    (38811, 0, "// ");
    (38841, 0, "w");
    (38841, 1, "");
    (38744, 0, "// ");
    (38814, 3, "");
    (38731, 0, "\n            ");
    (38732, 12, "");
    (38731, 0, "\n            let (mut c2, _) = self.iter_at_userpos(userpos);");
    (38683, 0, "// ");
    (38793, 0, " ");
    (38794, 0, " ");
    (38795, 0, "+");
    (38795, 1, "");
    (38794, 1, "");
    (38794, 0, "+");
    (38795, 0, " ");
    (38796, 0, "C");
    (38797, 0, ":");
    (38798, 0, ":");
    (38799, 0, "userlen_of_slice(items: &[Self::Item])");
    (38816, 20, "c");
    (38817, 0, "o");
    (38818, 0, "n");
    (38819, 0, "t");
    (38820, 0, "e");
    (38821, 0, "n");
    (38822, 0, "t");
    (38823, 0, "s");
    (38551, 0, "\n                ");
    (38568, 0, "/");
    (38569, 0, "/");
    (38570, 0, "/");
    (38571, 0, " ");
    (38571, 1, "");
    (38571, 0, " ");
    (38571, 1, "");
    (38570, 1, "");
    (38570, 0, " ");
    (38571, 0, "T");
    (38572, 0, "h");
    (38573, 0, "i");
    (38574, 0, "s");
    (38575, 0, " ");
    (38576, 0, "n");
    (38577, 0, "e");
    (38578, 0, "e");
    (38579, 0, "d");
    (38580, 0, "s");
    (38581, 0, " ");
    (38582, 0, "t");
    (38583, 0, "o");
    (38584, 0, " ");
    (38585, 0, "h");
    (38586, 0, "o");
    (38587, 0, "l");
    (38588, 0, "d");
    (38589, 0, " ");
    (38590, 0, "t");
    (38591, 0, "h");
    (38592, 0, "e");
    (38593, 0, " ");
    (38594, 0, "c");
    (38595, 0, "u");
    (38596, 0, "r");
    (38597, 0, "s");
    (38598, 0, "o");
    (38599, 0, "r");
    (38600, 0, " ");
    (38601, 0, "s");
    (38602, 0, "t");
    (38603, 0, "e");
    (38604, 0, "a");
    (38605, 0, "d");
    (38606, 0, "y");
    (38607, 0, ".");
    (38692, 347, "");
    (38033, 0, "\n                ");
    ( 38050,
      0,
      "        if cfg!(debug_assertions) {\n\
      \            // let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos + \
       C::userlen_of_slice(contents));\n\n\
      \            // c2.advance_by_items(contents.len(), self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       insert\"); }\n\
      \        }\n" );
    (38397, 0, "        ");
    (38387, 8, "                ");
    (38314, 12, "                    ");
    (38244, 12, "                    ");
    (38243, 0, "        ");
    (38150, 12, "                    ");
    (38086, 12, "                    ");
    (38034, 24, "                ");
    (38436, 1, "");
    (38251, 8, "");
    (38250, 1, "");
    (38251, 77, "");
    (38250, 1, "");
    (38175, 4, "");
    (38033, 0, "\n                ");
    (38362, 8, "");
    (38034, 16, "");
    (38034, 312, "");
    (37003, 0, "\n    ");
    (37008, 0, "\n    ");
    (37004, 4, "");
    (37009, 0, "f");
    (37010, 0, "n");
    (37011, 0, " ");
    (37012, 0, "d");
    (37013, 0, "b");
    (37014, 0, "g");
    (37015, 0, "_");
    (37016, 0, "c");
    (37017, 0, "h");
    (37018, 0, "e");
    (37019, 0, "c");
    (37020, 0, "k");
    (37021, 0, "_");
    (37022, 0, "c");
    (37023, 0, "u");
    (37024, 0, "r");
    (37025, 0, "s");
    (37026, 0, "o");
    (37027, 0, "r");
    (37028, 0, "_");
    (37029, 0, "a");
    (37030, 0, "t");
    (37031, 0, "(");
    (37032, 0, "&");
    (37033, 0, "s");
    (37034, 0, "e");
    (37035, 0, "l");
    (37036, 0, "f");
    (37037, 0, ",");
    (37038, 0, " ");
    (37039, 0, "m");
    (37039, 1, "");
    (37039, 0, "&");
    (37040, 0, "m");
    (37041, 0, "u");
    (37042, 0, "t");
    (37043, 0, " ");
    (37044, 0, "c");
    (37045, 0, "u");
    (37046, 0, "r");
    (37047, 0, "s");
    (37048, 0, "o");
    (37049, 0, "r");
    (37050, 0, ":");
    (37051, 0, " ");
    (37052, 0, "C");
    (37052, 1, "");
    (37051, 1, "");
    (37039, 5, "");
    (37046, 0, " ");
    (37047, 0, "&");
    (37048, 0, "c");
    (37049, 0, "u");
    (37050, 0, "r");
    (37050, 1, "");
    (37049, 1, "");
    (37048, 1, "");
    (37048, 0, "C");
    (37049, 0, "u");
    (37050, 0, "r");
    (37051, 0, "s");
    (37052, 0, "o");
    (37053, 0, "r");
    (37054, 0, "<");
    (37054, 1, "");
    (37054, 0, ")");
    (37055, 0, " ");
    (37056, 0, "{");
    (37057, 0, "\n        ");
    (37066, 0, "\n        ");
    (37058, 8, "");
    (37059, 8, "    }");
    (37054, 0, ",");
    (37055, 0, " ");
    (37056, 0, "u");
    (37057, 0, "s");
    (37058, 0, "e");
    (37059, 0, "r");
    (37060, 0, "p");
    (37061, 0, "o");
    (37054, 0, "<");
    (37055, 0, "C");
    (37056, 0, ">");
    (37065, 0, "s");
    (37066, 0, "L");
    (37067, 0, " ");
    (37067, 1, "");
    (37066, 1, "");
    (37065, 1, "");
    (37065, 0, ":");
    (37066, 0, " ");
    (37066, 1, "");
    (37065, 1, "");
    (37064, 1, "");
    (37064, 0, "s");
    (37065, 0, ":");
    (37065, 1, "");
    (37064, 1, "");
    (37064, 0, "o");
    (37065, 0, "s");
    (37066, 0, ":");
    (37067, 0, " ");
    (37068, 0, "u");
    (37069, 0, "s");
    (37070, 0, "i");
    (37071, 0, "z");
    (37072, 0, "e");
    ( 37077,
      0,
      "\n\
      \                if cfg!(debug_assertions) {\n\
      \                    // let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \                    let (c2, _) = self.iter_at_userpos(userpos + \
       C::userlen_of_slice(contents));\n\
      \                    if &cursor != &c2 { panic!(\"Invalid cursor after \
       insert\"); }\n\
      \                }" );
    (37372, 16, "        ");
    (37291, 20, "            ");
    (37194, 20, "            ");
    (37122, 20, "            ");
    (37078, 16, "        ");
    (37076, 1, "");
    (37231, 32, "");
    (37288, 13, "");
    (37246, 0, " ");
    (37246, 0, "a");
    (37247, 0, "s");
    (37248, 0, "s");
    (37249, 0, "e");
    (37250, 0, "r");
    (37246, 5, "assert_eq!");
    (37256, 0, "(");
    (37257, 1, "");
    (37257, 1, "");
    (37257, 1, "");
    (37257, 1, "");
    (37271, 30, "");
    (37271, 0, ")");
    (37272, 0, ";");
    (37271, 2, "");
    (37271, 0, " { panic!(\"Invalid cursor\"); }");
    (37257, 0, " if ");
    (37256, 1, "");
    (37246, 10, "asser");
    (37246, 5, "");
    (37246, 0, "asser");
    (37246, 5, "assert_eq!");
    (37256, 0, "(");
    (37257, 4, "");
    (37271, 30, "");
    (37271, 0, ");");
    (37257, 1, "");
    (37267, 1, "");
    (37267, 0, "&");
    (37257, 0, "&");
    (37264, 3, "");
    (37264, 0, ",");
    (37257, 1, "");
    (38317, 0, "                ");
    (38333, 0, "d");
    (38334, 0, "b");
    (38333, 2, "s");
    (38334, 0, "e");
    (38335, 0, "l");
    (38336, 0, "f");
    (38337, 0, ".");
    (38338, 0, "d");
    (38339, 0, "b");
    (38340, 0, "g");
    (38338, 3, "dbg_check_cursor_at(cursor: &Cursor<C>, userpos: usize)");
    (38358, 18, "&");
    (38359, 0, "c");
    (38360, 0, "u");
    (38361, 0, "r");
    (38362, 0, "s");
    (38363, 0, "o");
    (38364, 0, "r");
    (38367, 14, "userpos + C::userlen_of_slice(contents)");
    (38407, 0, ";");
    (38316, 0, "\n                ");
    (38960, 40, "");
    (38317, 16, "");
    ( 38944,
      0,
      "self.dbg_check_cursor_at(&cursor, userpos + \
       C::userlen_of_slice(contents));" );
    (39019, 0, "\n                ");
    (39019, 17, "");
    (39019, 0, "\n                ");
    (39019, 17, "");
    (38927, 0, "\n                ");
    (39036, 0, "\n                ");
    (38928, 16, "");
    (39037, 0, "\n                ");
    (39021, 16, "");
    (39038, 0, "/");
    (39039, 0, "/");
    (39040, 0, " ");
    (39022, 19, "");
    (39021, 1, "");
    (39020, 1, "");
    (38928, 0, "\n                ");
    (38945, 0, "/");
    (38946, 0, "/");
    (38947, 0, " ");
    (38948, 0, "T");
    (38949, 0, "h");
    (38950, 0, "e");
    (38951, 0, "r");
    (38952, 0, "e");
    (38953, 0, "'");
    (38954, 0, "s");
    (38955, 0, " ");
    (38956, 0, "n");
    (38957, 0, "o");
    (38958, 0, " ");
    (38959, 0, "w");
    (38960, 0, "a");
    (38961, 0, "y");
    (38962, 0, " ");
    (38963, 0, "t");
    (38964, 0, "o");
    (38965, 0, " ");
    (38966, 0, "k");
    (38967, 0, "e");
    (38968, 0, "e");
    (38969, 0, "p");
    (38970, 0, " ");
    (38971, 0, "t");
    (38972, 0, "h");
    (38973, 0, "e");
    (38974, 0, " ");
    (38975, 0, "c");
    (38976, 0, "u");
    (38977, 0, "r");
    (38978, 0, "s");
    (38979, 0, "o");
    (38980, 0, "r");
    (38981, 0, " ");
    (38982, 0, "s");
    (38983, 0, "t");
    (38984, 0, "e");
    (38985, 0, "a");
    (38986, 0, "d");
    (38987, 0, "y");
    (38988, 0, " ");
    (38989, 0, "f");
    (38990, 0, "o");
    (38991, 0, "r");
    (38992, 0, " ");
    (38993, 0, "t");
    (38994, 0, "h");
    (38995, 0, " ");
    (38996, 0, "e");
    (38997, 0, "f");
    (38998, 0, "i");
    (38998, 1, "");
    (38997, 1, "");
    (38996, 1, "");
    (38995, 1, "");
    (38995, 0, "e");
    (38996, 0, " ");
    (38997, 0, "f");
    (38998, 0, "i");
    (38999, 0, "n");
    (39000, 0, "a");
    (39001, 0, "l");
    (39002, 0, " ");
    (39003, 0, "i");
    (39004, 0, "n");
    (39005, 0, "s");
    (39006, 0, "e");
    (39007, 0, "r");
    (39008, 0, "t");
    (38959, 0, " ");
    (38960, 0, "c");
    (38961, 0, "e");
    (38962, 0, "a");
    (38962, 1, "");
    (38961, 1, "");
    (38960, 1, "");
    (38959, 1, "");
    (38959, 0, "c");
    (38960, 0, "o");
    (38961, 0, "l");
    (38962, 0, "e");
    (38963, 0, "a");
    (38964, 0, "n");
    (38965, 0, " ");
    (38959, 7, "c");
    (38960, 0, "l");
    (38961, 0, "e");
    (38962, 0, "a");
    (38963, 0, "n");
    (38964, 0, " ");
    (39015, 0, ".");
    (39016, 0, " ");
    (39017, 0, "W");
    (39018, 0, "e");
    (39019, 0, "'");
    (39020, 0, "l");
    (39021, 0, "l");
    (39022, 0, " ");
    (39023, 0, "j");
    (39024, 0, "u");
    (39025, 0, "s");
    (39026, 0, "t");
    (39027, 0, " ");
    (39028, 0, "m");
    (39029, 0, "a");
    (39030, 0, "k");
    (39031, 0, "e");
    (39032, 0, " ");
    (39033, 0, "s");
    (39034, 0, "u");
    (39035, 0, "r");
    (39036, 0, "e");
    (39037, 0, " ");
    (39038, 0, "t");
    (39039, 0, "h");
    (39040, 0, "e");
    (39041, 0, " ");
    (39042, 0, "c");
    (39043, 0, "u");
    (39044, 0, "r");
    (39045, 0, "s");
    (39046, 0, "o");
    (39047, 0, "r");
    (39048, 0, " ");
    (39049, 0, "i");
    (39050, 0, "s");
    (39051, 0, " ");
    (39052, 0, "i");
    (39053, 0, "n");
    (39054, 0, " ");
    (39055, 0, "t");
    (39056, 0, "h");
    (39057, 0, "e");
    (39058, 0, " ");
    (39059, 0, "r");
    (39060, 0, "i");
    (39061, 0, "g");
    (39062, 0, "h");
    (39063, 0, "t");
    (39064, 0, " ");
    (39065, 0, "p");
    (39066, 0, "o");
    (39067, 0, "s");
    (39068, 0, "i");
    (39069, 0, "t");
    (39070, 0, "i");
    (39071, 0, "o");
    (39072, 0, "n");
    (39073, 0, " ");
    (39074, 0, "b");
    (39075, 0, "e");
    (39076, 0, "f");
    (39077, 0, "o");
    (39078, 0, "r");
    (39079, 0, "e");
    (39080, 0, " ");
    (39081, 0, "t");
    (39082, 0, "h");
    (39083, 0, "a");
    (39084, 0, "t");
    (39085, 0, " ");
    (39086, 0, "c");
    (39087, 0, "a");
    (39088, 0, "l");
    (39089, 0, "l");
    (39090, 0, " ");
    (39091, 0, "f");
    (39092, 0, "o");
    (39093, 0, "r");
    (39094, 0, " ");
    (39095, 0, "n");
    (39096, 0, "o");
    (39097, 0, "w");
    (39098, 0, ".");
    ( 38929,
      170,
      "                // There's no clean way to keep the cursor steady for \
       the final\n\
      \                // insert. We'll just make sure the cursor is in the \
       right\n\
      \                // position before that call for now." );
    (39229, 0, "\n                ");
    (39230, 16, "");
    (37268, 0, ",");
    (37269, 0, " ");
    (37270, 0, "\"");
    (37271, 0, "A");
    (37272, 0, "S");
    (37273, 0, "d");
    (37274, 0, "f");
    (37275, 0, "\"");
    (15631, 0, "\n");
    (15632, 0, "\n");
    (15633, 0, "i");
    (15634, 0, "m");
    (15635, 0, "p");
    (15636, 0, "l");
    (15637, 0, "<");
    (15638, 0, "C");
    (15639, 0, ":");
    (15640, 0, " ");
    (15641, 0, "L");
    (15642, 0, "i");
    (15643, 0, "s");
    (15641, 3, "ListConfig");
    (15651, 0, ">");
    (15652, 0, " ");
    (15653, 0, "f");
    (15654, 0, "m");
    (15655, 0, "t");
    (15656, 0, ":");
    (15657, 0, ":");
    (15658, 0, "D");
    (15659, 0, "e");
    (15660, 0, "b");
    (15661, 0, "u");
    (15662, 0, "g");
    (15663, 0, " ");
    (15664, 0, "f");
    (15665, 0, "o");
    (15666, 0, "r");
    (15667, 0, " ");
    (15668, 0, "C");
    (15669, 0, "u");
    (15670, 0, "r");
    (15671, 0, "s");
    (15672, 0, "o");
    (15673, 0, "r");
    (15674, 0, "<");
    (15675, 0, "C");
    (15676, 0, ">");
    (15677, 0, " ");
    (15678, 0, "{");
    (15679, 0, "\n    ");
    (15680, 4, "}");
    (15679, 0, "\n    ");
    (15680, 4, "");
    (843, 0, "\n");
    (844, 0, "\n");
    (845, 0, "u");
    (846, 0, "s");
    (847, 0, "e");
    (848, 0, " ");
    (849, 0, "s");
    (850, 0, "t");
    (851, 0, "d");
    (852, 0, ":");
    (853, 0, ":");
    (854, 0, "f");
    (855, 0, "m");
    (856, 0, "t");
    (857, 0, ";");
    (11383, 7, "");
    (15688, 0, "    ");
    (15692, 0, "f");
    (15693, 0, "n");
    (15694, 0, " ");
    (15695, 0, "f");
    (15696, 0, "m");
    (15697, 0, "t");
    (15698, 0, "(");
    (15699, 0, "&");
    (15700, 0, "s");
    (15701, 0, "e");
    (15702, 0, "l");
    (15703, 0, "f");
    (15704, 0, ",");
    (15705, 0, " ");
    (15706, 0, "f: &mut fmt::Formatter<'_>");
    (15732, 0, ")");
    (15733, 0, " ");
    (15734, 0, "-");
    (15735, 0, ">");
    (15736, 0, " ");
    (15737, 0, "f");
    (15738, 0, "m");
    (15739, 0, "t");
    (15740, 0, ":");
    (15741, 0, ":");
    (15742, 0, "R");
    (15743, 0, "e");
    (15744, 0, "s");
    (15745, 0, "u");
    (15742, 4, "Result");
    (15748, 0, " ");
    (15749, 0, "{");
    (15750, 0, "\n        ");
    (15759, 0, "\n        ");
    (15751, 8, "");
    (15752, 8, "    }");
    (15751, 0, "        ");
    (15759, 0, "f");
    (15760, 0, ".");
    (15761, 0, "d");
    (15762, 0, "e");
    (15763, 0, "b");
    (15764, 0, "u");
    (15761, 4, "debug_struct(name: &str)");
    (15784, 0, "\"");
    (15774, 0, "\"");
    (15775, 10, "C");
    (15776, 0, "u");
    (15777, 0, "r");
    (15778, 0, "s");
    (15779, 0, "o");
    (15780, 0, "r");
    (15783, 0, "\n        ");
    (15792, 0, "    ");
    (15796, 0, ".");
    (15797, 0, "f");
    (15798, 0, "i");
    (15799, 0, "e");
    (15800, 0, "l");
    (15801, 0, "d");
    (15802, 0, "(");
    (15803, 0, "\"");
    (15804, 0, "u");
    (15805, 0, "s");
    (15806, 0, "e");
    (15807, 0, "r");
    (15808, 0, "p");
    (15809, 0, "o");
    (15810, 0, "s");
    (15811, 0, "\"");
    (15812, 0, ",");
    (15813, 0, " ");
    (15814, 0, "&");
    (15815, 0, "s");
    (15816, 0, "e");
    (15817, 0, "l");
    (15818, 0, "f");
    (15819, 0, ".");
    (15820, 0, "u");
    (15821, 0, "s");
    (15822, 0, "e");
    (15823, 0, "r");
    (15824, 0, "p");
    (15825, 0, "o");
    (15826, 0, "s");
    (15827, 0, ")");
    (15828, 0, "\n            ");
    (15841, 0, ".");
    (15842, 0, "f");
    (15843, 0, "i");
    (15844, 0, "n");
    (15845, 0, "i");
    (15846, 0, "s");
    (15847, 0, "h");
    (15848, 0, "(");
    (15849, 0, ")");
    (15848, 0, "_");
    (15849, 0, "n");
    (15850, 0, "o");
    (15842, 9, "finish_non_exhaustive()");
    (15865, 1, "");
    (15865, 1, "");
    (15848, 15, "");
    (15784, 0, "            .field(\"userpos\", &self.userpos)\n");
    (15849, 7, "i");
    (15850, 0, "n");
    (15851, 0, "d");
    (15852, 0, "e");
    (15853, 0, "x");
    (15870, 0, "");
    (15863, 8, "l");
    (15864, 0, "o");
    (15865, 0, "c");
    (15866, 0, "a");
    (15867, 0, "l");
    (15863, 5, "local_index");
    (15849, 5, "l");
    (15850, 0, "o");
    (15851, 0, "c");
    (15852, 0, "a");
    (15853, 0, "l");
    (15854, 0, "_");
    (15855, 0, "i");
    (15856, 0, "n");
    (15857, 0, "d");
    (15858, 0, "e");
    (15859, 0, "x");
    (15881, 0, "\n            ");
    (15894, 0, "/");
    (15895, 0, "/");
    (15896, 0, " ");
    (15882, 15, "");
    (15881, 1, "");
    (37548, 8, "");
    (37353, 0, ",");
    (37354, 0, " ");
    (37355, 0, "p");
    (37356, 0, "l");
    (37357, 0, "u");
    (37358, 0, "s");
    (37359, 0, "_");
    (37360, 0, "i");
    (37361, 0, "n");
    (37362, 0, "d");
    (37362, 1, "");
    (37361, 1, "");
    (37360, 1, "");
    (37360, 0, "i");
    (37361, 0, "t");
    (37362, 0, "e");
    (37363, 0, "m");
    (37364, 0, "s");
    (37365, 0, ":");
    (37366, 0, " ");
    (37367, 0, "u");
    (37368, 0, "s");
    (37369, 0, "i");
    (37370, 0, "e");
    (37370, 1, "");
    (37370, 0, "z");
    (37371, 0, "e");
    (37532, 0, "\n            ");
    (37545, 0, "i");
    (37546, 0, "f");
    (37547, 0, " ");
    (37548, 0, "(");
    (37549, 0, "p");
    (37550, 0, "l");
    (37551, 0, "u");
    (37552, 0, "s");
    (37548, 5, "p");
    (37549, 0, "l");
    (37550, 0, "u");
    (37548, 3, "plus_items");
    (37558, 0, " ");
    (37559, 0, ">");
    (37560, 0, " ");
    (37561, 0, "0");
    (37562, 0, " ");
    (37563, 0, "{");
    (37564, 0, "\n                ");
    (37565, 16, "");
    (37493, 0, "m");
    (37494, 0, "u");
    (37495, 0, "t");
    (37496, 0, " ");
    (37569, 0, "                ");
    (37585, 0, "c");
    (37586, 0, "2");
    (37587, 0, ".");
    (37588, 0, "advance_by_items(num: usize, height: u8)");
    (37605, 10, "p");
    (37606, 0, "l");
    (37607, 0, "u");
    (37608, 0, "s");
    (37609, 0, "_");
    (37610, 0, "i");
    (37611, 0, "t");
    (37612, 0, "e");
    (37613, 0, "m");
    (37614, 0, "s");
    (37617, 10, "s");
    (37618, 0, "e");
    (37619, 0, "l");
    (37620, 0, "f");
    (37621, 0, ".");
    (37622, 0, "h");
    (37623, 0, "e");
    (37624, 0, "i");
    (37625, 0, "g");
    (37622, 4, "h");
    (37623, 0, "e");
    (37624, 0, "a");
    (37625, 0, "d");
    (37626, 0, ".");
    (37627, 0, "h");
    (37628, 0, "e");
    (37629, 0, "i");
    (37627, 3, "height");
    (37634, 0, ";");
    (37537, 31, "");
    (37536, 1, "");
    (37537, 16, "            ");
    (38741, 32, "");
    (38741, 0, ",");
    (38742, 0, " ");
    (38743, 0, "c");
    (38744, 0, "o");
    (38745, 0, "n");
    (38746, 0, "t");
    (38747, 0, "e");
    (38748, 0, "n");
    (38749, 0, "t");
    (38750, 0, "s");
    (38751, 0, ".");
    (38752, 0, "l");
    (38753, 0, "e");
    (38754, 0, "n");
    (38755, 0, "(");
    (38756, 0, ")");
    (39504, 75, "self.dbg_check_cursor_at(&cursor, userpos, contents.len());");
    (7411, 0, "O");
    (7412, 0, "p");
    (7413, 0, "t");
    (7414, 0, "i");
    (7415, 0, "o");
    (7416, 0, "n");
    (7417, 0, "<");
    (7426, 0, ">");
    (16409, 0, "\n    ");
    (16414, 0, "\n    ");
    (16410, 4, "");
    (16415, 0, "p");
    (16416, 0, "u");
    (16417, 0, "b");
    (16418, 0, " ");
    (16419, 0, "f");
    (16420, 0, "n");
    (16421, 0, " ");
    (16422, 0, "I");
    (16422, 1, "");
    (16422, 0, "i");
    (16423, 0, "n");
    (16424, 0, "i");
    (16425, 0, "t");
    (16426, 0, "_");
    (16427, 0, "r");
    (16428, 0, "a");
    (16429, 0, "n");
    (16430, 0, "d");
    (16431, 0, "_");
    (16432, 0, "f");
    (16433, 0, "r");
    (16433, 1, "");
    (16432, 1, "");
    (16431, 1, "");
    (16430, 1, "");
    (16429, 1, "");
    (16428, 1, "");
    (16428, 0, "n");
    (16429, 0, "g");
    (16430, 0, "_");
    (16431, 0, "f");
    (16432, 0, "r");
    (16433, 0, "o");
    (16434, 0, "m");
    (16435, 0, "_");
    (16436, 0, "s");
    (16437, 0, "e");
    (16438, 0, "e");
    (16439, 0, "d");
    (16440, 0, "(");
    (16441, 0, "s");
    (16442, 0, "e");
    (16443, 0, "e");
    (16444, 0, "d");
    (16445, 0, ":");
    (16446, 0, " ");
    (16447, 0, "u");
    (16448, 0, "6");
    (16449, 0, "4");
    (16450, 0, ")");
    (16451, 0, " ");
    (16452, 0, "-");
    (16452, 1, "");
    (16452, 0, "{");
    (16453, 0, "\n        ");
    (16462, 0, "\n        ");
    (16454, 8, "");
    (16455, 8, "    }");
    (16079, 28, "");
    (16079, 0, "N");
    (16080, 0, "o");
    (16081, 0, "n");
    (16082, 0, "e");
    (16417, 0, "&");
    (16418, 0, "m");
    (16419, 0, "u");
    (16420, 0, "t");
    (16421, 0, " ");
    (16422, 0, "s");
    (16423, 0, "e");
    (16424, 0, "l");
    (16425, 0, "f");
    (16426, 0, ",");
    (16427, 0, " ");
    (16441, 0, "SmallRng::seed_from_u64(123)");
    (16441, 0, "        ");
    (16449, 0, "s");
    (16450, 0, "e");
    (16451, 0, "l");
    (16452, 0, "f");
    (16453, 0, ".");
    (16454, 0, "r");
    (16455, 0, "n");
    (16456, 0, "g");
    (16457, 0, " ");
    (16458, 0, "=");
    (16459, 0, " ");
    (16460, 0, "S");
    (16461, 0, "o");
    (16462, 0, "m");
    (16463, 0, "e");
    (16464, 0, "(");
    (16493, 0, ")");
    (16492, 0, "=");
    (16493, 0, "=");
    (16494, 0, "=");
    (16495, 0, "=");
    (16495, 1, "");
    (16494, 1, "");
    (16493, 1, "");
    (16492, 1, "");
    (16491, 1, "");
    (16490, 1, "");
    (16489, 1, "");
    (16489, 0, "s");
    (16490, 0, "e");
    (16491, 0, "e");
    (16492, 0, "d");
    (16495, 0, "\n        ");
    (16504, 0, "S");
    (16505, 0, "m");
    (16506, 0, "a");
    (16507, 0, "l");
    (16508, 0, "l");
    (16504, 5, "SmallRng");
    (16512, 0, ":");
    (16513, 0, ":");
    (16514, 0, "f");
    (16515, 0, "r");
    (16516, 0, "o");
    (16517, 0, "m");
    (16518, 0, "_");
    (16519, 0, "e");
    (16520, 0, "n");
    (16521, 0, "t");
    (16522, 0, "r");
    (16523, 0, "o");
    (16524, 0, "p");
    (16525, 0, "y");
    (16526, 0, "(");
    (16527, 0, ")");
    (16528, 0, ";");
    (16495, 0, ";");
    (23527, 0, "\n        ");
    (23536, 0, "i");
    (23537, 0, "f");
    (23538, 0, " ");
    (23539, 0, "s");
    (23540, 0, "e");
    (23541, 0, "l");
    (23542, 0, "f");
    (23543, 0, ".");
    (23544, 0, "r");
    (23545, 0, "n");
    (23546, 0, "g");
    (23547, 0, " ");
    (23547, 1, "");
    (23547, 0, ".");
    (23548, 0, "i");
    (23549, 0, "s");
    (23550, 0, "_");
    (23548, 3, "is_none()");
    (23557, 0, "n");
    (23557, 1, "");
    (23557, 0, " ");
    (23558, 0, "{");
    (23559, 0, "\n            ");
    (23572, 0, "s");
    (23573, 0, "e");
    (23574, 0, "l");
    (23575, 0, "f");
    (23576, 0, ".");
    (23577, 0, "r");
    (23578, 0, "n");
    (23579, 0, "g");
    (23580, 0, " ");
    (23581, 0, "=");
    (23582, 0, " ");
    (23583, 0, "S");
    (23584, 0, "o");
    (23585, 0, "n");
    (23586, 0, "e");
    (23587, 0, "(");
    (16497, 33, "");
    (16496, 1, "");
    (23551, 1, "");
    (23551, 0, "m");
    (23554, 0, "        SmallRng::from_entropy();");
    (23561, 1, "");
    (23560, 1, "");
    (23559, 1, "");
    (23558, 1, "");
    (23557, 1, "");
    (23556, 1, "");
    (23555, 1, "");
    (23554, 1, "");
    (23578, 1, "");
    (23578, 0, ")");
    (23579, 0, ";");
    (23580, 0, "\n            ");
    (23581, 12, "        }");
    (23590, 0, "\n        ");
    (23648, 0, ".");
    (23591, 8, "");
    (23641, 0, "u");
    (23642, 0, "n");
    (23643, 0, "w");
    (23644, 0, "r");
    (23641, 4, "unwrap()");
    (23648, 1, "");
    (23647, 1, "");
    (23646, 1, "");
    (23645, 1, "");
    (23644, 1, "");
    (23643, 1, "");
    (23642, 1, "");
    (23641, 1, "");
    (23640, 1, "");
    (23640, 0, ".");
    (23641, 0, "a");
    (23642, 0, "s");
    (23641, 2, "as_deref_mut()");
    (23655, 0, ".");
    (23656, 0, "u");
    (23657, 0, "n");
    (23658, 0, "w");
    (23659, 0, "r");
    (23660, 0, "a");
    (23656, 5, "unwrap()");
    (23649, 1, "");
    (23648, 1, "");
    (23647, 1, "");
    (23646, 1, "");
    (23645, 1, "");
    (23644, 1, "");
    (23591, 0, "\n        ");
    (23600, 0, "/");
    (23601, 0, "/");
    (23602, 0, " ");
    (23603, 0, "r");
    (23604, 0, "n");
    (23605, 0, "g");
    (23606, 0, " ");
    (23607, 0, "c");
    (23608, 0, "o");
    (23609, 0, "d");
    (23610, 0, "e");
    (23611, 0, " ");
    (23612, 0, "h");
    (23613, 0, "e");
    (23614, 0, "r");
    (23615, 0, "e");
    (23616, 0, " ");
    (23617, 0, "i");
    (23618, 0, "s");
    (23619, 0, " ");
    (23620, 0, "a");
    (23621, 0, " ");
    (23622, 0, "b");
    (23623, 0, "i");
    (23624, 0, "t");
    (23625, 0, " ");
    (23626, 0, "u");
    (23627, 0, "g");
    (23628, 0, "l");
    (23629, 0, "y");
    (23630, 0, ".");
    (23631, 0, " ");
    (22906, 0, "\n    ");
    (22911, 0, "\n    ");
    (22907, 4, "");
    (22912, 0, "f");
    (22913, 0, "n");
    (22914, 0, " ");
    (22915, 0, "g");
    (22916, 0, "e");
    (22917, 0, "t");
    (22918, 0, "_");
    (22919, 0, "r");
    (22920, 0, "n");
    (22921, 0, "g");
    (22922, 0, "(");
    (22923, 0, "&");
    (22924, 0, "m");
    (22925, 0, "u");
    (22926, 0, "t");
    (22927, 0, " ");
    (22928, 0, "s");
    (22929, 0, "e");
    (22930, 0, "l");
    (22931, 0, "f");
    (22932, 0, ")");
    (22933, 0, " ");
    (22934, 0, "-");
    (22935, 0, ">");
    (22936, 0, " ");
    (22937, 0, "&");
    (22938, 0, "m");
    (22939, 0, "u");
    (22940, 0, "t");
    (22941, 0, " ");
    (22942, 0, "S");
    (22943, 0, "m");
    (22944, 0, "a");
    (22942, 3, "SmallRng");
    (22950, 0, " ");
    (22951, 0, "{");
    (22952, 0, "\n        ");
    (22961, 0, "\n        ");
    (22953, 8, "");
    (22954, 8, "    }");
    ( 22953,
      0,
      "        if self.rng.is_none() {\n\
      \            self.rng = Some(SmallRng::from_entropy());\n\
      \        }\n\n\
      \        // rng code here is a bit ugly. \n\
      \        let new_node = Node::alloc(&mut self.rng.as_mut().unwrap());\n"
    );
    (23160, 1, "");
    (23159, 1, "");
    (23158, 1, "");
    (23100, 32, "");
    (23720, 139, "");
    (23785, 1, "");
    (23784, 1, "");
    (23783, 1, "");
    (23782, 1, "");
    (23781, 1, "");
    (23780, 1, "");
    (23779, 1, "");
    (23778, 1, "");
    (23777, 1, "");
    (23776, 1, "");
    (23775, 1, "");
    (23774, 1, "");
    (23773, 1, "");
    (23772, 1, "");
    (23771, 1, "");
    (23770, 1, "");
    (23769, 1, "");
    (23768, 1, "");
    (23767, 1, "");
    (23766, 1, "");
    (23765, 1, "");
    (23764, 1, "");
    (23763, 1, "");
    (23762, 1, "");
    (23761, 1, "");
    (23760, 1, "");
    (23759, 1, "");
    (23758, 1, "");
    (23757, 1, "");
    (23756, 1, "");
    (23755, 1, "");
    (23755, 0, "s");
    (23756, 0, "e");
    (23757, 0, "l");
    (23758, 0, "f");
    (23759, 0, ".");
    (23760, 0, "g");
    (23761, 0, "e");
    (23762, 0, "t");
    (23763, 0, "_");
    (23764, 0, "r");
    (23765, 0, "n");
    (23766, 0, "g");
    (23760, 7, "get_rng()");
    (22952, 0, "\n        ");
    (22961, 0, "/");
    (22962, 0, "/");
    (22963, 0, " ");
    (22964, 0, "I");
    (22965, 0, "'");
    (22966, 0, "m");
    (22967, 0, " ");
    (22968, 0, "s");
    (22969, 0, "u");
    (22970, 0, "r");
    (22971, 0, "e");
    (22972, 0, " ");
    (22973, 0, "t");
    (22974, 0, "h");
    (22975, 0, "e");
    (22976, 0, "r");
    (22977, 0, "e");
    (22978, 0, "'");
    (22979, 0, "s");
    (22980, 0, " ");
    (22981, 0, " ");
    (22981, 1, "");
    (22981, 0, "a");
    (22982, 0, " ");
    (22983, 0, "n");
    (22984, 0, "i");
    (22985, 0, "c");
    (22986, 0, "e");
    (22987, 0, "r");
    (22988, 0, " ");
    (22989, 0, "w");
    (22990, 0, "a");
    (22991, 0, "y");
    (22992, 0, " ");
    (22993, 0, "t");
    (22994, 0, "o");
    (22995, 0, " ");
    (22996, 0, "i");
    (22997, 0, "m");
    (22998, 0, "p");
    (22999, 0, "l");
    (23000, 0, "e");
    (23001, 0, "m");
    (23002, 0, "e");
    (23003, 0, "n");
    (23004, 0, "t");
    (23005, 0, " ");
    (23006, 0, "t");
    (23007, 0, "h");
    (23008, 0, "i");
    (23009, 0, "s");
    (23010, 0, ".");
    (23109, 42, "");
    (22907, 243, "");
    ( 16503,
      0,
      "\n\
      \    fn get_rng(&mut self) -> &mut SmallRng {\n\
      \        // I'm sure there's a nicer way to implement this.\n\
      \        if self.rng.is_none() {\n\
      \            self.rng = Some(SmallRng::from_entropy());\n\
      \        }\n\
      \        self.rng.as_mut().unwrap()\n\
      \    }\n" );
    (1667, 0, "\n");
    (1668, 0, "\n");
    (1669, 0, "t");
    (1670, 0, "y");
    (1671, 0, "p");
    (1672, 0, "e");
    (1673, 0, "d");
    (1674, 0, "e");
    (1675, 0, "f");
    (1676, 0, " ");
    (1669, 8, "s");
    (1670, 0, "t");
    (1671, 0, "r");
    (1672, 0, "u");
    (1673, 0, "c");
    (1674, 0, "t");
    (1675, 0, " ");
    (1676, 0, "I");
    (1677, 0, "t");
    (1678, 0, "e");
    (1679, 0, "m");
    (1680, 0, "M");
    (1681, 0, "a");
    (1682, 0, "r");
    (1683, 0, "k");
    (1684, 0, "e");
    (1685, 0, "r");
    (1686, 0, " ");
    (1687, 0, "{");
    (1688, 0, "\n    ");
    (1693, 0, "\n    ");
    (1689, 4, "");
    (1690, 4, "}");
    (1689, 0, "    ");
    (1693, 0, "p");
    (1694, 0, "t");
    (1695, 0, "r");
    (1696, 0, ":");
    (1697, 0, " ");
    (1669, 0, "p");
    (1670, 0, "u");
    (1671, 0, "b");
    (1672, 0, " ");
    (1702, 0, "*");
    (1703, 0, "m");
    (1704, 0, "u");
    (1705, 0, "t");
    (1706, 0, " ");
    (1707, 0, "N");
    (1708, 0, "o");
    (1709, 0, "d");
    (1710, 0, "e");
    (1690, 0, "<");
    (1691, 0, "C");
    (1692, 0, ":");
    (1693, 0, " ");
    (1694, 0, "L");
    (1695, 0, "i");
    (1696, 0, "s");
    (1697, 0, "t");
    (1698, 0, "C");
    (1699, 0, "o");
    (1700, 0, "n");
    (1694, 7, "ListConfig");
    (1704, 0, ">");
    (1726, 0, "<");
    (1727, 0, "C");
    (1728, 0, ">");
    (1729, 0, ",");
    (1730, 0, "\n    ");
    (1735, 0, "_");
    (1736, 0, "p");
    (1737, 0, "h");
    (1738, 0, "a");
    (1739, 0, "n");
    (1740, 0, "t");
    (1741, 0, "o");
    (1742, 0, "n");
    (1743, 0, ":");
    (1744, 0, " ");
    (1745, 0, "P");
    (1746, 0, "h");
    (1747, 0, "a");
    (1748, 0, "n");
    (1749, 0, "t");
    (1750, 0, "o");
    (1751, 0, "m");
    (1752, 0, "D");
    (1753, 0, "a");
    (1754, 0, "t");
    (1755, 0, "a");
    (1691, 0, "'");
    (1692, 0, "a");
    (1693, 0, ",");
    (1694, 0, " ");
    (1760, 0, "<");
    (1761, 0, "'");
    (1762, 0, "a");
    (1763, 0, ">");
    (843, 0, "\n");
    (844, 0, "u");
    (845, 0, "s");
    (846, 0, "e");
    (847, 0, " ");
    (848, 0, "s");
    (849, 0, "t");
    (850, 0, "d");
    (851, 0, ":");
    (852, 0, ":");
    (853, 0, "m");
    (854, 0, "a");
    (855, 0, "r");
    (856, 0, "k");
    (857, 0, "e");
    (858, 0, "r");
    (859, 0, ":");
    (860, 0, ":");
    (861, 0, "P");
    (862, 0, "h");
    (863, 0, "a");
    (864, 0, "n");
    (861, 4, "PhantomData");
    (872, 0, ";");
    (1791, 0, "&");
    (1794, 0, " ");
    (1795, 0, "S");
    (1796, 0, "k");
    (1797, 0, "i");
    (1798, 0, "p");
    (1795, 4, "SkipList");
    (1803, 0, "<");
    (1804, 0, "C");
    (1805, 0, ">");
    (2598, 0, "\n    ");
    (2603, 0, "\n    ");
    (2599, 4, "");
    (2600, 4, "");
    (2599, 0, "\n    ");
    (2600, 4, "");
    (2599, 1, "");
    (2598, 1, "");
    (2598, 0, "\n    ");
    (2603, 0, "f");
    (2604, 0, "n");
    (2605, 0, " ");
    (2606, 0, "n");
    (2607, 0, "o");
    (2608, 0, "t");
    (2609, 0, "i");
    (2610, 0, "f");
    (2611, 0, "y");
    (2612, 0, "(");
    (2613, 0, "&");
    (2614, 0, "m");
    (2615, 0, "u");
    (2616, 0, "t");
    (2617, 0, " ");
    (2618, 0, "S");
    (2618, 1, "");
    (2618, 0, "s");
    (2619, 0, "e");
    (2620, 0, "l");
    (2621, 0, "f");
    (2622, 0, ",");
    (2623, 0, " ");
    (2624, 0, "i");
    (2625, 0, "t");
    (2626, 0, "e");
    (2627, 0, "m");
    (2628, 0, ":");
    (2629, 0, " ");
    (2630, 0, "&");
    (2631, 0, "S");
    (2632, 0, "e");
    (2633, 0, "l");
    (2634, 0, "f");
    (2635, 0, ":");
    (2636, 0, ":");
    (2637, 0, "I");
    (2638, 0, "t");
    (2639, 0, "e");
    (2640, 0, "m");
    (2641, 0, ",");
    (2642, 0, " ");
    (2643, 0, "m");
    (2644, 0, "a");
    (2645, 0, "r");
    (2646, 0, "k");
    (2647, 0, "e");
    (2648, 0, "r");
    (2649, 0, ":");
    (2650, 0, " ");
    (2643, 0, "a");
    (2644, 0, "t");
    (2645, 0, "_");
    (2654, 0, "I");
    (2655, 0, "t");
    (2656, 0, "e");
    (2657, 0, "m");
    (2658, 0, "M");
    (2654, 5, "ItemMarker");
    (2664, 0, ")");
    (2665, 0, "{");
    (2665, 1, "");
    (2665, 0, " ");
    (2666, 0, "{");
    (2667, 0, "\n        ");
    (2668, 8, "    }");
    (2664, 0, "<");
    (2665, 0, "C");
    (2666, 0, ">");
    (2665, 1, "");
    (2665, 0, "S");
    (2666, 0, "e");
    (2667, 0, "l");
    (2668, 0, "f");
    (1937, 0, " ");
    (1938, 0, "+");
    (1939, 0, " ");
    (1940, 0, "S");
    (1941, 0, "i");
    (1942, 0, "z");
    (1943, 0, "e");
    (1944, 0, "d");
    (1769, 0, "// ");
    (1724, 1, "");
    (1723, 1, "");
    (1722, 1, "");
    (1721, 1, "");
    (1721, 0, "'a, ");
    (1769, 3, "");
    (1738, 0, " ");
    (1739, 0, "+");
    (1740, 0, " ");
    (1741, 0, "S");
    (1742, 0, "i");
    (1743, 0, "z");
    (1744, 0, "e");
    (1745, 0, "d");
    (2687, 0, " ");
    (2688, 0, "w");
    (2689, 0, "h");
    (2690, 0, "e");
    (2691, 0, "r");
    (2692, 0, "e");
    (2693, 0, " ");
    (2694, 0, "S");
    (2695, 0, "e");
    (2696, 0, "l");
    (2697, 0, "f");
    (2698, 0, ":");
    (2699, 0, " ");
    (2700, 0, "S");
    (2701, 0, "i");
    (2702, 0, "z");
    (2703, 0, "e");
    (2704, 0, "d");
    (2640, 0, "_");
    (2660, 0, "_");
    (1738, 8, "");
    (1937, 8, "");
    (5518, 0, "\n    ");
    (5523, 0, "\n    ");
    (5519, 4, "");
    (5524, 0, "/");
    (5525, 0, "/");
    (5526, 0, " ");
    (5527, 0, "T");
    (5528, 0, "h");
    (5529, 0, "e");
    (5530, 0, "r");
    (5531, 0, "e");
    (5532, 0, "'");
    (5533, 0, "s");
    (5534, 0, " ");
    (5535, 0, "a");
    (5536, 0, " ");
    (5537, 0, "l");
    (5538, 0, "o");
    (5539, 0, "t");
    (5540, 0, " ");
    (5541, 0, "o");
    (5542, 0, "f");
    (5543, 0, " ");
    (5544, 0, "w");
    (5545, 0, "a");
    (5546, 0, "y");
    (5547, 0, " ");
    (5547, 1, "");
    (5547, 0, "s");
    (5548, 0, " ");
    (5549, 0, "I");
    (5550, 0, " ");
    (5551, 0, "c");
    (5552, 0, "o");
    (5553, 0, "u");
    (5554, 0, "l");
    (5555, 0, "d");
    (5556, 0, " ");
    (5557, 0, "s");
    (5558, 0, "o");
    (5559, 0, "l");
    (5560, 0, "v");
    (5561, 0, "e");
    (5562, 0, " ");
    (5527, 36, "W");
    (5528, 0, "i");
    (5529, 0, "t");
    (5530, 0, "h");
    (5531, 0, " ");
    (5532, 0, "t");
    (5533, 0, "h");
    (5534, 0, "e");
    (5535, 0, " ");
    (5532, 4, "e");
    (5533, 0, "v");
    (5534, 0, "e");
    (5535, 0, "r");
    (5536, 0, "y");
    (5537, 0, "t");
    (5538, 0, "h");
    (5539, 0, "i");
    (5540, 0, "n");
    (5541, 0, "g");
    (5542, 0, " ");
    (5543, 0, "e");
    (5544, 0, "l");
    (5545, 0, "s");
    (5546, 0, "e");
    (5547, 0, ",");
    (5548, 0, " ");
    (5549, 0, "w");
    (5550, 0, "e");
    (5551, 0, " ");
    (5552, 0, "h");
    (5553, 0, "a");
    (5554, 0, "v");
    (5555, 0, "e");
    (5556, 0, " ");
    (5557, 0, "n");
    (5558, 0, "o");
    (5559, 0, " ");
    (5560, 0, "w");
    (5561, 0, "a");
    (5562, 0, "y");
    (5563, 0, " ");
    (5564, 0, "t");
    (5565, 0, "o");
    (5566, 0, " ");
    (5567, 0, "g");
    (5568, 0, "o");
    (5569, 0, " ");
    (5570, 0, "f");
    (5571, 0, "r");
    (5572, 0, "o");
    (5573, 0, "m");
    (5574, 0, " ");
    (5575, 0, "a");
    (5576, 0, " ");
    (5577, 0, "m");
    (5578, 0, "a");
    (5579, 0, "r");
    (5580, 0, "k");
    (5581, 0, "e");
    (5582, 0, "r");
    (5583, 0, " ");
    (5584, 0, "(");
    (5585, 0, "n");
    (5586, 0, "o");
    (5587, 0, "d");
    (5588, 0, "e");
    (5589, 0, " ");
    (5590, 0, "+");
    (5591, 0, " ");
    (1937, 0, " ");
    (1938, 0, "+");
    (1939, 0, " ");
    (1940, 0, "P");
    (1941, 0, "a");
    (1942, 0, "r");
    (1943, 0, "t");
    (1944, 0, "i");
    (1945, 0, "a");
    (1946, 0, "l");
    (1940, 7, "PartialEq");
    (5539, 23, "W");
    (5539, 0, "A");
    (5540, 0, "l");
    (5541, 0, "o");
    (5542, 0, "n");
    (5543, 0, "e");
    (5544, 0, ",");
    (5545, 0, " ");
    (5539, 7, "");
    (5539, 43, "W");
    (5540, 0, "i");
    (5541, 0, "t");
    (5542, 0, "h");
    (5543, 0, "t");
    (5544, 0, " ");
    (5545, 0, "h");
    (5546, 0, "e");
    (5546, 1, "");
    (5545, 1, "");
    (5544, 1, "");
    (5543, 1, "");
    (5543, 0, " ");
    (5544, 0, "t");
    (5545, 0, "h");
    (5546, 0, "e");
    (5547, 0, " ");
    (5548, 0, "h");
    (5549, 0, "e");
    (5550, 0, "a");
    (5551, 0, "d");
    (5552, 0, "s");
    (5553, 0, " ");
    (5554, 0, "a");
    (5555, 0, "r");
    (5556, 0, "r");
    (5557, 0, "a");
    (5558, 0, "y");
    (5559, 0, "s");
    (5560, 0, " ");
    (5560, 1, "");
    (5559, 1, "");
    (5559, 0, " ");
    (5560, 0, "a");
    (5561, 0, "s");
    (5562, 0, " ");
    (5563, 0, "i");
    (5564, 0, "s");
    (5565, 0, ",");
    (5566, 0, " ");
    (5567, 0, "w");
    (5568, 0, "e");
    (5569, 0, " ");
    (5570, 0, "h");
    (5571, 0, "a");
    (5572, 0, "v");
    (5573, 0, "e");
    (5574, 0, " ");
    (5575, 0, "n");
    (5576, 0, "o");
    (5577, 0, " ");
    (5578, 0, "i");
    (5578, 1, "");
    (5578, 0, "w");
    (5579, 0, "a");
    (5580, 0, "y");
    (5581, 0, " ");
    (5582, 0, "t");
    (5583, 0, "o");
    (5584, 0, " ");
    (5585, 0, "f");
    (5586, 0, "r");
    (5587, 0, "o");
    (5588, 0, "m");
    (5589, 0, " ");
    (5589, 1, "");
    (5588, 1, "");
    (5587, 1, "");
    (5586, 1, "");
    (5585, 1, "");
    (5585, 0, "g");
    (5586, 0, "o");
    (5587, 0, " ");
    (5588, 0, "f");
    (5589, 0, "r");
    (5590, 0, "o");
    (5591, 0, "m");
    (5592, 0, " ");
    (5593, 0, "a");
    (5594, 0, " ");
    (5595, 0, "m");
    (5596, 0, "a");
    (5597, 0, "r");
    (5598, 0, "k");
    (5599, 0, "e");
    (5600, 0, "r");
    (5601, 0, " ");
    (5602, 0, "b");
    (5603, 0, "a");
    (5604, 0, "c");
    (5605, 0, "k");
    (5606, 0, " ");
    (5607, 0, "t");
    (5608, 0, " ");
    (5609, 0, "a");
    (5609, 1, "");
    (5608, 1, "");
    (5608, 0, "o");
    (5609, 0, " ");
    (5610, 0, "a");
    (5611, 0, " ");
    (5612, 0, "c");
    (5613, 0, "u");
    (5614, 0, "r");
    (5615, 0, "s");
    (5616, 0, "o");
    (5617, 0, "r");
    (5618, 0, " ");
    (5619, 0, "(");
    (5620, 0, "w");
    (5621, 0, "h");
    (5622, 0, "i");
    (5623, 0, "c");
    (5624, 0, "h");
    (5625, 0, " ");
    (5626, 0, "i");
    (5627, 0, "s");
    (5628, 0, " ");
    (5629, 0, "r");
    (5630, 0, "e");
    (5631, 0, "q");
    (5632, 0, "u");
    (5633, 0, "i");
    (5634, 0, "r");
    (5635, 0, "e");
    (5636, 0, "d");
    (5637, 0, " ");
    (5638, 0, "t");
    (5639, 0, "o");
    (5640, 0, " ");
    (5641, 0, "i");
    (5642, 0, "n");
    (5643, 0, "s");
    (5644, 0, "e");
    (5645, 0, "r");
    (5646, 0, "t");
    (5647, 0, " ");
    (5648, 0, "a");
    (5649, 0, "t");
    (5650, 0, " ");
    (5651, 0, "t");
    (5652, 0, "h");
    (5653, 0, "a");
    (5654, 0, "t");
    (5655, 0, " ");
    (5656, 0, "l");
    (5657, 0, "o");
    (5658, 0, "c");
    (5659, 0, "a");
    (5660, 0, "t");
    (5661, 0, "i");
    (5662, 0, "o");
    (5663, 0, " ");
    (5664, 0, "i");
    (5665, 0, "n");
    (5665, 1, "");
    (5664, 1, "");
    (5663, 1, "");
    (5663, 0, "n");
    (5664, 0, " ");
    (5665, 0, "i");
    (5666, 0, "n");
    (5667, 0, " ");
    (5668, 0, "t");
    (5669, 0, "h");
    (5670, 0, "e");
    (5671, 0, " ");
    (5672, 0, "l");
    (5673, 0, "i");
    (5674, 0, "s");
    (5675, 0, "t");
    (5676, 0, ")");
    (5677, 0, ".");
    ( 5532,
      146,
      "    // With the heads array as is, we have no way to go from a marker \
       back to a\n\
      \    // cursor (which is required to insert at that location in the \
       list)." );
    (5685, 0, " ");
    (5686, 0, "F");
    (5687, 0, "o");
    (5688, 0, "r");
    (5689, 0, " ");
    (5690, 0, "t");
    (5691, 0, "h");
    (5692, 0, "a");
    (5693, 0, "t");
    (5694, 0, " ");
    (5695, 0, "w");
    (5696, 0, "e");
    (5697, 0, " ");
    (5698, 0, "n");
    (5699, 0, "e");
    (5700, 0, "e");
    (5701, 0, "d");
    (5702, 0, " ");
    (5537, 0, "/");
    (5619, 0, "/");
    (5705, 0, "t");
    (5706, 0, "o");
    (5707, 0, " ");
    (5708, 0, "b");
    (5709, 0, "e");
    (5710, 0, " ");
    (5711, 0, "a");
    (5712, 0, "b");
    (5713, 0, "l");
    (5714, 0, "e");
    (5715, 0, " ");
    (5716, 0, "t");
    (5717, 0, "o");
    (5718, 0, " ");
    (5719, 0, "f");
    (5720, 0, "i");
    (5721, 0, "g");
    (5722, 0, "u");
    (5723, 0, "r");
    (5724, 0, "e");
    (5725, 0, " ");
    (5726, 0, "o");
    (5727, 0, "u");
    (5728, 0, "t");
    (5729, 0, " ");
    (5730, 0, "a");
    (5731, 0, "t");
    (5732, 0, " ");
    (5733, 0, "e");
    (5734, 0, "a");
    (5735, 0, "c");
    (5736, 0, "h");
    (5737, 0, " ");
    (5738, 0, "l");
    (5739, 0, "e");
    (5740, 0, "v");
    (5741, 0, "e");
    (5742, 0, "l");
    (5743, 0, " ");
    (5744, 0, "o");
    (5745, 0, "f");
    (5746, 0, " ");
    (5747, 0, "t");
    (5748, 0, "h");
    (5749, 0, "e");
    (5750, 0, " ");
    (5751, 0, "n");
    (5752, 0, "e");
    (5753, 0, "x");
    (5754, 0, "t");
    (5755, 0, "s");
    (5756, 0, " ");
    (5757, 0, "p");
    (5758, 0, "o");
    (5759, 0, "i");
    (5760, 0, "n");
    (5761, 0, "t");
    (5762, 0, "e");
    (5763, 0, "r");
    (5764, 0, "s");
    (5765, 0, " ");
    (5766, 0, "w");
    (5767, 0, "h");
    (5768, 0, "i");
    (5769, 0, "c");
    (5770, 0, "h");
    (5771, 0, " ");
    (5772, 0, "o");
    (5773, 0, "b");
    (5774, 0, "j");
    (5775, 0, "e");
    (5776, 0, "c");
    (5777, 0, "t");
    (5778, 0, "s");
    (5772, 7, "o");
    (5773, 0, "b");
    (5774, 0, "j");
    (5775, 0, "e");
    (5776, 0, "c");
    (5777, 0, "t");
    (5778, 0, " ");
    (5779, 0, "p");
    (5780, 0, "o");
    (5781, 0, "i");
    (5782, 0, "n");
    (5783, 0, "t");
    (5784, 0, "s");
    (5785, 0, " ");
    (5786, 0, "t");
    (5787, 0, "o");
    (5788, 0, " ");
    (5789, 0, "u");
    (5790, 0, "s");
    (5791, 0, ",");
    (5792, 0, " ");
    (5793, 0, "a");
    (5794, 0, "n");
    (5795, 0, "d");
    (5796, 0, " ");
    (5797, 0, "h");
    (5798, 0, "o");
    (5799, 0, "w");
    (5800, 0, " ");
    (5801, 0, "f");
    (5802, 0, "a");
    (5803, 0, "r");
    (5804, 0, " ");
    (5805, 0, "i");
    (5806, 0, "n");
    (5807, 0, "t");
    (5808, 0, "o");
    (5809, 0, " ");
    (5810, 0, "t");
    (5811, 0, "h");
    (5812, 0, "e");
    ( 5613,
      200,
      "    /// cursor (which is required to insert at that location in the \
       list). For\n\
      \    /// that we need to be able to figure out at each level of the nexts\n\
      \    /// pointers which object points to us, and how far into the" );
    (5813, 16, "t");
    (5814, 0, "h");
    (5815, 0, "e");
    (5816, 0, " ");
    (5817, 0, "o");
    (5818, 0, "f");
    (5819, 0, "f");
    (5820, 0, "s");
    (5821, 0, "e");
    (5822, 0, "t");
    (5823, 0, " ");
    (5824, 0, "f");
    (5825, 0, "r");
    (5826, 0, "o");
    (5827, 0, "m");
    (5828, 0, " ");
    (5829, 0, "t");
    (5830, 0, "h");
    (5831, 0, "a");
    (5832, 0, "t");
    (5833, 0, " ");
    (5834, 0, "e");
    (5835, 0, "l");
    (5836, 0, "e");
    (5837, 0, "m");
    (5838, 0, "e");
    (5839, 0, "n");
    (5840, 0, "t");
    (5841, 0, " ");
    (5842, 0, "t");
    (5843, 0, "o");
    (5844, 0, " ");
    (5845, 0, "t");
    (5846, 0, "h");
    (5847, 0, "e");
    (5848, 0, " ");
    (5849, 0, "c");
    (5850, 0, "u");
    (5851, 0, "r");
    (5852, 0, "r");
    (5853, 0, "e");
    (5854, 0, "n");
    (5855, 0, "t");
    (5856, 0, " ");
    (5857, 0, "e");
    (5858, 0, "l");
    (5859, 0, "e");
    (5860, 0, "m");
    (5861, 0, "e");
    (5862, 0, "n");
    (5863, 0, "t");
    (5864, 0, ".");
    ( 5765,
      100,
      "    /// pointers which object points to us, and the offset from that \
       element to\n\
      \    /// the current element." );
    (5873, 0, " ");
    (5874, 0, "A");
    (5875, 0, "n");
    (5876, 0, "y");
    (5877, 0, "w");
    (5878, 0, "a");
    (5879, 0, "y");
    (5880, 0, ",");
    (5881, 0, " ");
    (5882, 0, "w");
    (5883, 0, "e");
    (5884, 0, " ");
    (5885, 0, "n");
    (5886, 0, "e");
    (5887, 0, "e");
    (5882, 6, "f");
    (5883, 0, "o");
    (5884, 0, "r");
    (5885, 0, "m");
    (5885, 1, "");
    (5885, 0, " ");
    (5886, 0, "m");
    (5887, 0, "a");
    (5888, 0, "r");
    (5889, 0, "k");
    (5890, 0, "e");
    (5891, 0, "r");
    (5892, 0, "s");
    (5893, 0, " ");
    (5894, 0, "t");
    (5895, 0, "o");
    (5896, 0, " ");
    (5897, 0, "w");
    (5898, 0, "o");
    (5899, 0, "r");
    (5900, 0, "k");
    (5901, 0, " ");
    (5902, 0, "w");
    (5903, 0, "e");
    (5904, 0, " ");
    (5905, 0, "n");
    (5906, 0, "e");
    (5907, 0, "e");
    (5908, 0, "d");
    (5909, 0, " ");
    (5910, 0, "t");
    (5911, 0, "h");
    (5912, 0, "i");
    (5913, 0, "s");
    (5914, 0, ".");
    (5915, 0, "\n    /// ");
    (5923, 1, "");
    (5922, 1, "");
    (5921, 1, "");
    (5920, 1, "");
    (5920, 0, "p");
    (5921, 0, "a");
    (5922, 0, "r");
    (5923, 0, "e");
    (5924, 0, "n");
    (5925, 0, "t");
    (5926, 0, ":");
    (5927, 0, " ");
    (5928, 0, "*");
    (5929, 0, "m");
    (5930, 0, "u");
    (5931, 0, "t");
    (5932, 0, " ");
    (5933, 0, "N");
    (5934, 0, "o");
    (5935, 0, "d");
    (5936, 0, "e");
    (5937, 0, " ");
    (5937, 1, "");
    (5937, 0, ";");
    (5937, 0, "<");
    (5938, 0, "C");
    (5939, 0, ">");
    (5940, 1, "");
    (5940, 0, ",");
    (9876, 0, "\n                ");
    (9893, 0, "p");
    (9894, 0, "a");
    (9895, 0, "r");
    (9896, 0, "e");
    (9897, 0, "n");
    (9893, 5, "parent");
    (9899, 0, ":");
    (9900, 0, " ");
    (9901, 0, "p");
    (9902, 0, "t");
    (9903, 0, "r");
    (9904, 0, ":");
    (9905, 0, ":");
    (9906, 0, "n");
    (9907, 0, "u");
    (9908, 0, "l");
    (9909, 0, "l");
    (9906, 4, "null_mut()");
    (9916, 0, ",");
    (16970, 0, "\n                ");
    (16987, 0, "p");
    (16988, 0, "a");
    (16989, 0, "r");
    (16990, 0, "e");
    (16991, 0, "n");
    (16987, 5, "parent");
    (16993, 0, ":");
    (16994, 0, " ");
    (16995, 0, "p");
    (16996, 0, "t");
    (16997, 0, "r");
    (16998, 0, ":");
    (16999, 0, ":");
    (17000, 0, "n");
    (17001, 0, "u");
    (17002, 0, "l");
    (17003, 0, "l");
    (17000, 4, "null()");
    (17004, 0, "_");
    (17005, 0, "m");
    (17006, 0, "u");
    (17007, 0, "t");
    (17010, 0, ",");
    (19797, 7, "_");
    (19776, 7, "_");
    (18635, 7, "_");
    (18645, 7, "_");
    (18615, 0, "m");
    (18616, 0, "u");
    (18617, 0, "t");
    (18618, 0, " ");
    (18628, 12, "");
    (18628, 0, " as *const _");
    (18618, 1, "");
    (18615, 3, "");
    (19568, 57, "");
    (19551, 0, "\n                ");
    (19568, 0, "a");
    (19569, 0, "s");
    (19570, 0, "s");
    (19552, 19, "");
    (19551, 1, "");
    (19551, 0, "\n                ");
    (19568, 0, "a");
    (19569, 0, "s");
    (19570, 0, "s");
    (19571, 0, "e");
    (19572, 0, "r");
    (19568, 5, "assert_eq!");
    (19578, 0, "(");
    (19579, 0, "e");
    (19580, 0, "n");
    (19581, 0, "t");
    (19582, 0, "r");
    (19583, 0, "y");
    (19584, 0, ".");
    (19568, 0, "// ");
    (19568, 3, "");
    (19577, 8, "n");
    (19577, 1, "!(entry.");
    (19579, 6, "n");
    (19580, 0, ".");
    (19581, 0, "i");
    (19582, 0, "n");
    (19583, 0, "t");
    (19584, 0, "o");
    (19581, 4, "");
    (19580, 1, "");
    (19580, 0, ".");
    (19581, 0, "p");
    (19582, 0, "a");
    (19583, 0, "r");
    (19584, 0, "e");
    (19585, 0, "n");
    (19586, 0, "t");
    (19587, 0, ",");
    (19588, 0, " ");
    (19589, 0, "i");
    (19590, 0, "t");
    (19591, 0, "e");
    (19592, 0, "r");
    (19593, 0, "[");
    (19594, 0, "n");
    (19595, 0, ".");
    (19596, 0, "h");
    (19597, 0, "e");
    (19598, 0, "i");
    (19599, 0, "g");
    (19600, 0, "h");
    (19601, 0, "t");
    (19602, 0, " ");
    (19603, 0, "a");
    (19604, 0, "s");
    (19605, 0, " ");
    (19606, 0, "u");
    (19607, 0, "s");
    (19608, 0, "i");
    (19609, 0, "z");
    (19610, 0, "e");
    (19611, 0, "]");
    (19612, 0, ")");
    (19613, 0, ";");
    (19612, 0, ".");
    (19613, 0, "n");
    (19614, 0, "o");
    (19615, 0, "d");
    (19616, 0, "e");
    (19551, 0, "\n                ");
    (19568, 0, "l");
    (19569, 0, "e");
    (19570, 0, "t");
    (19571, 0, " ");
    (19572, 0, "e");
    (19573, 0, "x");
    (19574, 0, "p");
    (19575, 0, "e");
    (19576, 0, "c");
    (19577, 0, "t");
    (19578, 0, "_");
    (19579, 0, "p");
    (19580, 0, "a");
    (19581, 0, "r");
    (19582, 0, "e");
    (19583, 0, "n");
    (19584, 0, "t");
    (19585, 0, " ");
    (19586, 0, "=");
    (19587, 0, " ");
    (19588, 0, "i");
    (19589, 0, "f");
    (19590, 0, " ");
    (19591, 0, "n");
    (19592, 0, ".");
    (19593, 0, "h");
    (19594, 0, "e");
    (19595, 0, "i");
    (19596, 0, "g");
    (19597, 0, "h");
    (19598, 0, "t");
    (19599, 0, " ");
    (19600, 0, "=");
    (19601, 0, "=");
    (19602, 0, " ");
    (19603, 0, "N");
    (19604, 0, "O");
    (19605, 0, "D");
    (19606, 0, "E");
    (19607, 0, "_");
    (19608, 0, "M");
    (19609, 0, "A");
    (19609, 1, "");
    (19608, 1, "");
    (19603, 5, "H");
    (19604, 0, "E");
    (19605, 0, "I");
    (19606, 0, "G");
    (19607, 0, "H");
    (19608, 0, "T");
    (19603, 6, "MAX_HEIGHT_U8");
    (19616, 0, " ");
    (19617, 0, "{");
    (19618, 0, " ");
    (19619, 0, "&");
    (19620, 0, "s");
    (19621, 0, "e");
    (19622, 0, "l");
    (19623, 0, "f");
    (19624, 0, ".");
    (19625, 0, "h");
    (19626, 0, "e");
    (19627, 0, "a");
    (19628, 0, "d");
    (19629, 0, " ");
    (19630, 0, "}");
    (19631, 0, " ");
    (19632, 0, "e");
    (19633, 0, "l");
    (19634, 0, "s");
    (19635, 0, "e");
    (19636, 0, " ");
    (19637, 0, "iter[n.height as usize].node");
    (19665, 0, " ");
    (19666, 0, "}");
    (19637, 0, "{");
    (19638, 0, " ");
    (19629, 0, ".");
    (19630, 0, "a");
    (19631, 0, "s");
    (19632, 0, "_");
    (19630, 3, "as_mut_ptr");
    (19640, 0, "(");
    (19641, 0, ")");
    (19619, 0, "(");
    (19630, 0, ")");
    (19630, 14, "");
    (19619, 1, "");
    (19629, 0, "&self.head as *const _;");
    (19629, 11, "");
    (19629, 0, " ");
    (19641, 0, " ");
    (19642, 0, "a");
    (19643, 0, "s");
    (19644, 0, " ");
    (19645, 0, "*");
    (19646, 0, "m");
    (19647, 0, "u");
    (19648, 0, "t");
    (19649, 0, " ");
    (19650, 0, "_");
    (19618, 1, "");
    (19618, 0, "\n                    ");
    (19672, 1, "");
    (19671, 1, "");
    (19671, 0, "\n                ");
    (19696, 1, "");
    (19696, 0, "\n                    ");
    (19745, 1, "");
    (19745, 0, "\n                ");
    (19763, 0, ";");
    (19764, 0, "\n                ");
    (19819, 28, "e");
    (19765, 16, "");
    (19804, 0, "x");
    (19805, 0, "p");
    (19806, 0, "e");
    (19803, 4, "expect_parent");
    (19588, 0, "\n                ");
    (19589, 16, "            }");
    (19602, 0, " ");
    (19603, 0, "e");
    (19604, 0, "l");
    (19605, 0, "s");
    (19606, 0, "e");
    (19607, 0, " ");
    (19601, 0, "    ");
    (19588, 0, "i");
    (19589, 0, "f");
    (19590, 0, " ");
    (19591, 0, "i");
    (19592, 0, "s");
    (19593, 0, "_");
    (19594, 0, "h");
    (19595, 0, "e");
    (19596, 0, "a");
    (19597, 0, "d");
    (19598, 0, " ");
    (19599, 0, "{");
    (19600, 0, " ");
    (19600, 1, "");
    (19600, 0, "\n                    ");
    (19621, 0, "p");
    (19622, 0, "t");
    (19623, 0, "r");
    (19624, 0, ":");
    (19625, 0, ":");
    (19626, 0, "n");
    (19627, 0, "u");
    (19628, 0, "l");
    (19629, 0, "l");
    (19626, 4, "null_mut()");
    (19633, 1, "");
    (19632, 1, "");
    (19631, 1, "");
    (19630, 1, "");
    (19729, 10, "");
    (19632, 0, " ");
    (19633, 0, "/");
    (19634, 0, "/");
    (19635, 0, " ");
    (19636, 0, "T");
    (19637, 0, "h");
    (19638, 0, "e");
    (19639, 0, " ");
    (19640, 0, "h");
    (19641, 0, "e");
    (19642, 0, "a");
    (19643, 0, "d");
    (19644, 0, "'");
    (19645, 0, "s");
    (19646, 0, " ");
    (19647, 0, "p");
    (19648, 0, "a");
    (19649, 0, "r");
    (19650, 0, "e");
    (19651, 0, "n");
    (19652, 0, "t");
    (19653, 0, " ");
    (19654, 0, "i");
    (19655, 0, "s");
    (19656, 0, " ");
    (19657, 0, "n");
    (19658, 0, "u");
    (19659, 0, "l");
    (19660, 0, "l");
    (19758, 0, " ");
    (19759, 0, "/");
    (19760, 0, "/");
    (19761, 0, " ");
    (19762, 0, "D");
    (19763, 0, "o");
    (19764, 0, "n");
    (19765, 0, "'");
    (19766, 0, "t");
    (19767, 0, " ");
    (19762, 6, "M");
    (19763, 0, "a");
    (19764, 0, "x");
    (19765, 0, " ");
    (19766, 0, "h");
    (19767, 0, "e");
    (19768, 0, "i");
    (19769, 0, "g");
    (19770, 0, "h");
    (19771, 0, "t");
    (19772, 0, " ");
    (19773, 0, "n");
    (19774, 0, "o");
    (19775, 0, "d");
    (19776, 0, "e");
    (19777, 0, "s");
    (19778, 0, " ");
    (19779, 0, "p");
    (19780, 0, "o");
    (19781, 0, "i");
    (19782, 0, "n");
    (19783, 0, "t");
    (19784, 0, " ");
    (19785, 0, "b");
    (19786, 0, "a");
    (19787, 0, "c");
    (19788, 0, "k");
    (19789, 0, " ");
    (19790, 0, "t");
    (19791, 0, "o");
    (19792, 0, " ");
    (19793, 0, "h");
    (19794, 0, "e");
    (19795, 0, "a");
    (19796, 0, "d");
    (19927, 0, " ");
    (19928, 0, "a");
    (19929, 0, "s");
    (19930, 0, " ");
    (19931, 0, "*");
    (19932, 0, "c");
    (19933, 0, "o");
    (19934, 0, "n");
    (19935, 0, "s");
    (19936, 0, "t");
    (19937, 0, " ");
    (19938, 0, "_");
    (19954, 0, ",");
    (19955, 0, " ");
    (19956, 0, "\"");
    (19957, 0, "i");
    (19958, 0, "n");
    (19959, 0, "v");
    (19960, 0, "a");
    (19961, 0, "l");
    (19962, 0, "i");
    (19963, 0, "d");
    (19964, 0, " ");
    (19965, 0, "a");
    (19965, 1, "");
    (19965, 0, "p");
    (19966, 0, "a");
    (19967, 0, "r");
    (19968, 0, "e");
    (19969, 0, "n");
    (19970, 0, "t");
    (19971, 0, "\"");
    (1808, 0, "// ");
    (1765, 0, "// ");
    (1742, 0, "// ");
    (1699, 0, "// ");
    (1817, 3, "");
    (1771, 3, "");
    (1745, 3, "");
    (1699, 3, "");
    (25858, 0, "\n        ");
    (25867, 0, "\n        ");
    (25859, 8, "");
    (25868, 0, "(");
    (25869, 0, "*");
    (25870, 0, "n");
    (25871, 0, "e");
    (25872, 0, "w");
    (25873, 0, "_");
    (25874, 0, "n");
    (25875, 0, "o");
    (25876, 0, "d");
    (25877, 0, "e");
    (25878, 0, ")");
    (25879, 0, ".");
    (25880, 0, "p");
    (25881, 0, "a");
    (25882, 0, "r");
    (25883, 0, "e");
    (25884, 0, "n");
    (25885, 0, "t");
    (25886, 0, " ");
    (25887, 0, "=");
    (25888, 0, " ");
    (25868, 0, "// ");
    (24879, 0, "\n        ");
    (24888, 0, "l");
    (24889, 0, "e");
    (24890, 0, "t");
    (24891, 0, " ");
    (24892, 0, "n");
    (24893, 0, "e");
    (24894, 0, "w");
    (24895, 0, "_");
    (24896, 0, "n");
    (24897, 0, "o");
    (24898, 0, "d");
    (24899, 0, "e");
    (24900, 0, " ");
    (24901, 0, "=");
    (24902, 0, " ");
    (24900, 0, "_");
    (24901, 0, "R");
    (24902, 0, "e");
    (24903, 0, "f");
    (24901, 1, "");
    (24901, 0, "r");
    (24907, 0, "&");
    (24907, 1, "");
    (24907, 0, "&");
    (24908, 0, "*");
    (24908, 1, "");
    (24908, 0, "m");
    (24909, 0, "u");
    (24910, 0, "t");
    (24911, 0, " ");
    (24912, 0, "*");
    (24913, 0, "n");
    (24914, 0, "e");
    (24915, 0, "w");
    (24916, 0, "_");
    (24917, 0, "n");
    (24918, 0, "o");
    (24919, 0, "d");
    (24920, 0, "e");
    (24921, 0, ";");
    (26079, 11, "n");
    (25914, 11, "n");
    (25073, 11, "n");
    (24985, 11, "n");
    (24931, 11, "n");
    (26040, 0, "e");
    (25885, 0, "e");
    (25054, 0, "e");
    (24976, 0, "e");
    (24932, 0, "e");
    (26045, 0, "w");
    (25889, 0, "w");
    (25057, 0, "w");
    (24978, 0, "w");
    (24933, 0, "w");
    (26050, 0, "_");
    (25893, 0, "_");
    (25060, 0, "_");
    (24980, 0, "_");
    (24934, 0, "_");
    (26055, 0, "n");
    (25897, 0, "n");
    (25063, 0, "n");
    (24982, 0, "n");
    (24935, 0, "n");
    (26060, 0, "o");
    (25901, 0, "o");
    (25066, 0, "o");
    (24984, 0, "o");
    (24936, 0, "o");
    (26065, 0, "d");
    (25905, 0, "d");
    (25069, 0, "d");
    (24986, 0, "d");
    (24937, 0, "d");
    (26063, 7, "new_node_ref");
    (25902, 7, "new_node_ref");
    (25065, 7, "new_node_ref");
    (24981, 7, "new_node_ref");
    (24931, 7, "new_node_ref");
    (26083, 12, "new_nod");
    (25917, 12, "new_nod");
    (25075, 12, "new_nod");
    (24986, 12, "new_nod");
    (24931, 12, "new_nod");
    (26063, 7, "new_node_ref");
    (25902, 7, "new_node_ref");
    (25065, 7, "new_node_ref");
    (24981, 7, "new_node_ref");
    (24931, 7, "new_node_ref");
    (26755, 0, "_ptr");
    (26491, 0, "_ptr");
    (24921, 0, "_ptr");
    (24848, 0, "_ptr");
    (26099, 4, "");
    (25091, 4, "");
    (25002, 4, "");
    (24947, 4, "");
    (24904, 4, "");
    (25906, 3, "");
    (25917, 1, "");
    (25916, 1, "");
    (25915, 1, "");
    (25914, 1, "");
    (25924, 0, "c");
    (25925, 0, "u");
    (25925, 1, "");
    (25924, 1, "");
    (25924, 0, "c");
    (25925, 0, "u");
    (25926, 0, "r");
    (25927, 0, "s");
    (25928, 0, "o");
    (25929, 0, "r");
    (25930, 0, ".");
    (25931, 0, "e");
    (25932, 0, "n");
    (25931, 2, "entries");
    (25938, 0, "[");
    (25939, 0, "n");
    (25940, 0, "e");
    (25941, 0, "w");
    (25942, 0, "_");
    (25943, 0, "h");
    (25944, 0, "e");
    (25945, 0, "i");
    (25939, 7, "new_height_usize");
    (25197, 0, "\n        let mut head_height = self.head.height as usize;");
    (25089, 57, "");
    (25140, 0, "\n");
    (25088, 1, "");
    (25045, 0, "\n        ");
    (25964, 0, "]");
    (25046, 8, "");
    (25957, 0, ".");
    (25958, 0, "n");
    (25959, 0, "o");
    (25960, 0, "d");
    (25961, 0, "e");
    (25962, 0, ";");
    (25898, 0, "\n        ");
    (25907, 0, "i");
    (25908, 0, "f");
    (25909, 0, " ");
    (25910, 0, "n");
    (25911, 0, "e");
    (25912, 0, "w");
    (25913, 0, "_");
    (25914, 0, "h");
    (25910, 5, "new_height_usize");
    (25926, 0, " ");
    (25927, 0, ">");
    (25928, 0, " ");
    (25928, 1, "");
    (25927, 1, "");
    (25927, 0, "=");
    (25928, 0, "=");
    (25929, 0, " ");
    (25930, 0, "M");
    (25931, 0, "A");
    (25932, 0, "X");
    (25933, 0, "_");
    (25930, 4, "MAX_HEIGHT");
    (25949, 18, "");
    (25907, 0, "new_node.parent = ");
    (25958, 0, " ");
    (25959, 0, "{");
    (25960, 0, "\n            ");
    (25973, 0, "s");
    (25974, 0, "e");
    (25975, 0, "l");
    (25976, 0, "f");
    (25977, 0, ".");
    (25978, 0, "h");
    (25979, 0, "e");
    (25980, 0, "a");
    (25981, 0, "d");
    (25982, 0, "\n            ");
    (25983, 12, "        }");
    (25992, 0, " ");
    (25993, 0, "e");
    (25994, 0, "l");
    (25995, 0, "s");
    (25996, 0, "e");
    (25997, 0, " ");
    (25998, 0, "{");
    (25983, 63, "        } else { cursor.entries[new_height_usize].node;");
    (26037, 1, "");
    (26037, 0, " ");
    (26038, 0, "}");
    (26039, 0, ";");
    (25973, 0, "&");
    (25983, 0, " ");
    (25983, 1, "");
    (25983, 0, " ");
    (25984, 0, "a");
    (25985, 0, "s");
    (25986, 0, " ");
    (25987, 0, "*");
    (25988, 0, "c");
    (25989, 0, "o");
    (25990, 0, "n");
    (25991, 0, "s");
    (25992, 0, "t");
    (25993, 0, " ");
    (25994, 0, "_");
    (25995, 0, " ");
    (25996, 0, "a");
    (25997, 0, "s");
    (25998, 0, " ");
    (25999, 0, "*");
    (26000, 0, "m");
    (26001, 0, "u");
    (26002, 0, "t");
    (26003, 0, " ");
    (26004, 0, "_");
    (27224, 0, "\n        ");
    (27233, 0, "\n        ");
    (27225, 8, "");
    (27234, 0, "/");
    (27235, 0, "/");
    (27236, 0, " ");
    (27237, 0, "U");
    (27238, 0, "p");
    (27239, 0, "d");
    (27240, 0, "a");
    (27241, 0, "t");
    (27242, 0, "e");
    (27243, 0, " ");
    (27244, 0, "p");
    (27245, 0, "a");
    (27246, 0, "r");
    (27247, 0, "e");
    (27248, 0, "n");
    (27249, 0, "t");
    (27250, 0, "s");
    (27251, 0, " ");
    (27252, 0, "o");
    (27253, 0, "f");
    (27254, 0, " ");
    (27255, 0, "t");
    (27256, 0, "h");
    (27257, 0, "i");
    (27258, 0, "s");
    (27259, 0, " ");
    (27260, 0, "n");
    (27261, 0, "o");
    (27262, 0, "d");
    (27263, 0, "e");
    (27264, 0, "'");
    (27265, 0, "s");
    (27266, 0, " ");
    (27267, 0, "n");
    (27268, 0, "e");
    (27269, 0, "w");
    (27270, 0, " ");
    (27271, 0, "c");
    (27272, 0, "h");
    (27273, 0, "i");
    (27274, 0, "l");
    (27275, 0, "d");
    (27276, 0, "r");
    (27277, 0, "e");
    (27278, 0, "n");
    (27279, 0, ".");
    (27280, 0, "\n        ");
    (27289, 0, "f");
    (27290, 0, "o");
    (27291, 0, "r");
    (27292, 0, " ");
    (27289, 4, "");
    (27289, 0, "l");
    (27290, 0, "e");
    (27291, 0, "t");
    (27292, 0, " ");
    (27293, 0, "m");
    (27294, 0, "u");
    (27295, 0, "t");
    (27296, 0, " ");
    (27297, 0, "n");
    (27298, 0, " ");
    (27299, 0, "=");
    (27300, 0, " ");
    (27301, 0, "n");
    (27302, 0, "e");
    (27303, 0, "w");
    (27304, 0, "_");
    (27301, 4, "new_node");
    (27309, 0, ".");
    (27310, 0, "n");
    (27310, 1, "");
    (27309, 1, "");
    (27309, 0, ".");
    (27310, 0, "n");
    (27311, 0, "e");
    (27312, 0, "x");
    (27313, 0, "t");
    (27314, 0, "s");
    (27315, 0, "_");
    (27310, 6, "nexts_mut");
    (27319, 0, "(");
    (27320, 0, ")");
    (27321, 0, ".");
    (27321, 1, "");
    (27321, 0, "[");
    (27322, 0, "n");
    (27323, 0, "e");
    (27324, 0, "w");
    (27325, 0, "_");
    (27322, 4, "new_height_usize");
    (27338, 0, " ");
    (27339, 0, "-");
    (27340, 0, " ");
    (27341, 0, "1");
    (27342, 0, "]");
    (27343, 0, ";");
    (27344, 0, "\n        ");
    (27353, 0, "w");
    (27354, 0, "h");
    (27355, 0, "i");
    (27356, 0, "l");
    (27357, 0, "e");
    (27358, 0, " ");
    (27359, 0, "!");
    (27360, 0, "n");
    (27361, 0, ".");
    (27362, 0, "i");
    (27363, 0, "s");
    (27364, 0, "_");
    (27365, 0, "n");
    (27366, 0, "u");
    (27367, 0, "l");
    (27368, 0, "l");
    (27362, 7, "is_null");
    (27369, 0, "(");
    (27370, 0, ")");
    (27371, 0, " ");
    (27372, 0, "{");
    (27373, 0, "\n            ");
    (27386, 0, "\n            ");
    (27374, 12, "");
    (27375, 12, "        }");
    (27343, 0, ".");
    (27344, 0, "n");
    (27345, 0, "o");
    (27346, 0, "d");
    (27347, 0, "e");
    (27309, 0, "_");
    (27310, 0, "p");
    (27311, 0, "t");
    (27312, 0, "r");
    (27313, 40, "");
    (27313, 0, ";");
    (27343, 0, "\n            ");
    (27356, 0, "n");
    (27357, 0, " ");
    (27358, 0, "=");
    (27359, 0, " ");
    (27360, 0, ".nexts_mut()[new_height_usize - 1].node;");
    (27360, 0, "n");
    (27360, 0, "(");
    (27361, 0, "*");
    (27363, 0, ")");
    (27323, 18, "");
    (27323, 0, "l");
    (27324, 0, "o");
    (27325, 0, "o");
    (27326, 0, "p");
    (27390, 0, "\n            ");
    (27403, 0, "i");
    (27404, 0, "f");
    (27405, 0, " ");
    (27406, 0, "while !n.is_null()");
    (27406, 7, "");
    (27417, 0, " ");
    (27418, 0, "{");
    (27419, 0, " ");
    (27420, 0, "b");
    (27421, 0, "r");
    (27422, 0, "e");
    (27423, 0, "a");
    (27424, 0, "k");
    (27425, 0, ";");
    (27426, 0, " ");
    (27427, 0, "}");
    (27429, 0, "\n            ");
    (27430, 12, "");
    (27280, 0, " ");
    (27281, 0, "T");
    (27282, 0, "h");
    (27283, 0, "i");
    (27284, 0, "s");
    (27285, 0, " ");
    (27286, 0, "i");
    (27287, 0, "s");
    (27288, 0, ",");
    (27289, 0, " ");
    (27290, 0, "a");
    (27291, 0, "l");
    (27292, 0, "l");
    (27293, 0, " ");
    (27294, 0, "c");
    (27295, 0, "h");
    (27296, 0, "i");
    (27297, 0, "l");
    (27298, 0, "d");
    (27299, 0, "r");
    (27300, 0, "e");
    (27301, 0, "n");
    (27302, 0, " ");
    (27303, 0, "a");
    (27304, 0, "t");
    (27305, 0, " ");
    (27306, 0, "t");
    (27307, 0, "h");
    (27308, 0, "e");
    (27309, 0, " ");
    (27293, 17, " ");
    (27294, 0, "n");
    (27295, 0, "o");
    (27296, 0, "d");
    (27297, 0, "e");
    (27298, 0, "s");
    (27299, 0, " ");
    (27300, 0, "a");
    (27301, 0, "t");
    (27302, 0, " ");
    (27303, 0, "t");
    (27304, 0, "h");
    (27305, 0, "e");
    (27306, 0, " ");
    (27307, 0, "e");
    (27308, 0, "x");
    (27309, 0, "p");
    (27310, 0, "e");
    (27311, 0, "c");
    (27312, 0, "t");
    (27313, 0, "e");
    (27314, 0, "d");
    (27315, 0, " ");
    (27316, 0, "h");
    (27317, 0, "e");
    (27318, 0, "i");
    (27319, 0, "g");
    (27320, 0, "h");
    (27321, 0, "t");
    (27237, 85, "P");
    (27238, 0, "o");
    (27239, 0, "i");
    (27240, 0, "n");
    (27241, 0, "t");
    (27242, 0, " ");
    (27243, 0, "a");
    (27244, 0, "l");
    (27245, 0, "l");
    (27246, 0, " ");
    (27247, 0, "n");
    (27248, 0, "o");
    (27249, 0, "d");
    (27250, 0, "e");
    (27251, 0, "s");
    (27252, 0, " ");
    (27253, 0, "a");
    (27254, 0, "t");
    (27255, 0, " ");
    (27256, 0, "h");
    (27257, 0, "e");
    (27258, 0, "i");
    (27259, 0, "g");
    (27260, 0, "h");
    (27261, 0, "t");
    (27262, 0, "-");
    (27263, 0, "1");
    (27401, 0, " ");
    (27402, 0, "|");
    (27403, 0, "|");
    (27404, 0, " ");
    (27405, 0, "(");
    (27406, 0, "*");
    (27407, 0, "n");
    (27408, 0, ")");
    (27409, 0, ".");
    (27410, 0, "n");
    (27410, 1, "");
    (27410, 0, "h");
    (27411, 0, "e");
    (27412, 0, "i");
    (27413, 0, "g");
    (27414, 0, "h");
    (27415, 0, "t");
    (27416, 0, " ");
    (27417, 0, ">");
    (27418, 0, " ");
    (27419, 0, "n");
    (27420, 0, "e");
    (27421, 0, "w");
    (27422, 0, "_");
    (27419, 4, "new_height");
    (27418, 0, "=");
    (27237, 27, "U");
    (27238, 0, "p");
    (27239, 0, "d");
    (27240, 0, "a");
    (27241, 0, "t");
    (27242, 0, "e");
    (27243, 0, " ");
    (27244, 0, "p");
    (27245, 0, "a");
    (27246, 0, "r");
    (27247, 0, "e");
    (27248, 0, "n");
    (27249, 0, "t");
    (27250, 0, "s");
    (27251, 0, ".");
    (27431, 0, "            ");
    (27443, 0, "n");
    (27444, 0, ".");
    (27445, 0, "p");
    (27445, 1, "");
    (27444, 1, "");
    (27443, 1, "");
    (27443, 0, "(");
    (27444, 0, "*");
    (27445, 0, "n");
    (27446, 0, ")");
    (27447, 0, ".");
    (27448, 0, "p");
    (27449, 0, "a");
    (27450, 0, "r");
    (27451, 0, "e");
    (27452, 0, "n");
    (27453, 0, "t");
    (27454, 0, " ");
    (27455, 0, "=");
    (27456, 0, " ");
    (27443, 0, "// ");
    (27318, 0, "&");
    (27319, 0, "m");
    (27320, 0, "u");
    (27321, 0, "t");
    (27322, 0, " ");
    (27323, 0, "*");
    (27400, 1, "");
    (27399, 1, "");
    (27398, 1, "");
    (27398, 0, " ");
    (27400, 1, "");
    (27446, 3, "");
    (27446, 0, "// ");
    (27367, 0, ")");
    (27324, 0, "(");
    (27368, 1, "");
    (27324, 1, "");
    (27446, 3, "");
    (27446, 0, "// ");
    (27400, 0, ")");
    (27398, 1, "");
    (27398, 0, " (*");
    (27322, 2, "");
    (27318, 4, "");
    (27443, 3, "");
    (27457, 0, "n");
    (27458, 0, "e");
    (27459, 0, "w");
    (27460, 0, "_");
    (27461, 0, "n");
    (27462, 0, "o");
    (27463, 0, "d");
    (27457, 7, "new_node_ptr");
    (27469, 0, ";");
    (16787, 4, "i");
    (16788, 0, "f");
    (16789, 0, " ");
    (16789, 1, "");
    (16787, 2, "None");
    (16787, 0, "if cfg!(debug_assertions)");
    (16812, 4, "");
    (16812, 0, " ");
    (16813, 0, "{");
    (16814, 0, " ");
    (16815, 0, "Some(SmallRng::seed_from_u64(seed))");
    (16850, 0, " ");
    (16851, 0, "}");
    (16852, 0, " ");
    (16787, 66, "");
    (16787, 0, "N");
    (16788, 0, "o");
    (16789, 0, "n");
    (16790, 0, "e");
    (17388, 0, "\n            ");
    (17401, 0, "/");
    (17402, 0, "/");
    (17403, 0, " ");
    (17404, 0, "W");
    (17404, 1, "");
    (17404, 0, "I");
    (17405, 0, "f");
    (17406, 0, " ");
    (17407, 0, "w");
    (17408, 0, "e");
    (17409, 0, "'");
    (17410, 0, "r");
    (17411, 0, "e");
    (17412, 0, " ");
    (17413, 0, "i");
    (17414, 0, "n");
    (17415, 0, " ");
    (17416, 0, "d");
    (17417, 0, "e");
    (17418, 0, "b");
    (17419, 0, "u");
    (17420, 0, "g");
    (17421, 0, " ");
    (17422, 0, "m");
    (17423, 0, "o");
    (17424, 0, "d");
    (17425, 0, "e");
    (17426, 0, ",");
    (17427, 0, " ");
    (17404, 24, "W");
    (17405, 0, "e");
    (17406, 0, "'");
    (17407, 0, "l");
    (17408, 0, "l");
    (17409, 0, " ");
    (17410, 0, "u");
    (17411, 0, "s");
    (17412, 0, "e");
    (17413, 0, " ");
    (17414, 0, "a");
    (17415, 0, " ");
    (17416, 0, "s");
    (17417, 0, "t");
    (17418, 0, "a");
    (17419, 0, "b");
    (17420, 0, "l");
    (17421, 0, "e");
    (17422, 0, " ");
    (17423, 0, "N");
    (17424, 0, "R");
    (17424, 1, "");
    (17423, 1, "");
    (17423, 0, "R");
    (17424, 0, "N");
    (17425, 0, "G");
    (17426, 0, " ");
    (17427, 0, "i");
    (17428, 0, "n");
    (17429, 0, " ");
    (17430, 0, "d");
    (17431, 0, "e");
    (17432, 0, "b");
    (17433, 0, "u");
    (17434, 0, "g");
    (17435, 0, " ");
    (17436, 0, "m");
    (17437, 0, "o");
    (17438, 0, "d");
    (17439, 0, "e");
    (17440, 0, " ");
    (17441, 0, "s");
    (17442, 0, "o");
    (17443, 0, " ");
    (17444, 0, "t");
    (17445, 0, "h");
    (17446, 0, "e");
    (17447, 0, " ");
    (17448, 0, "t");
    (17449, 0, "e");
    (17450, 0, "s");
    (17451, 0, "t");
    (17452, 0, "s");
    (17453, 0, " ");
    (17454, 0, "a");
    (17455, 0, "r");
    (17456, 0, "e");
    (17457, 0, " ");
    (17458, 0, "s");
    (17459, 0, "t");
    (17460, 0, "a");
    (17461, 0, "b");
    (17462, 0, "l");
    (17463, 0, "e");
    (17464, 0, ".");
    (17465, 0, "\n            ");
    ( 17478,
      0,
      "if cfg!(debug_assertions) { Some(SmallRng::seed_from_u64(seed)) } " );
    (17503, 41, "");
    (17503, 0, " ");
    (17504, 0, "{");
    (17505, 0, "\n                ");
    (17522, 0, "s");
    (17523, 0, "e");
    (17524, 0, "l");
    (17525, 0, "f");
    (17526, 0, ".");
    (17527, 0, "i");
    (17528, 0, "n");
    (17529, 0, "i");
    (17530, 0, "t");
    (17527, 4, "init_rng_from_seed(seed: u64)");
    (17546, 9, "3");
    (17547, 0, "2");
    (17548, 0, "1");
    (17550, 0, ";");
    (17551, 0, "\n                ");
    (17552, 16, "            }");
    (17565, 0, " ");
    (17566, 0, "e");
    (17567, 0, "l");
    (17568, 0, "s");
    (17569, 0, "e");
    (17570, 0, " ");
    (17571, 0, "{");
    (17585, 0, "    ");
    (17631, 0, "\n                ");
    (17632, 16, "            }");
    (17546, 3, "1");
    (17547, 0, "2");
    (17548, 0, "3");
    (17549, 0, "\n                ");
    (17549, 17, "");
    (18728, 0, "\n            ");
    (18741, 0, "l");
    (18742, 0, "e");
    (18743, 0, "t");
    (18744, 0, " ");
    (18745, 0, "m");
    (18746, 0, "u");
    (18747, 0, "t");
    (18748, 0, " ");
    (18749, 0, "p");
    (18750, 0, "r");
    (18751, 0, "e");
    (18752, 0, "v");
    (18753, 0, " ");
    (18753, 1, "");
    (18753, 0, ":");
    (18754, 0, " ");
    (18755, 0, "*mut Node<C>");
    (18755, 0, "[");
    (18768, 0, ";");
    (18769, 0, " ");
    (18770, 0, "M");
    (18771, 0, "A");
    (18772, 0, "X");
    (18770, 3, "MAX_HEIGHT");
    (18780, 0, "]");
    (18781, 0, " ");
    (18782, 0, "=");
    (18783, 0, " ");
    (18784, 0, "[");
    (18570, 0, "\n            ");
    (18583, 0, "l");
    (18584, 0, "e");
    (18585, 0, "t");
    (18586, 0, " ");
    (18587, 0, "h");
    (18588, 0, "e");
    (18589, 0, "a");
    (18590, 0, "d");
    (18591, 0, "_");
    (18592, 0, "p");
    (18593, 0, "t");
    (18594, 0, "r");
    (18595, 0, " ");
    (18596, 0, "=");
    (18597, 0, " ");
    (18598, 0, "&self.head as *const _ as *mut _");
    (18630, 0, ";");
    (18934, 32, "h");
    (18935, 0, "e");
    (18936, 0, "a");
    (18937, 0, "d");
    (18938, 0, "_");
    (18934, 5, "head_ptr");
    (18846, 0, "n");
    (18847, 0, "u");
    (18848, 0, "l");
    (18849, 0, "l");
    (18850, 0, "_");
    (18846, 5, "p");
    (18847, 0, "t");
    (18848, 0, "r");
    (18849, 0, ":");
    (18850, 0, ":");
    (18851, 0, "n");
    (18852, 0, "u");
    (18853, 0, "l");
    (18851, 3, "null_mut()");
    (18861, 0, ";");
    (18862, 0, " ");
    (18863, 0, "_");
    (18864, 0, ")");
    (18864, 1, "");
    (18864, 0, "]");
    (18865, 0, ";");
    (18866, 0, "\n            ");
    (18867, 12, "");
    (18863, 1, "");
    (18863, 0, "M");
    (18864, 0, "A");
    (18865, 0, "X");
    (18863, 3, "MAX_HEIGHT");
    (20636, 0, "\n                    ");
    (20657, 0, "p");
    (20658, 0, "r");
    (20659, 0, "e");
    (20660, 0, "v");
    (20661, 0, "[");
    (20662, 0, "i");
    (20663, 0, "]");
    (20664, 0, " ");
    (20665, 0, "=");
    (20666, 0, " ");
    (20667, 0, "n");
    (20668, 0, ";");
    (20657, 0, "// ");
    (18818, 3, "c");
    (18819, 0, "o");
    (18820, 0, "n");
    (18821, 0, "s");
    (18822, 0, "t");
    (18860, 1, "");
    (18859, 1, "");
    (18858, 1, "");
    (18857, 1, "");
    (20655, 3, "");
    (20167, 4, "p");
    (20168, 0, "r");
    (20169, 0, "e");
    (20170, 0, "v");
    (20194, 1, "");
    (20193, 1, "");
    (20192, 1, "");
    (20191, 1, "");
    (20190, 1, "");
    (27706, 1, "");
    (27706, 0, "2");
    (27604, 0, "\n        ");
    (27613, 0, "i");
    (27614, 0, "f");
    (27615, 0, " ");
    (27616, 0, "n");
    (27617, 0, "e");
    (27618, 0, "w");
    (27619, 0, "_");
    (27620, 0, "h");
    (27616, 5, "new_height_usize");
    (27632, 0, " ");
    (27633, 0, ">");
    (27634, 0, " ");
    (27635, 0, "1");
    (27636, 0, " ");
    (27637, 0, "{");
    (27857, 8, "            ");
    (27817, 12, "                ");
    (27749, 12, "                ");
    (27688, 12, "                ");
    (27673, 8, "            ");
    (27639, 8, "            ");
    (27890, 0, "\n            ");
    (27891, 12, "        }");
    (36777, 0, "\n                ");
    (36794, 0, "\n                ");
    (36778, 16, "");
    ( 36795,
      0,
      "\n\
      \        // Update parents.\n\
      \        if new_height_usize > 1 {\n\
      \            let mut n = new_node_ptr;\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[new_height_usize - 2].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\n\
      \                (*n).parent = new_node_ptr;\n\
      \            }\n\
      \        }" );
    (36779, 16, "");
    (37093, 8, "            ");
    (37079, 12, "                ");
    (37035, 16, "                    ");
    (36963, 16, "                    ");
    (36898, 16, "                    ");
    (36879, 12, "                ");
    (36841, 12, "                ");
    (36807, 8, "            ");
    (36780, 8, "            ");
    (37125, 12, "                ");
    (37107, 16, "                    ");
    (37059, 20, "                        ");
    (36983, 20, "                        ");
    (36914, 20, "                        ");
    (36891, 16, "                    ");
    (36849, 16, "                    ");
    (36811, 12, "                ");
    (36780, 12, "                ");
    (36778, 1, "");
    (36833, 16, "h");
    (36834, 0, "e");
    (36835, 0, "i");
    (36836, 0, "g");
    (36837, 0, "h");
    (36838, 0, "t");
    (36878, 12, "e");
    (36953, 16, "h");
    (36954, 0, "e");
    (36955, 0, "i");
    (36956, 0, "g");
    (36957, 0, "h");
    (36958, 0, "t");
    (37028, 10, "h");
    (37029, 0, "e");
    (37030, 0, "i");
    (37031, 0, "g");
    (37032, 0, "h");
    (37033, 0, "t");
    (37034, 0, " ");
    (37035, 0, "a");
    (37036, 0, "s");
    (37037, 0, " ");
    (37038, 0, "u");
    (37039, 0, "8");
    (36845, 0, "\n                    ");
    (36846, 20, "");
    (36845, 1, "");
    (36880, 0, "\n                    ");
    (36901, 0, "l");
    (36902, 0, "e");
    (36903, 0, "t");
    (36904, 0, " ");
    (36905, 0, "n");
    (36906, 0, "e");
    (36907, 0, "w");
    (36908, 0, "_");
    (36909, 0, "p");
    (36910, 0, "a");
    (36911, 0, "r");
    (36912, 0, "e");
    (36913, 0, "n");
    (36914, 0, "t");
    (36915, 0, " ");
    (36916, 0, "=");
    (36917, 0, " ");
    (36918, 0, "c");
    (36919, 0, "u");
    (36920, 0, "r");
    (36921, 0, "s");
    (36922, 0, "o");
    (36923, 0, "r");
    (36924, 0, ".");
    (36925, 0, "e");
    (36926, 0, "n");
    (36927, 0, "t");
    (36928, 0, "r");
    (36929, 0, "i");
    (36930, 0, "e");
    (36931, 0, "s");
    (36932, 0, "[");
    (36933, 0, "h");
    (36934, 0, "e");
    (36935, 0, "i");
    (36936, 0, "g");
    (36937, 0, "h");
    (36938, 0, "t");
    (36939, 0, " ");
    (36940, 0, "-");
    (36941, 0, " ");
    (36942, 0, "1");
    (36943, 0, "]");
    (36944, 0, ".");
    (36945, 0, "n");
    (36946, 0, "o");
    (36947, 0, "d");
    (36948, 0, "e");
    (36949, 0, ";");
    (37161, 12, "n");
    (37162, 0, "e");
    (37163, 0, "w");
    (37164, 0, "_");
    (37165, 0, "p");
    (37166, 0, "a");
    (37161, 6, "new_parent");
    (2641, 0, "s");
    (2645, 0, "[");
    (2656, 0, "]");
    (2661, 1, "");
    (2660, 1, "");
    (2660, 0, "t");
    (2661, 0, "o");
    (2661, 1, "");
    (2660, 1, "");
    (2660, 0, "a");
    (2661, 0, "t");
    (2688, 18, "");
    (2688, 0, " where Self: Sized");
    (2699, 0, ":");
    (2700, 0, ":");
    (2701, 0, "I");
    (2702, 0, "t");
    (2701, 2, "Item");
    (2701, 4, "It");
    (2699, 4, "");
    (1809, 0, "\n");
    (1810, 0, "i");
    (1811, 0, "m");
    (1812, 0, "p");
    (1813, 0, "l");
    (1814, 0, " ");
    (1815, 0, "S");
    (1816, 0, "i");
    (1817, 0, "z");
    (1818, 0, "e");
    (1819, 0, "d");
    (1820, 0, " ");
    (1821, 0, "f");
    (1822, 0, "o");
    (1823, 0, "r");
    (1824, 0, " ");
    (1825, 0, "I");
    (1826, 0, "t");
    (1827, 0, "e");
    (1828, 0, "m");
    (1825, 4, "ItemMarker");
    (1835, 0, " ");
    (1836, 0, "{");
    (1837, 0, "}");
    (1814, 0, "<");
    (1815, 0, "C");
    (1816, 0, ":");
    (1817, 0, " ");
    (1818, 0, "L");
    (1819, 0, "i");
    (1820, 0, "s");
    (1821, 0, "t");
    (1818, 4, "ListConfig");
    (1828, 0, ">");
    (1850, 0, "<");
    (1851, 0, "C");
    (1852, 0, ">");
    (1809, 47, "");
    (1738, 0, " ");
    (1739, 0, "+");
    (1740, 0, " ");
    (1741, 0, "S");
    (1742, 0, "i");
    (1743, 0, "z");
    (1744, 0, "e");
    (1745, 0, "d");
    (2696, 19, " ");
    (2696, 1, " where Self: Sized ");
    (1738, 8, "");
    (2715, 267, "");
    (2713, 0, "// ");
    (2615, 0, "// ");
    (24334, 0, "\n    ");
    (24339, 0, "\n    ");
    (24335, 4, "");
    (24340, 0, "p");
    (24341, 0, "u");
    (24342, 0, "b");
    (24343, 0, " ");
    (24344, 0, "f");
    (24345, 0, "n");
    (24346, 0, " ");
    (24347, 0, "i");
    (24348, 0, "t");
    (24349, 0, "e");
    (24350, 0, "r");
    (24351, 0, "_");
    (24352, 0, "a");
    (24353, 0, "t");
    (24354, 0, "_");
    (24355, 0, "m");
    (24356, 0, "a");
    (24357, 0, "r");
    (24358, 0, "k");
    (24359, 0, "e");
    (24360, 0, "r");
    (24361, 0, "(");
    (24362, 0, "&");
    (24363, 0, "m");
    (24364, 0, "u");
    (24365, 0, "t");
    (24366, 0, " ");
    (24367, 0, "s");
    (24368, 0, "e");
    (24369, 0, "l");
    (24370, 0, "f");
    (24371, 0, ",");
    (24372, 0, " ");
    (24373, 0, "m");
    (24374, 0, "a");
    (24375, 0, "r");
    (24376, 0, "k");
    (24377, 0, "e");
    (24378, 0, "r");
    (24379, 0, ":");
    (24380, 0, " ");
    (24381, 0, "M");
    (24382, 0, "a");
    (24383, 0, "r");
    (24384, 0, "k");
    (24381, 4, "I");
    (24382, 0, "t");
    (24383, 0, "e");
    (24384, 0, "m");
    (24385, 0, "m");
    (24381, 5, "ItemMarker");
    (24391, 0, ")");
    (24392, 0, " ");
    (24393, 0, "-");
    (24394, 0, ">");
    (24395, 0, " ");
    (24396, 0, "C");
    (24397, 0, "u");
    (24398, 0, "r");
    (24399, 0, "s");
    (24400, 0, "o");
    (24401, 0, "r");
    (24402, 0, " ");
    (24403, 0, "{");
    (24404, 0, "\n        ");
    (24413, 0, "\n        ");
    (24405, 8, "");
    (24406, 8, "    }");
    (24405, 0, "        ");
    (24405, 8, "");
    (24391, 0, "<");
    (24392, 0, "C");
    (24393, 0, ">");
    (24405, 0, "<");
    (24406, 0, "C");
    (24407, 0, ">");
    (24411, 0, "        ");
    (24419, 0, "/");
    (24420, 0, "/");
    (24421, 0, " ");
    (24422, 0, "T");
    (24423, 0, "h");
    (24424, 0, "e");
    (24425, 0, " ");
    (24426, 0, "m");
    (24427, 0, "a");
    (24428, 0, "r");
    (24429, 0, "k");
    (24430, 0, "e");
    (24431, 0, "r");
    (24432, 0, " ");
    (24433, 0, "g");
    (24434, 0, "i");
    (24435, 0, "v");
    (24436, 0, "e");
    (24437, 0, "s");
    (24438, 0, " ");
    (24439, 0, "u");
    (24440, 0, "s");
    (24441, 0, " ");
    (24442, 0, "a");
    (24443, 0, " ");
    (24444, 0, "p");
    (24445, 0, "o");
    (24446, 0, "i");
    (24447, 0, "n");
    (24448, 0, "t");
    (24449, 0, "e");
    (24450, 0, "r");
    (24451, 0, " ");
    (24452, 0, "i");
    (24453, 0, "n");
    (24454, 0, "t");
    (24455, 0, "o");
    (24456, 0, " ");
    (24457, 0, "a");
    (24458, 0, " ");
    (24459, 0, "n");
    (24460, 0, "o");
    (24461, 0, "d");
    (24462, 0, "e");
    (3554, 0, "\n");
    (3555, 0, "\n");
    (3556, 0, "\n");
    (3557, 0, "s");
    (3558, 0, "t");
    (3559, 0, "r");
    (3560, 0, "u");
    (3561, 0, "c");
    (3562, 0, "t");
    (3563, 0, " ");
    (3564, 0, "F");
    (3565, 0, "o");
    (3566, 0, "o");
    (3567, 0, " ");
    (3567, 1, "");
    (3567, 0, "(");
    (3568, 0, ")");
    (3569, 0, "\n");
    (3570, 0, "\n");
    (3570, 1, "");
    (3569, 1, "");
    (3569, 0, ";");
    (3570, 0, "\n");
    (3571, 0, "\n");
    (3572, 0, "i");
    (3573, 0, "m");
    (3574, 0, "p");
    (3575, 0, "l");
    (3576, 0, " ");
    (3567, 0, "<");
    (3568, 0, "T");
    (3569, 0, ">");
    (3571, 0, "&");
    (3571, 1, "");
    (3571, 0, "T");
    (3581, 0, "F");
    (3582, 0, "o");
    (3583, 0, "o");
    (3584, 0, " ");
    (3585, 0, "{");
    (3586, 0, "\n    ");
    (3591, 0, "\n    ");
    (3587, 4, "");
    (3588, 4, "}");
    (3580, 0, "<");
    (3581, 0, "T");
    (3582, 0, ">");
    (3587, 0, "<");
    (3588, 0, "T");
    (3589, 0, ">");
    (3593, 0, "    ");
    (3597, 0, "f");
    (3598, 0, "n");
    (3599, 0, " ");
    (3600, 0, "b");
    (3601, 0, "l");
    (3602, 0, "a");
    (3603, 0, "h");
    (3604, 0, "(");
    (3605, 0, ")");
    (3606, 0, " ");
    (3607, 0, "{");
    (3608, 0, "\n        ");
    (3617, 0, "\n        ");
    (3609, 8, "");
    (3610, 8, "    }");
    (3606, 0, " ");
    (3607, 0, "w");
    (3608, 0, "h");
    (3609, 0, "e");
    (3610, 0, "r");
    (3611, 0, "e");
    (3612, 0, " ");
    (3613, 0, "T");
    (3614, 0, ":");
    (3615, 0, " ");
    (3616, 0, "D");
    (3617, 0, "e");
    (3618, 0, "b");
    (3619, 0, "u");
    (3620, 0, "g");
    (3616, 5, "C");
    (3617, 0, "o");
    (3618, 0, "p");
    (3619, 0, "y");
    (3631, 0, "\n");
    (3632, 0, "\n");
    (3633, 0, "f");
    (3634, 0, "n");
    (3635, 0, " ");
    (3636, 0, "x");
    (3637, 0, "(");
    (3638, 0, ")");
    (3639, 0, " ");
    (3640, 0, "{");
    (3641, 0, "\n    ");
    (3646, 0, "\n    ");
    (3642, 4, "");
    (3643, 4, "}");
    (3642, 0, "    ");
    (3646, 0, "F");
    (3647, 0, "o");
    (3648, 0, "o");
    (3649, 0, "(");
    (3650, 0, "3");
    (3651, 0, ")");
    (3646, 0, "l");
    (3647, 0, "e");
    (3648, 0, "t");
    (3649, 0, " ");
    (3650, 0, "x");
    (3651, 0, " ");
    (3652, 0, "=");
    (3653, 0, " ");
    (3660, 0, ";");
    (3661, 0, "\n    ");
    (3666, 0, "x");
    (3667, 0, ".");
    (3668, 0, "b");
    (3669, 0, "l");
    (3670, 0, "a");
    (3671, 0, "h");
    (3672, 0, "(");
    (3673, 0, ")");
    (3674, 0, ";");
    (3605, 0, "&");
    (3606, 0, "s");
    (3607, 0, "e");
    (3608, 0, "l");
    (3609, 0, "f");
    (3663, 1, "");
    (3663, 0, "F");
    (3664, 0, "o");
    (3665, 0, "o");
    (3666, 0, "(");
    (3667, 0, "3");
    (3668, 0, ")");
    (3556, 131, "");
    (3555, 1, "");
    (2721, 0, "        ");
    (2725, 4, "");
    (1937, 12, "");
    (2713, 0, "\n    ");
    (2718, 0, "f");
    (2719, 0, "n");
    (2720, 0, " ");
    (2721, 0, "c");
    (2722, 0, "o");
    (2723, 0, "n");
    (2724, 0, "t");
    (2725, 0, "a");
    (2726, 0, "i");
    (2727, 0, "n");
    (2728, 0, "s");
    (2729, 0, "_");
    (2730, 0, "i");
    (2731, 0, "t");
    (2732, 0, "e");
    (2733, 0, "m");
    (2734, 0, "(");
    (2735, 0, "&");
    (2735, 1, "");
    (2735, 0, "*");
    (2736, 0, "i");
    (2737, 0, "t");
    (2738, 0, "e");
    (2739, 0, "m");
    (2740, 0, ":");
    (2741, 0, " ");
    (2742, 0, "&");
    (2743, 0, "S");
    (2744, 0, "e");
    (2745, 0, "l");
    (2746, 0, "f");
    (2747, 0, ":");
    (2748, 0, ":");
    (2749, 0, "I");
    (2750, 0, "t");
    (2751, 0, "e");
    (2752, 0, "m");
    (2753, 0, ",");
    (2754, 0, " ");
    (2735, 1, "");
    (2754, 0, "q");
    (2755, 0, "u");
    (2756, 0, "e");
    (2757, 0, "r");
    (2758, 0, "y");
    (2759, 0, ":");
    (2760, 0, " ");
    (2761, 0, "&");
    (2762, 0, "S");
    (2763, 0, "e");
    (2764, 0, "l");
    (2765, 0, "f");
    (2766, 0, ":");
    (2767, 0, ":");
    (2768, 0, "I");
    (2769, 0, "t");
    (2770, 0, "e");
    (2771, 0, "m");
    (2772, 0, ")");
    (2773, 0, " ");
    (2774, 0, "-");
    (2775, 0, ">");
    (2776, 0, " ");
    (2777, 0, "B");
    (2777, 1, "");
    (2777, 0, "b");
    (2778, 0, "o");
    (2779, 0, "o");
    (2780, 0, "l");
    (2781, 0, " ");
    (2782, 0, "{");
    (2783, 0, " ");
    (2784, 0, "f");
    (2785, 0, "a");
    (2786, 0, "l");
    (2787, 0, "s");
    (2788, 0, "e");
    (2789, 0, " ");
    (2790, 0, "}");
    (2784, 5, "");
    (2784, 1, "");
    (2783, 1, "");
    (2783, 0, "\n        \n    ");
    (2792, 0, "u");
    (2793, 0, "n");
    (2794, 0, "i");
    (2795, 0, "m");
    (2796, 0, "p");
    (2797, 0, "l");
    (2792, 6, "unimplemented!");
    (2806, 0, "(");
    (2807, 0, ")");
    (2808, 0, ";");
    (2807, 0, "\"");
    (2808, 0, "I");
    (2809, 0, "m");
    (2810, 0, "p");
    (2811, 0, "l");
    (2812, 0, "e");
    (2813, 0, "m");
    (2814, 0, "e");
    (2815, 0, "n");
    (2816, 0, "t");
    (2817, 0, "s");
    (2817, 1, "");
    (2817, 0, " ");
    (2818, 0, "c");
    (2819, 0, "o");
    (2820, 0, "n");
    (2821, 0, "t");
    (2822, 0, "a");
    (2823, 0, "i");
    (2824, 0, "n");
    (2825, 0, "s");
    (2826, 0, "_");
    (2827, 0, "i");
    (2828, 0, "t");
    (2829, 0, "e");
    (2830, 0, "m");
    (2831, 0, " ");
    (2832, 0, "f");
    (2833, 0, "o");
    (2834, 0, "r");
    (2835, 0, " ");
    (2808, 28, "c");
    (2809, 0, "o");
    (2810, 0, "n");
    (2811, 0, "t");
    (2812, 0, "a");
    (2808, 5, "m");
    (2809, 0, "i");
    (2810, 0, "s");
    (2811, 0, "s");
    (2812, 0, "i");
    (2813, 0, "n");
    (2814, 0, "g");
    (2815, 0, " ");
    (2816, 0, "c");
    (2817, 0, "o");
    (2818, 0, "n");
    (2819, 0, "t");
    (2820, 0, "a");
    (2821, 0, "i");
    (2822, 0, "n");
    (2823, 0, "s");
    (2824, 0, "_");
    (2825, 0, "i");
    (2826, 0, "t");
    (2827, 0, "e");
    (2828, 0, "m");
    (2829, 0, " ");
    (2830, 0, "i");
    (2831, 0, "m");
    (2832, 0, "p");
    (2833, 0, "l");
    (2834, 0, " ");
    (2835, 0, "f");
    (2836, 0, "o");
    (2837, 0, "r");
    (2838, 0, " ");
    (2784, 57, "");
    (2783, 1, "");
    (2713, 76, "");
    (2715, 0, "\n");
    (2716, 0, "\n");
    (2717, 0, "p");
    (2718, 0, "u");
    (2719, 0, "b");
    (2720, 0, " ");
    (2721, 0, "t");
    (2722, 0, "r");
    (2723, 0, "a");
    (2724, 0, "i");
    (2725, 0, "t");
    (2726, 0, " ");
    (2727, 0, "C");
    (2728, 0, "o");
    (2729, 0, "n");
    (2730, 0, "t");
    (2731, 0, "a");
    (2732, 0, "i");
    (2733, 0, "n");
    (2734, 0, "s");
    (2735, 0, " ");
    (2736, 0, "{");
    (2737, 0, "\n    ");
    (2742, 0, "\n    ");
    (2738, 4, "");
    (2739, 4, "}");
    ( 2738,
      0,
      "\n\
      \    fn contains_item(item: &Self::Item, query: &Self::Item) -> bool {\n\
      \    }" );
    (2737, 1, "");
    (2790, 6, "");
    (2770, 6, "");
    (2793, 8, "");
    (2793, 0, ";");
    (24482, 0, " ");
    (24483, 0, "w");
    (24484, 0, "h");
    (24485, 0, "e");
    (24486, 0, "r");
    (24487, 0, "e");
    (24488, 0, " ");
    (24489, 0, "C");
    (24490, 0, ":");
    (24491, 0, ":");
    (24492, 0, "I");
    (24493, 0, "t");
    (24494, 0, "e");
    (24495, 0, "m");
    (24496, 0, " ");
    (24497, 0, ":");
    (24497, 1, "");
    (24496, 1, "");
    (24496, 0, ":");
    (24497, 0, " ");
    (24498, 0, "C");
    (24499, 0, "o");
    (24500, 0, "n");
    (24501, 0, "t");
    (24502, 0, "a");
    (24503, 0, "i");
    (24504, 0, "n");
    (24505, 0, "s");
    (24561, 0, "\n        ");
    (24570, 0, "u");
    (24571, 0, "n");
    (24570, 2, "unimplemented!");
    (24584, 0, "(");
    (24585, 0, ")");
    (24586, 0, ";");
    (11918, 0, "p");
    (11919, 0, "u");
    (11920, 0, "b");
    (11921, 0, " ");
    (24574, 17, "");
    (24472, 0, ",");
    (24473, 0, " ");
    (24474, 0, "q");
    (24475, 0, "u");
    (24476, 0, "e");
    (24477, 0, "r");
    (24478, 0, "y");
    (24479, 0, ":");
    (24480, 0, " ");
    (24481, 0, "&");
    (24482, 0, "I");
    (24482, 1, "");
    (24482, 0, "C");
    (24483, 0, ":");
    (24484, 0, ":");
    (24485, 0, "I");
    (24486, 0, "t");
    (24487, 0, "e");
    (24485, 3, "Item");
    (24582, 0, ".");
    (24583, 0, " ");
    (24584, 0, "W");
    (24585, 0, "e");
    (24585, 1, "");
    (24584, 1, "");
    (24583, 1, "");
    (24583, 0, " ");
    (24584, 0, "F");
    (24585, 0, "i");
    (24586, 0, "n");
    (24587, 0, "d");
    (24588, 0, " ");
    (24589, 0, "t");
    (24590, 0, "h");
    (24591, 0, "e");
    (24592, 0, " ");
    (24593, 0, "i");
    (24594, 0, "t");
    (24595, 0, "e");
    (24596, 0, "m");
    (2789, 0, "O");
    (2790, 0, "p");
    (2791, 0, "t");
    (2792, 0, "i");
    (2793, 0, "o");
    (2794, 0, "n");
    (2795, 0, "<");
    (2796, 4, "u");
    (2797, 0, "s");
    (2798, 0, "i");
    (2799, 0, "z");
    (2800, 0, "e");
    (2801, 0, ">");
    (2737, 0, "\n    ");
    (2742, 0, "/");
    (2743, 0, "/");
    (2744, 0, " ");
    (2745, 0, "T");
    (2745, 1, "");
    (2745, 0, "R");
    (2746, 0, "e");
    (2747, 0, "t");
    (2748, 0, "u");
    (2749, 0, "r");
    (2750, 0, "n");
    (2751, 0, "s");
    (2752, 0, " ");
    (2753, 0, "C");
    (2754, 0, "o");
    (2755, 0, "m");
    (2756, 0, "e");
    (2757, 0, "(");
    (2757, 1, "");
    (2756, 1, "");
    (2755, 1, "");
    (2754, 1, "");
    (2753, 1, "");
    (2753, 0, "S");
    (2754, 0, "o");
    (2755, 0, "m");
    (2756, 0, "e");
    (2757, 0, "(");
    (2758, 0, "o");
    (2759, 0, "f");
    (2760, 0, "f");
    (2761, 0, "s");
    (2762, 0, "e");
    (2763, 0, "t");
    (2764, 0, ")");
    (2765, 0, " ");
    (2766, 0, "i");
    (2767, 0, "n");
    (2768, 0, "t");
    (2769, 0, "o");
    (2770, 0, " ");
    (2771, 0, "t");
    (2772, 0, "h");
    (2773, 0, "e");
    (2774, 0, " ");
    (2775, 0, "i");
    (2776, 0, "t");
    (2777, 0, "e");
    (2778, 0, "m");
    (2779, 0, " ");
    (2780, 0, "i");
    (2781, 0, "f");
    (2782, 0, " ");
    (2783, 0, "i");
    (2784, 0, "t");
    (2785, 0, "s");
    (2786, 0, " ");
    (2787, 0, "c");
    (2788, 0, "o");
    (2789, 0, "n");
    (2790, 0, "t");
    (2791, 0, "a");
    (2792, 0, "i");
    (2793, 0, "n");
    (2794, 0, "e");
    (2795, 0, "d");
    (2796, 0, ".");
    (2797, 0, " ");
    (2798, 0, "O");
    (2799, 0, "t");
    (2800, 0, "h");
    (2801, 0, "e");
    (2802, 0, "r");
    (2803, 0, "w");
    (2804, 0, "i");
    (2805, 0, "s");
    (2806, 0, "e");
    (2807, 0, " ");
    (2808, 0, "N");
    (2809, 0, "o");
    (2810, 0, "n");
    (2811, 0, "e");
    (2812, 0, ".");
    (24682, 0, ".");
    (24683, 0, "\n        ");
    (24692, 0, "l");
    (24693, 0, "e");
    (24694, 0, "t");
    (24695, 0, " ");
    (24696, 0, "&");
    (24697, 0, "m");
    (24698, 0, "u");
    (24699, 0, "t");
    (24700, 0, " ");
    (24503, 0, "u");
    (24504, 0, "n");
    (24505, 0, "s");
    (24506, 0, "a");
    (24507, 0, "f");
    (24508, 0, "e");
    (24509, 0, " ");
    (24503, 7, "");
    (24506, 0, " ");
    (24507, 0, "p");
    (24508, 0, "u");
    (24508, 1, "");
    (24507, 1, "");
    (24507, 0, "u");
    (24508, 0, "n");
    (24509, 0, "s");
    (24510, 0, "a");
    (24511, 0, "f");
    (24512, 0, "e");
    (24708, 0, "n");
    (24709, 0, "o");
    (24710, 0, "d");
    (24711, 0, "e");
    (24712, 0, " ");
    (24713, 0, "=");
    (24714, 0, " ");
    (24715, 0, "m");
    (24716, 0, "a");
    (24717, 0, "r");
    (24718, 0, "k");
    (24719, 0, "e");
    (24720, 0, "r");
    (24721, 0, ".");
    (24506, 7, "");
    (24683, 0, "\n        ");
    (24692, 0, "u");
    (24693, 0, "n");
    (24694, 0, "s");
    (24695, 0, "a");
    (24696, 0, "f");
    (24697, 0, "e");
    (24698, 0, " ");
    (24699, 0, "{");
    (24709, 0, "    ");
    (24735, 1, "");
    (24735, 0, ".");
    (24736, 0, "ptr");
    (24739, 0, ";");
    (24729, 0, "*");
    (24729, 1, "");
    (24729, 0, "&");
    (24730, 0, "*");
    (24730, 0, "m");
    (24731, 0, "u");
    (24732, 0, "t");
    (24733, 0, " ");
    (24747, 8, "        }");
    (24746, 0, "\n            ");
    (24759, 0, "\n            ");
    (24747, 12, "");
    (24760, 0, "f");
    (24761, 0, "o");
    (24762, 0, "r");
    (24763, 0, " ");
    (24764, 0, "i");
    (24765, 0, "t");
    (24766, 0, "e");
    (24767, 0, "m");
    (24768, 0, " ");
    (24769, 0, "i");
    (24770, 0, "n");
    (24771, 0, " ");
    (24772, 0, "n");
    (24773, 0, "o");
    (24774, 0, "d");
    (24775, 0, "e");
    (24776, 0, ".");
    (24777, 0, "c");
    (24778, 0, "o");
    (24779, 0, "n");
    (24780, 0, "t");
    (24781, 0, "e");
    (24782, 0, "n");
    (24783, 0, "t");
    (24784, 0, "_");
    (24777, 8, "content_slice");
    (24790, 0, "(");
    (24791, 0, ")");
    (24792, 0, " ");
    (24793, 0, "{");
    (24794, 0, "\n                ");
    (24811, 0, "\n                ");
    (24795, 16, "");
    (24796, 16, "            }");
    (24795, 0, "                ");
    (24825, 0, "\n            ");
    (24795, 16, "");
    (24822, 0, "\n            ");
    (24810, 12, "");
    (24823, 0, "u");
    (24824, 0, "n");
    (24825, 0, "i");
    (24826, 0, "m");
    (24823, 4, "unimplemented!");
    (24837, 0, "(");
    (24838, 0, ")");
    (24839, 0, ";");
    (24795, 0, "                ");
    (24795, 16, "");
    (24733, 1, "");
    (24732, 1, "");
    (24731, 1, "");
    (24730, 1, "");
    (24718, 3, "");
    (24718, 1, "");
    (24726, 1, "");
    (24725, 1, "");
    (24717, 5, "n");
    (24762, 0, ")");
    (24758, 0, "(");
    (24759, 4, "*");
    (24760, 0, "n");
    (24781, 0, "                ");
    (24797, 0, "i");
    (24798, 0, "t");
    (24799, 0, "e");
    (24800, 0, "m");
    (24801, 0, ".");
    (24802, 0, "c");
    (24803, 0, "o");
    (24804, 0, "n");
    (24805, 0, "t");
    (24806, 0, "a");
    (24807, 0, "i");
    (24808, 0, "n");
    (24809, 0, "s");
    (24802, 8, "contains");
    (24810, 0, "(");
    (24810, 1, "");
    (24810, 0, "_");
    (24811, 0, "i");
    (24812, 0, "t");
    (24813, 0, "e");
    (24802, 12, "contains_item");
    (24815, 0, "(");
    (24816, 0, "q");
    (24817, 0, "u");
    (24818, 0, "e");
    (24819, 0, "r");
    (24820, 0, "y");
    (24821, 0, ")");
    (2835, 6, "");
    (2836, 4, "s");
    (2837, 0, "e");
    (2838, 0, "l");
    (2839, 0, "f");
    (24791, 0, "i");
    (24792, 0, "f");
    (24793, 0, " ");
    (24794, 0, "l");
    (24795, 0, "e");
    (24796, 0, "t");
    (24797, 0, " ");
    (24798, 0, "S");
    (24799, 0, "o");
    (24800, 0, "m");
    (24801, 0, "e");
    (24802, 0, "(");
    (24803, 0, "o");
    (24804, 0, "f");
    (24805, 0, "f");
    (24806, 0, "s");
    (24807, 0, "e");
    (24808, 0, "t");
    (24809, 0, ")");
    (24810, 0, " ");
    (24811, 0, "=");
    (24812, 0, " ");
    (24838, 0, " ");
    (24839, 0, "{");
    (24840, 0, "\n                    ");
    (24861, 0, "\n                    ");
    (24841, 20, "");
    (24842, 20, "                }");
    (24841, 0, "                    ");
    (24841, 20, "");
    (24727, 0, "\n            ");
    (24740, 0, "l");
    (24741, 0, "e");
    (24742, 0, "t");
    (24743, 0, " ");
    (24744, 0, "o");
    (24745, 0, "f");
    (24746, 0, "f");
    (24747, 0, "s");
    (24748, 0, "e");
    (24749, 0, "t");
    (24749, 0, "m");
    (24750, 0, "u");
    (24750, 1, "");
    (24749, 1, "");
    (24744, 0, "m");
    (24745, 0, "u");
    (24746, 0, "t");
    (24747, 0, " ");
    (24754, 0, ":");
    (24755, 0, " ");
    (24756, 0, "i");
    (24757, 0, "s");
    (24757, 1, "");
    (24756, 1, "");
    (24756, 0, "s");
    (24757, 0, "i");
    (24757, 1, "");
    (24756, 1, "");
    (24756, 0, "u");
    (24757, 0, "s");
    (24758, 0, "i");
    (24759, 0, "z");
    (24760, 0, "e");
    (24761, 0, " ");
    (24762, 0, "=");
    (24763, 0, " ");
    (24764, 0, "0");
    (24765, 0, ";");
    (24898, 0, " ");
    (24899, 0, "e");
    (24900, 0, "l");
    (24901, 0, "s");
    (24902, 0, "e");
    (24903, 0, " ");
    (24904, 0, "{");
    (24905, 0, "\n                    ");
    (24906, 20, "                }");
    (24842, 0, "i");
    (24843, 0, "t");
    (24844, 0, "e");
    (24845, 0, "m");
    (24846, 0, "_");
    (24910, 0, "\n                    ");
    (24931, 0, "o");
    (24932, 0, "f");
    (24933, 0, "f");
    (24934, 0, "s");
    (24935, 0, "e");
    (24936, 0, "t");
    (24937, 0, " ");
    (24938, 0, "+");
    (24939, 0, "=");
    (24940, 0, " ");
    (24941, 0, "C");
    (24942, 0, ":");
    (24943, 0, ":");
    (24944, 0, "get_usersize(_item: &Self::Item)");
    (24957, 18, "i");
    (24958, 0, "t");
    (24959, 0, "e");
    (24960, 0, "m");
    (24962, 0, ";");
    (24885, 0, "                    ");
    (24905, 0, "o");
    (24906, 0, "f");
    (24907, 0, "f");
    (24908, 0, "s");
    (24909, 0, "e");
    (24910, 0, "t");
    (24911, 0, " ");
    (24912, 0, "+");
    (24913, 0, "=");
    (24914, 0, " ");
    (24915, 0, "i");
    (24916, 0, "t");
    (24917, 0, "e");
    (24918, 0, "m");
    (24915, 4, "item_offset");
    (24926, 0, ";");
    (24927, 0, "\n                    ");
    (24948, 0, "b");
    (24949, 0, "r");
    (24950, 0, "e");
    (24951, 0, "a");
    (24952, 0, "k");
    (24953, 0, ";");
    (25064, 0, "\n            ");
    (25077, 0, "/");
    (25078, 0, "/");
    (25079, 0, " ");
    (25080, 0, "t");
    (25081, 0, "O");
    (25082, 0, "D");
    (25082, 1, "");
    (25081, 1, "");
    (25080, 1, "");
    (25080, 0, "T");
    (25081, 0, "O");
    (25082, 0, "D");
    (25083, 0, "O");
    (25084, 0, ":");
    (25085, 0, " ");
    (25086, 0, "T");
    (25087, 0, "h");
    (25088, 0, "r");
    (25089, 0, "o");
    (25086, 4, "P");
    (25087, 0, "a");
    (25088, 0, "n");
    (25089, 0, "i");
    (25090, 0, "c");
    (25091, 0, " ");
    (25092, 0, "i");
    (25093, 0, "f");
    (25094, 0, " ");
    (25095, 0, "t");
    (25096, 0, "h");
    (25097, 0, "e");
    (25098, 0, " ");
    (25099, 0, "i");
    (25100, 0, "t");
    (25101, 0, "e");
    (25102, 0, "m");
    (25103, 0, " ");
    (25104, 0, "i");
    (25105, 0, "s");
    (25106, 0, "n");
    (25107, 0, "'");
    (25108, 0, "t");
    (25109, 0, " ");
    (25110, 0, "f");
    (25111, 0, "o");
    (25112, 0, "u");
    (25113, 0, "n");
    (25114, 0, "d");
    (25115, 0, ".");
    (25116, 0, " ");
    (25117, 0, "T");
    (25117, 1, "");
    (25117, 0, "C");
    (25118, 0, "u");
    (25119, 0, "r");
    (25120, 0, "r");
    (25121, 0, "e");
    (25122, 0, "n");
    (25123, 0, "t");
    (24766, 0, "\n            ");
    (24779, 0, "l");
    (24780, 0, "e");
    (24781, 0, "t");
    (24782, 0, " ");
    (24783, 0, "m");
    (24784, 0, "u");
    (24785, 0, "t");
    (24786, 0, " ");
    (24787, 0, "f");
    (24788, 0, "o");
    (24789, 0, "u");
    (24790, 0, "n");
    (24791, 0, "d");
    (24792, 0, " ");
    (24793, 0, "=");
    (24794, 0, " ");
    (24795, 0, "f");
    (24796, 0, "a");
    (24797, 0, "l");
    (24798, 0, "s");
    (24799, 0, "e");
    (24800, 0, ";");
    (24962, 0, "\n                    ");
    (24983, 0, "f");
    (24984, 0, "o");
    (24985, 0, "u");
    (24986, 0, "n");
    (24987, 0, "d");
    (24988, 0, " ");
    (24989, 0, "=");
    (24990, 0, " ");
    (24991, 0, "t");
    (24992, 0, "r");
    (24993, 0, "u");
    (24994, 0, "e");
    (24995, 0, ";");
    (25146, 47, "");
    (25146, 0, "a");
    (25147, 0, "s");
    (25148, 0, "s");
    (25149, 0, "e");
    (25150, 0, "r");
    (25151, 0, "t");
    (25152, 0, "(");
    (25152, 1, "");
    (25152, 0, "!");
    (25153, 0, "(");
    (25154, 0, "f");
    (25155, 0, "o");
    (25156, 0, "u");
    (25157, 0, "n");
    (25158, 0, "d");
    (25159, 0, ")");
    (25160, 0, ";");
    (25159, 0, ",");
    (25160, 0, " ");
    (25161, 0, "\"");
    (25162, 0, "M");
    (25162, 1, "");
    (25162, 0, "I");
    (25163, 0, "n");
    (25164, 0, "v");
    (25165, 0, "a");
    (25166, 0, "l");
    (25167, 0, "i");
    (25168, 0, "d");
    (25169, 0, " ");
    (25170, 0, "m");
    (25171, 0, "a");
    (25172, 0, "r");
    (25173, 0, "k");
    (25174, 0, " ");
    (25175, 0, "e");
    (25175, 1, "");
    (25174, 1, "");
    (25174, 0, "e");
    (25175, 0, "r");
    (25176, 0, " ");
    (25177, 0, "-");
    (25178, 0, " ");
    (25179, 0, "i");
    (25180, 0, "t");
    (25181, 0, "e");
    (25182, 0, "m");
    (25183, 0, " ");
    (25184, 0, "n");
    (25185, 0, "o");
    (25186, 0, "t");
    (25187, 0, " ");
    (25188, 0, "f");
    (25189, 0, "o");
    (25190, 0, "u");
    (25191, 0, "n");
    (25192, 0, "d");
    (25193, 0, " ");
    (25194, 0, "i");
    (25195, 0, "n");
    (25196, 0, " ");
    (25197, 0, "n");
    (25198, 0, "o");
    (25199, 0, "d");
    (25200, 0, "e");
    (25201, 0, "\"");
    (25204, 0, "\n            ");
    (25217, 0, "\n            ");
    (25205, 12, "");
    (25218, 0, "/");
    (25219, 0, "/");
    (25220, 0, " ");
    (25221, 0, "N");
    (25222, 0, "o");
    (25223, 0, "w");
    (25224, 0, " ");
    (25225, 0, "w");
    (25226, 0, "e");
    (25227, 0, " ");
    (25228, 0, "n");
    (25229, 0, "e");
    (25230, 0, "e");
    (25231, 0, "d");
    (25232, 0, " ");
    (25233, 0, "t");
    (25234, 0, "o");
    (25235, 0, " ");
    (25236, 0, "m");
    (25237, 0, "a");
    (25238, 0, "k");
    (25239, 0, "e");
    (25240, 0, " ");
    (25241, 0, "a");
    (25242, 0, " ");
    (25243, 0, "c");
    (25244, 0, "u");
    (25245, 0, "r");
    (25246, 0, "s");
    (25247, 0, "o");
    (25248, 0, "r");
    (25249, 0, " ");
    (25250, 0, "a");
    (25251, 0, "t");
    (25252, 0, " ");
    (25253, 0, "t");
    (25254, 0, "h");
    (25255, 0, "e");
    (25256, 0, " ");
    (25257, 0, "u");
    (25258, 0, "s");
    (25259, 0, "e");
    (25260, 0, "r");
    (25261, 0, "p");
    (25262, 0, "o");
    (25263, 0, "s");
    (25264, 0, ".");
    (25256, 0, " ");
    (25257, 0, "n");
    (25258, 0, "o");
    (25259, 0, "d");
    (25260, 0, "e");
    (25261, 0, "/");
    (25262, 1, "");
    (25269, 0, " ");
    (25270, 0, "p");
    (25271, 0, "a");
    (25272, 0, "i");
    (25273, 0, "r");
    (25270, 0, "l");
    (25271, 0, "o");
    (25272, 0, "c");
    (25273, 0, "a");
    (25274, 0, "t");
    (25275, 0, "i");
    (25276, 0, "o");
    (25277, 0, "n");
    (25278, 0, " ");
    (25284, 0, "\n            ");
    (25297, 0, "l");
    (25298, 0, "e");
    (25299, 0, "t");
    (25300, 0, " ");
    (25301, 0, "c");
    (25302, 0, "u");
    (25303, 0, "r");
    (25304, 0, "s");
    (25305, 0, "o");
    (25305, 1, "");
    (25301, 4, "cursor");
    (25307, 0, " ");
    (25308, 0, "=");
    (25309, 0, " ");
    (25310, 0, "C");
    (25311, 0, "u");
    (25312, 0, "r");
    (25313, 0, "s");
    (25314, 0, "o");
    (25315, 0, "r");
    (25316, 0, " ");
    (25317, 0, "{");
    (25318, 0, "\n                ");
    (25335, 0, "\n                ");
    (25319, 16, "");
    (25320, 16, "            }");
    (25333, 0, ";");
    (25319, 0, "                ");
    (25335, 0, "e");
    (25336, 0, "n");
    (25337, 0, "t");
    (25335, 3, "eprint!");
    (25335, 7, "ent");
    (25338, 0, "e");
    (25335, 4, "");
    (25335, 0, "e");
    (25336, 0, "n");
    (25337, 0, "t");
    (25338, 0, "r");
    (25339, 0, "i");
    (25340, 0, "e");
    (25341, 0, "s");
    (25342, 0, ":");
    (25343, 0, " ");
    (25344, 0, "[");
    (25345, 0, "]");
    (25316, 0, "<");
    (25317, 0, "C");
    (25318, 0, ">");
    (25318, 1, "");
    (25317, 1, "");
    (25316, 1, "");
    (25318, 0, "\n                ");
    (25335, 0, "u");
    (25336, 0, "s");
    (25337, 0, "e");
    (25338, 0, "r");
    (25339, 0, "p");
    (25340, 0, "o");
    (25341, 0, "s");
    (25342, 0, ":");
    (25343, 0, " ");
    (25344, 0, "0");
    (25345, 0, ",");
    (25346, 0, "\n                ");
    (25363, 0, "l");
    (25364, 0, "o");
    (25365, 0, "c");
    (25366, 0, "a");
    (25367, 0, "l");
    (25368, 0, "_");
    (25369, 0, "i");
    (25370, 0, "n");
    (25371, 0, "d");
    (25363, 9, "local_index");
    (25374, 0, ":");
    (25375, 0, " ");
    (25376, 0, "0");
    (25377, 0, ",");
    (24787, 14, "");
    (24787, 0, "l");
    (24788, 0, "o");
    (24789, 0, "c");
    (24790, 0, "a");
    (24791, 0, "l");
    (24792, 0, "_");
    (24793, 0, "i");
    (24794, 0, "n");
    (24795, 0, "d");
    (24796, 0, "e");
    (24797, 0, "x");
    (24798, 0, " ");
    (24799, 0, "=");
    (24800, 0, " ");
    (24801, 0, "N");
    (24802, 0, "o");
    (24803, 0, "n");
    (24804, 0, "e");
    (24805, 0, ";");
    (24988, 13, "");
    (24988, 0, "l");
    (24989, 0, "o");
    (24990, 0, "c");
    (24991, 0, "a");
    (24992, 0, "l");
    (24993, 0, "_");
    (24988, 6, "local_index");
    (24999, 0, " ");
    (25000, 0, "=");
    (25001, 0, " ");
    (25002, 0, "S");
    (25003, 0, "o");
    (25004, 0, "m");
    (25005, 0, "e");
    (25006, 0, "(");
    (24851, 0, ".");
    (24852, 0, "e");
    (24853, 0, "n");
    (24854, 0, "u");
    (24855, 0, "m");
    (24852, 4, "enumerate");
    (24861, 0, "(");
    (24862, 0, ")");
    (24823, 0, "(");
    (24824, 0, "i");
    (24825, 0, ")");
    (24825, 1, "");
    (24825, 0, ",");
    (24826, 0, " ");
    (24831, 0, ")");
    (24856, 0, ".");
    (24857, 0, "i");
    (24858, 0, "t");
    (24859, 0, "e");
    (24860, 0, "r");
    (24861, 0, "(");
    (24862, 0, ")");
    (25031, 0, "i");
    (25032, 0, ")");
    (25033, 0, ";");
    (25184, 14, "");
    (25184, 0, "l");
    (25185, 0, "e");
    (25186, 0, "t");
    (25187, 0, " ");
    (25188, 0, "l");
    (25189, 0, "o");
    (25190, 0, "c");
    (25191, 0, "a");
    (25192, 0, "l");
    (25193, 0, "_");
    (25194, 0, "i");
    (25195, 0, "n");
    (25196, 0, "d");
    (25197, 0, "e");
    (25198, 0, "x");
    (25199, 0, " ");
    (25200, 0, "=");
    (25201, 0, " ");
    (25202, 0, "u");
    (25202, 1, "");
    (25202, 0, "l");
    (25203, 0, "o");
    (25204, 0, "c");
    (25205, 0, "a");
    (25206, 0, "l");
    (25202, 5, "local_index");
    (25213, 0, ".");
    (25214, 0, "u");
    (25215, 0, "n");
    (25214, 2, "");
    (25213, 1, "");
    (25213, 0, ".");
    (25214, 0, "e");
    (25215, 0, "x");
    (25216, 0, "p");
    (25217, 0, "e");
    (25214, 4, "expect(msg: &str)");
    (25221, 9, "");
    (25221, 1, "");
    (25221, 1, "");
    (25202, 61, "");
    (25172, 31, "");
    (25171, 1, "");
    (25343, 1, "");
    (25343, 0, "local_index.expect(\"Invalid marker - item not found in node\")");
    (25311, 1, "");
    (25311, 0, "o");
    (25312, 0, "f");
    (25313, 0, "f");
    (25314, 0, "s");
    (25315, 0, "e");
    (25316, 0, "t");
    (25311, 6, "");
    (25311, 0, "0");
    ( 25432,
      0,
      "\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX" );
    (25489, 16, "                    ");
    (25433, 16, "                    ");
    (25538, 0, "\n                    ");
    (25539, 20, "                ");
    ( 25431,
      125,
      "[SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT]," );
    (25542, 12, "                ");
    (25500, 16, "                    ");
    (25444, 16, "                    ");
    (25610, 17, "r");
    (25611, 0, "e");
    (25612, 0, "t");
    (25613, 0, "u");
    (25614, 0, "r");
    (25615, 0, "n");
    (25616, 0, " ");
    (25617, 0, "c");
    (25618, 0, "r");
    (25618, 1, "");
    (25610, 8, "");
    (25610, 0, "c");
    (25611, 0, "u");
    (25612, 0, "r");
    (25613, 0, "s");
    (25614, 0, "o");
    (25615, 0, "r");
    (25596, 0, "\n            ");
    (25609, 0, "\n            ");
    (25597, 12, "");
    (25610, 0, "f");
    (25611, 0, "o");
    (25612, 0, "r");
    (25613, 0, " ");
    (25614, 0, "i");
    (25615, 0, " ");
    (25616, 0, "i");
    (25617, 0, "n");
    (25618, 0, " ");
    (25619, 0, "0");
    (25619, 1, "");
    (25619, 0, "0");
    (25620, 0, ".");
    (25621, 0, ".");
    (25622, 0, "s");
    (25623, 0, "e");
    (25624, 0, "l");
    (25625, 0, "f");
    (25626, 0, ".");
    (25627, 0, "h");
    (25628, 0, "e");
    (25629, 0, "i");
    (25629, 1, "");
    (25628, 1, "");
    (25627, 1, "");
    (25627, 0, "h");
    (25628, 0, "e");
    (25629, 0, "a");
    (25630, 0, "d");
    (25631, 0, ".");
    (25632, 0, "h");
    (25633, 0, "e");
    (25634, 0, "i");
    (25632, 3, "height");
    (25638, 0, " ");
    (25639, 0, "a");
    (25640, 0, "s");
    (25641, 0, " ");
    (25642, 0, "u");
    (25643, 0, "s");
    (25644, 0, "i");
    (25645, 0, "z");
    (25646, 0, "e");
    (25647, 0, " ");
    (25648, 0, "{");
    (25649, 0, "\n                ");
    (25666, 0, "\n                ");
    (25650, 16, "");
    (25651, 16, "            }");
    (25650, 0, "                ");
    (25650, 16, "");
    (25596, 0, "\n            ");
    (25609, 0, "\n            ");
    (25597, 12, "");
    (25610, 0, "c");
    (25611, 0, "u");
    (25612, 0, "r");
    (25613, 0, "s");
    (25614, 0, "o");
    (25615, 0, "r");
    (25616, 0, ".");
    (25617, 0, "e");
    (25618, 0, "n");
    (25619, 0, "t");
    (25620, 0, "r");
    (25621, 0, "i");
    (25622, 0, "e");
    (25623, 0, "s");
    (25624, 0, "[");
    (25625, 0, "0");
    (25626, 0, "]");
    (25627, 0, " ");
    (25628, 0, "=");
    (25629, 0, " ");
    (25630, 0, "S");
    (25631, 0, "k");
    (25632, 0, "i");
    (25633, 0, "p");
    (25630, 4, "SkipEntry");
    (25639, 0, " ");
    (25640, 0, "{");
    (25641, 0, "\n                ");
    (25658, 0, "\n                ");
    (25642, 16, "");
    (25643, 16, "            }");
    (25656, 0, ";");
    (25642, 0, "                ");
    (25658, 0, "n");
    (25659, 0, "o");
    (25660, 0, "d");
    (25661, 0, "e");
    (25662, 0, ":");
    (25663, 0, " ");
    (25664, 0, "n");
    (25665, 0, ",");
    (25666, 0, "\n                ");
    (25683, 0, "s");
    (25684, 0, "k");
    (25685, 0, "i");
    (25686, 0, "p");
    (25687, 0, "_");
    (25688, 0, "u");
    (25689, 0, "s");
    (25690, 0, "e");
    (25691, 0, "r");
    (25692, 0, "s");
    (25693, 0, "i");
    (25683, 11, "skip_usersize");
    (25696, 0, ":");
    (25697, 0, " ");
    (25698, 0, "o");
    (25699, 0, "f");
    (25700, 0, "f");
    (25701, 0, "s");
    (25702, 0, "e");
    (25703, 0, "t");
    (25268, 0, "m");
    (25269, 0, "u");
    (25270, 0, "t");
    (25271, 0, " ");
    (25777, 0, "                ");
    (25777, 16, "");
    (25746, 1, "");
    (25746, 0, "1");
    (25777, 0, "                ");
    (25777, 16, "");
    (24710, 0, " ");
    (24711, 0, "m");
    (24712, 0, "u");
    (24713, 0, "t");
    (25781, 0, "                ");
    (25797, 0, "n");
    (25798, 0, " ");
    (25799, 0, "=");
    (25800, 0, " ");
    (25801, 0, "n");
    (25802, 0, ".");
    (25802, 1, "");
    (25801, 1, "");
    (25801, 0, "(");
    (25802, 0, "*");
    (25803, 0, "n");
    (25804, 0, ")");
    (25805, 0, ".");
    (25806, 0, "p");
    (25807, 0, "a");
    (25808, 0, "r");
    (25809, 0, "e");
    (25810, 0, "n");
    (25811, 0, "t");
    (25812, 0, "r");
    (25812, 1, "");
    (25812, 0, ";");
    (25813, 0, "\n                ");
    (25830, 0, "/");
    (25831, 0, "/");
    (25832, 0, " ");
    (25833, 0, "A");
    (25834, 0, "n");
    (25835, 0, "d");
    (25836, 0, " ");
    (25837, 0, "f");
    (25838, 0, "i");
    (25839, 0, "n");
    (25840, 0, "d");
    (25841, 0, " ");
    (25842, 0, "t");
    (25843, 0, "h");
    (25844, 0, "e");
    (25845, 0, " ");
    (25846, 0, "o");
    (25847, 0, "f");
    (25848, 0, "f");
    (25849, 0, "s");
    (25850, 0, "e");
    (25851, 0, "t");
    (25846, 6, "l");
    (25847, 0, "o");
    (25848, 0, "c");
    (25849, 0, "a");
    (25850, 0, "l");
    (25851, 0, " ");
    (25852, 0, "o");
    (25853, 0, "f");
    (25854, 0, "f");
    (25855, 0, "s");
    (25856, 0, "e");
    (25857, 0, "t");
    (25858, 0, ".");
    (25859, 0, " ");
    (25860, 0, "N");
    (25861, 0, "o");
    (25862, 0, "t");
    (25863, 0, "e");
    (25878, 0, "\n            ");
    (25891, 0, "a");
    (25892, 0, "s");
    (25893, 0, "d");
    (25894, 0, "f");
    (25895, 0, "j");
    (25896, 0, "h");
    (25897, 0, "a");
    (25898, 0, "s");
    (25899, 0, "k");
    (25900, 0, "d");
    (25901, 0, "f");
    (25902, 0, "j");
    (25903, 0, "h");
    (25891, 13, "u");
    (25892, 0, "n");
    (25891, 2, "unimplemented!");
    (25905, 0, "(");
    (25906, 0, ")");
    (25907, 0, ";");
    (2727, 8, "I");
    (2728, 0, "t");
    (2729, 0, "e");
    (2730, 0, "m");
    (2731, 0, "Q");
    (2732, 0, "u");
    (2733, 0, "e");
    (2734, 0, "r");
    (2735, 0, "y");
    (2738, 0, "\n    ");
    (2743, 0, "t");
    (2744, 0, "y");
    (2745, 0, "p");
    (2746, 0, "e");
    (2747, 0, " ");
    (2748, 0, "Q");
    (2749, 0, "u");
    (2750, 0, "e");
    (2751, 0, "r");
    (2752, 0, "y");
    (2753, 0, ":");
    (2754, 0, " ");
    (2754, 1, "");
    (2753, 1, "");
    (2753, 0, ";");
    (2754, 0, "\n    ");
    (2872, 4, "Q");
    (2755, 4, "");
    (2869, 0, "u");
    (2870, 0, "e");
    (2871, 0, "r");
    (2872, 0, "y");
    (2868, 0, "S");
    (2869, 0, "e");
    (2870, 0, "l");
    (2871, 0, "f");
    (2872, 0, ":");
    (2873, 0, ":");
    (2743, 0, "// ");
    (2763, 3, "");
    (2763, 0, "// ");
    (2743, 3, "");
    (2727, 9, "Q");
    (2728, 0, "u");
    (2729, 0, "e");
    (2730, 0, "r");
    (2731, 0, "y");
    (2732, 0, "a");
    (2733, 0, "b");
    (2734, 0, "l");
    (2735, 0, "e");
    (24543, 0, "<");
    (24544, 0, "Q");
    (24545, 0, ":");
    (24546, 0, " ");
    (24547, 0, "Q");
    (24548, 0, "u");
    (24549, 0, "e");
    (24550, 0, "r");
    (24547, 4, "Queryable");
    (24556, 0, ">");
    (24600, 7, "");
    (24600, 0, "Q");
    (24601, 0, ":");
    (24602, 0, ":");
    (24603, 0, "Q");
    (24604, 0, "u");
    (24605, 0, "e");
    (24606, 0, "r");
    (24607, 0, "y");
    (24543, 14, "");
    (24543, 0, "<Q: Queryable>");
    (24545, 11, "");
    (24627, 8, "Q");
    (24628, 0, "u");
    (24629, 0, "e");
    (24630, 0, "r");
    (24627, 4, "Queryable");
    (24545, 1, "");
    (24544, 1, "");
    (24543, 1, "");
    (24586, 1, "");
    (24586, 0, "(");
    (24587, 0, "C");
    (24588, 0, ":");
    (24589, 0, ":");
    (24590, 0, "I");
    (24591, 0, "t");
    (24592, 0, "e");
    (24593, 0, "m");
    (24594, 0, " ");
    (24595, 0, "a");
    (24596, 0, "s");
    (24597, 0, " ");
    (24597, 1, "");
    (24596, 1, "");
    (24595, 1, "");
    (24594, 1, "");
    (24594, 0, " ");
    (24595, 0, "a");
    (24596, 0, "s");
    (24597, 0, " ");
    (24598, 0, "Q");
    (24599, 0, "u");
    (24600, 0, "e");
    (24601, 0, "r");
    (24602, 0, "y");
    (24598, 5, "Queryable");
    (24607, 0, ">");
    (24607, 1, "");
    (24607, 0, ">");
    (24586, 1, "");
    (24586, 0, "<");
    (24586, 1, "");
    (24586, 0, "(");
    (24607, 1, "");
    (24607, 0, ")");
    (24594, 14, "");
    (24586, 1, "");
    (24586, 0, "<");
    (24594, 0, " ");
    (24595, 0, "a");
    (24596, 0, "s");
    (24597, 0, " ");
    (24598, 0, "Q");
    (24599, 0, "u");
    (24600, 0, "e");
    (24601, 0, "r");
    (24602, 0, "y");
    (24603, 0, "a");
    (24604, 0, "b");
    (24605, 0, "l");
    (24606, 0, "e");
    (24607, 0, ">");
    (24615, 1, "");
    (24615, 0, ")");
    (24516, 0, "\n    ");
    (24521, 0, "\n    ");
    (24517, 4, "");
    (24522, 0, "p");
    (24523, 0, "u");
    (24524, 0, "b");
    (24525, 0, " ");
    (24526, 0, "f");
    (24527, 0, "n");
    (24528, 0, " ");
    (24529, 0, "i");
    (24530, 0, "t");
    (24531, 0, "e");
    (24532, 0, "r");
    (24533, 0, "_");
    (24534, 0, "a");
    (24535, 0, "t");
    (24536, 0, "_");
    (24537, 0, "n");
    (24538, 0, "o");
    (24539, 0, "d");
    (24540, 0, "e");
    (24541, 0, "(");
    (24542, 0, "&");
    (24543, 0, "m");
    (24544, 0, "u");
    (24545, 0, "t");
    (24546, 0, " ");
    (24547, 0, "s");
    (24548, 0, "e");
    (24549, 0, "l");
    (24550, 0, "f");
    (24551, 0, ",");
    (24552, 0, " ");
    (24553, 0, "n");
    (24554, 0, "o");
    (24555, 0, "d");
    (24556, 0, "e");
    (24557, 0, ":");
    (24558, 0, " ");
    (24559, 0, "&");
    (24559, 1, "");
    (24559, 0, "*");
    (24560, 0, "m");
    (24561, 0, "u");
    (24562, 0, "t");
    (24563, 0, " ");
    (24564, 0, "N");
    (24565, 0, "o");
    (24566, 0, "d");
    (24567, 0, "e");
    (24568, 0, ")");
    (24569, 0, " ");
    (24570, 0, "{");
    (24571, 0, "\n        ");
    (24580, 0, "\n        ");
    (24572, 8, "");
    (24573, 8, "    }");
    (24568, 0, "<");
    (24569, 0, "C");
    (24570, 0, ">");
    (24522, 4, "");
    (24568, 0, " ");
    (24569, 0, "-");
    (24570, 0, ">");
    (24571, 0, " ");
    (24572, 0, "C");
    (24573, 0, "u");
    (24574, 0, "r");
    (24575, 0, "s");
    (24576, 0, "o");
    (24572, 5, "Cursor");
    (24578, 0, "<");
    (24579, 0, "C");
    (24580, 0, ">");
    (24522, 0, "u");
    (24523, 0, "n");
    (24524, 0, "s");
    (24525, 0, "a");
    (24526, 0, "f");
    (24527, 0, "e");
    (24528, 0, " ");
    ( 24591,
      0,
      "\n\
      \            // Now we need to make a cursor at the node/userpos \
       location pair.\n\
      \            let mut cursor = Cursor {\n\
      \                userpos: 0,\n\
      \                local_index: local_index.expect(\"Invalid marker - item \
       not found in node\"),\n\
      \                entries: [SkipEntry {\n\
      \                    node: &self.head as *const _ as *mut _,\n\
      \                    skip_usersize: usize::MAX\n\
      \                }; MAX_HEIGHT],\n\
      \            };" );
    (24591, 0, "        ");
    (24599, 0, "l");
    (24600, 0, "e");
    (24601, 0, "t");
    (24602, 0, " ");
    (24603, 0, "m");
    (24604, 0, "u");
    (24605, 0, "t");
    (24606, 0, " ");
    (24607, 0, "o");
    (24608, 0, "f");
    (24609, 0, "f");
    (24610, 0, "s");
    (24611, 0, "e");
    (24612, 0, "t");
    (24613, 0, " ");
    (24614, 0, "=");
    (24615, 0, " ");
    (24616, 0, "0");
    (24617, 0, ";");
    (24574, 0, ",");
    (24575, 0, " ");
    (24576, 0, "s");
    (24577, 0, "i");
    (24577, 1, "");
    (24576, 1, "");
    (24576, 0, "o");
    (24577, 0, "f");
    (24578, 0, "f");
    (24579, 0, "s");
    (24580, 0, "e");
    (24581, 0, "t");
    (24582, 0, ":");
    (24583, 0, " ");
    (24584, 0, "s");
    (24585, 0, "i");
    (24586, 0, "z");
    (24587, 0, "e");
    (24588, 0, "_");
    (24588, 1, "");
    (24587, 1, "");
    (24586, 1, "");
    (24585, 1, "");
    (24584, 1, "");
    (24584, 0, "u");
    (24585, 0, "s");
    (24586, 0, "i");
    (24587, 0, "z");
    (24588, 0, "e");
    (24606, 27, "");
    (24605, 1, "");
    (24576, 0, "m");
    (24577, 0, "u");
    (24578, 0, "t");
    (24579, 0, " ");
    (25023, 12, "        ");
    (24991, 16, "            ");
    (24945, 20, "                ");
    (24885, 20, "                ");
    (24847, 16, "            ");
    (24755, 16, "            ");
    (24727, 16, "            ");
    (24689, 12, "        ");
    (24610, 12, "        ");
    (24610, 74, "");
    (24609, 1, "");
    (24667, 0, " ");
    (24668, 0, "/");
    (24669, 0, "/");
    (24670, 0, " ");
    (24671, 0, "W");
    (24672, 0, "e");
    (24673, 0, "'");
    (24674, 0, "l");
    (24675, 0, "l");
    (24676, 0, " ");
    (24677, 0, "s");
    (24678, 0, "e");
    (24679, 0, "t");
    (24680, 0, " ");
    (24681, 0, "t");
    (24682, 0, "h");
    (24683, 0, "i");
    (24684, 0, "s");
    (24685, 0, " ");
    (24686, 0, "l");
    (24687, 0, "a");
    (24688, 0, "t");
    (24689, 0, "e");
    (24690, 0, "r");
    (24691, 0, ".");
    (24718, 61, "");
    (24718, 0, "u");
    (24719, 0, "s");
    (24720, 0, "i");
    (24721, 0, "z");
    (24722, 0, "e");
    (24723, 0, ":");
    (24724, 0, ":");
    (24725, 0, "M");
    (24726, 0, "A");
    (24727, 0, "X");
    (24729, 0, " ");
    (24730, 0, "/");
    (24731, 0, "/");
    (24732, 0, " ");
    (24733, 0, "s");
    (24734, 0, "e");
    (24735, 0, "t");
    (24733, 3, "m");
    (24734, 0, "u");
    (24735, 0, "s");
    (24736, 0, "t");
    (24737, 0, " ");
    (24738, 0, "b");
    (24739, 0, "e");
    (24740, 0, " ");
    (24741, 0, "s");
    (24742, 0, "e");
    (24743, 0, "t");
    (24744, 0, " ");
    (24745, 0, "b");
    (24746, 0, "y");
    (24747, 0, " ");
    (24748, 0, "c");
    (24749, 0, "a");
    (24750, 0, "l");
    (24751, 0, "l");
    (24752, 0, "e");
    (24753, 0, "r");
    (24754, 0, ".");
    (24755, 0, " ");
    (24756, 0, "(");
    (24757, 0, "M");
    (24758, 0, "a");
    (24759, 0, "y");
    (24760, 0, "b");
    (24761, 0, "e");
    (24762, 0, " ");
    (24763, 0, "t");
    (24764, 0, "h");
    (24765, 0, "i");
    (24766, 0, "s");
    (24767, 0, " ");
    (24762, 6, " ");
    (24763, 0, "s");
    (24764, 0, "h");
    (24765, 0, "o");
    (24766, 0, "u");
    (24767, 0, "l");
    (24768, 0, "d");
    (24769, 0, " ");
    (24770, 0, "j");
    (24771, 0, "u");
    (24772, 0, "s");
    (24773, 0, "t");
    (24774, 0, " ");
    (24775, 0, "b");
    (24776, 0, "e");
    (24777, 0, " ");
    (24778, 0, "p");
    (24779, 0, "a");
    (24780, 0, "s");
    (24781, 0, "e");
    (24781, 1, "");
    (24781, 0, "s");
    (24782, 0, "e");
    (24783, 0, "d");
    (24784, 0, " ");
    (24785, 0, "i");
    (24786, 0, "n");
    (24787, 0, ")");
    (24718, 70, "l");
    (24719, 0, "o");
    (24720, 0, "c");
    (24721, 0, "a");
    (24722, 0, "l");
    (24723, 0, "_");
    (24724, 0, "i");
    (24725, 0, "n");
    (24726, 0, "d");
    (24727, 0, "e");
    (24728, 0, "x");
    (24729, 0, ",");
    (24593, 0, ",");
    (24594, 0, " ");
    (24595, 0, "l");
    (24596, 0, "o");
    (24597, 0, "c");
    (24598, 0, "a");
    (24599, 0, "l");
    (24600, 0, "_");
    (24601, 0, "i");
    (24602, 0, "n");
    (24603, 0, "d");
    (24604, 0, "e");
    (24605, 0, "x");
    (24606, 0, ":");
    (24607, 0, " ");
    (24608, 0, "u");
    (24609, 0, "s");
    (24610, 0, "i");
    (24611, 0, "z");
    (24612, 0, "e");
    (24921, 0, "\n        ");
    (24930, 0, "\n        ");
    (24922, 8, "");
    (24931, 0, "\n        ");
    (24923, 8, "");
    (24932, 0, "c");
    (24933, 0, "u");
    (24934, 0, "r");
    (24935, 0, "s");
    (24936, 0, "o");
    (24937, 0, "r");
    (24921, 0, "\n        ");
    (24930, 0, "\n        ");
    (24922, 8, "");
    (24923, 8, "");
    ( 24922,
      0,
      "\n\
      \            for i in 1..self.head.height as usize {\n\
      \                n = (*n).parent;\n\
      \                // And find the local offset. Note\n\
      \            }" );
    (25059, 12, "        ");
    (25008, 16, "            ");
    (24975, 16, "            ");
    (24923, 12, "        ");
    (25057, 1, "");
    (25056, 1, "");
    (26215, 122, "");
    ( 24922,
      0,
      "\n\
      \            cursor.entries[0] = SkipEntry {\n\
      \                node: n,\n\
      \                skip_usersize: offset\n\
      \            };" );
    (25030, 12, "        ");
    (24992, 16, "            ");
    (24967, 16, "            ");
    (24923, 12, "        ");
    (25028, 0, "\n        ");
    (25029, 8, "");
    (24556, 4, "n");
    (25026, 0, "\n        ");
    (25035, 0, "/");
    (25036, 0, "/");
    (25037, 0, " ");
    (24556, 0, "m");
    (24557, 0, "u");
    (24558, 0, "t");
    (24559, 0, " ");
    (25042, 0, "N");
    (25043, 0, "o");
    (25044, 0, "w");
    (25045, 0, " ");
    (25046, 0, "w");
    (25047, 0, "e");
    (25048, 0, " ");
    (25049, 0, "n");
    (25050, 0, "e");
    (25051, 0, "e");
    (25052, 0, "d");
    (25053, 0, " ");
    (25054, 0, "t");
    (25055, 0, "o");
    (25056, 0, " ");
    (25057, 0, "w");
    (25058, 0, "a");
    (25059, 0, "l");
    (25060, 0, "k");
    (25061, 0, " ");
    (25062, 0, "u");
    (25063, 0, "p");
    (25064, 0, " ");
    (25065, 0, "t");
    (25066, 0, "h");
    (25067, 0, "e");
    (25068, 0, " ");
    (25069, 0, "p");
    (25070, 0, "a");
    (25071, 0, "r");
    (25072, 0, "e");
    (25073, 0, "n");
    (25074, 0, "t");
    (25075, 0, "s");
    (25076, 0, "'");
    (25077, 0, " ");
    (25078, 0, "t");
    (25079, 0, "r");
    (25080, 0, "e");
    (25081, 0, "e");
    (24923, 0, "\n        ");
    (24932, 0, "l");
    (24933, 0, "e");
    (24934, 0, "t");
    (24935, 0, " ");
    (24936, 0, "m");
    (24937, 0, "u");
    (24938, 0, "t");
    (24939, 0, " ");
    (24940, 0, "h");
    (24941, 0, "e");
    (24942, 0, "i");
    (24943, 0, "g");
    (24944, 0, "h");
    (24945, 0, "t");
    (24946, 0, " ");
    (24947, 0, "=");
    (24948, 0, " ");
    (24949, 0, "0");
    (24950, 0, ";");
    (24951, 0, "\n        ");
    (24960, 0, "\n        ");
    (24952, 8, "");
    (24961, 0, "f");
    (24962, 0, "o");
    (24963, 0, "r");
    (24964, 0, " ");
    (24932, 0, "// ");
    (24968, 0, "h");
    (24969, 0, " ");
    (24970, 0, "i");
    (24971, 0, "n");
    (24972, 0, " ");
    (24973, 0, "0");
    (24974, 0, ".");
    (24975, 0, ".");
    (24976, 0, "(");
    (24977, 0, "*");
    (24978, 0, "n");
    (24979, 0, ")");
    (24980, 0, ".");
    (24981, 0, "h");
    (24982, 0, "e");
    (24983, 0, "i");
    (24984, 0, "g");
    (24985, 0, "h");
    (24986, 0, "t");
    (24987, 0, " ");
    (24987, 0, " ");
    (24988, 0, "a");
    (24989, 0, "s");
    (24990, 0, " ");
    (24991, 0, "u");
    (24992, 0, "s");
    (24993, 0, "i");
    (24994, 0, "z");
    (24995, 0, "e");
    (24996, 0, " ");
    (24997, 0, "{");
    (25095, 8, "            ");
    (25061, 12, "                ");
    (25040, 12, "                ");
    (25000, 8, "            ");
    (25121, 0, "\n            ");
    (25122, 12, "        }");
    (25027, 1, "");
    (25027, 0, "h");
    (24998, 1, "");
    (25183, 0, "\n        ");
    (25192, 0, "for h in 0..(*n).height as usize { ");
    (24955, 0, "\n        ");
    (24964, 0, "/");
    (24965, 0, "/");
    (24966, 0, " ");
    (24967, 0, "C");
    (24968, 0, "o");
    (24969, 0, "u");
    (24970, 0, "l");
    (24971, 0, "d");
    (24972, 0, " ");
    (24973, 0, "e");
    (24974, 0, "v");
    (24975, 0, "e");
    (24976, 0, "n");
    (24977, 0, " ");
    (24978, 0, "j");
    (24979, 0, "u");
    (24980, 0, "s");
    (24981, 0, "t");
    (24982, 0, " ");
    (24964, 19, "");
    (24960, 4, "");
    (24956, 4, "");
    (24955, 1, "");
    (25146, 11, "");
    (24955, 0, "\n        ");
    (24964, 0, "\n        ");
    (24956, 8, "");
    (24957, 8, "");
    (24956, 0, "\n        ");
    (24965, 0, "l");
    (24966, 0, "e");
    (24967, 0, "t");
    (24968, 0, " ");
    (24969, 0, "h");
    (24970, 0, " ");
    (24971, 0, "=");
    (24972, 0, " ");
    (24969, 3, "m");
    (24970, 0, "m");
    (24970, 1, "");
    (24970, 0, "u");
    (24971, 0, "t");
    (24972, 0, " ");
    (24973, 0, "h");
    (24974, 0, " ");
    (24975, 0, "=");
    (24976, 0, " ");
    (24977, 0, "0");
    (24978, 0, ";");
    (24979, 0, "\n        ");
    (24988, 0, "w");
    (24989, 0, "h");
    (24990, 0, "i");
    (24991, 0, "l");
    (24988, 4, "");
    (24988, 0, "l");
    (24989, 0, "o");
    (24990, 0, "o");
    (24991, 0, "p");
    (24992, 0, " ");
    (24993, 0, "{");
    (24994, 0, "\n            ");
    (25007, 1, "\n            ");
    (25008, 12, "        }");
    (25007, 0, "w");
    (25008, 0, "h");
    (25009, 0, "i");
    (25010, 0, "l");
    (25011, 0, "e");
    (25012, 0, " ");
    (25013, 0, "h");
    (25014, 0, " ");
    (25015, 0, "<");
    (25016, 0, " ");
    (25017, 0, "(*n).height");
    (25028, 0, " ");
    (25029, 0, "a");
    (25030, 0, "s");
    (25031, 0, " ");
    (25032, 0, "u");
    (25033, 0, "s");
    (25034, 0, "i");
    (25035, 0, "z");
    (25036, 0, "e");
    (25037, 0, " ");
    (25038, 0, "{");
    (25039, 0, "\n                ");
    (25056, 0, "\n                ");
    (25040, 16, "");
    (25041, 16, "            }");
    (25109, 122, "");
    ( 25040,
      0,
      "            cursor.entries[h] = SkipEntry {\n\
      \                node: n,\n\
      \                skip_usersize: offset\n\
      \            };\n" );
    (25162, 0, "    ");
    (25147, 12, "                ");
    (25109, 16, "                    ");
    (25084, 16, "                    ");
    (25040, 12, "                ");
    (25177, 1, "");
    (25258, 0, "// ");
    (25215, 0, "// ");
    (25195, 0, "\n            ");
    (25208, 0, "\n            ");
    (25196, 12, "");
    (25498, 0, "// ");
    (25451, 0, "// ");
    (25422, 0, "// ");
    (25374, 0, "// ");
    (25330, 0, "// ");
    (25197, 12, "");
    (25197, 0, "    n = (*n).parent;");
    (25197, 4, "            ");
    (25225, 0, "\n            ");
    (25238, 0, "i");
    (25239, 0, "f");
    (25240, 0, " ");
    (25241, 0, "n");
    (25242, 0, " ");
    (25243, 0, "=");
    (25244, 0, "=");
    (25245, 0, " ");
    (25246, 0, "s");
    (25247, 0, "e");
    (25248, 0, "l");
    (25249, 0, "f");
    (25250, 0, ".");
    (25251, 0, "h");
    (25252, 0, "e");
    (25253, 0, "a");
    (25254, 0, "d");
    (25246, 0, "&");
    (25256, 0, " ");
    (25257, 0, "{");
    (25258, 0, " ");
    (25259, 0, "b");
    (25260, 0, "r");
    (25261, 0, "e");
    (25262, 0, "a");
    (25263, 0, "k");
    (25264, 0, ";");
    (25265, 0, " ");
    (25266, 0, "}");
    (25267, 0, "\n            ");
    (25268, 12, "");
    (25242, 0, "a");
    (25243, 0, "s");
    (25244, 0, " ");
    (25244, 1, "");
    (25243, 1, "");
    (25242, 1, "");
    (25242, 0, " ");
    (25243, 0, "a");
    (25244, 0, "s");
    (25245, 0, " ");
    (25246, 0, "*");
    (25247, 0, "c");
    (25248, 0, "o");
    (25249, 0, "n");
    (25250, 0, "s");
    (25251, 0, "t");
    (25252, 0, " ");
    (25253, 0, "_");
    (25268, 0, " ");
    (25269, 0, "a");
    (25270, 0, "s");
    (25271, 0, " ");
    (25272, 0, "*");
    (25273, 0, "c");
    (25274, 0, "o");
    (25275, 0, "n");
    (25276, 0, "s");
    (25277, 0, "t");
    (25278, 0, " ");
    (25279, 0, "_");
    (25269, 12, "");
    (25280, 0, "            ");
    (25280, 12, "");
    (25279, 1, "");
    (25225, 0, "\n            ");
    (25238, 0, "\n            ");
    (25226, 12, "");
    (25227, 12, "");
    (25226, 0, "\n            ");
    (25227, 12, "");
    (25181, 0, "\n                ");
    (25182, 16, "");
    (25181, 1, "");
    (25180, 1, "");
    (25179, 1, "");
    (25178, 1, "");
    (25177, 1, "");
    (25177, 0, "\n                ");
    (25194, 0, "h");
    (25195, 0, " ");
    (25196, 0, "+");
    (25197, 0, "=");
    (25198, 0, " ");
    (25199, 0, "1");
    (25200, 0, ";");
    (25177, 0, "\n                ");
    (25263, 0, "            ");
    (25178, 16, "");
    (25259, 0, "d");
    (25260, 0, "e");
    (25261, 0, "b");
    (25262, 0, "u");
    (25263, 0, "g");
    (25259, 5, "debug_assert!");
    (25272, 0, "(");
    (25273, 0, "(");
    (25274, 0, "*");
    (25275, 0, "n");
    (25276, 0, ")");
    (25277, 0, ".");
    (25278, 0, "h");
    (25279, 0, "e");
    (25280, 0, "i");
    (25281, 0, "g");
    (25282, 0, "h");
    (25283, 0, "t");
    (25284, 0, " ");
    (25285, 0, ">");
    (25286, 0, " ");
    (25287, 0, "h");
    (25288, 0, ")");
    (25289, 0, ";");
    (25288, 0, " ");
    (25289, 0, "a");
    (25290, 0, "s");
    (25291, 0, " ");
    (25288, 4, "");
    (25284, 0, " ");
    (25285, 0, "a");
    (25286, 0, "s");
    (25287, 0, " ");
    (25288, 0, "u");
    (25289, 0, "s");
    (25290, 0, "i");
    (25291, 0, "z");
    (25292, 0, "e");
    (25355, 0, "\n");
    (25301, 1, "");
    (25354, 0, "\n");
    (25300, 1, "");
    (25353, 0, "\n            debug_assert!((*n).height as usize > h);");
    (25247, 53, "");
    (25300, 0, "\n            n = (*n).parent;");
    (25218, 29, "");
    (25271, 0, "\n");
    (25217, 1, "");
    (25216, 0, "\n            ");
    (25229, 0, "\n            ");
    (25217, 12, "");
    (25230, 0, "/");
    (25231, 0, "/");
    (25232, 0, " ");
    (25233, 0, "?");
    (25234, 0, "?");
    (25235, 0, " ");
    (25236, 0, "C");
    (25237, 0, "o");
    (25238, 0, "u");
    (25239, 0, "l");
    (25240, 0, "d");
    (25241, 0, " ");
    (25242, 0, "i");
    (25243, 0, "n");
    (25244, 0, "s");
    (25245, 0, "t");
    (25246, 0, "e");
    (25247, 0, "a");
    (25248, 0, "d");
    (25249, 0, " ");
    (25250, 0, "c");
    (25251, 0, "h");
    (25252, 0, "e");
    (25253, 0, "c");
    (25254, 0, "k");
    (25255, 0, " ");
    (25256, 0, "i");
    (25257, 0, "f");
    (25258, 0, " ");
    (25259, 0, "n");
    (25260, 0, " ");
    (25261, 0, "i");
    (25262, 0, "s");
    (25263, 0, " ");
    (25264, 0, "n");
    (25265, 0, "u");
    (25266, 0, "l");
    (25267, 0, "l");
    (25268, 0, ".");
    (25408, 0, "            ");
    (25408, 12, "");
    (25233, 2, "S");
    (25234, 0, "h");
    (25235, 0, "o");
    (25236, 0, "u");
    (25237, 0, "l");
    (25238, 0, "d");
    (25239, 6, "");
    (25247, 0, " ");
    (25248, 0, "b");
    (25249, 0, "e");
    (25250, 0, " ");
    (25251, 0, "a");
    (25252, 0, "b");
    (25253, 0, "l");
    (25254, 0, "e");
    (25255, 0, " ");
    (25256, 0, "t");
    (25257, 0, "o");
    (25417, 0, "            ");
    (25429, 0, "/");
    (25430, 0, "/");
    (25431, 0, " ");
    (25432, 0, "A");
    (25433, 0, "n");
    (25434, 0, "d");
    (25435, 0, " ");
    (25436, 0, "u");
    (25437, 0, "p");
    (25437, 1, "");
    (25436, 1, "");
    (25436, 0, "f");
    (25437, 0, "i");
    (25438, 0, "g");
    (25439, 0, "u");
    (25440, 0, "r");
    (25441, 0, "e");
    (25442, 0, " ");
    (25443, 0, "o");
    (25444, 0, "u");
    (25445, 0, "t");
    (25446, 0, " ");
    (25447, 0, "t");
    (25448, 0, "h");
    (25449, 0, "e");
    (25450, 0, " ");
    (25451, 0, "o");
    (25452, 0, "f");
    (25453, 0, "f");
    (25454, 0, "s");
    (25455, 0, "e");
    (25456, 0, "t");
    (25457, 0, ".");
    (25346, 0, "l");
    (25347, 0, "e");
    (25348, 0, "t");
    (25349, 0, " ");
    (25350, 1, "p");
    (25351, 0, "a");
    (25352, 0, "r");
    (25353, 0, "e");
    (25354, 0, "n");
    (25355, 0, "t");
    (25467, 0, "\n            ");
    (25480, 0, "\n            ");
    (25468, 12, "");
    (25481, 0, "n");
    (25482, 0, " ");
    (25483, 0, "=");
    (25484, 0, " ");
    (25485, 0, "p");
    (25486, 0, "a");
    (25487, 0, "r");
    (25488, 0, "e");
    (25489, 0, "n");
    (25490, 0, "t");
    (25491, 0, ";");
    (25466, 1, "");
    (25466, 0, " ");
    (25467, 0, "f");
    (25468, 0, "r");
    (25469, 0, "o");
    (25470, 0, "m");
    (25471, 0, " ");
    (25472, 0, "p");
    (25473, 0, "a");
    (25474, 0, "r");
    (25475, 0, "e");
    (25476, 0, "n");
    (25477, 0, "t");
    (25478, 0, " ");
    (25479, 0, "t");
    (25480, 0, "o");
    (25481, 0, " ");
    (25482, 0, "n");
    (25483, 0, ".");
    (25484, 0, "\n            ");
    ( 25497,
      0,
      "            let mut n = new_node_ptr;\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[new_height_usize - 2].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\n\
      \                (*n).parent = new_node_ptr;\n\
      \            }" );
    (25485, 24, "            ");
    (25485, 38, "");
    (25485, 214, "");
    (25484, 1, "");
    (25484, 0, "\n            ");
    (25497, 0, "\n            ");
    (25485, 12, "");
    (25486, 12, "");
    (25441, 3, "W");
    (25442, 0, "a");
    (25443, 0, "l");
    (25444, 0, "k");
    (25445, 0, " ");
    (25446, 0, "f");
    (25447, 0, "r");
    (25448, 0, "o");
    (25449, 0, "m");
    (25450, 0, " ");
    (25451, 0, "b");
    (25452, 0, "p");
    (25452, 1, "");
    (25451, 1, "");
    (25451, 0, "p");
    (25452, 0, "a");
    (25453, 0, "r");
    (25454, 0, "e");
    (25455, 0, "n");
    (25456, 0, "t");
    (25457, 0, " ");
    (25458, 0, "b");
    (25459, 0, "a");
    (25460, 0, "c");
    (25461, 0, "k");
    (25462, 0, " ");
    (25463, 0, "t");
    (25464, 0, "o");
    (25465, 0, " ");
    (25466, 0, "n");
    (25467, 0, ",");
    (25468, 0, " ");
    (25468, 1, "");
    (25474, 1, "");
    (25474, 0, "i");
    (25475, 0, "n");
    (25476, 0, "g");
    (25492, 18, ".");
    (25493, 0, "\n            ");
    (25506, 0, "l");
    (25507, 0, "e");
    (25508, 0, "t");
    (25509, 0, " ");
    (25510, 0, "i");
    (25510, 1, "");
    (25510, 0, "c");
    (25511, 0, "u");
    (25511, 1, "");
    (25511, 0, " ");
    (25512, 0, "=");
    (25513, 0, " ");
    (25514, 0, "p");
    (25515, 0, "a");
    (25516, 0, "r");
    (25517, 0, "e");
    (25518, 0, "n");
    (25519, 0, "t");
    (25520, 0, ";");
    (25521, 0, "\n            ");
    (25534, 0, "w");
    (25535, 0, "h");
    (25536, 0, "i");
    (25537, 0, "l");
    (25538, 0, "e");
    (25539, 0, " ");
    (25540, 0, "c");
    (25541, 0, " ");
    (25542, 0, "!");
    (25543, 0, "=");
    (25544, 0, " ");
    (25545, 0, "n");
    (25546, 0, " ");
    (25547, 0, "{");
    (25548, 0, "\n                ");
    (25565, 0, "\n                ");
    (25549, 16, "");
    (25550, 16, "            }");
    (25549, 0, "                ");
    (25565, 0, "c");
    (25566, 0, " ");
    (25567, 0, "=");
    (25568, 0, " ");
    (25569, 0, "(");
    (25570, 0, "*");
    (25571, 0, "c");
    (25572, 0, ")");
    (25573, 0, ".");
    (25574, 0, "n");
    (25575, 0, "e");
    (25576, 0, "x");
    (25577, 0, "s");
    (25577, 1, "");
    (25577, 0, "t");
    (25578, 0, "s");
    (25579, 0, "[");
    (25580, 0, "(");
    (25581, 0, "*");
    (25582, 0, "c");
    (25583, 0, ")");
    (25584, 0, ".");
    (25585, 0, "h");
    (25586, 0, "e");
    (25587, 0, "i");
    (25588, 0, "g");
    (25589, 0, "h");
    (25590, 0, "t");
    (25591, 0, " ");
    (25592, 0, "-");
    (25593, 0, " ");
    (25594, 0, "1");
    (25594, 1, "");
    (25594, 0, "2");
    (25400, 1, "");
    (25400, 0, "p");
    (25401, 0, "a");
    (25402, 0, "r");
    (25403, 0, "e");
    (25404, 0, "n");
    (25405, 0, "t");
    (25371, 0, "\n            ");
    (25372, 12, "");
    (25371, 1, "");
    (25429, 0, "\n            ");
    (25442, 0, "\n            ");
    (25430, 12, "");
    (25443, 0, "l");
    (25444, 0, "e");
    (25445, 0, "t");
    (25446, 0, " ");
    (25447, 0, "p");
    (25448, 0, "_");
    (25449, 0, "h");
    (25450, 0, "e");
    (25451, 0, "i");
    (25452, 0, "g");
    (25453, 0, "h");
    (25454, 0, "t");
    (25455, 0, " ");
    (25456, 0, "=");
    (25457, 0, " ");
    (25458, 0, "(");
    (25459, 0, "*");
    (25460, 0, "p");
    (25461, 0, "a");
    (25462, 0, "r");
    (25463, 0, "e");
    (25464, 0, "n");
    (25465, 0, "t");
    (25466, 0, ")");
    (25467, 0, ".");
    (25468, 0, "h");
    (25469, 0, "e");
    (25470, 0, "i");
    (25471, 0, "g");
    (25472, 0, "h");
    (25473, 0, "t");
    (25474, 0, ";");
    (25475, 0, "\n");
    (25430, 1, "");
    (25474, 0, "\n            debug_assert!((*parent).height as usize > h);");
    (25372, 58, "");
    (25443, 16, "p");
    (25444, 0, "_");
    (25445, 0, "h");
    (25446, 0, "e");
    (25447, 0, "i");
    (25448, 0, "g");
    (25449, 0, "h");
    (25450, 0, "t");
    (25451, 9, "");
    (25415, 0, " ");
    (25416, 0, "a");
    (25417, 0, "s");
    (25418, 0, " ");
    (25419, 0, "s");
    (25420, 0, "u");
    (25420, 1, "");
    (25419, 1, "");
    (25419, 0, "u");
    (25420, 0, "s");
    (25421, 0, "i");
    (25422, 0, "z");
    (25423, 0, "e");
    (25467, 1, "");
    (25424, 0, " ");
    (25425, 0, "-");
    (25426, 0, " ");
    (25427, 0, "1");
    (25426, 2, "");
    (25424, 2, "");
    (25467, 0, "\n");
    (25419, 5, "");
    (25419, 0, "su");
    (25418, 3, "");
    (25415, 3, "");
    (25451, 0, " as usize");
    (25443, 8, "(*parent).height");
    (25416, 58, "");
    (25372, 0, "            debug_assert!((*parent).height as usize > h);\n");
    (25474, 1, "");
    (25430, 0, "\n");
    (25443, 32, "let p_height = (*parent).height as usize - 1;");
    (25447, 8, "w");
    (25448, 0, "a");
    (25449, 0, "l");
    (25450, 0, "k");
    (25451, 0, "_");
    (25452, 0, "h");
    (25453, 0, "e");
    (25454, 0, "i");
    (25455, 0, "g");
    (25456, 0, "h");
    (25457, 0, "t");
    (25491, 1, "");
    (25431, 0, "            \n");
    (25504, 68, "");
    ( 25444,
      0,
      "            // Walk from parent back to n, figuring out the offset.\n" );
    (25572, 28, "");
    (25512, 0, "            let c = parent;\n");
    (25439, 4, "");
    (25435, 4, "");
    (25431, 4, "");
    (25430, 1, "");
    (25646, 15, "");
    (25646, 0, "w");
    (25647, 0, "a");
    (25648, 0, "l");
    (25649, 0, "k");
    (25650, 0, "_");
    (25651, 0, "h");
    (25652, 0, "e");
    (25653, 0, "i");
    (25646, 8, "walk_height");
    (25657, 0, "]");
    (25585, 1, "");
    (25585, 0, "2");
    (25585, 1, "");
    (25585, 0, "1");
    (25585, 1, "");
    (25585, 0, "2");
    (25631, 0, "l");
    (25632, 0, "e");
    (25633, 0, "t");
    (25634, 0, " ");
    (25635, 0, "e");
    (25636, 0, "l");
    (25637, 0, "e");
    (25638, 0, "m");
    (25639, 0, " ");
    (25640, 0, "=");
    (25641, 1, "");
    (25641, 1, "");
    (25641, 1, "");
    (25641, 1, "");
    (25641, 0, " ");
    (25665, 0, ";");
    (25666, 0, "\n                ");
    (25683, 0, "c");
    (25684, 0, " ");
    (25685, 0, "=");
    (25686, 0, " ");
    (25687, 0, "e");
    (25688, 0, "l");
    (25689, 0, "e");
    (25690, 0, "m");
    (25691, 0, "e");
    (25692, 0, ".");
    (25692, 1, "");
    (25691, 1, "");
    (25691, 0, ".");
    (25692, 0, "n");
    (25693, 0, "o");
    (25694, 0, "d");
    (25695, 0, "e");
    (25696, 0, ";");
    (25666, 0, "\n                ");
    (25683, 0, "o");
    (25684, 0, "f");
    (25685, 0, "f");
    (25686, 0, "s");
    (25687, 0, "e");
    (25688, 0, "t");
    (25689, 0, " ");
    (25690, 0, "+");
    (25691, 0, "=");
    (25692, 0, " ");
    (25693, 0, "e");
    (25694, 0, "l");
    (25695, 0, "e");
    (25696, 0, "m");
    (25697, 0, ".");
    (25698, 0, "s");
    (25699, 0, "k");
    (25700, 0, "i");
    (25701, 0, "p");
    (25702, 0, "_");
    (25703, 0, "u");
    (25698, 6, "skip_usersize");
    (25711, 0, ";");
    (25515, 0, "m");
    (25516, 0, "u");
    (25517, 0, "t");
    (25518, 0, " ");
    (25762, 1, "");
    (25797, 295, "");
    (25218, 115, "");
    (25217, 1, "");
    (25216, 1, "");
    (25216, 0, "\n            ");
    (25325, 0, "\n            ");
    (25217, 12, "");
    (25326, 0, "\n            ");
    (25314, 12, "");
    (25327, 0, "i");
    (25328, 0, "f");
    (25329, 0, " ");
    (25330, 0, "p");
    (25331, 0, "a");
    (25332, 0, "r");
    (25333, 0, "e");
    (25334, 0, "n");
    (25335, 0, "t");
    (25336, 0, ".");
    (25337, 0, "i");
    (25338, 0, "s");
    (25339, 0, "_");
    (25340, 0, "n");
    (25341, 0, "u");
    (25342, 0, "l");
    (25343, 0, "l");
    (25344, 0, "(");
    (25345, 0, ")");
    (25346, 0, " ");
    (25347, 0, "{");
    (25348, 0, " ");
    (25349, 0, "b");
    (25350, 0, "r");
    (25351, 0, "e");
    (25352, 0, "a");
    (25353, 0, "k");
    (25354, 0, ";");
    (25355, 0, " ");
    (25356, 0, "}");
    (25314, 0, "\n            ");
    (25327, 0, "/");
    (25328, 0, "/");
    (25329, 0, " ");
    (25330, 0, "R");
    (25331, 0, "e");
    (25332, 0, "a");
    (25333, 0, "c");
    (25334, 0, "h");
    (25335, 0, "e");
    (25336, 0, "d");
    (25337, 0, " ");
    (25338, 0, "t");
    (25339, 0, "h");
    (25340, 0, "e");
    (25341, 0, " ");
    (25342, 0, "h");
    (25343, 0, "e");
    (25344, 0, "a");
    (25345, 0, "d");
    (25346, 0, ".");
    (24955, 1, "");
    (24924, 31, "");
    (24923, 1, "");
    (25725, 0, "\n        ");
    (25734, 0, "c");
    (25735, 0, "u");
    (25736, 0, "r");
    (25737, 0, "s");
    (25738, 0, "o");
    (25739, 0, "r");
    (25740, 0, ".");
    (25741, 0, "u");
    (25742, 0, "s");
    (25743, 0, "e");
    (25744, 0, "r");
    (25745, 0, "p");
    (25746, 0, "o");
    (25747, 0, "s");
    (25748, 0, " ");
    (25749, 0, "=");
    (25750, 0, " ");
    (25751, 0, "o");
    (25752, 0, "f");
    (25753, 0, "f");
    (25754, 0, "s");
    (25755, 0, "e");
    (25756, 0, "t");
    (25757, 0, ";");
    (26487, 610, "");
    (26487, 0, "\n            ");
    (26500, 0, "s");
    (26501, 0, "e");
    (26502, 0, "l");
    (26503, 0, "f");
    (26504, 0, ".");
    (26505, 0, "i");
    (26506, 0, "t");
    (26507, 0, "e");
    (26508, 0, "r");
    (26509, 0, "_");
    ( 26505,
      5,
      "iter_at_node(mut n: *mut Node<C>, mut offset: usize, local_index: usize)"
    );
    (26518, 19, "n");
    (26521, 17, "o");
    (26522, 0, "f");
    (26523, 0, "f");
    (26524, 0, "s");
    (26525, 0, "e");
    (26526, 0, "t");
    (26529, 18, "l");
    (26530, 0, "o");
    (26531, 0, "c");
    (26532, 0, "a");
    (26533, 0, "l");
    (26534, 0, "_");
    (26535, 0, "i");
    (26536, 0, "n");
    (26537, 0, "d");
    (26538, 0, "e");
    (26539, 0, "x");
    (26541, 20, "");
    (26541, 0, "\n\n            cursor");
    (26529, 11, "local_index: usize");
    (26521, 6, "mut offset: usize");
    (26518, 1, "mut n: *mut Node<C>");
    (26505, 72, "iter_");
    (26487, 23, "");
    ( 26487,
      0,
      "\n\
      \            // Now we need to make a cursor at the node/userpos \
       location pair.\n\
      \            let mut cursor = Cursor {\n\
      \                userpos: 0,\n\
      \                local_index: local_index.expect(\"Invalid marker - item \
       not found in node\"),\n\
      \                entries: [SkipEntry {\n\
      \                    node: &self.head as *const _ as *mut _,\n\
      \                    skip_usersize: usize::MAX\n\
      \                }; MAX_HEIGHT],\n\
      \            };\n\n\n\
      \            for i in 1..self.head.height as usize {\n\
      \                n = (*n).parent;\n\
      \                // And find the local offset. Note\n\
      \            }\n\
      \            unimplemented!();" );
    (25750, 8, "");
    (25750, 0, " offset;");
    (26487, 0, "self.iter_at_node(n, offset, local_index)");
    (26487, 0, "            ");
    (26540, 0, "\n            ");
    (26728, 61, "");
    (26541, 12, "");
    ( 26528,
      11,
      "local_index.expect(\"Invalid marker - item not found in node\")" );
    (26590, 550, "");
    (26590, 20, "");
    (26486, 0, "\n            ");
    (26499, 0, "\n            ");
    (26487, 12, "");
    (26500, 0, "l");
    (26501, 0, "e");
    (26502, 0, "t");
    (26503, 0, " ");
    (26504, 0, "l");
    (26505, 0, "o");
    (26506, 0, "c");
    (26507, 0, "a");
    (26508, 0, "l");
    (26509, 0, "_");
    (26510, 0, "i");
    (26511, 0, "n");
    (26504, 8, "local_index");
    (26515, 0, " ");
    (26516, 0, "=");
    (26517, 0, " ");
    (26560, 61, "");
    (26518, 0, "local_index.expect(\"Invalid marker - item not found in node\")");
    (26579, 0, ";");
    (26622, 0, "o");
    (26623, 0, "=");
    (26623, 1, "");
    (26623, 0, "l");
    (26624, 0, "o");
    (26624, 1, "");
    (26623, 1, "");
    (26622, 1, "");
    (26622, 0, "l");
    (26623, 0, "o");
    (26624, 0, "c");
    (26625, 0, "a");
    (26626, 0, "l");
    (26622, 5, "local_index");
    (26022, 3, "");
    (26021, 1, "");
    (20829, 0, "\n                ");
    (20846, 0, "\n                ");
    (20830, 16, "");
    (20847, 0, "/");
    (20848, 0, "/");
    (20849, 0, " ");
    (20850, 0, "C");
    (20851, 0, "h");
    (20852, 0, "e");
    (20853, 0, "c");
    (20854, 0, "k");
    (20855, 0, " ");
    (20856, 0, "t");
    (20857, 0, "h");
    (20858, 0, "e");
    (20859, 0, " ");
    (20860, 0, "v");
    (20861, 0, "a");
    (20862, 0, "l");
    (20863, 0, "u");
    (20864, 0, "e");
    (20865, 0, " ");
    (20866, 0, "r");
    (20867, 0, "e");
    (20868, 0, "t");
    (20869, 0, "u");
    (20870, 0, "r");
    (20871, 0, "n");
    (20872, 0, "e");
    (20873, 0, "d");
    (20874, 0, " ");
    (20875, 0, "b");
    (20876, 0, "y");
    (20877, 0, " ");
    (20878, 0, "t");
    (20879, 0, "h");
    (20880, 0, "e");
    (20881, 0, " ");
    (20882, 0, "i");
    (20883, 0, "t");
    (20884, 0, "e");
    (20885, 0, "r");
    (20886, 0, "a");
    (20887, 0, "t");
    (20888, 0, "o");
    (20889, 0, "r");
    (20890, 0, " ");
    (20891, 0, "f");
    (20892, 0, "u");
    (20893, 0, "n");
    (20894, 0, "c");
    (20895, 0, "t");
    (20896, 0, "i");
    (20897, 0, "o");
    (20898, 0, "n");
    (20899, 0, "s");
    (20900, 0, " ");
    (20901, 0, "m");
    (20902, 0, "a");
    (20903, 0, "t");
    (20904, 0, "c");
    (20905, 0, "h");
    (20906, 0, "e");
    (20907, 0, "s");
    (20908, 0, ".");
    (20909, 0, "\n                ");
    (20926, 0, "s");
    (20927, 0, "e");
    (20928, 0, "l");
    (20929, 0, "f");
    (20930, 0, ".");
    (20931, 0, "i");
    (20932, 0, "t");
    (20933, 0, "e");
    (20934, 0, "r");
    ( 20931,
      4,
      "iter_at_node(mut n: *mut Node<C>, mut offset: usize, local_index: usize)"
    );
    (20944, 19, "n");
    (20947, 17, "n");
    (20948, 0, ".");
    (20949, 0, "g");
    (20950, 0, "e");
    (20951, 0, "t");
    (20952, 0, "_");
    (20953, 0, "l");
    (20954, 0, "o");
    (20954, 1, "");
    (20953, 1, "");
    (20953, 0, "u");
    (20954, 0, "s");
    (20955, 0, "e");
    (20956, 0, "r");
    (20957, 0, "l");
    (20958, 0, "e");
    (20959, 0, "n");
    (20960, 0, "(");
    (20961, 0, ")");
    (20964, 18, "n");
    (20965, 0, ".");
    (20966, 0, "n");
    (20967, 0, "u");
    (20968, 0, "m");
    (20969, 0, "_");
    (20970, 0, "i");
    (20971, 0, "t");
    (20966, 6, "num_items");
    (20976, 0, ";");
    (20926, 0, "l");
    (20927, 0, "e");
    (20928, 0, "t");
    (20929, 0, " ");
    (20930, 0, "n");
    (20931, 0, "o");
    (20932, 0, "d");
    (20933, 0, "e");
    (20934, 0, "_");
    (20935, 0, "i");
    (20936, 0, "t");
    (20937, 0, "e");
    (20938, 0, "r");
    (20939, 0, " ");
    (20940, 0, "=");
    (20941, 0, " ");
    (24728, 3, "c");
    (24729, 0, "o");
    (24730, 0, "n");
    (24731, 0, "s");
    (24732, 0, "t");
    (24796, 0, "\n        ");
    (24805, 0, "l");
    (24806, 0, "e");
    (24807, 0, "t");
    (24808, 0, " ");
    (24809, 0, "n");
    (24810, 0, " ");
    (24811, 0, "=");
    (24812, 0, " ");
    (24809, 0, "m");
    (24810, 0, "u");
    (24811, 0, "t");
    (24812, 0, " ");
    (24817, 0, "n");
    (24818, 0, " ");
    (24819, 0, "a");
    (24820, 0, "s");
    (24821, 0, " ");
    (24822, 0, "*");
    (24823, 0, "m");
    (24824, 0, "u");
    (24825, 0, "t");
    (24826, 0, " ");
    (24827, 0, "_");
    (24828, 0, ";");
    (24720, 4, "");
    (24825, 0, "\n        ");
    (24826, 8, "");
    (24825, 0, " ");
    (24826, 0, "/");
    (24827, 0, "/");
    (24828, 0, " ");
    (24829, 0, "W");
    (24830, 0, "e");
    (24831, 0, " ");
    (24832, 0, "d");
    (24833, 0, "o");
    (24834, 0, "n");
    (24835, 0, "'");
    (24836, 0, "t");
    (24837, 0, " ");
    (24838, 0, "m");
    (24839, 0, "u");
    (24840, 0, "t");
    (24841, 0, "a");
    (24842, 0, "t");
    (24843, 0, "e");
    (24844, 0, ",");
    (24845, 0, " ");
    (24846, 0, "b");
    (24847, 0, "u");
    (24848, 0, "t");
    (24849, 0, " ");
    (24823, 1, "N");
    (24824, 0, "o");
    (24825, 0, "d");
    (24826, 0, "e");
    (24827, 0, "<");
    (24828, 0, "C");
    (24829, 0, ">");
    (24856, 0, "w");
    (24857, 0, "e");
    (24858, 0, " ");
    (24859, 0, "n");
    (24860, 0, "e");
    (24861, 0, "e");
    (24862, 0, "d");
    (24863, 0, " ");
    (24864, 0, "a");
    (24865, 0, " ");
    (24866, 0, "m");
    (24867, 0, "u");
    (24868, 0, "t");
    (24869, 0, " ");
    (24870, 0, "p");
    (24871, 0, "t");
    (24872, 0, "r");
    (24873, 0, ".");
    (24709, 11, "");
    (24709, 0, "&mut self, ");
    (24710, 4, "");
    (20991, 0, " ");
    (20992, 0, "a");
    (20993, 0, "s");
    (20994, 0, " ");
    (20995, 0, "u");
    (20996, 0, "s");
    (20997, 0, "i");
    (20998, 0, "z");
    (20999, 0, "e");
    (20942, 0, "u");
    (20943, 0, "n");
    (20944, 0, "s");
    (20945, 0, "a");
    (20946, 0, "f");
    (20947, 0, "e");
    (20948, 0, " ");
    (20949, 0, "{");
    (20950, 0, " ");
    (21010, 0, " ");
    (21011, 0, "}");
    (21013, 0, "\n                ");
    (21030, 0, "l");
    (21031, 0, "e");
    (21032, 0, "t");
    (21033, 0, " ");
    (21034, 0, "n");
    (21035, 0, "o");
    (21036, 0, "r");
    (21037, 0, "m");
    (21038, 0, "a");
    (21039, 0, "l");
    (21040, 0, "_");
    (21041, 0, "i");
    (21042, 0, "t");
    (21043, 0, "e");
    (21044, 0, "r");
    (21045, 0, " ");
    (21046, 0, "=");
    (21047, 0, " ");
    (21048, 0, "s");
    (21049, 0, "e");
    (21050, 0, "l");
    (21051, 0, "f");
    (21052, 0, ".");
    (21053, 0, "iter_at_userpos(target_userpos: usize)");
    (21069, 21, "n");
    (21070, 0, "u");
    (21071, 0, "m");
    (21072, 0, "u");
    (21073, 0, "s");
    (21074, 0, "e");
    (21075, 0, "r");
    (21075, 1, "");
    (21074, 1, "");
    (21073, 1, "");
    (21072, 1, "");
    (21072, 0, "_");
    (21073, 0, "u");
    (21074, 0, "s");
    (21075, 0, "e");
    (21076, 0, "r");
    (21077, 0, "c");
    (21078, 0, "o");
    (21079, 0, "u");
    (21080, 0, "n");
    (21081, 0, "t");
    (21083, 0, ";");
    ( 21084,
      0,
      "\n\
      \                let node_iter = unsafe { self.iter_at_node(n, \
       n.get_userlen(), n.num_items as usize) };" );
    (20910, 104, "");
    (21084, 0, "\n                ");
    (21101, 0, "a");
    (21102, 0, "s");
    (21103, 0, "s");
    (21101, 3, "assert_eq!");
    (21111, 0, "(");
    (21112, 0, "n");
    (21113, 0, "o");
    (21114, 0, "r");
    (21115, 0, "m");
    (21116, 0, "a");
    (21117, 0, "l");
    (21118, 0, "_");
    (21119, 0, "i");
    (21120, 0, "t");
    (21121, 0, "e");
    (21122, 0, "r");
    (21123, 0, ",");
    (21124, 0, " ");
    (21125, 0, "n");
    (21126, 0, "o");
    (21127, 0, "d");
    (21128, 0, "e");
    (21129, 0, "_");
    (21130, 0, "i");
    (21131, 0, "t");
    (21132, 0, "e");
    (21133, 0, "r");
    (21134, 0, ")");
    (21135, 0, ";");
    (20930, 0, "(");
    (20942, 0, ",");
    (20943, 0, " ");
    (20944, 0, "_");
    (20945, 0, ")");
    (20944, 1, "");
    (20944, 0, "l");
    (20945, 0, "o");
    (20946, 0, "c");
    (20947, 0, "a");
    (20948, 0, "l");
    (20949, 0, "_");
    (20950, 0, "o");
    (20951, 0, "f");
    (20952, 0, "f");
    (20953, 0, "s");
    (20954, 0, "e");
    (20955, 0, "t");
    (20996, 0, "\n                ");
    (21013, 0, "a");
    (21014, 0, "s");
    (21013, 2, "assert_eq!");
    (21023, 0, "(");
    (21024, 0, "l");
    (21025, 0, "o");
    (21026, 0, "c");
    (21027, 0, "a");
    (21028, 0, "l");
    (21029, 0, "_");
    (21030, 0, "o");
    (21031, 0, "f");
    (21032, 0, "f");
    (21033, 0, "s");
    (21034, 0, "e");
    (21035, 0, "t");
    (21036, 0, ",");
    (21037, 0, " ");
    (21038, 0, "n");
    (21039, 0, ".");
    (21040, 0, "g");
    (21041, 0, "e");
    (21042, 0, "t");
    (21043, 0, ")");
    (21044, 0, "u");
    (21044, 1, "");
    (21043, 1, "");
    (21043, 0, "_");
    (21044, 0, "u");
    (21045, 0, "s");
    (21046, 0, "e");
    (21047, 0, "r");
    (21048, 0, "l");
    (21049, 0, "e");
    (21040, 10, "get_userlen");
    (21051, 0, "(");
    (21052, 0, ")");
    (21053, 0, ")");
    (21054, 0, ";");
    (25816, 0, "\n            // Reached the head.");
    (25741, 33, "");
    (25783, 0, "\n");
    (25740, 1, "");
    (25782, 0, "\n            debug_assert!((*parent).height as usize > h);");
    (25682, 58, "");
    (25816, 0, "\n");
    (25783, 1, "");
    (25815, 0, "\n            debug_assert!((*parent).height as usize > h);");
    (25725, 58, "");
    (25757, 0, "\n            if parent.is_null() { break; }");
    (25682, 43, "");
    (25757, 0, "\n            ");
    (25828, 1, "");
    (25758, 12, "");
    (25815, 1, "");
    (25815, 0, ";");
    (21038, 15, "0");
    (26024, 5, "");
    (26023, 1, "");
    (26023, 0, ".");
    (26024, 0, "n");
    (26025, 0, "e");
    (26026, 0, "x");
    (26027, 0, "t");
    (26028, 0, "s");
    (26029, 0, "_");
    (26030, 0, "m");
    (26031, 0, "u");
    (26032, 0, "t");
    (26033, 0, "(");
    (26034, 0, ")");
    (26029, 4, "");
    (18167, 0, "\n    ");
    (18172, 0, "\n    ");
    (18168, 4, "");
    (18173, 0, "f");
    (18174, 0, "n");
    (18175, 0, " ");
    (18176, 0, "i");
    (18177, 0, "s");
    (18178, 0, "_");
    (18179, 0, "h");
    (18180, 0, "e");
    (18181, 0, "a");
    (18182, 0, "d");
    (18183, 0, "(");
    (18184, 0, "*");
    (18184, 1, "");
    (18184, 0, "&");
    (18185, 0, "s");
    (18186, 0, "e");
    (18187, 0, "l");
    (18188, 0, "f");
    (18189, 0, ",");
    (18190, 0, " ");
    (18191, 0, "&");
    (18191, 1, "");
    (18191, 0, "*");
    (18192, 0, "m");
    (18192, 1, "");
    (18192, 0, "m");
    (18193, 0, "u");
    (18194, 0, "t");
    (18195, 0, " ");
    (18196, 0, "N");
    (18197, 0, "o");
    (18198, 0, "d");
    (18199, 0, "e");
    (18200, 0, "<");
    (18201, 0, "C");
    (18202, 0, ">");
    (18203, 0, ")");
    (18191, 0, "n");
    (18192, 0, "o");
    (18193, 0, "d");
    (18194, 0, "e");
    (18195, 0, ":");
    (18196, 0, " ");
    (18210, 0, " ");
    (18211, 0, "{");
    (18212, 0, "\n        ");
    (18221, 0, "\n        ");
    (18213, 8, "");
    (18214, 8, "    }");
    (18213, 0, "is_head = n as *const _ == &self.head as *const _");
    (18213, 0, "        ");
    (18221, 10, "");
    (18221, 1, "n");
    (18222, 0, "o");
    (18223, 0, "d");
    (18224, 0, "e");
    (18210, 0, " ");
    (18211, 0, "-");
    (18212, 0, ">");
    (18213, 0, " ");
    (18214, 0, "b");
    (18215, 0, "o");
    (18216, 0, "o");
    (18217, 0, "l");
    (19538, 0, "s");
    (19539, 0, "e");
    (19540, 0, "l");
    (19541, 0, "f");
    (19542, 0, ".");
    (19550, 0, "(");
    (19551, 0, "n");
    (19552, 0, ")");
    (19550, 3, "");
    (19538, 5, "");
    (18213, 5, "");
    (18213, 0, " bool");
    (19538, 0, "self.");
    (19538, 5, "");
    (19447, 71, "");
    (19467, 0, "s");
    (19468, 0, "e");
    (19469, 0, "l");
    (19470, 0, "f");
    (19471, 0, ".");
    (19479, 0, "(");
    (19480, 0, "n");
    (19481, 0, ")");
    (18198, 3, "c");
    (18199, 0, "o");
    (18200, 0, "n");
    (18201, 0, "s");
    (18202, 0, "t");
    (19888, 0, "s");
    (19889, 0, "e");
    (19890, 0, "l");
    (19891, 0, "f");
    (19892, 0, ".");
    (19900, 0, "(");
    (19901, 0, "n");
    (19902, 0, ")");
    (25828, 0, " ");
    (25828, 0, "p");
    (25828, 1, "");
    (25828, 0, "s");
    (25829, 0, "e");
    (25830, 0, "l");
    (25831, 0, "f");
    (25832, 0, ".");
    (25833, 0, "i");
    (25834, 0, "s");
    (25835, 0, "_");
    (25836, 0, "h");
    (25833, 4, "is_head(node: *const Node<C>)");
    (25861, 0, ")");
    (25841, 0, "(");
    (25842, 20, "p");
    (25843, 0, "a");
    (25844, 0, "r");
    (25845, 0, "e");
    (25846, 0, "n");
    (25847, 0, "t");
    (25847, 1, "");
    (25847, 1, "");
    (25846, 1, "");
    (25841, 5, "p");
    (25842, 0, "a");
    (25843, 0, "r");
    (25844, 0, "e");
    (25845, 0, "n");
    (25846, 0, "t");
    (25848, 0, " ");
    (25849, 0, "|");
    (25850, 0, "|");
    (25801, 0, "\n            ");
    (25814, 0, "/");
    (25815, 0, "/");
    (25816, 0, " ");
    (25817, 0, "I");
    (25818, 0, "f");
    (25819, 0, " ");
    (25820, 0, "w");
    (25821, 0, "e");
    (25822, 0, "'");
    (25823, 0, "r");
    (25824, 0, "e");
    (25825, 0, " ");
    (25826, 0, "t");
    (25827, 0, "h");
    (25828, 0, "e");
    (25829, 0, " ");
    (25830, 0, "s");
    (25831, 0, "a");
    (25832, 0, "m");
    (25833, 0, "e");
    (25834, 0, " ");
    (25835, 0, "h");
    (25836, 0, "i");
    (25837, 0, "e");
    (25837, 1, "");
    (25836, 1, "");
    (25835, 1, "");
    (25835, 0, "h");
    (25836, 0, "e");
    (25837, 0, "i");
    (25838, 0, "g");
    (25839, 0, "h");
    (25840, 0, "t");
    (25868, 24, "");
    (25897, 0, "\n        ");
    (25906, 0, "|");
    (25907, 0, "|");
    (25908, 0, " ");
    (25906, 0, "    ");
    (25910, 0, "    ");
    (25917, 0, "self.is_head(parent) || ");
    (25940, 1, "");
    (25939, 1, "");
    (25938, 1, "");
    (25917, 0, "(");
    (25940, 0, ")");
    (25939, 0, "&");
    (25940, 0, "&");
    (25941, 0, " ");
    (25942, 0, "(*parent).height as usize > h");
    (25968, 1, "");
    (25968, 0, "=");
    (25969, 0, "=");
    (25841, 0, " ");
    (25842, 0, "a");
    (25843, 0, "s");
    (25844, 0, " ");
    (25845, 0, "t");
    (25846, 0, "h");
    (25847, 0, "e");
    (25848, 0, " ");
    (25849, 0, "p");
    (25850, 0, "a");
    (25851, 0, "r");
    (25852, 0, "e");
    (25853, 0, "n");
    (25854, 0, "t");
    (25855, 0, ",");
    (25856, 0, " ");
    (25817, 4, "W");
    (25822, 0, " ");
    (25823, 0, "e");
    (25824, 0, "i");
    (25825, 0, "t");
    (25826, 0, "h");
    (25827, 0, "e");
    (25828, 0, "r");
    (25817, 44, "I");
    (25818, 0, "f");
    (25819, 0, " ");
    (25820, 0, "w");
    (25821, 0, "e");
    (25822, 0, "'");
    (25823, 0, "r");
    (25824, 0, "e");
    (25825, 0, " ");
    (25826, 0, "t");
    (25827, 0, "h");
    (25828, 0, "e");
    (25829, 0, " ");
    (25830, 0, "s");
    (25831, 0, "a");
    (25832, 0, "m");
    (25833, 0, "e");
    (25834, 0, " ");
    (25835, 0, "h");
    (25836, 0, "e");
    (25837, 0, "i");
    (25838, 0, "g");
    (25839, 0, "h");
    (25840, 0, "t");
    (25841, 0, " ");
    (25842, 0, "a");
    (25843, 0, "s");
    (25844, 0, " ");
    (25845, 0, "t");
    (25846, 0, "h");
    (25847, 0, "e");
    (25848, 0, " ");
    (25849, 0, "p");
    (25850, 0, "a");
    (25851, 0, "r");
    (25852, 0, "e");
    (25853, 0, "n");
    (25854, 0, "t");
    (25855, 0, " ");
    (25856, 0, "i");
    (25857, 0, "t");
    (25858, 0, " ");
    (25859, 0, "s");
    (25859, 1, "");
    (25858, 1, "");
    (25858, 0, "s");
    (25859, 0, " ");
    (25860, 0, "i");
    (25861, 0, "f");
    (25862, 0, "n");
    (25863, 0, "e");
    (25864, 0, ".");
    (25859, 6, " ");
    (25860, 0, "f");
    (25861, 0, "i");
    (25862, 0, "n");
    (25863, 0, "e");
    (25864, 0, ".");
    (21098, 0, "\n                ");
    (21115, 0, "/");
    (21116, 0, "/");
    (21117, 0, " ");
    (21118, 0, "D");
    (21119, 0, "i");
    (21120, 0, "r");
    (21121, 0, "e");
    (21122, 0, "t");
    (21122, 1, "");
    (21121, 1, "");
    (21121, 0, "t");
    (21122, 0, "y");
    (21123, 0, " ");
    (21124, 0, "h");
    (21125, 0, "a");
    (21126, 0, "c");
    (21127, 0, "k");
    (21128, 0, ".");
    (21129, 0, " ");
    (21130, 0, "I");
    (21131, 0, "f");
    (21132, 0, " ");
    (21133, 0, "a");
    (21134, 0, " ");
    (21135, 0, "n");
    (21136, 0, "o");
    (21130, 7, "T");
    (21131, 0, "h");
    (21132, 0, "e");
    (21133, 0, " ");
    (21133, 1, "");
    (21132, 1, "");
    (21131, 1, "");
    (21130, 1, "");
    (21130, 0, "I");
    (21131, 0, "f");
    (21132, 0, " ");
    (21133, 0, "n");
    (21134, 0, " ");
    (21135, 0, "h");
    (21136, 0, "a");
    (21137, 0, "s");
    (21138, 0, " ");
    (21139, 0, "0");
    (21140, 0, "-");
    (21141, 0, "s");
    (21142, 0, "i");
    (21143, 0, "z");
    (21144, 0, "e");
    (21145, 0, "d");
    (21146, 0, " ");
    (21147, 0, "e");
    (21148, 0, "l");
    (21149, 0, "e");
    (21150, 0, "m");
    (21151, 0, "e");
    (21152, 0, "n");
    (21153, 0, "t");
    (21154, 0, "s");
    (21155, 0, " ");
    (21156, 0, "a");
    (21157, 0, "t");
    (21158, 0, " ");
    (21159, 0, "t");
    (21160, 0, "h");
    (21161, 0, "e");
    (21162, 0, " ");
    (21163, 0, "e");
    (21164, 0, "n");
    (21165, 0, "d");
    (21166, 0, ",");
    (21167, 0, " ");
    (21168, 0, "t");
    (21169, 0, "h");
    (21170, 0, "e");
    (21171, 0, " ");
    (21172, 0, "c");
    (21173, 0, "u");
    (21174, 0, "r");
    (21175, 0, "s");
    (21176, 0, "o");
    (21177, 0, "r");
    (21172, 6, "n");
    (21173, 0, "o");
    (21174, 0, "r");
    (21175, 0, "m");
    (21176, 0, "a");
    (21177, 0, "l");
    (21178, 0, " ");
    (21179, 0, "c");
    (21180, 0, "u");
    (21181, 0, "r");
    (21182, 0, "s");
    (21183, 0, "o");
    (21184, 0, " ");
    (21184, 1, "");
    (21184, 0, "r");
    (21185, 0, " ");
    (21186, 0, "w");
    (21187, 0, "o");
    (21188, 0, "n");
    (21189, 0, "'");
    (21190, 0, "t");
    (21191, 0, " ");
    (21192, 0, "b");
    (21193, 0, "e");
    (21194, 0, " ");
    (21195, 0, "a");
    (21196, 0, "t");
    (21197, 0, " ");
    (21198, 0, "t");
    (21199, 0, "h");
    (21200, 0, "e");
    (21201, 0, " ");
    (21202, 0, "e");
    (21203, 0, "n");
    (21204, 0, "d");
    (21205, 0, ".");
    (21206, 0, ".");
    (21207, 0, ".");
    ( 21099,
      109,
      "                // Dirty hack. If n has 0-sized elements at the end, \
       the normal\n\
      \                // cursor won't be at the end..." );
    (21227, 0, "\n                ");
    (21244, 0, "n");
    (21245, 0, "o");
    (21246, 0, "r");
    (21247, 0, "m");
    (21244, 4, "normal_iter");
    (21255, 0, ".");
    (21256, 0, "l");
    (21257, 0, "o");
    (21258, 0, "c");
    (21259, 0, "a");
    (21256, 4, "local_index");
    (21267, 0, " ");
    (21268, 0, "=");
    (21269, 0, " ");
    (21270, 0, "n");
    (21271, 0, "o");
    (21272, 0, "r");
    (21273, 0, "m");
    (21274, 0, "a");
    (21270, 5, "normal_iter");
    (21270, 11, "");
    (21270, 0, "n");
    (21271, 0, ".");
    (21272, 0, "n");
    (21273, 0, "u");
    (21274, 0, "m");
    (21275, 0, "_");
    (21272, 4, "num_items");
    (21281, 0, " ");
    (21281, 1, "");
    (21281, 0, " ");
    (21282, 0, "a");
    (21283, 0, "s");
    (21284, 0, " ");
    (21285, 0, "u");
    (21286, 0, "s");
    (21287, 0, "i");
    (21288, 0, "z");
    (21289, 0, "e");
    (21290, 0, ";");
    (20988, 0, "m");
    (20989, 0, "u");
    (20990, 0, "t");
    (20991, 0, " ");
    (21295, 0, "\n                ");
    (21312, 0, "w");
    (21313, 0, "h");
    (21314, 0, "i");
    (21315, 0, "l");
    (21316, 0, "e");
    (21317, 0, " ");
    (21318, 0, "(");
    (21318, 1, "");
    (21318, 0, "n");
    (21319, 0, "o");
    (21320, 0, "r");
    (21321, 0, "m");
    (21322, 0, "a");
    (21318, 5, "normal_iter");
    (21329, 0, ".");
    (21330, 0, "here_ptr()");
    (21340, 0, ".");
    (21341, 0, "g");
    (21342, 0, "e");
    (21343, 0, "t");
    (21344, 0, "_");
    (21345, 0, "u");
    (21341, 5, "get_userlen");
    (21352, 0, "(");
    (21353, 0, ")");
    (21354, 0, " ");
    (21340, 15, "");
    (21340, 0, " ");
    (21341, 0, "!");
    (21342, 0, "=");
    (21343, 0, " ");
    (21344, 0, "n");
    (21345, 0, " ");
    (21346, 0, "{");
    (21347, 0, "\n                    ");
    (21368, 0, "n");
    (21369, 0, "o");
    (21370, 0, "r");
    (21371, 0, "m");
    (21372, 0, "a");
    (21373, 0, "l");
    (21368, 6, "normal_iter");
    (21379, 0, ".");
    (21380, 0, "a");
    (21381, 0, "d");
    (21382, 0, "v");
    (21383, 0, "a");
    (21384, 0, "n");
    (21380, 5, "advance_node");
    (21392, 0, "(");
    (21393, 0, ")");
    (21394, 0, ";");
    (21395, 0, "\n                    ");
    (21396, 20, "                }");
    (21295, 52, "");
    (21232, 16, "                    ");
    (21232, 0, "                while normal_iter.here_ptr() != n {\n");
    (21351, 48, "");
    (21284, 0, "                    normal_iter.advance_node();\n");
    (21399, 18, "");
    (21332, 20, "                ");
    (21332, 0, "                }\n");
    (21281, 0, " ");
    (21282, 0, "a");
    (21283, 0, "s");
    (21284, 0, " ");
    (21285, 0, "*");
    (21286, 0, "c");
    (21287, 0, "o");
    (21288, 0, "n");
    (21289, 0, "s");
    (21290, 0, "t");
    (21291, 0, " ");
    (21292, 0, "_");
    (21293, 0, " ");
    (21294, 0, "a");
    (21295, 0, "s");
    (21296, 0, " ");
    (21297, 0, "*");
    (21298, 0, "m");
    (21299, 0, "u");
    (21300, 0, "t");
    (21301, 0, " ");
    (21302, 0, "_");
    (21102, 0, "\n                ");
    ( 31268,
      0,
      "\n\
      \    unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {" );
    (21103, 16, "");
    (31169, 0, "// ");
    (31284, 0, "F");
    (31285, 0, ">");
    (31285, 1, "");
    (31284, 1, "");
    (31284, 0, "<");
    (31285, 0, "F");
    (31286, 0, ">");
    (31285, 1, "");
    (31285, 0, "N");
    (31286, 0, "o");
    (31286, 1, "");
    (31286, 0, "o");
    (31287, 0, "t");
    (31288, 0, "i");
    (31289, 0, "f");
    (31290, 0, "y");
    (31348, 0, ",");
    (31349, 0, " ");
    (31350, 0, "n");
    (31351, 0, "o");
    (31352, 0, "t");
    (31353, 0, "i");
    (31354, 0, "f");
    (31355, 0, "y");
    (31356, 0, ":");
    (31357, 0, " ");
    (31358, 0, "N");
    (31359, 0, "o");
    (31360, 0, "t");
    (31361, 0, "i");
    (31362, 0, "f");
    (31363, 0, "y");
    (31365, 0, "\n    ");
    (31370, 1, "");
    (31370, 0, "    ");
    (31374, 0, "w");
    (31375, 0, "h");
    (31376, 0, "e");
    (31377, 0, "r");
    (31378, 0, "e");
    (31379, 0, " ");
    (31380, 0, "n");
    (31381, 0, "o");
    (31382, 0, "t");
    (31383, 0, "i");
    (31384, 0, "f");
    (31385, 0, "y");
    (31386, 0, ":");
    (31387, 0, " ");
    (31379, 9, " ");
    (31380, 0, "N");
    (31381, 0, "o");
    (31382, 0, "t");
    (31383, 0, "i");
    (31384, 0, "f");
    (31385, 0, "y");
    (31386, 0, ":");
    (31387, 0, " ");
    (31388, 0, "F");
    (31389, 0, "n");
    (31390, 0, "M");
    (31391, 0, "u");
    (31392, 0, "t");
    (31393, 0, "(");
    (31394, 0, ")");
    (31395, 0, " ");
    (31164, 0, "\n    ");
    (31169, 0, "/");
    (31170, 0, "/");
    ( 31171,
      0,
      "fn notify(&mut self, _items: &[Self::Item], _at_marker: \
       ItemMarker<Self>)" );
    (31474, 0, "i");
    (31475, 0, "t");
    (31476, 0, "e");
    (31477, 0, "m");
    (31478, 0, "s");
    (31479, 0, ":");
    (31480, 0, " ");
    (31481, 0, "&");
    (31482, 0, "[");
    (31483, 0, "S");
    (31484, 0, "e");
    (31485, 0, "l");
    (31486, 0, "f");
    (31487, 0, ":");
    (31488, 0, ":");
    (31489, 0, "I");
    (31490, 0, "t");
    (31491, 0, "e");
    (31492, 0, "m");
    (31493, 0, "]");
    (31474, 7, "");
    (31476, 0, "c");
    (31477, 0, ":");
    (31478, 0, ":");
    (31478, 1, "");
    (31477, 1, "");
    (31476, 1, "");
    (31476, 4, "C");
    (31454, 0, "    ");
    (31488, 0, ",");
    (31489, 0, " ");
    (31490, 0, "ItemMarker<Self>");
    (31501, 4, "C");
    (31163, 0, "\n    ");
    (31168, 0, "\n    ");
    (31164, 4, "");
    (31169, 0, "f");
    (31170, 0, "n");
    (31171, 0, " ");
    (31172, 0, "n");
    (31173, 0, "o");
    (31174, 0, "_");
    (31175, 0, "n");
    (31176, 0, "o");
    (31177, 0, "t");
    (31178, 0, "i");
    (31179, 0, "f");
    (31180, 0, "y");
    (31181, 0, "(");
    (31181, 1, "");
    (31181, 0, "(&[C::Item], ItemMarker<C>)");
    (31208, 0, " ");
    (31209, 0, "{");
    (31210, 0, "}");
    (31182, 0, "_");
    (31183, 0, "i");
    (31184, 0, "t");
    (31185, 0, "e");
    (31186, 0, "m");
    (31187, 0, "s");
    (31188, 0, ",");
    (31189, 0, " ");
    (31188, 1, "");
    (31188, 0, ":");
    (31202, 0, "m");
    (31203, 0, "a");
    (31204, 0, "r");
    (31205, 0, "k");
    (31206, 0, "e");
    (31207, 0, "r");
    (31208, 0, ":");
    (31209, 0, " ");
    (31202, 0, "_");
    (37128, 0, "\n    ");
    (37133, 0, "\n    ");
    (37129, 4, "");
    ( 37134,
      0,
      "unsafe fn insert_at_iter<Notify>(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], notify: Notify)" );
    (37222, 16, "");
    (37158, 8, "");
    (31415, 0, "n");
    (31416, 0, "o");
    (31417, 0, "t");
    (31418, 0, "i");
    (31415, 4, "");
    (31429, 0, "_");
    (31430, 0, "a");
    (31431, 0, "n");
    (31432, 0, "d");
    (31433, 0, "_");
    (31434, 0, "n");
    (31435, 0, "o");
    (31436, 0, "t");
    (31437, 0, "i");
    (31438, 0, "f");
    (31439, 0, "y");
    (37226, 0, " ");
    (37227, 0, "{");
    (37228, 0, "\n        ");
    (37237, 0, "\n        ");
    (37229, 8, "");
    (37230, 8, "    }");
    (37229, 0, "        ");
    (37237, 0, "i");
    (37238, 0, "n");
    (37239, 0, "s");
    (37240, 0, "e");
    (37241, 0, "r");
    (37242, 0, "t");
    (37243, 0, "_");
    (37244, 0, "a");
    (37237, 8, "insert_at_iter_and_notify");
    (37262, 0, "(");
    (37263, 0, "s");
    (37264, 0, "e");
    (37265, 0, "l");
    (37266, 0, "f");
    (37267, 0, ",");
    (37268, 0, " ");
    (37269, 0, "c");
    (37270, 0, "u");
    (37271, 0, "r");
    (37272, 0, "s");
    (37273, 0, "o");
    (37274, 0, "r");
    (37275, 0, ",");
    (37276, 0, " ");
    (37277, 0, "c");
    (37278, 0, "o");
    (37279, 0, "n");
    (37280, 0, "t");
    (37281, 0, "e");
    (37282, 0, "n");
    (37283, 0, "t");
    (37284, 0, "s");
    (37285, 0, ",");
    (37286, 0, " ");
    (37287, 0, "n");
    (37288, 0, "o");
    (37287, 2, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (37297, 18, ")");
    (37297, 26, "");
    (37296, 1, "");
    (37296, 0, ")");
    (37297, 0, ";");
    (37297, 1, "");
    (37237, 0, "S");
    (37238, 0, "e");
    (37239, 0, "F");
    (37239, 1, "");
    (37239, 0, "l");
    (37240, 0, "f");
    (37241, 0, ":");
    (37242, 0, ":");
    (37237, 6, "");
    (37237, 25, "");
    (37237, 1, "");
    (37241, 0, ".");
    (37242, 0, "insert_at_iter_and_notify");
    (37267, 0, "(");
    (37268, 1, "");
    (37268, 1, "");
    (37296, 0, ";");
    (37296, 1, "");
    (37286, 0, "s");
    (37287, 0, "e");
    (37288, 0, "l");
    (37289, 0, "f");
    (37290, 0, ":");
    (37291, 0, ":");
    (37286, 1, "");
    (37286, 0, "S");
    (37190, 4, "");
    (37190, 0, "mut ");
    (34363, 0, "\n            ");
    (34376, 0, "\n            ");
    (34364, 12, "");
    (34377, 0, "/");
    (34378, 0, "/");
    (34379, 0, " ");
    (34380, 0, "N");
    (34381, 0, "o");
    (34382, 0, "t");
    (34383, 0, "i");
    (34384, 0, "f");
    (34385, 0, "y");
    (34386, 0, "\n            ");
    (34399, 0, "n");
    (34400, 0, "o");
    (34401, 0, "t");
    (34402, 0, "i");
    (34403, 0, "f");
    (34399, 5, "notify");
    (34405, 0, "(");
    (34405, 1, "");
    (34399, 0, "// ");
    (34399, 3, "");
    (34405, 0, "(");
    (34406, 0, "c");
    (34407, 0, "o");
    (34408, 0, "n");
    (34409, 0, "t");
    (34410, 0, "e");
    (34411, 0, "n");
    (34412, 0, "t");
    (34413, 0, "s");
    (34414, 0, ",");
    (34415, 0, " ");
    (34416, 0, "M");
    (34417, 0, "a");
    (34418, 0, "r");
    (34416, 3, "");
    (34416, 0, "I");
    (34417, 0, "t");
    (34418, 0, "e");
    (34419, 0, "m");
    (34416, 4, "ItemMarker");
    (34426, 0, " ");
    (34427, 0, "{");
    (34428, 0, "\n                ");
    (34445, 0, "\n                ");
    (34429, 16, "");
    (34430, 16, "            }");
    (34443, 0, ")");
    (34429, 0, "                ");
    (34445, 0, "p");
    (34446, 0, "t");
    (34447, 0, "r");
    (34448, 0, ":");
    (34449, 0, " ");
    (34450, 0, "e");
    (34451, 0, ",");
    (34452, 0, "\n                ");
    (34469, 0, "P");
    (34470, 0, "h");
    (34471, 0, "a");
    (34469, 3, "PhantomData");
    (34469, 11, "");
    (34469, 0, "_");
    (34469, 1, "_phanton");
    (34477, 0, ":");
    (34478, 0, " ");
    (34479, 0, "PhantomData");
    (34476, 1, "m");
    (1776, 1, "m");
    (34505, 0, ";");
    (31506, 0, "m");
    (31507, 0, "u");
    (31508, 0, "t");
    (31509, 0, " ");
    (34369, 21, "");
    (34368, 1, "");
    (31163, 0, "\n    ");
    (31168, 0, "\n    ");
    (31164, 4, "");
    ( 31169,
      0,
      "unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, contents: \
       &[C::Item], new_userlen: usize, move_cursor: bool) {" );
    (31192, 1, "");
    (31191, 1, "");
    (31191, 0, "_");
    (31191, 1, "");
    (31191, 0, "a");
    (31192, 0, "n");
    (31193, 0, "d");
    (31194, 0, "_");
    (31195, 0, "n");
    (31196, 0, "o");
    (31197, 0, "t");
    (31198, 0, "i");
    (31199, 0, "f");
    (31200, 0, "y");
    (31201, 0, "<");
    (31202, 0, "N");
    (31203, 0, "o");
    (31204, 0, "t");
    (31205, 0, "i");
    (31206, 0, "f");
    (31207, 0, "y");
    (31208, 0, ">");
    (31305, 0, ",");
    (31306, 0, " ");
    (31307, 0, ", mut notify: Notify");
    (31308, 1, "");
    (31307, 1, "");
    (31327, 0, "\n        ");
    (31336, 0, "\n        ");
    (31328, 8, "");
    (31329, 8, "    }");
    (31326, 1, "");
    (31325, 1, "");
    (31325, 0, ")");
    (31304, 1, "");
    (31325, 0, "\n    ");
    (31330, 0, "where Notify: FnMut(&[C::Item], ItemMarker<C>) {");
    (31330, 0, "    ");
    (31383, 0, "\n            ");
    (31392, 4, "");
    (31392, 0, "s");
    (31393, 0, "e");
    (31394, 0, "l");
    (31395, 0, "f");
    (31396, 0, ".");
    (31397, 0, "i");
    (31398, 0, "n");
    (31399, 0, "s");
    (31400, 0, "e");
    (31401, 0, "r");
    (31402, 0, "t");
    ( 31397,
      6,
      "insert_node_at(cursor: &mut Cursor<C>, contents: &[C::Item], \
       new_userlen: usize, move_cursor: bool)" );
    (31412, 22, "c");
    (31413, 0, "u");
    (31414, 0, "r");
    (31415, 0, "s");
    (31416, 0, "o");
    (31417, 0, "r");
    (31420, 20, "c");
    (31421, 0, "o");
    (31422, 0, "n");
    (31423, 0, "t");
    (31424, 0, "e");
    (31425, 0, "n");
    (31426, 0, "t");
    (31427, 0, "s");
    (31430, 18, "n");
    (31431, 0, "e");
    (31432, 0, "w");
    (31433, 0, "_");
    (31434, 0, "u");
    (31435, 0, "s");
    (31436, 0, "e");
    (31437, 0, "r");
    (31438, 0, "l");
    (31439, 0, "e");
    (31440, 0, "n");
    (31443, 17, "m");
    (31444, 0, "o");
    (31445, 0, "v");
    (31446, 0, "e");
    (31447, 0, "_");
    (31448, 0, "c");
    (31449, 0, "u");
    (31450, 0, "r");
    (31451, 0, "s");
    (31452, 0, "o");
    (31453, 0, "r");
    (31455, 0, ";");
    (31383, 80, "");
    (31165, 218, "");
    (31164, 1, "");
    ( 27886,
      0,
      "    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n" );
    (27890, 0, "// ");
    ( 28016,
      126,
      "    unsafe fn insert_node_and_notify<Notify>(&mut self, cursor: &mut \
       Cursor<C>, contents: &[C::Item], new_userlen: usize, move_cursor: bool, \
       mut notify: Notify)\n\
      \        where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n" );
    (28016, 4, "        ");
    (28016, 8, "    ");
    (28177, 0, "    ");
    (31383, 0, "\n        ");
    (31392, 0, "\n        ");
    (31384, 8, "");
    (31393, 0, "n");
    (31394, 0, "o");
    (31395, 0, "t");
    (31396, 0, "i");
    (31397, 0, "f");
    (31398, 0, "y");
    (31399, 0, "(");
    (31400, 0, "c");
    (31401, 0, "o");
    (31402, 0, "n");
    (31403, 0, "t");
    (31404, 0, "e");
    (31405, 0, "n");
    (31406, 0, "t");
    (31407, 0, "s");
    (31408, 0, ",");
    (31409, 0, " ");
    (31410, 0, "M");
    (31410, 1, "");
    (31410, 0, "I");
    (31411, 0, "t");
    (31412, 0, "e");
    (31413, 0, "m");
    (31410, 4, "ItemMarker");
    (31420, 0, " ");
    (31421, 0, "{");
    (31422, 0, "\n            ");
    (31435, 0, "\n            ");
    (31423, 12, "");
    (31424, 12, "        }");
    (31433, 0, ")");
    (31423, 0, "            ");
    (31435, 0, "p");
    (31436, 0, "t");
    (31437, 0, "r");
    (31438, 0, ":");
    (31439, 0, " ");
    (31440, 0, "n");
    (31441, 0, "e");
    (31442, 0, "w");
    (31443, 0, "_");
    (31444, 0, "n");
    (31445, 0, "o");
    (31440, 6, "new_node");
    (31448, 0, "_");
    (31449, 0, "p");
    (31450, 0, "t");
    (31451, 0, "r");
    (31452, 0, ",");
    (31453, 0, "\n            ");
    (31466, 0, "_");
    (31467, 0, "p");
    (31468, 0, "h");
    (31466, 3, "_phantom");
    (31474, 0, ":");
    (31475, 0, " ");
    (31476, 0, "P");
    (31477, 0, "h");
    (31476, 2, "PhantomData");
    (31498, 0, ";");
    (31505, 65, "");
    (36968, 1, "");
    (36967, 1, "");
    ( 36955,
      12,
      "insert_node_and_notify(cursor: &mut Cursor<C>, contents: &[C::Item], \
       new_userlen: usize, move_cursor: bool, mut notify: Notify)" );
    (36977, 105, "");
    (37006, 0, ",");
    (37007, 0, " ");
    (37008, 0, "n");
    (37009, 0, "o");
    (37010, 0, "t");
    (37011, 0, "i");
    (37012, 0, "f");
    (37013, 0, "y");
    (37525, 0, ",");
    (37526, 0, " ");
    (37527, 0, "n");
    (37528, 0, "o");
    (37529, 0, "t");
    (37530, 0, "i");
    (37531, 0, "f");
    (37532, 0, "y");
    (37484, 1, "");
    (37483, 1, "");
    (37483, 0, "a");
    (37484, 0, "n");
    (37485, 0, "d");
    (37486, 0, "_");
    (37487, 0, "n");
    (37488, 0, "o");
    (37489, 0, "t");
    (37490, 0, "i");
    (37491, 0, "f");
    (37492, 0, "y");
    (37736, 0, ";");
    (37736, 1, "");
    (37483, 10, "");
    (37483, 0, "at");
    (37526, 7, "");
    (37525, 1, "");
    (37007, 7, "");
    (37006, 1, "");
    ( 36977,
      0,
      "(cursor: &mut Cursor<C>, contents: &[C::Item], new_userlen: usize, \
       move_cursor: bool, mut notify: Notify)" );
    (36955, 127, "insert_node_");
    (36967, 0, "at");
    ( 31505,
      0,
      "\n\n    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}" );
    (31498, 1, "");
    (31476, 11, "Ph");
    (31476, 2, "PhantomData");
    (31498, 0, ";");
    (31505, 65, "");
    (36967, 2, "");
    ( 36955,
      12,
      "insert_node_and_notify(cursor: &mut Cursor<C>, contents: &[C::Item], \
       new_userlen: usize, move_cursor: bool, mut notify: Notify)" );
    (36977, 105, "");
    (37006, 0, ",");
    (37007, 0, " notify");
    (37525, 0, ",");
    (37526, 0, " notify");
    (37483, 2, "");
    (37483, 0, "and_notify");
    (37736, 0, ";");
    (37574, 0, "\n    ");
    ( 37579,
      0,
      "\n\n    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}" );
    (37575, 4, "");
    (37575, 1, "");
    (37574, 1, "");
    (37806, 0, "// ");
    (37731, 0, "// ");
    (37643, 0, "// ");
    (37490, 3, "");
    (37484, 5, "");
    (36974, 3, "");
    (36968, 5, "");
    (28049, 3, "");
    (28043, 5, "");
    (2704, 3, "");
    (2603, 3, "");
    (31702, 1, "");
    (31701, 1, "");
    (31700, 1, "");
    (31699, 1, "");
    (31698, 1, "");
    (31697, 1, "");
    (31696, 1, "");
    (31695, 1, "");
    (31694, 1, "");
    (31693, 1, "");
    (31692, 1, "");
    (31778, 59, "");
    (31777, 1, "");
    (31777, 0, "\n");
    (31778, 0, "            where Notify: FnMut(&[C::Item], ItemMarker<C>) ");
    (31692, 0, "_and_notify");
    (31703, 125, "");
    ( 31703,
      1,
      "<Notify>(&mut self, cursor: &mut Cursor<C>, contents: &[C::Item], mut \
       notify: Notify)\n\
      \            where Notify: FnMut(&[C::It" );
    (31793, 0, "// ");
    (31668, 0, "// ");
    (31577, 3, "");
    (31660, 128, "");
    (31573, 4, "        ");
    ( 31573,
      0,
      "    // unsafe fn insert_at_iter_and_notify<Notify>(&mut self, cursor: \
       &mut Cursor<C>, contents: &[C::Item], mut notify: Notify)\n" );
    (31792, 64, "");
    (31701, 8, "            ");
    ( 31701,
      0,
      "    //         where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n" );
    (31765, 12, "        ");
    (31765, 8, "    ");
    (28014, 0, "// ");
    (27884, 3, "");
    (28006, 156, "");
    (27880, 4, "        ");
    ( 27880,
      0,
      "    // unsafe fn insert_node_at<Notify>(&mut self, cursor: &mut \
       Cursor<C>, contents: &[C::Item], new_userlen: usize, move_cursor: bool, \
       mut notify: Notify)\n" );
    (28036, 8, "    ");
    (28175, 0, "// ");
    ( 28226,
      0,
      "\n\
      \    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {" );
    (28163, 12, "    ");
    (28036, 127, "");
    (31374, 0, "c");
    (31375, 0, ":");
    (31375, 1, "");
    (31374, 1, "");
    (31374, 0, "C");
    (31375, 0, ":");
    (31376, 0, ":");
    (31384, 0, "s");
    (31385, 0, "e");
    (31386, 0, ".");
    (31387, 0, "f");
    (31387, 1, "");
    (31386, 1, "");
    (31386, 0, "l");
    (31387, 0, "f");
    (31388, 0, ".");
    (31389, 0, "c");
    (31390, 0, "o");
    (31391, 0, "n");
    (31392, 0, "f");
    (31393, 0, "i");
    (31394, 0, "g");
    (31395, 0, ",");
    (31396, 0, " ");
    (31384, 0, "&");
    (31385, 0, "m");
    (31386, 0, "u");
    (31387, 0, "t");
    (31388, 0, " ");
    (31388, 1, "");
    (31384, 4, "");
    (31396, 1, "");
    (31386, 10, "");
    (31386, 0, ".f");
    (31384, 4, "");
    (31374, 3, "");
    (31374, 0, "c:");
    (31374, 2, "");
    (28091, 127, "");
    (28036, 4, "            ");
    ( 28036,
      0,
      "    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n" );
    (28175, 3, "");
    (28036, 4, "        ");
    ( 28166,
      0,
      "\n\
      \    // unsafe fn insert_node_at<Notify>(&mut self, cursor: &mut \
       Cursor<C>, contents: &[C::Item], new_userlen: usize, move_cursor: bool, \
       mut notify: Notify)" );
    (28036, 8, "    ");
    (27880, 156, "");
    (27884, 0, "// ");
    (28014, 3, "");
    (31765, 4, "        ");
    (31765, 8, "            ");
    ( 31860,
      0,
      "\n    //         where Notify: FnMut(&[C::Item], ItemMarker<C>) {" );
    (31765, 12, "        ");
    (31701, 64, "");
    ( 31792,
      0,
      "\n\
      \    // unsafe fn insert_at_iter_and_notify<Notify>(&mut self, cursor: \
       &mut Cursor<C>, contents: &[C::Item], mut notify: Notify)" );
    (31701, 8, "    ");
    (31573, 128, "");
    (31577, 0, "// ");
    (31796, 3, "");
    (31668, 3, "");
    (2701, 0, "// ");
    (2603, 0, "// ");
    (2704, 3, "");
    (2603, 3, "");
    (2701, 0, "// ");
    (2603, 0, "// ");
    (37469, 0, "ify");
    (37468, 0, "nd_no");
    (36961, 0, "ify");
    (36960, 0, "nd_no");
    (28044, 0, "ify");
    (28043, 0, "nd_no");
    (37490, 3, "");
    (37484, 5, "");
    (36974, 3, "");
    (36968, 5, "");
    (28049, 3, "");
    (28043, 5, "");
    (31698, 11, "");
    (37539, 64, "");
    (44354, 0, "\n    ");
    ( 44359,
      0,
      "\n    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}" );
    (44355, 4, "");
    (44419, 0, "\n    ");
    (44420, 4, "");
    (44354, 1, "");
    (41488, 0, "\n    ");
    ( 41493,
      0,
      "    unsafe fn insert_at_iter<Notify>(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], mut notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n" );
    (41607, 12, "    ");
    (41489, 8, "    ");
    (41607, 0, "// ");
    (41493, 0, "// ");
    (41692, 0, "<");
    (41693, 0, "N");
    (41694, 0, "o");
    (41695, 0, "t");
    (41696, 0, "i");
    (41697, 0, "f");
    (41698, 0, "y");
    (41699, 0, ">");
    (41794, 0, ",");
    (41795, 0, " ");
    (41796, 0, "m");
    (41797, 0, "u");
    (41798, 0, "t");
    (41799, 0, " ");
    (41800, 0, "n");
    (41801, 0, "o");
    (41802, 0, "t");
    (41803, 0, "i");
    (41804, 0, "f");
    (41805, 0, "y");
    (41806, 0, ":");
    (41807, 0, " ");
    (41808, 0, "N");
    (41809, 0, "o");
    (41810, 0, "t");
    (41811, 0, "i");
    (41812, 0, "f");
    (41813, 0, "y");
    (41815, 1, "");
    (41815, 0, "\n    ");
    (41820, 0, "    ");
    (41824, 0, "    ");
    (41828, 0, "w");
    (41829, 0, "h");
    (41830, 0, "e");
    (41831, 0, "r");
    (41832, 0, "e");
    (41833, 0, " ");
    (41834, 1, "");
    (41834, 0, "Notify: FnMut(&[C::Item], ItemMarker<C>) {");
    (44136, 0, ",");
    (44137, 0, " ");
    (44138, 0, "n");
    (44139, 0, "o");
    (44140, 0, "t");
    (44141, 0, "i");
    (44142, 0, "f");
    (44143, 0, "y");
    (43103, 0, "\n            ");
    (43116, 0, "\n            ");
    (43104, 12, "");
    (43117, 0, "n");
    (43118, 0, "o");
    (43119, 0, "t");
    (43120, 0, "i");
    (43121, 0, "f");
    (43122, 0, "y");
    (43123, 0, "(");
    (43124, 0, "n");
    (43125, 0, "e");
    (43126, 0, "w");
    (43127, 0, "_");
    (43128, 0, "i");
    (43129, 0, "t");
    (43130, 0, "e");
    (43131, 0, "m");
    (43132, 0, "s");
    (43133, 0, ",");
    (43134, 0, " ");
    (43135, 0, "I");
    (43136, 0, "t");
    (43137, 0, "e");
    (43138, 0, "m");
    (43135, 4, "ItemMarker");
    (43145, 0, " ");
    (43146, 0, "{");
    (43147, 0, "\n                ");
    (43164, 0, "\n                ");
    (43148, 16, "");
    (43149, 16, "            }");
    (43162, 0, ")");
    (43148, 0, "                ");
    (43164, 0, "_");
    (43164, 1, "_phantom");
    (43172, 0, ":");
    (43173, 0, " ");
    (43174, 0, "P");
    (43175, 0, "a");
    (43176, 0, "h");
    (43174, 3, "PhantomData");
    (43147, 0, "\n                ");
    (43202, 0, ",");
    (43148, 16, "");
    (43148, 0, "                ");
    (43164, 0, "p");
    (43165, 0, "t");
    (43166, 0, "r");
    (43167, 0, ":");
    (43168, 0, " ");
    (43169, 0, "e");
    (43170, 0, ",");
    (43225, 0, ";");
    (43104, 122, "");
    (43103, 1, "");
    (43819, 0, "\n            ");
    ( 43832,
      0,
      "\n\
      \            notify(new_items, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });" );
    (43820, 12, "");
    (45213, 0, ",");
    (45214, 0, " ");
    (45215, 0, "n");
    (45216, 0, "o");
    (45215, 2, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (45215, 53, "no");
    (45217, 0, "n");
    (45217, 1, "");
    (45217, 0, "_");
    (45218, 0, "n");
    (45219, 0, "o");
    (45220, 0, "f");
    (45220, 1, "");
    (45220, 0, "t");
    (45221, 0, "i");
    (45222, 0, "f");
    (45223, 0, "y");
    (45215, 0, "S");
    (45216, 0, "e");
    (45217, 0, "l");
    (45218, 0, "f");
    (45219, 0, ":");
    (45220, 0, ":");
    (45855, 0, "Self::no_notify");
    (45855, 15, "");
    (45855, 0, ",");
    (45856, 0, " ");
    (45857, 0, "Self::no_notify");
    (46407, 0, ",");
    (46408, 0, " ");
    (46409, 0, "Self::no_notify");
    (46484, 0, ",");
    (46485, 0, " ");
    (46486, 0, "Self::no_notify");
    (46846, 0, ",");
    (46847, 0, " ");
    (46848, 0, "Self::no_notify");
    (31776, 0, "&");
    (28161, 0, "&");
    (44263, 0, "&");
    (46851, 0, "&");
    (46489, 0, "&");
    (46412, 0, "&");
    (45860, 0, "&");
    (31765, 3, "");
    (31765, 1, "");
    (31774, 0, "m");
    (31775, 0, "u");
    (31776, 0, "t");
    (31777, 0, " ");
    (46855, 0, "m");
    (46492, 0, "m");
    (46414, 0, "m");
    (45861, 0, "m");
    (46859, 0, "u");
    (46495, 0, "u");
    (46416, 0, "u");
    (45862, 0, "u");
    (46863, 0, "t");
    (46498, 0, "t");
    (46418, 0, "t");
    (45863, 0, "t");
    (46867, 0, " ");
    (46501, 0, " ");
    (46420, 0, " ");
    (45864, 0, " ");
    (44264, 0, "m");
    (44265, 0, "u");
    (44266, 0, "t");
    (44267, 0, " ");
    (28149, 4, "");
    (28158, 0, "m");
    (28159, 0, "u");
    (28160, 0, "t");
    (28161, 0, " ");
    (31500, 79, "");
    (31499, 1, "");
    (1182, 1, "");
    (1182, 0, "1");
    (1183, 0, "9");
    (1184, 0, "9");
    (1184, 1, "");
    (1183, 1, "");
    (1183, 0, "0");
    (1184, 0, "0");
    (1182, 3, "2");
    (1572, 1, "");
    (1572, 0, "1");
    (1573, 0, "0");
    (26440, 0, "            let walk_height = (*parent).height as usize - 2;\n");
    (26452, 0, "// ");
    (26534, 29, "");
    (26534, 0, "(");
    (26535, 0, "*");
    (26536, 0, "n");
    (26537, 0, ")");
    (26538, 0, ".");
    (26539, 0, "h");
    (26540, 0, "e");
    (26541, 0, "i");
    (26542, 0, "g");
    (26543, 0, "h");
    (26544, 0, "t");
    (26545, 0, " ");
    (26546, 0, "-");
    (26547, 0, " ");
    (26548, 0, "1");
    (26549, 0, " ");
    (26550, 0, "a");
    (26551, 0, "s");
    (26552, 0, " ");
    (26553, 0, "u");
    (26554, 0, "s");
    (26555, 0, "i");
    (26556, 0, "z");
    (26557, 0, "e");
    (26549, 9, "");
    (26545, 0, " as usize");
    (20003, 1, "");
    (20003, 0, ">");
    (20003, 1, "");
    (20003, 0, "-");
    (20003, 1, "");
    (20003, 0, "=");
    (20006, 13, "");
    (20006, 0, "s");
    (20007, 0, "e");
    (20008, 0, ".");
    (20008, 1, "");
    (20008, 0, "l");
    (20009, 0, "f");
    (20010, 0, ".");
    (20011, 0, "h");
    (20012, 0, "e");
    (20013, 0, "a");
    (20014, 0, "d");
    (20015, 0, " ");
    (20016, 0, "a");
    (20017, 0, "s");
    (20018, 0, " ");
    (20019, 0, "u");
    (20019, 1, "");
    (20018, 1, "");
    (20017, 1, "");
    (20016, 1, "");
    (20015, 1, "");
    (20015, 0, " ");
    (20016, 0, "a");
    (20017, 0, "s");
    (20018, 0, " ");
    (20019, 0, "u");
    (20020, 0, "s");
    (20021, 0, "i");
    (20022, 0, "z");
    (20023, 0, "e");
    (20015, 9, "");
    (20011, 4, "");
    (20011, 0, "h");
    (20012, 0, "e");
    (20013, 0, "i");
    (20014, 0, "g");
    (20015, 0, "h");
    (20016, 0, "t");
    (20011, 0, "n");
    (20012, 0, "o");
    (20013, 0, "d");
    (20014, 0, "e");
    (20015, 0, ".");
    (20011, 4, "h");
    (20012, 0, "e");
    (20013, 0, "a");
    (20014, 0, "d");
    (20195, 0, "\n                ");
    (20212, 0, "d");
    (20213, 0, "b");
    (20214, 0, "g");
    (20215, 0, "!");
    (20216, 0, "(");
    (20217, 0, "n");
    (20218, 0, ".");
    (20219, 0, "p");
    (20220, 0, "a");
    (20221, 0, "r");
    (20222, 0, "e");
    (20223, 0, "n");
    (20224, 0, "t");
    (20225, 0, ")");
    (20226, 0, ";");
    (20227, 0, "\n                ");
    (20228, 16, "");
    (20196, 0, "                dbg!(n.parent);\n");
    (20249, 8, "s");
    (20250, 0, "e");
    (20251, 0, "l");
    (20252, 0, "f");
    (20253, 0, ".");
    (20254, 0, "h");
    (20255, 0, "e");
    (20256, 0, "a");
    (20257, 0, "d");
    (20249, 0, "&");
    (20259, 0, " ");
    (20260, 0, "a");
    (20261, 0, "s");
    (20262, 0, " ");
    (20263, 0, "&");
    (20264, 0, "*");
    (20264, 1, "");
    (20263, 1, "");
    (20263, 0, "*");
    (20264, 0, "c");
    (20265, 0, "o");
    (20266, 0, "n");
    (20267, 0, "s");
    (20268, 0, "t");
    (20269, 0, " ");
    (20270, 0, "_");
    (1183, 0, "0");
    (20274, 0, "\n                dbg!(&self.head as *const _);");
    (20274, 0, "\n                dbg!(n.parent);");
    (20197, 32, "");
    (20218, 10, "n");
    (40996, 0, "\n                    ");
    (41017, 0, "\n                    ");
    (40997, 20, "");
    (41018, 0, "\n                    ");
    (40998, 20, "");
    (41019, 0, "\n                    ");
    (40999, 20, "");
    (41000, 20, "");
    (40999, 0, "                    ");
    (41019, 0, "l");
    (41020, 0, "e");
    (41021, 0, "t");
    (41022, 0, " ");
    (41023, 0, "m");
    (41024, 0, "u");
    (41025, 0, "t");
    (41026, 0, " ");
    (41027, 0, "s");
    (41028, 0, "k");
    (41029, 0, "i");
    (41030, 0, "p");
    (41031, 0, "_");
    (41032, 0, "h");
    (41033, 0, "e");
    (41034, 0, "i");
    (41035, 0, "g");
    (41036, 0, "h");
    (41037, 0, "t");
    (41038, 0, " ");
    (41039, 0, "=");
    (41040, 0, " ");
    (41041, 0, "1");
    (41042, 0, ";");
    (41042, 1, "");
    (41041, 1, "");
    (41041, 0, "-");
    (41041, 1, "");
    (41041, 0, "0");
    (41042, 0, ";");
    (40998, 0, "                    ");
    (41018, 0, "/");
    (41019, 0, "/");
    (41020, 0, " ");
    (41021, 0, "W");
    (41022, 0, "e");
    (41023, 0, " ");
    (41024, 0, "n");
    (41025, 0, "e");
    (41026, 0, "e");
    (41027, 0, "d");
    (41028, 0, " ");
    (41029, 0, "t");
    (41030, 0, "o");
    (41031, 0, " ");
    (41032, 0, "u");
    (41033, 0, "p");
    (41034, 0, "d");
    (41035, 0, "a");
    (41036, 0, "t");
    (41037, 0, "e");
    (41038, 0, " ");
    (41039, 0, "a");
    (41040, 0, "l");
    (41041, 0, "l");
    (41042, 0, " ");
    (41043, 0, "t");
    (41044, 0, "h");
    (41045, 0, "e");
    (41046, 0, " ");
    (41047, 0, "n");
    (41048, 0, "o");
    (41049, 0, "d");
    (41050, 0, "e");
    (41051, 0, "s");
    (41052, 0, " ");
    (41053, 0, "t");
    (41054, 0, "h");
    (41055, 0, "a");
    (41056, 0, "t");
    (41057, 0, " ");
    (41021, 37, "I");
    (41022, 0, "f");
    (41023, 0, " ");
    (41024, 0, "y");
    (41025, 0, "o");
    (41026, 0, "u");
    (41027, 0, " ");
    (41028, 0, "i");
    (41029, 0, "m");
    (41030, 0, "a");
    (41031, 0, "g");
    (41032, 0, "i");
    (41033, 0, "n");
    (41034, 0, "e");
    (41035, 0, " ");
    (41036, 0, "t");
    (41037, 0, "h");
    (41038, 0, "i");
    (41039, 0, "s");
    (41040, 0, " ");
    (41041, 0, "n");
    (41042, 0, "o");
    (41043, 0, "d");
    (41044, 0, "e");
    (41045, 0, " ");
    (41046, 0, "a");
    (41047, 0, "s");
    (41048, 0, " ");
    (41049, 0, "b");
    (41050, 0, "e");
    (41050, 1, "");
    (41049, 1, "");
    (41049, 0, "a");
    (41050, 0, " ");
    (41051, 0, "b");
    (41052, 0, "i");
    (41053, 0, "g");
    (41054, 0, " ");
    (41055, 0, "b");
    (41056, 0, "u");
    (41057, 0, "i");
    (41058, 0, "l");
    (41059, 0, "d");
    (41060, 0, "i");
    (41061, 0, "n");
    (41062, 0, "g");
    (41063, 0, ",");
    (41064, 0, " ");
    (41065, 0, "w");
    (41066, 0, "e");
    (41067, 0, " ");
    (41068, 0, "n");
    (41069, 0, "e");
    (41070, 0, "e");
    (41071, 0, "d");
    (41072, 0, " ");
    (41073, 0, "t");
    (41074, 0, "o");
    (41075, 0, " ");
    (41076, 0, "u");
    (41077, 0, "p");
    (41078, 0, "d");
    (41079, 0, "a");
    (41080, 0, "t");
    (41081, 0, "e");
    (41082, 0, " ");
    (41083, 0, "a");
    (41084, 0, "l");
    (41085, 0, "l");
    (41086, 0, " ");
    (41087, 0, "t");
    (41088, 0, "h");
    (41089, 0, "e");
    (41090, 0, " ");
    (41091, 0, "n");
    (41092, 0, "o");
    (41093, 0, "d");
    (41094, 0, "e");
    (41095, 0, "s");
    (41083, 13, "t");
    (41084, 0, "h");
    (41085, 0, "e");
    (41086, 0, " ");
    (41087, 0, "p");
    (41088, 0, "a");
    (41089, 0, "r");
    (41090, 0, "e");
    (41091, 0, "n");
    (41092, 0, "t");
    (41093, 0, " ");
    (41094, 0, "o");
    (41095, 0, "f");
    (41096, 0, " ");
    (41097, 0, "a");
    (41098, 0, "l");
    (41099, 0, "l");
    (41100, 0, " ");
    (41101, 0, "t");
    (41102, 0, "h");
    (41103, 0, "e");
    (41104, 0, " ");
    (41105, 0, "n");
    (41106, 0, "o");
    (41107, 0, "d");
    (41108, 0, "e");
    (41109, 0, "s");
    (41110, 0, " ");
    (41111, 0, "w");
    (41112, 0, "e");
    (41113, 0, " ");
    (41114, 0, "c");
    (41115, 0, "a");
    (41116, 0, "n");
    (41116, 1, "");
    (41116, 0, "s");
    (41117, 0, "t");
    (41118, 0, " ");
    (41119, 0, "a");
    (41120, 0, " ");
    (41121, 0, "s");
    (41121, 1, "");
    (41121, 0, "s");
    (41122, 0, "h");
    (41123, 0, "a");
    (41124, 0, "d");
    (41125, 0, "o");
    (41126, 0, "w");
    (41127, 0, " ");
    (41128, 0, "o");
    (41129, 0, "v");
    (41130, 0, "e");
    (41131, 0, "r");
    (41132, 0, ".");
    (41133, 0, " ");
    (41134, 0, "S");
    (41135, 0, "o");
    (41136, 0, ",");
    (41137, 0, " ");
    (41138, 0, "t");
    (41139, 0, "h");
    (41140, 0, "e");
    (41141, 0, " ");
    (41142, 0, "n");
    (41143, 0, "e");
    (41138, 6, "i");
    (41139, 0, "f");
    (41140, 0, " ");
    (41141, 0, "w");
    (41141, 1, "");
    (41141, 0, "o");
    (41142, 0, "u");
    (41143, 0, "r");
    (41144, 0, " ");
    (41145, 0, "h");
    (41146, 0, "e");
    (41147, 0, "i");
    (41148, 0, "g");
    (41149, 0, "h");
    (41150, 0, "t");
    (41151, 0, " ");
    (41152, 0, "i");
    (41153, 0, "s");
    (41154, 0, " ");
    (41155, 0, "2");
    (41156, 0, ",");
    (41157, 0, " ");
    (41157, 1, "");
    (41156, 1, "");
    (41155, 1, "");
    (41155, 0, "3");
    (41156, 0, " ");
    (41157, 0, "a");
    (41158, 0, "n");
    (41159, 0, "d");
    (41160, 0, " ");
    (41161, 0, "t");
    (41162, 0, "h");
    (41163, 0, "e");
    (41164, 0, " ");
    (41165, 0, "n");
    (41166, 0, "e");
    (41167, 0, "x");
    (41168, 0, "t");
    (41169, 0, " ");
    (41170, 0, "n");
    (41171, 0, "o");
    (41172, 0, "d");
    (41173, 0, "e");
    (41174, 0, "s");
    (41175, 0, " ");
    (41176, 0, "h");
    (41177, 0, "a");
    (41178, 0, "v");
    (41179, 0, "e");
    (41180, 0, " ");
    (41181, 0, "h");
    (41182, 0, "e");
    (41183, 0, "i");
    (41184, 0, "g");
    (41185, 0, "h");
    (41186, 0, "t");
    (41187, 0, "s");
    (41188, 0, " ");
    (41189, 0, "1");
    (41190, 0, " ");
    (41191, 0, "a");
    (41192, 0, "n");
    (41193, 0, "d");
    (41194, 0, " ");
    (41195, 0, "2");
    (41196, 0, ",");
    (41197, 0, " ");
    (41198, 0, "t");
    (41199, 0, "h");
    (41200, 0, "e");
    (41201, 0, "y");
    (41202, 0, " ");
    (41203, 0, "b");
    (41204, 0, "o");
    (41205, 0, "t");
    (41206, 0, "h");
    (41207, 0, " ");
    (41208, 0, "n");
    (41209, 0, "e");
    (41210, 0, "e");
    (41211, 0, "d");
    (41212, 0, " ");
    (41213, 0, "n");
    (41214, 0, "e");
    (41215, 0, "w");
    (41216, 0, " ");
    (41217, 0, "p");
    (41218, 0, "a");
    (41219, 0, "r");
    (41220, 0, "e");
    (41221, 0, "n");
    (41222, 0, "t");
    (41223, 0, "s");
    (41224, 0, ".");
    (41225, 0, " ");
    (41226, 0, "T");
    (41227, 0, "h");
    (41228, 0, "e");
    (41229, 0, " ");
    (41229, 1, "");
    (41228, 1, "");
    (41227, 1, "");
    (41226, 1, "");
    (41225, 1, "");
    ( 40998,
      227,
      "                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents." );
    (41511, 0, "\n                        ");
    (41536, 0, "s");
    (41537, 0, "k");
    (41538, 0, "i");
    (41539, 0, "p");
    (41540, 0, "_");
    (41536, 5, "skip_height");
    (41547, 0, " ");
    (41548, 0, "=");
    (41549, 0, " ");
    (41550, 0, "u");
    (41551, 0, "s");
    (41552, 0, "i");
    (41553, 0, "z");
    (41554, 0, "e");
    (41555, 0, ":");
    (41556, 0, ":");
    (41557, 0, "m");
    (41558, 0, "a");
    (41559, 0, "x");
    (41550, 10, "s");
    (41551, 0, "k");
    (41552, 0, "i");
    (41553, 0, "p");
    (41554, 0, "_");
    (41550, 5, "skip_height");
    (41561, 0, ".");
    (41562, 0, "m");
    (41563, 0, "a");
    (41564, 0, "p");
    (41564, 1, "");
    (41564, 0, "x");
    (41565, 0, "(");
    (41566, 0, "(");
    (41567, 0, "*");
    (41568, 0, "n");
    (41569, 0, ")");
    (41570, 0, ".");
    (41571, 0, "h");
    (41572, 0, "e");
    (41573, 0, "i");
    (41574, 0, "g");
    (41575, 0, "h");
    (41576, 0, "t");
    (41577, 0, ")");
    (41578, 0, ";");
    (41577, 0, " ");
    (41578, 0, "a");
    (41579, 0, "s");
    (41580, 0, " ");
    (41581, 0, "s");
    (41582, 0, "u");
    (41582, 1, "");
    (41581, 1, "");
    (41580, 1, "");
    (41579, 1, "");
    (41578, 1, "");
    (41577, 1, "");
    (41577, 0, " ");
    (41578, 0, "a");
    (41579, 0, "s");
    (41580, 0, " ");
    (41581, 0, "u");
    (41582, 0, "s");
    (41583, 0, "i");
    (41584, 0, "z");
    (41585, 0, "e");
    (41413, 10, "s");
    (41414, 0, "k");
    (41415, 0, "i");
    (41416, 0, "p");
    (41413, 4, "skip_height");
    (41589, 1, "");
    (41513, 0, "                        \n");
    (41614, 50, "");
    (41538, 0, "                        (*n).parent = new_parent;\n");
    (40947, 0, "// ");
    (41579, 10, "cursor.entries[height - 1].node");
    (41594, 10, "s");
    (41595, 0, "k");
    (41596, 0, "i");
    (41597, 0, "p");
    (41594, 4, "skip_height");
    (41605, 0, " ");
    (41606, 0, "+");
    (41607, 0, " ");
    (41608, 0, "1");
    (41594, 11, "(*n).height as usize");
    (41664, 11, "");
    (41664, 0, "u");
    (41665, 0, "s");
    (41666, 0, "i");
    (41667, 0, "z");
    (41668, 0, "e");
    (41669, 0, ":");
    (41670, 0, ":");
    (41671, 0, "m");
    (41672, 1, "");
    (41672, 1, "");
    (41675, 0, "skip_height");
    (41686, 0, ",");
    (41687, 0, " ");
    (41370, 0, "\n                        ");
    (41395, 0, "d");
    (41396, 0, "b");
    (41397, 0, "g");
    (41395, 3, "dbg!");
    (41399, 0, "(");
    (41400, 0, "\"");
    (41401, 0, "s");
    (41402, 0, "k");
    (41402, 1, "");
    (41401, 1, "");
    (41400, 1, "");
    (41400, 0, "s");
    (41401, 0, "k");
    (41402, 0, "i");
    (41403, 0, "p");
    (41404, 0, "_");
    (41400, 5, "skip_height");
    (41411, 0, ")");
    (41412, 0, ";");
    (41413, 0, "\n                        ");
    (41438, 0, "d");
    (41439, 0, "b");
    (41440, 0, "g");
    (41441, 0, "!");
    (41442, 0, "(");
    (41443, 0, "(*n).height as usize");
    (41463, 0, ")");
    (41464, 0, ";");
    (41465, 0, "\n                        ");
    (41828, 0, " ");
    (41466, 24, "");
    (41805, 0, "-");
    (41806, 0, " ");
    (41807, 0, "1");
    (41438, 0, "// ");
    (41395, 0, "// ");
    (41642, 0, "\n                        ");
    (41667, 0, "/");
    (41668, 0, "/");
    (41669, 0, " ");
    (41670, 0, "T");
    (41671, 0, "O");
    (41672, 0, "D");
    (41673, 0, "O");
    (41674, 0, ":");
    (41675, 0, " ");
    (41676, 0, "W");
    (41677, 0, "e");
    (41678, 0, " ");
    (41679, 0, "c");
    (41680, 0, "a");
    (41681, 0, "n");
    (41682, 0, " ");
    (41683, 0, "c");
    (41684, 0, "a");
    (41685, 0, "c");
    (41686, 0, "h");
    (41687, 0, "e");
    (41688, 0, " ");
    (41689, 0, "t");
    (41690, 0, "h");
    (41691, 0, "i");
    (41692, 0, "s");
    (41693, 0, " ");
    (41694, 0, "e");
    (41695, 0, "a");
    (41696, 0, "c");
    (41697, 0, "h");
    (41698, 0, " ");
    (41699, 0, "t");
    (41700, 0, "i");
    (41701, 0, "m");
    (41702, 0, "e");
    (41703, 0, " ");
    (41704, 0, "t");
    (41705, 0, "h");
    (41706, 0, "e");
    (41707, 0, " ");
    (41708, 0, "c");
    (41709, 0, "u");
    (41710, 0, "r");
    (41708, 3, "h");
    (41709, 0, "e");
    (41710, 0, "i");
    (41710, 1, "");
    (41710, 0, "i");
    (41711, 0, "g");
    (41712, 0, "h");
    (41713, 0, "t");
    (41714, 0, " ");
    (41715, 0, "g");
    (41716, 0, "o");
    (41717, 0, "e");
    (41718, 0, "s");
    (41719, 0, " ");
    (41720, 0, "u");
    (41721, 0, "p");
    (41722, 0, "?");
    (41679, 3, "c");
    (41680, 0, "p");
    (41681, 0, "u");
    (41681, 1, "");
    (41680, 1, "");
    (41680, 0, "o");
    (41681, 0, "u");
    (41682, 0, "l");
    (41683, 0, "d");
    (20218, 0, "(");
    (20232, 0, ",");
    (20233, 0, " ");
    (20234, 0, "*");
    (20235, 0, "(");
    (20235, 1, "");
    (20234, 1, "");
    (20234, 0, "(");
    (20235, 0, "*");
    (20236, 0, "n");
    (20237, 0, ")");
    (20238, 0, ".");
    (20239, 0, "h");
    (20240, 0, "e");
    (20241, 0, "i");
    (20242, 0, "g");
    (20243, 0, "h");
    (20244, 0, "t");
    (20245, 0, ")");
    (31088, 0, "\n            ");
    (31101, 0, "\n            ");
    (31089, 12, "");
    (31102, 0, "\n            ");
    (31090, 12, "");
    (31103, 0, "\n            ");
    (31091, 12, "");
    (31104, 0, "\n            ");
    (31092, 12, "");
    (31093, 12, "");
    ( 31090,
      0,
      "                if height > 1 {\n\
      \                    let mut n = e;\n\
      \                    // let new_parent = cursor.entries[height - \
       1].node;\n\n\
      \                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents.\n\
      \                    let mut skip_height = 0;\n\n\
      \                    loop {\n\
      \                        // dbg!(skip_height);\n\
      \                        // dbg!((*n).height as usize);\n\n\
      \                        n = (*n).nexts_mut()[skip_height].node;\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }\n\
      \                        \n\
      \                        // TODO: We could cache this each time the \
       height goes up?\n\
      \                        (*n).parent = cursor.entries[(*n).height as \
       usize + 1].node;\n\
      \                        skip_height = usize::max(skip_height, \
       (*n).height as usize - 1);\n\
      \                    }\n\
      \                }" );
    (32152, 16, "            ");
    (32130, 20, "                ");
    (32041, 24, "                    ");
    (31956, 24, "                    ");
    (31873, 24, "                    ");
    (31848, 24, "                    ");
    (31767, 24, "                    ");
    (31703, 24, "                    ");
    (31647, 24, "                    ");
    (31601, 24, "                    ");
    (31574, 20, "                ");
    (31528, 20, "                ");
    (31470, 20, "                ");
    (31390, 20, "                ");
    (31309, 20, "                ");
    (31231, 20, "                ");
    (31157, 20, "                ");
    (31122, 20, "                ");
    (31090, 16, "            ");
    (31089, 28, "\\");
    (32053, 13, "");
    (32052, 1, "");
    (32035, 16, "            ");
    (31950, 20, "                ");
    (31869, 20, "                ");
    (31790, 20, "                ");
    (31769, 20, "                ");
    (31692, 20, "                ");
    (31632, 20, "                ");
    (31580, 20, "                ");
    (31538, 20, "                ");
    (31515, 16, "            ");
    (31473, 16, "            ");
    (31419, 16, "            ");
    (31343, 16, "            ");
    (31266, 16, "            ");
    (31192, 16, "            ");
    (31122, 16, "            ");
    (31091, 16, "            ");
    (31983, 0, "// ");
    (31902, 0, "// ");
    (31825, 0, "// ");
    (31750, 0, "// ");
    (31660, 0, "// ");
    (31604, 0, "// ");
    (31556, 0, "// ");
    (31518, 0, "// ");
    (31499, 0, "// ");
    (31461, 0, "// ");
    (31411, 0, "// ");
    (31339, 0, "// ");
    (31266, 0, "// ");
    (31196, 0, "// ");
    (31130, 0, "// ");
    (31103, 0, "// ");
    (32028, 3, "");
    (31944, 3, "");
    (31864, 3, "");
    (31786, 3, "");
    (31693, 3, "");
    (31634, 3, "");
    (31583, 3, "");
    (31542, 3, "");
    (31520, 3, "");
    (31479, 3, "");
    (31426, 3, "");
    (31351, 3, "");
    (31275, 3, "");
    (31202, 3, "");
    (31133, 3, "");
    (31103, 3, "");
    (31115, 1, "");
    (31115, 0, "n");
    (31116, 0, "e");
    (31117, 0, "w");
    (31118, 0, "_");
    (31119, 0, "n");
    (31120, 0, "o");
    (31115, 6, "new_node");
    (31123, 0, "_");
    (31124, 0, "p");
    (31125, 0, "t");
    (31126, 0, "r");
    (32249, 0, "// ");
    (32205, 0, "// ");
    (32133, 0, "// ");
    (32068, 0, "// ");
    (32049, 0, "// ");
    (32011, 0, "// ");
    (31854, 46, "");
    (31854, 0, "n");
    (31855, 0, "e");
    (31856, 0, "w");
    (31857, 0, "_");
    (31858, 0, "n");
    (31859, 0, "o");
    (31854, 6, "new_node_ptr");
    (31749, 74, "");
    (31748, 1, "");
    (31791, 0, ";");
    (31128, 331, "");
    (31089, 1, "");
    (31376, 0, "n");
    (31377, 0, "e");
    (31378, 0, "w");
    (31379, 0, "_");
    (31391, 1, "");
    (31390, 1, "");
    (31389, 1, "");
    (31388, 1, "");
    (31387, 1, "");
    (31386, 1, "");
    (31555, 2, "");
    (42035, 0, "\n                        ");
    (42060, 0, "d");
    (42061, 0, "b");
    (42062, 0, "g");
    (42063, 0, "!");
    (42064, 0, "(");
    (42065, 0, "n");
    (42066, 0, ".");
    (42067, 0, "c");
    (42068, 0, "o");
    (42069, 0, "n");
    (42070, 0, "t");
    (42071, 0, "e");
    (42072, 0, "n");
    (42073, 0, "t");
    (42074, 0, "_");
    (42067, 8, "content_slice");
    (42080, 0, "(");
    (42081, 0, ")");
    (42082, 0, ")");
    (42083, 0, ";");
    (1939, 0, " ");
    (1940, 0, "+");
    (1941, 0, " ");
    (1942, 0, "D");
    (1943, 0, "e");
    (1944, 0, "b");
    (1945, 0, "u");
    (1946, 0, "g");
    (1942, 0, "f");
    (1943, 0, "m");
    (1944, 0, "t");
    (1945, 0, ":");
    (1946, 0, ":");
    (1942, 0, "s");
    (1943, 0, "t");
    (1944, 0, "d");
    (1945, 0, ":");
    (1946, 0, ":");
    (42083, 0, "(");
    (42084, 0, "*");
    (42086, 0, ")");
    (42054, 0, "                        dbg!((*n).content_slice());\n");
    (42140, 15, "");
    (42140, 0, "h");
    (42141, 0, "e");
    (42142, 0, "i");
    (42143, 0, "g");
    (42144, 0, "h");
    (42145, 0, "t");
    (42148, 0, "\n                        ");
    (42173, 0, "s");
    (42174, 0, "e");
    (42175, 0, "l");
    (42176, 0, "f");
    (42177, 0, ".");
    (42178, 0, "i");
    (42179, 0, "s");
    (42180, 0, "_");
    (42178, 3, "is_head(node: *const Node<C>)");
    (42186, 20, "n");
    (42187, 0, ".");
    (42188, 0, "p");
    (42189, 0, "a");
    (42190, 0, "r");
    (42191, 0, "e");
    (42192, 0, "n");
    (42193, 0, "t");
    (42195, 0, ";");
    (42173, 23, "");
    (42149, 24, "");
    (42148, 1, "");
    (42148, 0, "\n                        ");
    (42362, 0, "\n                        ");
    (42149, 24, "");
    (42363, 0, "a");
    (42364, 0, "s");
    (42365, 0, "s");
    (42363, 3, "assert_eq!");
    (42373, 0, "(");
    (42374, 0, "(");
    (42375, 0, "*");
    (42376, 0, "n");
    (42377, 0, ")");
    (42378, 0, ".");
    (42379, 0, "p");
    (42380, 0, "a");
    (42381, 0, "r");
    (42382, 0, "e");
    (42383, 0, "n");
    (42384, 0, "t");
    (42385, 0, ",");
    (42386, 0, " ");
    (42387, 0, "e");
    (42388, 0, ")");
    (42389, 0, ";");
    (42387, 1, "");
    (42387, 0, "n");
    (40967, 11, "g");
    (40968, 0, "h");
    (40968, 1, "");
    (40967, 1, "");
    (40967, 0, "e");
    (40967, 1, "");
    (40967, 0, "h");
    (40968, 0, "e");
    (40969, 0, "i");
    (40969, 1, "");
    (40967, 2, "height");
    (40973, 9, "");
    (38979, 0, "\n            ");
    (38992, 0, "s");
    (38993, 0, "e");
    (38994, 0, "l");
    (38995, 0, "f");
    (38996, 0, ".");
    (38997, 0, "c");
    (38998, 0, "h");
    (38999, 0, "e");
    (39000, 0, "c");
    (38997, 4, "check()");
    (39004, 0, ";");
    (38992, 0, " ");
    (38992, 0, "i");
    (38993, 0, "f");
    (38994, 0, " ");
    (38995, 0, "e");
    (38996, 0, "n");
    (38997, 0, "v");
    (38992, 6, "");
    (38992, 0, "if cfg!(debug_assertions) {");
    (39033, 0, " ");
    (39034, 0, "}");
    (42961, 0, "\n            ");
    (42974, 0, "\n            ");
    (42962, 12, "");
    (42975, 0, "if cfg!(debug_assertions) { self.check(); }");
    (1182, 2, "2");
    (38978, 0, "\n            ");
    (38991, 0, "s");
    (38992, 0, "e");
    (38993, 0, "l");
    (38994, 0, "f");
    (38995, 0, ".");
    (38996, 0, "p");
    (38997, 0, "r");
    (38998, 0, "i");
    (38996, 3, "print()");
    (39003, 0, ";");
    (50957, 0, "\n        ");
    (50966, 0, "l");
    (50967, 0, "e");
    (50968, 0, "t");
    (50969, 0, " ");
    (50970, 0, "p");
    (50971, 0, "t");
    (50972, 0, "r");
    (50973, 0, "T");
    (50973, 1, "");
    (50973, 0, "_");
    (50974, 0, "t");
    (50975, 0, "o");
    (50976, 0, "_");
    (50977, 0, "i");
    (50978, 0, "d");
    (50979, 0, " ");
    (50980, 0, "=");
    (50981, 0, " ");
    (50982, 0, "s");
    (50983, 0, "t");
    (50984, 0, "d");
    (50957, 0, "\n        ");
    (50966, 0, "u");
    (50967, 0, "s");
    (50968, 0, "e");
    (50969, 0, " ");
    (50970, 0, "s");
    (50971, 0, "t");
    (50972, 0, "d");
    (50973, 0, ":");
    (50974, 0, ":");
    (50975, 0, "c");
    (50976, 0, "o");
    (50977, 0, "l");
    (50978, 0, "l");
    (50975, 4, "collections");
    (50986, 0, ":");
    (50987, 0, ":");
    (50988, 0, "H");
    (50989, 0, "a");
    (50990, 0, "s");
    (50991, 0, "h");
    (50988, 4, "HashMap");
    (50995, 0, ";");
    (51021, 3, "H");
    (51022, 0, "a");
    (51023, 0, "s");
    (51024, 0, "h");
    (51025, 0, "M");
    (51026, 0, "a");
    (51027, 0, "p");
    (51021, 7, "HashMap");
    (51028, 0, ":");
    (51029, 0, ":");
    (51030, 0, "n");
    (51031, 0, "e");
    (51032, 0, "w");
    (51030, 3, "new()");
    (51035, 0, "(");
    (51036, 0, ")");
    (51036, 1, "");
    (51035, 1, "");
    (51035, 0, ";");
    (51117, 0, "\n            ");
    (51130, 0, "p");
    (51131, 0, "t");
    (51132, 0, "r");
    (51130, 3, "ptr_to_id");
    (51139, 0, ".");
    (51140, 0, "s");
    (51141, 0, "e");
    (51141, 1, "");
    (51140, 1, "");
    (51139, 1, "");
    (51139, 0, ".");
    (51140, 0, "i");
    (51141, 0, "n");
    (51142, 0, "s");
    (51143, 0, "e");
    (51144, 0, "r");
    (51140, 5, "insert(k: K, v: V)");
    (51147, 4, "n");
    (51148, 0, "o");
    (51149, 0, "d");
    (51150, 0, "e");
    (51151, 0, " ");
    (51152, 0, "a");
    (51153, 0, "s");
    (51154, 0, " ");
    (51155, 0, "*");
    (51156, 0, "c");
    (51157, 0, "o");
    (51158, 0, "n");
    (51159, 0, "s");
    (51160, 0, "t");
    (51161, 0, " ");
    (51162, 0, "_");
    (51165, 4, "i");
    (51167, 0, ";");
    (51008, 0, " ");
    (51009, 0, "m");
    (51010, 0, "i");
    (51011, 0, "u");
    (51011, 1, "");
    (51010, 1, "");
    (51010, 0, "u");
    (51011, 0, "t");
    (51272, 0, "\n            ");
    (51285, 0, "p");
    (51286, 0, "r");
    (51287, 0, "i");
    (51288, 0, "n");
    (51289, 0, "t");
    (51290, 0, " ");
    (51290, 1, "");
    (51290, 0, "!");
    (51291, 0, "(");
    (51292, 0, "\"");
    (51293, 0, "(");
    (51294, 0, "p");
    (51295, 0, "a");
    (51296, 0, "r");
    (51297, 0, "e");
    (51298, 0, "n");
    (51299, 0, "t");
    (51300, 0, ":");
    (51301, 0, " ");
    (51302, 0, "{");
    (51303, 0, "}");
    (51304, 0, "}");
    (51304, 1, "");
    (51304, 0, ")");
    (51305, 0, "\"");
    (51306, 0, ";");
    (51306, 1, "");
    (51306, 0, ",");
    (51307, 0, " ");
    (51272, 0, "\n            ");
    (51285, 0, "i");
    (51286, 0, "f");
    (51287, 0, " ");
    (51288, 0, "l");
    (51289, 0, "e");
    (51290, 0, "t");
    (51291, 0, " ");
    (51292, 0, "p");
    (51293, 0, "t");
    (51294, 0, "r");
    (51285, 0, "// ");
    (51040, 0, "\n        ");
    (51049, 0, "p");
    (51050, 0, "t");
    (51051, 0, "r");
    (51049, 3, "ptr");
    (51052, 0, ".");
    (51052, 1, "");
    (51052, 0, "_");
    (51053, 0, "t");
    (51054, 0, "o");
    (51049, 6, "ptr_to_id");
    (51058, 0, ".");
    (51059, 0, "i");
    (51060, 0, "n");
    (51061, 0, "s");
    (51062, 0, "e");
    (51063, 0, "r");
    (51064, 0, "t");
    (51065, 0, "(");
    (51066, 0, "p");
    (51067, 0, "t");
    (51068, 0, "r");
    (51069, 0, ":");
    (51069, 1, "");
    (51068, 1, "");
    (51066, 2, "s");
    (51067, 0, "t");
    (51068, 0, "d");
    (51069, 0, ":");
    (51070, 0, ":");
    (51071, 0, "p");
    (51072, 0, "t");
    (51073, 0, "r");
    (51074, 0, ":");
    (51075, 0, ":");
    (51076, 0, "n");
    (51077, 0, "u");
    (51078, 0, "l");
    (51079, 0, "l");
    (51076, 4, "null()");
    (51082, 0, ",");
    (51083, 0, " ");
    (51084, 0, "-");
    (51085, 0, "1");
    (51086, 0, ")");
    (51087, 0, ";");
    (51085, 1, "");
    (51084, 1, "");
    (51084, 0, "u");
    (51085, 0, "s");
    (51086, 0, "i");
    (51087, 0, "z");
    (51088, 0, "e");
    (51089, 0, ":");
    (51090, 0, ":");
    (51091, 0, "M");
    (51092, 0, "A");
    (51093, 0, "X");
    (51341, 13, "");
    (51341, 0, "p");
    (51342, 0, "t");
    (51343, 0, "r");
    (51341, 3, "ptr_to_id");
    (51350, 0, ".");
    (51351, 0, "g");
    (51352, 0, "e");
    (51351, 2, "get(k: &Q)");
    (51355, 5, "n");
    (51356, 0, "o");
    (51357, 0, "d");
    (51358, 0, "e");
    (51359, 0, ".");
    (51360, 0, "p");
    (51361, 0, "o");
    (51361, 1, "");
    (51361, 0, "a");
    (51362, 0, "r");
    (51363, 0, "e");
    (51364, 0, "n");
    (51365, 0, "t");
    (51367, 0, ";");
    (51366, 0, " ");
    (51367, 0, "a");
    (51368, 0, "s");
    (51369, 0, " ");
    (51370, 0, "*");
    (51371, 0, "c");
    (51372, 0, "o");
    (51373, 0, "n");
    (51374, 0, "s");
    (51375, 0, "t");
    (51376, 0, " ");
    (51377, 0, "_");
    (51366, 12, "");
    (51355, 0, "&");
    (51367, 0, " ");
    (51368, 0, "a");
    (51369, 0, "s");
    (51370, 0, " ");
    (51371, 0, "*");
    (51372, 0, "c");
    (51373, 0, "o");
    (51374, 0, "n");
    (51375, 0, "s");
    (51376, 0, "t");
    (51377, 0, " ");
    (51378, 0, "_");
    (51356, 0, "(");
    (51380, 0, ")");
    (51341, 0, "i");
    (51342, 0, "f");
    (51343, 0, " ");
    (51344, 0, "l");
    (51345, 0, "e");
    (51346, 0, "t");
    (51347, 0, " ");
    (51348, 0, "S");
    (51349, 0, "o");
    (51350, 0, "m");
    (51351, 0, "e");
    (51352, 0, "(");
    (51353, 0, "i");
    (51354, 0, "d");
    (51355, 0, ")");
    (51356, 0, " ");
    (51357, 0, "=");
    (51358, 0, " ");
    (51400, 1, "");
    (51400, 0, " ");
    (51401, 0, "{");
    (51415, 0, "    ");
    (51442, 0, "i");
    (51443, 0, "d");
    (51444, 0, ")");
    (51445, 0, ";");
    (51446, 0, "\n                ");
    (51447, 16, "            }");
    (51520, 0, "\n            }");
    (51461, 12, "                ");
    (51447, 14, "");
    (51510, 0, "\n                print!(\"(parent: {})\", id);");
    (51403, 44, "");
    ( 51466,
      0,
      "\n\
      \            if let Some(id) = ptr_to_id.get(&(node.parent as *const _)) \
       {" );
    (51403, 16, "            ");
    (51329, 74, "");
    (51347, 1, "");
    (51346, 1, "");
    (51518, 0, "\n            ");
    (51531, 0, "p");
    (51532, 0, "r");
    (51533, 0, "i");
    (51534, 0, "n");
    (51531, 4, "println!");
    (51539, 0, "(");
    (51540, 0, ")");
    (51541, 0, ";");
    (51518, 0, "\n            ");
    (51519, 12, "");
    (51485, 0, " ");
    (51460, 0, "\n                ");
    (51477, 0, "i");
    (51478, 0, "f");
    (51477, 2, "");
    (51477, 0, "i");
    (51478, 0, "f");
    (51479, 0, " ");
    (51480, 0, "i");
    (51481, 0, "d");
    (51482, 0, " ");
    (51483, 0, "=");
    (51484, 0, "=");
    (51485, 0, " ");
    (51486, 0, "u");
    (51487, 0, "s");
    (51488, 0, "i");
    (51489, 0, "z");
    (51490, 0, "e");
    (51491, 0, ":");
    (51492, 0, ":");
    (51493, 0, "M");
    (51494, 0, "A");
    (51495, 0, "X");
    (51496, 0, " ");
    (51497, 0, "{");
    (51498, 0, " ");
    (51461, 38, "");
    (51460, 1, "");
    (51049, 0, "// ");
    (51464, 0, "                print!(\" (parent: {})\", id);\n");
    (51553, 14, "");
    (51509, 16, "            ");
    (51509, 0, "            }\n");
    (51545, 6, "p");
    (51546, 0, "o");
    (51547, 0, "i");
    (51548, 0, "n");
    (51549, 0, "t");
    (51550, 0, "e");
    (51551, 0, "r");
    (51560, 2, "");
    (51555, 0, ":");
    (51556, 0, "?");
    (51562, 0, "n");
    (51563, 0, "o");
    (51564, 0, "d");
    (51565, 0, "e");
    (51566, 0, " ");
    (51567, 0, "a");
    (51568, 0, "s");
    (51569, 0, " ");
    (51570, 0, "*");
    (51571, 0, "c");
    (51572, 0, "o");
    (51573, 0, "n");
    (51574, 0, "s");
    (51575, 0, "t");
    (51576, 0, " ");
    (51577, 0, "_");
    (42454, 1, "");
    (42454, 0, "e");
    (42297, 0, "\n");
    (42216, 1, "");
    (42296, 0, "\n                        dbg!((*n).height);");
    (42173, 43, "");
    (42253, 0, "\n                        dbg!((*n).content_slice());");
    (42121, 52, "");
    ( 42201,
      0,
      "\n                        n = (*n).nexts_mut()[skip_height].node;" );
    (42057, 64, "");
    (42137, 0, "\n");
    (42056, 1, "");
    (42201, 0, "\n");
    (42137, 1, "");
    ( 42200,
      0,
      "\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }" );
    (42056, 81, "");
    (42055, 0, "\n                        ");
    (42321, 1, "");
    (42056, 24, "");
    (42279, 0, "// ");
    (42227, 0, "// ");
    (20314, 0, "// ");
    (20282, 0, "// ");
    (20230, 0, "// ");
    (20320, 3, "");
    (20285, 3, "");
    (20230, 3, "");
    (20314, 0, "// ");
    (20282, 0, "// ");
    (20230, 0, "// ");
    (20230, 3, "");
    (20214, 0, "                dbg!((n as *const _, (*n).height));\n");
    (20235, 1, "");
    (20248, 14, "");
    (20267, 0, "// ");
    (19391, 0, "(");
    (19392, 0, "i");
    (19393, 0, ",");
    (19394, 0, " ");
    (19396, 0, ")");
    (19412, 0, ".");
    (19413, 0, "e");
    (19414, 0, "n");
    (19415, 0, "u");
    (19416, 0, "m");
    (19413, 4, "enumerate()");
    (20247, 0, "// ");
    (20230, 0, "\n                ");
    (20247, 0, "p");
    (20248, 0, "r");
    (20249, 0, "i");
    (20250, 0, "n");
    (20247, 4, "println!");
    (20255, 0, "(");
    (20256, 0, "\"");
    (20257, 0, "v");
    (20258, 0, "i");
    (20259, 0, "s");
    (20260, 0, "i");
    (20261, 0, "t");
    (20262, 0, "i");
    (20263, 0, "n");
    (20264, 0, "g");
    (20265, 0, " ");
    (20266, 0, "{");
    (20267, 0, "}");
    (20268, 0, "\"");
    (20269, 0, ",");
    (20270, 0, " ");
    (20271, 0, "i");
    (20272, 0, ")");
    (20273, 0, ";");
    (20291, 3, "");
    (20291, 0, "// ");
    (20268, 0, " ");
    (20269, 0, "{");
    (20270, 0, ":");
    (20271, 0, "?");
    (20272, 0, "}");
    (20277, 0, ",");
    (20278, 0, " ");
    (20279, 0, "n as *const _");
    (18524, 0, "\n            ");
    (18537, 0, "s");
    (18538, 0, "e");
    (18539, 0, "l");
    (18540, 0, "f");
    (18541, 0, ".");
    (18542, 0, "p");
    (18543, 0, "r");
    (18544, 0, "i");
    (18542, 3, "print()");
    (18549, 0, ";");
    (41062, 0, "\n                ");
    (41079, 0, "\n                ");
    (41063, 16, "");
    (41080, 0, "p");
    (41081, 0, "r");
    (41082, 0, "i");
    (41083, 0, "n");
    (41080, 4, "println!");
    (41088, 0, "(");
    (41089, 0, "\"");
    (41090, 0, "r");
    (41091, 0, "e");
    (41092, 0, "m");
    (41093, 0, "o");
    (41094, 0, "v");
    (41095, 0, "i");
    (41096, 0, "n");
    (41097, 0, "g");
    (41098, 0, "\"");
    (41099, 0, ",");
    (41100, 0, " ");
    (41098, 0, " ");
    (41099, 0, "{");
    (41100, 0, "}");
    (41104, 0, "e");
    (41105, 0, ")");
    (41106, 0, ";");
    (41105, 0, ",");
    (41106, 0, " ");
    (41107, 0, "\"");
    (41108, 0, "c");
    (41109, 0, "o");
    (41110, 0, "n");
    (41111, 0, "t");
    (41112, 0, "e");
    (41113, 0, "n");
    (41114, 0, "t");
    (41115, 0, "s");
    (41116, 0, "\"");
    (41117, 0, " ");
    (41117, 1, "");
    (41101, 0, " ");
    (41102, 0, "c");
    (41103, 0, "o");
    (41104, 0, "n");
    (41105, 0, "t");
    (41106, 0, "e");
    (41107, 0, "n");
    (41108, 0, "t");
    (41109, 0, "s");
    (41110, 0, " ");
    (41111, 0, "{");
    (41112, 0, "}");
    (41113, 0, " ");
    (41114, 0, "e");
    (41115, 0, "h");
    (41115, 1, "");
    (41114, 1, "");
    (41114, 0, "h");
    (41115, 0, "e");
    (41116, 0, "i");
    (41117, 0, "g");
    (41118, 0, "h");
    (41119, 0, "t");
    (41120, 0, " ");
    (41121, 0, "{");
    (41122, 0, "}");
    (41129, 10, "");
    (41064, 68, "");
    (41063, 1, "");
    (41175, 0, "\n                ");
    (41176, 16, "");
    (41175, 0, "\n                ");
    ( 41192,
      0,
      "                println!(\"removing {} contents {} height {}\", e, );\n"
    );
    (41176, 32, "                ");
    (41243, 1, "");
    (41241, 0, "(");
    (41242, 0, "*");
    (41243, 0, "e");
    (41244, 0, ")");
    (41245, 0, ".");
    (41246, 0, "c");
    (41247, 0, "o");
    (41248, 0, "n");
    (41246, 3, "content_slice");
    (41259, 0, "(");
    (41260, 0, ")");
    (41261, 0, ",");
    (41262, 0, " ");
    (41263, 0, "h");
    (41264, 0, "e");
    (41265, 0, "i");
    (41266, 0, "g");
    (41267, 0, "h");
    (41268, 0, "t");
    (41212, 0, ":");
    (41213, 0, "?");
    (41226, 0, ":");
    (41227, 0, "?");
    ( 42720,
      0,
      "\n\
      \                        // TODO: We could cache this each time the \
       height goes up?" );
    (42586, 83, "");
    (42805, 0, "\n                        ");
    (42806, 24, "");
    (42671, 10, "C");
    (42710, 1, "");
    (42749, 0, "\n                        ");
    (42774, 0, "    ");
    (42824, 0, "\n                            ");
    (42825, 28, "                    }");
    (42825, 21, "");
    (42824, 1, "");
    (42749, 0, "i");
    (42750, 0, "f");
    (42751, 0, " ");
    (42183, 0, "\n                    ");
    (42204, 0, "l");
    (42205, 0, "e");
    (42206, 0, "t");
    (42207, 0, " ");
    (42208, 0, "c");
    (42209, 0, "u");
    (42210, 0, "r");
    (42211, 0, "s");
    (42212, 0, "o");
    (42213, 0, "r");
    (42214, 0, "_");
    (42215, 0, "n");
    (42216, 0, "o");
    (42217, 0, "d");
    (42218, 0, "e");
    (42219, 0, " ");
    (42220, 0, "=");
    (42221, 0, " ");
    (42222, 0, "c");
    (42223, 0, "u");
    (42224, 0, "r");
    (42225, 0, "s");
    (42226, 0, "o");
    (42227, 0, "r");
    (42228, 0, ".");
    (42229, 0, "h");
    (42230, 0, "e");
    (42231, 0, "r");
    (42232, 0, "e");
    (42229, 4, "here_ptr()");
    (42239, 0, ";");
    (42240, 0, "\n                    ");
    (42261, 0, "l");
    (42262, 0, "e");
    (42263, 0, "t");
    (42264, 0, " ");
    (42265, 0, "c");
    (42266, 0, "u");
    (42267, 0, "r");
    (42268, 0, "s");
    (42269, 0, "o");
    (42270, 0, "r");
    (42271, 0, "_");
    (42272, 0, "n");
    (42273, 0, "o");
    (42274, 0, "d");
    (42275, 0, "e");
    (42276, 0, "_");
    (42277, 0, "h");
    (42278, 0, "e");
    (42279, 0, "i");
    (42280, 0, "g");
    (42281, 0, "h");
    (42282, 0, "t");
    (42283, 0, " ");
    (42284, 0, "=");
    (42285, 0, " ");
    (42286, 0, "*");
    (42286, 1, "");
    (42286, 0, "(");
    (42287, 0, "*");
    (42288, 0, "c");
    (42289, 0, "u");
    (42290, 0, "r");
    (42291, 0, "s");
    (42292, 0, "o");
    (42288, 5, "cursor_node");
    (42299, 0, ")");
    (42300, 0, ".");
    (42301, 0, "h");
    (42302, 0, "e");
    (42303, 0, "i");
    (42301, 3, "height");
    (42307, 0, " ");
    (42308, 0, "a");
    (42309, 0, "s");
    (42310, 0, " ");
    (42311, 0, "u");
    (42312, 0, "s");
    (42313, 0, "i");
    (42314, 0, "z");
    (42315, 0, "e");
    (42316, 0, ";");
    (42886, 0, "c");
    (42887, 0, "u");
    (42888, 0, "r");
    (42889, 0, "o");
    (42890, 0, "s");
    (42891, 0, "r");
    (42886, 6, "cursor_node_height");
    (42904, 0, " ");
    (42905, 0, ">");
    (42906, 0, "=");
    (42907, 0, " ");
    (42908, 0, "(");
    (42909, 0, "*");
    (42910, 0, "n");
    (42911, 0, ")");
    (42912, 0, ".");
    (42913, 0, "h");
    (42914, 0, "e");
    (42915, 0, "i");
    (42916, 0, "g");
    (42917, 0, "h");
    (42918, 0, "t");
    (42919, 0, " ");
    (42920, 0, "{");
    (42921, 0, "\n                            ");
    (42922, 28, "                        }");
    (42947, 0, " ");
    (42948, 0, "e");
    (42949, 0, "l");
    (42950, 0, "s");
    (42951, 0, "e");
    (42952, 0, " ");
    (42953, 0, "{");
    (43028, 1, "");
    (43028, 0, "\n                            ");
    (43029, 28, "                        }");
    (42921, 0, "\n                            ");
    (42950, 0, "c");
    (42951, 0, "u");
    (42952, 0, "r");
    (42953, 0, "s");
    (42954, 0, "o");
    (42955, 0, "r");
    (42950, 6, "cursor_node");
    (43094, 0, ";");
    (42307, 9, "");
    (42897, 1, "");
    ( 43058,
      0,
      "\n\
      \                            cursor.entries[(*n).height as usize + \
       1].node" );
    (43058, 0, "\n                        } else {");
    (42952, 33, "");
    (42940, 0, "// ");
    (42940, 3, "");
    (43025, 33, "");
    (42952, 0, "                        } else {\n");
    (43058, 74, "");
    (43051, 1, "");
    (43050, 1, "");
    (43049, 1, "");
    (43048, 1, "");
    (43047, 1, "");
    (43047, 0, "e");
    (43540, 0, "// ");
    (41192, 0, "// ");
    (39147, 0, "// ");
    (39176, 0, "// ");
    (20273, 0, "// ");
    (18537, 0, "// ");
    (19421, 0, "_");
    (52080, 0, "// ");
    (52035, 0, "// ");
    (51961, 0, "// ");
    (51564, 0, "// ");
    (51755, 0, "// ");
    (51525, 0, "// ");
    (51525, 3, "");
    (51755, 3, "");
    (51564, 3, "");
    (52086, 3, "");
    (52038, 3, "");
    (51961, 3, "");
    (1572, 2, "5");
    (1182, 1, "");
    (1182, 0, "1");
    (1183, 0, "0");
    (42851, 76, "");
    (42779, 24, "                            ");
    ( 42779,
      0,
      "                        (*n).parent = if cursor_node_height > \
       (*n).height {\n" );
    (42931, 40, "");
    (42855, 0, "                            cursor_node\n");
    (42971, 33, "");
    (42895, 0, "                        } else {\n");
    (42965, 0, "W");
    (42966, 0, "e");
    (42967, 0, " ");
    (42968, 0, "s");
    (42969, 0, "h");
    (42970, 0, "o");
    (42971, 0, "u");
    (42972, 0, "l");
    (42973, 0, "d");
    (42974, 0, " ");
    (42975, 0, "b");
    (42976, 0, "e");
    (42977, 0, " ");
    (42978, 0, "a");
    (42979, 0, "b");
    (42980, 0, "l");
    (42981, 0, "e");
    (42982, 0, " ");
    (42983, 0, "t");
    (42984, 0, "o");
    (42985, 0, " ");
    (42986, 1, "");
    (42986, 0, "c");
    ( 42928,
      97,
      "                            // TODO: We should be able to cache this \
       each time\n\
      \                            // the height goes up" );
    (43056, 0, ".");
    (42518, 0, "\n                        ");
    (42543, 0, "l");
    (42544, 0, "e");
    (42545, 0, "t");
    (42546, 0, " ");
    (42547, 0, "n");
    (42548, 0, "-");
    (42548, 1, "");
    (42548, 0, "_");
    (42549, 0, "h");
    (42550, 0, "e");
    (42551, 0, "i");
    (42552, 0, "g");
    (42553, 0, "h");
    (42554, 0, "t");
    (42555, 0, " ");
    (42556, 0, "=");
    (42557, 0, " ");
    (42558, 0, "(");
    (42559, 0, "*");
    (42560, 0, "n");
    (42561, 0, ")");
    (42562, 0, ".");
    (42563, 0, "h");
    (42564, 0, "e");
    (42565, 0, "i");
    (42566, 0, "g");
    (42567, 0, "h");
    (42568, 0, "t");
    (42569, 0, ";");
    (42519, 51, "");
    (42518, 1, "");
    (42599, 0, "\n                        ");
    (42624, 0, "                        let n_height = (*n).height;");
    (42600, 48, "                        ");
    (43270, 11, "n");
    (43153, 11, "n");
    (42893, 11, "n");
    (43251, 0, "_");
    (43144, 0, "_");
    (42894, 0, "_");
    (43254, 0, "h");
    (43146, 0, "h");
    (42895, 0, "h");
    (43257, 0, "e");
    (43148, 0, "e");
    (42896, 0, "e");
    (43260, 0, "i");
    (43150, 0, "i");
    (42897, 0, "i");
    (43263, 0, "g");
    (43152, 0, "g");
    (42898, 0, "g");
    (43266, 0, "h");
    (43154, 0, "h");
    (42899, 0, "h");
    (43269, 0, "t");
    (43156, 0, "t");
    (42900, 0, "t");
    ( 43287,
      0,
      "\n\
      \                        \n\
      \                        assert_eq!((*n).parent, e);\n\
      \                        (*n).parent = if cursor_node_height > n_height {\n\
      \                            cursor_node\n\
      \                        } else {\n\
      \                            // TODO: We should be able to cache this \
       each time\n\
      \                            // the height goes up.\n\
      \                            cursor.entries[n_height as usize].node\n\
      \                        };\n\n\
      \                        skip_height = usize::max(skip_height, n_height \
       as usize - 1);" );
    (43226, 0, "// ");
    (43198, 0, "// ");
    (43131, 0, "// ");
    (43080, 0, "// ");
    (43001, 0, "// ");
    (42968, 0, "// ");
    (42928, 0, "// ");
    (42855, 0, "// ");
    (42803, 0, "// ");
    (43391, 0, "\n                        ");
    (43416, 0, "\n                        ");
    (43392, 24, "");
    (43364, 53, "");
    (42803, 3, "");
    (42830, 0, "\n                        ");
    (43361, 0, "\n                        ");
    (42831, 24, "");
    (43362, 0, "i");
    (43363, 0, "f");
    (43364, 0, " ");
    (43365, 0, "n");
    (43366, 0, "_");
    (43367, 0, "h");
    (43368, 0, "e");
    (43369, 0, "i");
    (43370, 0, "g");
    (43371, 0, "h");
    (43372, 0, "t");
    (43373, 0, " ");
    (43374, 0, ">");
    (43375, 0, " ");
    (43376, 0, "s");
    (43377, 0, "k");
    (43378, 0, "i");
    (43379, 0, "p");
    (43380, 0, "_");
    (43381, 0, "h");
    (43382, 0, "e");
    (43383, 0, "i");
    (43376, 8, "skip_height");
    (43373, 0, " ");
    (43374, 0, "a");
    (43375, 0, "s");
    (43376, 0, " ");
    (43377, 0, "u");
    (43378, 0, "s");
    (43379, 0, "i");
    (43380, 0, "z");
    (43381, 0, "e");
    (43396, 0, " ");
    (43397, 0, "{");
    (43398, 0, "\n                            ");
    (43427, 0, "\n                            ");
    (43399, 28, "");
    (43400, 28, "                        }");
    (43399, 0, "                            ");
    (43427, 0, "s");
    (43428, 0, "k");
    (43429, 0, "i");
    (43430, 0, "p");
    (43431, 0, "_");
    (43427, 5, "skip_height");
    (43438, 0, " ");
    (43439, 0, "=");
    (43440, 0, " ");
    (43441, 0, "n");
    (43442, 0, "_");
    (43443, 0, "e");
    (43444, 0, "i");
    (43444, 1, "");
    (43443, 1, "");
    (43443, 0, "h");
    (43444, 0, "e");
    (43445, 0, "i");
    (43446, 0, "g");
    (43447, 0, "h");
    (43448, 0, "t");
    (43449, 0, " ");
    (43450, 0, "=");
    (43450, 1, "");
    (43450, 0, "a");
    (43451, 0, "s");
    (43452, 0, " ");
    (43453, 0, "u");
    (43454, 0, "s");
    (43455, 0, "i");
    (43456, 0, "z");
    (43457, 0, "e");
    (43458, 0, ";");
    (43459, 0, "\n                            ");
    (43935, 0, "// ");
    (43460, 28, "");
    (42324, 0, "\n                    ");
    (42345, 0, "l");
    (42346, 0, "e");
    (42347, 0, "t");
    (42348, 0, " ");
    (42349, 0, "m");
    (42350, 0, "u");
    (42351, 0, "t");
    (42352, 0, " ");
    (42353, 0, "n");
    (42354, 0, "e");
    (42355, 0, "w");
    (42356, 0, "_");
    (42357, 0, "p");
    (42358, 0, "a");
    (42359, 0, "r");
    (42360, 0, "e");
    (42361, 0, "n");
    (42362, 0, "t");
    (42363, 0, " ");
    (42364, 0, "=");
    (42365, 0, " ");
    (42366, 0, "c");
    (42367, 0, "u");
    (42368, 0, "r");
    (42369, 0, "s");
    (42370, 0, "o");
    (42371, 0, "r");
    (42372, 0, "_");
    (42373, 0, "n");
    (42374, 0, "o");
    (42375, 0, "d");
    (42376, 0, "e");
    (42377, 0, ";");
    (43514, 0, "                            ");
    (43542, 0, "if cursor_node_height > n_height");
    (43564, 1, "");
    (43564, 0, "<");
    (43565, 0, "=");
    (43575, 0, " ");
    (43576, 0, "{");
    (43577, 0, "\n                                ");
    (43610, 0, "\n                                ");
    (43578, 32, "");
    (43579, 32, "                            }");
    (43567, 8, "");
    (43566, 1, "");
    (43565, 1, "");
    (43564, 1, "");
    (43563, 1, "");
    (43545, 0, ">");
    (43546, 0, "=");
    (43547, 0, " ");
    (43545, 0, "n_height");
    (43553, 0, " ");
    (43578, 0, "                                ");
    (43610, 0, "n");
    (43611, 0, "e");
    (43612, 0, "w");
    (43613, 0, "_");
    (43614, 0, "p");
    (43615, 0, "a");
    (43616, 0, "r");
    (43617, 0, "e");
    (43618, 0, "n");
    (43619, 0, "t");
    (43620, 0, " ");
    (43621, 0, "=");
    (43622, 0, " ");
    (43623, 0, "cursor.entries[n_height as usize].node");
    (43638, 17, "s");
    (43639, 0, "k");
    (43640, 0, "i");
    (43641, 0, "p");
    (43642, 0, "_");
    (43643, 0, "h");
    (43638, 6, "skip_height");
    (43775, 331, "");
    (43775, 0, "n");
    (43776, 0, "e");
    (43777, 0, "w");
    (43778, 0, "_");
    (43779, 0, "p");
    (43780, 0, "a");
    (43775, 6, "new_parent");
    (43785, 0, ";");
    (43787, 90, "");
    (43761, 0, "// ");
    (43710, 0, "// ");
    (43680, 0, "// ");
    (43602, 0, "// ");
    (43538, 0, "// ");
    (43477, 0, "// ");
    (43416, 0, "// ");
    (43302, 3, "");
    (43271, 3, "");
    (43201, 3, "");
    (43147, 3, "");
    (43065, 3, "");
    (43029, 3, "");
    (42986, 3, "");
    (42910, 3, "");
    (42884, 0, "\n                        ");
    (42909, 0, "a");
    (42910, 0, "s");
    (42911, 0, "s");
    (42912, 0, "e");
    (42913, 0, "r");
    (42914, 0, "t");
    (42915, 0, "!");
    (42916, 0, "(");
    (42917, 0, "s");
    (42918, 0, "k");
    (42919, 0, "i");
    (42920, 0, "p");
    (42917, 4, "skip_height");
    (42917, 0, "n");
    (42918, 0, "_");
    (42919, 0, "h");
    (42920, 0, "e");
    (42921, 0, "i");
    (42922, 0, "g");
    (42923, 0, "h");
    (42924, 0, "t");
    (42925, 0, " ");
    (42926, 0, ">");
    (42927, 0, "=");
    (42928, 0, " ");
    (42940, 0, ")");
    (42941, 0, ";");
    (42925, 0, " ");
    (42926, 0, "a");
    (42927, 0, "s");
    (42928, 0, " ");
    (42929, 0, "u");
    (42930, 0, "s");
    (42931, 0, "i");
    (42932, 0, "z");
    (42933, 0, "e");
    (42704, 0, " ");
    (42705, 0, "a");
    (42706, 0, "s");
    (42707, 0, " ");
    (42708, 0, "u");
    (42709, 0, "s");
    (42710, 0, "i");
    (42711, 0, "z");
    (42712, 0, "e");
    (42935, 8, "");
    (42934, 1, "");
    (42323, 0, " ");
    (42324, 0, "a");
    (42325, 0, "s");
    (42326, 0, " ");
    (42327, 0, "u");
    (42328, 0, "s");
    (42329, 0, "i");
    (42330, 0, "z");
    (42331, 0, "e");
    (43357, 0, "// ");
    (43471, 3, "");
    (43532, 3, "");
    (43774, 3, "");
    (43482, 9, "");
    (43549, 9, "");
    (43482, 0, " ");
    (43483, 0, "-");
    (43484, 0, " ");
    (43485, 0, "1");
    (43357, 3, "");
    (43524, 0, "// ");
    (43468, 0, "// ");
    (43763, 0, "// ");
    (43468, 3, "");
    (43524, 3, "");
    (43757, 3, "");
    (43550, 0, " ");
    (43551, 0, "-");
    (43552, 0, " ");
    (43553, 0, "1");
    (43357, 0, "// ");
    (43329, 0, "// ");
    (43262, 0, "// ");
    (43211, 0, "// ");
    (43132, 0, "// ");
    (43099, 0, "// ");
    (43059, 0, "// ");
    (42986, 0, "// ");
    (43752, 3, "");
    (43671, 3, "");
    (43604, 3, "");
    (43715, 0, " ");
    (43716, 0, "-");
    (43717, 0, " ");
    (43717, 1, "");
    (43716, 1, "");
    (43716, 0, "+");
    (43717, 0, " ");
    (43718, 0, "1");
    (43831, 3, "");
    (43621, 1, "");
    (43621, 0, "=");
    (42197, 1, "");
    (42197, 0, "1");
    (42574, 0, " ");
    (42575, 0, "-");
    (42576, 0, " ");
    (42577, 0, "1");
    (42962, 0, " ");
    (42963, 0, "-");
    (42964, 0, " ");
    (42965, 0, "1");
    (43514, 1, "");
    (43513, 1, "");
    (43512, 1, "");
    (43511, 1, "");
    (43581, 1, "");
    (43580, 1, "");
    (43579, 1, "");
    (43578, 1, "");
    (43718, 1, "");
    (43717, 1, "");
    (43716, 1, "");
    (43715, 1, "");
    (43715, 0, " + 1");
    (43578, 0, " - 1");
    (43511, 0, " - 1");
    (42964, 2, "");
    (42962, 2, "");
    (42576, 2, "");
    (42574, 2, "");
    (42197, 1, "");
    (42197, 0, "0");
    (43755, 26, "");
    (43726, 28, "                                ");
    (43644, 32, "                                    ");
    (43580, 28, "                                ");
    (43580, 0, "                        }\n");
    (43760, 32, "                            ");
    (43674, 36, "                                ");
    (43606, 32, "                            ");
    (43752, 28, "                        ");
    (43670, 32, "                            ");
    (43606, 28, "                        ");
    (43769, 0, "\n                            skip_height = n_height - 1;");
    (43524, 56, "");
    (43713, 56, "");
    (43524, 0, "                            skip_height = n_height - 1;\n");
    (43744, 24, "                            ");
    (43666, 28, "                                ");
    (43606, 24, "                            ");
    (43752, 28, "                                ");
    (43670, 32, "                                    ");
    (43606, 28, "                                ");
    (43793, 0, "\n                        }");
    (43760, 32, "                            ");
    (43674, 36, "                                ");
    (43606, 32, "                            ");
    (43580, 26, "");
    ( 42388,
      0,
      "                            if n_height >= cursor_node_height {\n\
      \                                new_parent = cursor.entries[skip_height \
       + 1].node\n\
      \                            }" );
    (42534, 28, "                    ");
    (42452, 32, "                        ");
    (42388, 28, "                    ");
    (42411, 8, "(*n).height as usize");
    (42411, 20, "g");
    (42412, 0, "e");
    (42413, 0, "u");
    (42414, 0, "g");
    (42414, 1, "");
    (42413, 1, "");
    (42412, 1, "");
    (42411, 1, "");
    (42411, 0, "h");
    (42412, 0, "e");
    (42413, 0, "i");
    (42414, 0, "g");
    (42415, 0, "h");
    (42416, 0, "t");
    (42408, 33, "");
    (42375, 0, "if height >= cursor_node_height {");
    (42408, 0, "\n                        ");
    (42444, 1, "");
    (42445, 20, "                    }");
    (42466, 0, " ");
    (42467, 0, "e");
    (42468, 0, "l");
    (42469, 0, "s");
    (42470, 0, "e");
    (42471, 0, " ");
    (42472, 0, "{");
    (42498, 13, "");
    (42556, 0, "\n                    ");
    (42557, 20, "");
    (42556, 0, ";");
    (42558, 0, "                    ");
    (42556, 1, "");
    (42556, 21, "");
    (42498, 0, "new_parent = ");
    (42471, 2, "");
    (42466, 5, "");
    (42445, 21, "                    ");
    (42444, 0, ";");
    (42408, 25, "");
    (42375, 33, "");
    (42408, 0, "if height >= cursor_node_height {");
    (42411, 6, "");
    (42411, 0, "geug");
    (42411, 4, "(*n).height as usize");
    (42411, 20, "geug");
    (42411, 4, "");
    (42411, 0, "height");
    (42408, 33, "");
    (42375, 0, "if height >= cursor_node_height {");
    (42408, 0, "\n                        ");
    (42444, 1, "");
    (42445, 20, "                    }");
    (42466, 0, " else");
    (42471, 0, " {");
    (42498, 13, "");
    (42556, 0, "\n                    ");
    (42557, 20, "");
    (42556, 0, ";");
    (42534, 0, "\n                    } else {");
    (42445, 29, "");
    (42505, 0, "\n                        cursor_node");
    (42409, 36, "");
    (42505, 29, "");
    (42470, 0, "                    } else {\n");
    (43131, 506, "");
    (43372, 0, "arent");
    (43368, 3, "");
    (43220, 0, "arent");
    (43216, 3, "");
    (43178, 0, "arent");
    (43174, 3, "");
    (43121, 0, "arent");
    (43117, 3, "");
    (42737, 0, "arent");
    (42733, 3, "");
    (42452, 0, "arent");
    (42448, 3, "");
    (42187, 0, "arent");
    (42183, 3, "");
    (42199, 1, "");
    (42199, 0, "1");
    (42466, 1, "");
    (42465, 1, "");
    (42464, 1, "");
    (42463, 1, "");
    (42746, 0, " ");
    (42747, 0, "-");
    (42748, 0, " ");
    (42749, 0, "1");
    (43136, 0, " ");
    (43137, 0, "-");
    (43138, 0, " ");
    (43139, 0, "1");
    (43199, 0, " ");
    (43200, 0, "-");
    (43201, 0, " ");
    (43202, 0, "1");
    (43182, 1, "");
    (43181, 1, "");
    (43180, 1, "");
    (43179, 1, "");
    (43198, 1, "");
    (43197, 1, "");
    (43196, 1, "");
    (43195, 1, "");
    (43253, 1, "");
    (43252, 1, "");
    (43251, 1, "");
    (43250, 1, "");
    (43392, 1, "");
    (43391, 1, "");
    (43390, 1, "");
    (43389, 1, "");
    (1939, 0, "/");
    (1940, 0, "/");
    (1938, 0, ";");
    (31737, 271, "");
    (31368, 86, "");
    (1934, 4, "C");
    (1935, 0, "l");
    (1936, 0, "o");
    (1937, 0, "n");
    (1938, 0, "e");
    (29029, 0, ".");
    (29030, 0, "c");
    (29031, 0, "l");
    (29032, 0, "o");
    (29033, 0, "n");
    (29034, 0, "e");
    (29035, 0, "(");
    (29036, 0, ")");
    (29029, 8, "");
    (29008, 1, "");
    (29007, 1, "");
    (29006, 1, "");
    (29005, 1, "");
    (29005, 0, "c");
    (29006, 0, "l");
    (29007, 0, "o");
    (29008, 0, "n");
    (29009, 0, "e");
    (29005, 5, "");
    (29005, 0, "copy");
    (29029, 0, ".clone()");
    (29029, 8, "");
    (1934, 5, "Copy");
    (1934, 4, "Clone");
    (1934, 5, "Copy");
    (1934, 4, "U");
    (1935, 0, "n");
    (1936, 0, "p");
    (1937, 0, "i");
    (1938, 0, "n");
    (1933, 0, " ");
    (1934, 0, "s");
    (1935, 0, "t");
    (1936, 0, "d");
    (1937, 0, ":");
    (1938, 0, ":");
    (1939, 0, "p");
    (1940, 0, "i");
    (1939, 2, "pin");
    (1942, 0, ":");
    (1943, 0, ":");
    (1944, 1, "");
    (1944, 5, "");
    (1944, 0, "I");
    (1944, 1, "");
    (1944, 0, "U");
    (1945, 0, "n");
    (1946, 0, "p");
    (1947, 0, "i");
    (1931, 17, "");
    (28422, 0, ",");
    (28423, 0, " ");
    (28424, 0, "I");
    (28602, 0, ",");
    (28603, 0, "\n            ");
    (28603, 13, "");
    (28603, 0, " ");
    (28604, 0, "I");
    (28605, 0, ":");
    (28606, 0, " ");
    (28607, 0, "E");
    (28608, 0, "x");
    (28609, 0, "a");
    (28607, 3, "ExactSizeIterator");
    (28624, 0, "<");
    (28625, 0, "I");
    (28626, 0, "t");
    (28627, 0, "e");
    (28628, 0, "m");
    (28629, 0, "=");
    (28630, 0, "C");
    (28631, 0, ":");
    (28632, 0, ":");
    (28633, 0, "I");
    (28634, 0, "t");
    (28635, 0, "e");
    (28636, 0, "m");
    (28637, 0, ">");
    (28472, 10, "");
    (28472, 0, "I");
    (28964, 0, "/");
    (28965, 0, "/");
    (28963, 0, " ");
    (28964, 0, "i");
    (28965, 0, "t");
    (28965, 1, "");
    (28964, 1, "");
    (28964, 0, "c");
    (28965, 0, "o");
    (28966, 0, "n");
    (28967, 0, "t");
    (28968, 0, "e");
    (28969, 0, "n");
    (28970, 0, "t");
    (28971, 0, "s");
    (28972, 0, ".");
    (28973, 0, "s");
    (28974, 0, "i");
    (28975, 0, "z");
    (28973, 3, "size_hint()");
    (28984, 0, ";");
    (28984, 19, "");
    (28984, 0, " ");
    (28973, 9, "l");
    (28974, 0, "e");
    (28975, 0, "n");
    (28973, 3, "size_hint");
    (28984, 1, "");
    (28984, 0, "; //contents.len() ");
    (28984, 1, "");
    (28973, 11, "siz");
    (28964, 12, "");
    (28964, 0, "it");
    (28963, 3, "");
    (28964, 2, "");
    (28994, 0, "// ");
    (28985, 0, "\n        ");
    (28994, 0, "\n        ");
    (28986, 8, "");
    (28987, 8, "");
    (28986, 0, "\n        ");
    (28995, 0, "f");
    (28996, 0, "o");
    (28997, 0, "r");
    (28995, 3, "");
    (28995, 0, "f");
    (28996, 0, "o");
    (28997, 0, "r");
    (28998, 0, " ");
    (28999, 0, "i");
    (29000, 0, "t");
    (29001, 0, "e");
    (29002, 0, "m");
    (29003, 0, " ");
    (29004, 0, "i");
    (29005, 0, "n");
    (29006, 0, " ");
    (29007, 0, "c");
    (29008, 0, "o");
    (29009, 0, "n");
    (29010, 0, "t");
    (29011, 0, "e");
    (29012, 0, "n");
    (29013, 0, "t");
    (29014, 0, "s");
    (29015, 0, " ");
    (29016, 0, "{");
    (29017, 0, "\n            ");
    (29030, 0, "\n            ");
    (29018, 12, "");
    (29019, 12, "        }");
    (29018, 0, "            ");
    (29030, 0, "new_node.items[..contents.len()]");
    (29045, 16, "");
    (29045, 0, "0");
    (29047, 0, " ");
    (29048, 0, "=");
    (29049, 0, " ");
    (29050, 0, "i");
    (29051, 0, "t");
    (29052, 0, "e");
    (29053, 0, "m");
    (29054, 0, ";");
    (28934, 0, "\n        ");
    (28943, 0, "l");
    (28944, 0, "e");
    (28945, 0, "t");
    (28946, 0, " ");
    (28947, 0, "l");
    (28948, 0, "e");
    (28949, 0, "n");
    (28950, 0, " ");
    (28951, 0, "=");
    (28952, 0, " ");
    (28983, 14, "");
    (28953, 0, "contents.len()");
    (28967, 0, ";");
    (28998, 0, "l");
    (28999, 0, "e");
    (29000, 0, "n");
    (29000, 1, "ms");
    (28998, 1, "num_it");
    (28949, 1, "ms");
    (28947, 1, "num_it");
    (29034, 16, "");
    (29034, 0, "i");
    (29035, 0, " ");
    (29036, 0, "i");
    (29037, 0, "n");
    (29038, 0, " ");
    (29039, 0, "0");
    (29040, 0, ".");
    (29041, 0, ".");
    (29042, 0, "n");
    (29043, 0, "u");
    (29044, 0, "m");
    (29045, 0, "_");
    (29046, 0, "i");
    (29042, 5, "num_items");
    (29081, 1, "");
    (29081, 0, "i");
    (29086, 4, "c");
    (29087, 0, "o");
    (29088, 0, "n");
    (29089, 0, "t");
    (29090, 0, "e");
    (29091, 0, "n");
    (29092, 0, "t");
    (29093, 0, "s");
    (29094, 0, ".");
    (29095, 0, "n");
    (29096, 0, "e");
    (29095, 2, "next()");
    (29101, 0, ".");
    (29102, 0, "u");
    (29103, 0, "n");
    (29104, 0, "w");
    (29105, 0, "r");
    (29102, 4, "unwrap");
    (29108, 0, "(");
    (29109, 0, ")");
    (28472, 0, "7");
    (28472, 1, "");
    (28472, 0, "&");
    (28473, 0, "m");
    (28474, 0, "i");
    (28475, 0, "u");
    (28476, 0, "t");
    (28477, 0, " ");
    (28477, 1, "");
    (28476, 1, "");
    (28475, 1, "");
    (28474, 1, "");
    (28474, 0, "u");
    (28475, 0, "t");
    (28476, 0, " ");
    (28603, 17, "I");
    (28604, 0, "t");
    (28605, 0, "e");
    (28606, 0, "r");
    (28607, 0, "a");
    (28608, 0, "t");
    (28609, 0, "o");
    (28610, 0, "r");
    (28479, 0, " ");
    (28480, 0, "n");
    (28481, 0, "u");
    (28482, 0, "m");
    (28483, 0, "_");
    (28484, 0, "i");
    (28485, 0, "t");
    (28486, 0, "e");
    (28487, 0, "m");
    (28488, 0, "s");
    (28489, 0, ":");
    (28490, 0, " ");
    (28491, 0, "u");
    (28492, 0, "s");
    (28493, 0, "i");
    (28494, 0, "z");
    (28495, 0, "e");
    (28496, 0, ",");
    (28736, 0, "// ");
    (28809, 0, "// ");
    (28809, 3, "");
    (28817, 14, "n");
    (28818, 0, "u");
    (28819, 0, "m");
    (28820, 0, "_");
    (28821, 0, "i");
    (28822, 0, "t");
    (28823, 0, "e");
    (28824, 0, "m");
    (28825, 0, "s");
    (28955, 0, "// ");
    (29049, 17, "");
    (29049, 0, "(");
    (29050, 0, "s");
    (29051, 0, "l");
    (29052, 0, "o");
    (29053, 0, "t");
    (29054, 0, ",");
    (29055, 0, " ");
    (29056, 0, "i");
    (29057, 0, "t");
    (29058, 0, "e");
    (29059, 0, "m");
    (29060, 0, ")");
    (29061, 0, " ");
    (29062, 0, "i");
    (29063, 0, "n");
    (29064, 0, " ");
    (29064, 1, "");
    (29061, 3, "");
    (29055, 6, "");
    (29055, 0, " item)");
    (29061, 0, " in");
    (29064, 0, " ");
    (29065, 0, "n");
    (29066, 0, "e");
    (29067, 0, "w");
    (29068, 0, "_");
    (29065, 4, "new_node");
    (29073, 0, ".");
    (29074, 0, "i");
    (29075, 0, "t");
    (29076, 0, "e");
    (29077, 0, "m");
    (29078, 0, "s");
    (29079, 0, "[");
    (29080, 0, ".");
    (29081, 0, ".");
    (29082, 0, "n");
    (29083, 0, "u");
    (29084, 0, "m");
    (29085, 0, "_");
    (29086, 0, "i");
    (29087, 0, "t");
    (29088, 0, "e");
    (29089, 0, "m");
    (29090, 0, "s");
    (29091, 0, "]");
    (29092, 0, ".");
    (29093, 0, "z");
    (29094, 0, "i");
    (29095, 0, "p");
    (29096, 0, "(");
    (29097, 0, "c");
    (29098, 0, "u");
    (29099, 0, "r");
    (29097, 3, "");
    (29097, 0, "c");
    (29098, 0, "o");
    (29099, 0, "n");
    (29100, 0, "t");
    (29101, 0, "e");
    (29102, 0, "n");
    (29103, 0, "t");
    (29104, 0, "s");
    (29105, 0, ")");
    (29121, 0, "// ");
    (29169, 0, "\n            ");
    (29182, 0, "(");
    (29182, 1, "");
    (29182, 0, "*");
    (29183, 0, "s");
    (29184, 0, "l");
    (29185, 0, "o");
    (29186, 0, "t");
    (29187, 0, " ");
    (29188, 0, "=");
    (29189, 0, " ");
    (29190, 0, "i");
    (29191, 0, "t");
    (29192, 0, "e");
    (29193, 0, "m");
    (29194, 0, ";");
    (29092, 0, ".");
    (29093, 0, "i");
    (29094, 0, "t");
    (29095, 0, "e");
    (29096, 0, "r");
    (29097, 0, "(");
    (29098, 0, ")");
    (29097, 0, "_");
    (29098, 0, "m");
    (29099, 0, "u");
    (29100, 0, "t");
    (29216, 0, "\n        ");
    (29225, 0, "\n        ");
    (29217, 8, "");
    (29226, 0, "/");
    (29227, 0, "/");
    (29228, 0, " ");
    (29229, 0, "D");
    (29229, 1, "");
    (29229, 0, "T");
    (29230, 0, "O");
    (29231, 0, "D");
    (29232, 0, "O");
    (29233, 0, "O");
    (29234, 0, ":");
    (29235, 0, " ");
    (29235, 1, "");
    (29234, 1, "");
    (29233, 1, "");
    (29233, 0, ":");
    (29234, 0, " ");
    (29235, 0, "M");
    (29236, 0, "a");
    (29237, 0, "k");
    (29238, 0, "e");
    (29239, 0, " ");
    (29240, 0, "s");
    (29241, 0, "u");
    (29242, 0, "r");
    (29243, 0, "e");
    (29244, 0, " ");
    (29245, 0, "t");
    (29246, 0, "h");
    (29247, 0, "e");
    (29248, 0, " ");
    (29249, 0, "i");
    (29250, 0, "t");
    (29251, 0, "e");
    (29252, 0, "r");
    (29253, 0, "a");
    (29254, 0, "t");
    (29255, 0, "o");
    (29256, 0, "r");
    (29257, 0, " ");
    (29258, 0, "w");
    (29259, 0, "r");
    (29260, 0, "o");
    (29261, 0, "t");
    (29262, 0, "e");
    (29263, 0, " ");
    (29264, 0, "n");
    (29265, 0, "u");
    (29266, 0, "m");
    (29267, 0, "_");
    (29268, 0, "i");
    (29269, 0, "t");
    (29270, 0, "e");
    (29271, 0, "m");
    (29272, 0, "s");
    (29264, 0, "a");
    (29265, 0, "t");
    (29266, 0, " ");
    (29267, 0, "l");
    (29268, 0, "e");
    (29269, 0, "a");
    (29270, 0, "s");
    (29271, 0, "t");
    (29272, 0, " ");
    (29282, 0, ".");
    (29283, 0, " ");
    (29284, 0, "I");
    (29285, 0, "f");
    (29286, 0, " ");
    (29287, 0, "n");
    (29288, 0, "o");
    (29289, 0, "t");
    (29290, 0, ",");
    (29291, 0, " ");
    (29292, 0, "w");
    (29293, 0, "e");
    (29294, 0, "'");
    (29295, 0, "r");
    (29296, 0, "e");
    (29297, 0, " ");
    (29298, 0, "i");
    (29299, 0, "n");
    (29300, 0, " ");
    (29301, 0, "a");
    (29302, 0, "n");
    (29303, 0, " ");
    (29304, 0, "i");
    (29305, 0, "n");
    (29306, 0, "v");
    (29307, 0, "a");
    (29308, 0, "l");
    (29309, 0, "i");
    (29310, 0, "d");
    (29311, 0, " ");
    (29312, 0, "s");
    (29313, 0, "t");
    (29314, 0, "a");
    (29315, 0, "t");
    (29316, 0, "e");
    (29317, 0, "!");
    (29318, 0, "\n        ");
    (29399, 0, "\n");
    (29328, 1, "");
    (29319, 8, "");
    (29390, 0, "\n");
    (29319, 1, "");
    ( 29389,
      0,
      "\n\
      \        // TODO: Make sure the iterator wrote at least num_items. If \
       not, we're in an invalid state!" );
    (29218, 101, "");
    (29288, 0, "\n");
    (29217, 1, "");
    ( 29390,
      0,
      "        // debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n"
    );
    (29398, 3, "");
    (29459, 1, "");
    (29389, 0, "\n        ");
    (29457, 8, "n");
    (29390, 8, "");
    (29450, 0, "e");
    (29451, 0, "w");
    (29449, 3, "new_node");
    (29457, 0, ".");
    (29458, 0, "i");
    (29458, 1, "");
    (29457, 1, "");
    (29457, 0, ".");
    (29458, 0, "i");
    (29459, 0, "t");
    (29460, 0, "e");
    (29461, 0, "m");
    (29462, 0, "s");
    (29463, 0, "(");
    (29464, 0, ")");
    (29458, 5, "c");
    (29459, 0, "o");
    (29460, 0, "n");
    (29461, 0, "t");
    (29462, 0, "e");
    (29463, 0, "n");
    (29464, 0, "t");
    (29465, 0, "_");
    (29466, 0, "s");
    (29467, 0, "l");
    (29468, 0, "i");
    (29469, 0, "c");
    (29470, 0, "e");
    (28621, 8, "E");
    (28622, 0, "x");
    (28623, 0, "a");
    (28624, 0, "c");
    (28621, 4, "ExactSizeIterator");
    (28855, 0, "\n        ");
    (28864, 0, "d");
    (28865, 0, "e");
    (28866, 0, "b");
    (28867, 0, "u");
    (28868, 0, "g");
    (28864, 5, "debug_assert!");
    (28877, 0, "(");
    (28878, 0, "c");
    (28879, 0, "o");
    (28880, 0, "n");
    (28881, 0, "t");
    (28882, 0, "e");
    (28883, 0, "n");
    (28884, 0, "t");
    (28885, 0, "s");
    (28886, 0, ".");
    (28887, 0, "l");
    (28888, 0, "e");
    (28889, 0, "n");
    (28890, 0, "(");
    (28891, 0, ")");
    (28892, 0, " ");
    (28893, 0, ">");
    (28894, 0, " ");
    (28894, 1, "");
    (28894, 0, "=");
    (28895, 0, " ");
    (28896, 0, "n");
    (28897, 0, "u");
    (28898, 0, "m");
    (28899, 0, "_");
    (28900, 0, "i");
    (28901, 0, "t");
    (28902, 0, "e");
    (28896, 7, "num_items");
    (28905, 0, ")");
    (28906, 0, ";");
    (29537, 1, "");
    (29349, 102, "");
    (32303, 8, "new_node.content_slice()");
    (32600, 9, "m");
    (32601, 0, "u");
    (32602, 0, "t");
    (32603, 0, " ");
    (32604, 0, "I");
    (32552, 0, ",");
    (32553, 0, " ");
    (32554, 0, "I");
    (32689, 0, ",");
    (32690, 0, " ");
    (32691, 0, ", I: ExactSizeIterator<Item=C::Item>");
    (32692, 1, "");
    (32691, 1, "");
    (32690, 1, "");
    (32690, 0, " ");
    (33161, 0, "// ");
    ( 34474,
      0,
      "                c[..].copy_within(item_idx..e_num_items,\n\
      \                    item_idx + num_inserted_items);\n" );
    (34656, 0, "// ");
    (34599, 0, "// ");
    (34473, 0, "\n                ");
    (34490, 0, "/");
    (34491, 0, "/");
    (34492, 0, " ");
    (34493, 0, "C");
    (34494, 0, "a");
    (34495, 0, "n");
    (34496, 0, "'");
    (34497, 0, "t");
    (34498, 0, " ");
    (34499, 0, "u");
    (34500, 0, "s");
    (34501, 0, "e");
    (34502, 0, " ");
    (34503, 0, "c");
    (34504, 0, "o");
    (34505, 0, "p");
    (34506, 0, "y");
    (34507, 0, "_");
    (34508, 0, "w");
    (34509, 0, "i");
    (34510, 0, "t");
    (34511, 0, "h");
    (34512, 0, "i");
    (34513, 0, "n");
    (34514, 0, " ");
    (34515, 0, "b");
    (34516, 0, "e");
    (34517, 0, "c");
    (34518, 0, "a");
    (34519, 0, "u");
    (34520, 0, "s");
    (34521, 0, "e");
    (34522, 0, " ");
    (34523, 0, "w");
    (34524, 0, "e");
    (34525, 0, " ");
    (34526, 0, "a");
    (34527, 0, "r");
    (34528, 0, "e");
    (34529, 0, "n");
    (34530, 0, "'");
    (34531, 0, "t");
    (34532, 0, " ");
    (34533, 0, "s");
    (34534, 0, "u");
    (34535, 0, "r");
    (34536, 0, "e");
    (34537, 0, " ");
    (34538, 0, "i");
    (34539, 0, "f");
    (34540, 0, " ");
    (34541, 0, "i");
    (34541, 1, "");
    (34541, 0, "t");
    (34542, 0, "h");
    (34543, 0, "e");
    (34544, 0, " ");
    (34545, 0, "t");
    (34546, 0, "y");
    (34547, 0, "p");
    (34548, 0, "e");
    (34549, 0, " ");
    (34550, 0, "i");
    (34551, 0, "m");
    (34552, 0, "p");
    (34553, 0, "l");
    (34554, 0, "e");
    (34555, 0, "m");
    (34556, 0, "e");
    (34557, 0, "n");
    (34558, 0, "t");
    (34559, 0, "s");
    (34560, 0, " ");
    (34561, 0, "C");
    (34562, 0, "o");
    (34563, 0, "p");
    (34564, 0, "y");
    (34565, 0, ".");
    (34566, 0, " ");
    (34567, 0, "M");
    (34567, 1, "");
    (34567, 0, "M");
    (34568, 0, "e");
    (34569, 0, "m");
    (34570, 0, "m");
    (34571, 0, "o");
    (34572, 0, "v");
    (34573, 0, "e");
    (34574, 0, " ");
    (34575, 0, "i");
    (34576, 0, "n");
    (34577, 0, "s");
    (34578, 0, "t");
    (34579, 0, "e");
    (34580, 0, "a");
    (34581, 0, "d");
    (34582, 0, ".");
    (34600, 92, "");
    ( 34600,
      0,
      "                    ptr::copy(\n\
      \                        &c[leading_bytes + removed_bytes],\n\
      \                        &mut c[leading_bytes],\n\
      \                        trailing_bytes);" );
    (34737, 24, "                    ");
    (34690, 24, "                    ");
    (34631, 24, "                    ");
    (34584, 36, "                ");
    (34574, 9, " ");
    (34575, 0, "t");
    (34576, 0, "h");
    (34577, 0, "e");
    (34578, 0, " ");
    (34579, 0, "e");
    (34580, 0, "x");
    (34581, 0, "i");
    (34582, 0, "s");
    (34583, 0, "t");
    (34584, 0, "i");
    (34585, 0, "n");
    (34586, 0, "g");
    (34587, 0, " ");
    (34588, 0, "i");
    (34589, 0, "t");
    (34590, 0, "e");
    (34591, 0, "s");
    (34592, 0, "m");
    (34592, 1, "");
    (34591, 1, "");
    (34591, 0, "m");
    (34592, 0, "s");
    (34593, 0, ".");
    ( 34595,
      161,
      "                ptr::copy(\n\
      \                    &c[offset_bytes],\n\
      \                    &mut c[offset_bytes + num_inserted_bytes],\n\
      \                    (*e).num_bytes as usize - offset_bytes);" );
    (34645, 12, "item_idx");
    (34683, 33, "item_idx + num_inserted_items");
    (34740, 9, "");
    (34739, 1, "");
    (34739, 0, ".");
    (34740, 0, "n");
    (34741, 0, "u");
    (34742, 0, "m");
    (34743, 0, "_");
    (34744, 0, "i");
    (34745, 0, "t");
    (34746, 0, "e");
    (34747, 0, "m");
    (34748, 0, "s");
    (34761, 12, "i");
    (34762, 0, "t");
    (34763, 0, "e");
    (34764, 0, "m");
    (34765, 0, "_");
    (34766, 0, "i");
    (34767, 0, "d");
    (34768, 0, "x");
    (34956, 0, "// ");
    (34943, 0, "\n            ");
    ( 34956,
      0,
      "\n\
      \    for (cell, item) in into.iter_mut().zip(iter) {\n\
      \        *cell = item;\n\
      \    }" );
    (34944, 12, "");
    (35019, 4, "        ");
    (34997, 8, "            ");
    (34945, 4, "        ");
    (35027, 8, "            ");
    (35001, 12, "                ");
    (34945, 8, "            ");
    (34943, 1, "");
    (34943, 0, ".");
    (34944, 0, " ");
    (34945, 0, "C");
    (34946, 0, "a");
    (34947, 0, "n");
    (34948, 0, "'");
    (34949, 0, "t");
    (34950, 0, " ");
    (34951, 0, "m");
    (34952, 0, "e");
    (34953, 0, "m");
    (34954, 0, "c");
    (34955, 0, "p");
    (34956, 0, "y");
    (34957, 0, " ");
    (34958, 0, "f");
    (34959, 0, "r");
    (34960, 0, "o");
    (34961, 0, "m");
    (34962, 0, " ");
    (34963, 0, "a");
    (34964, 0, "n");
    (34965, 0, " ");
    (34966, 0, "i");
    (34967, 0, "t");
    (34968, 0, "e");
    (34969, 0, "r");
    (34970, 0, "a");
    (34971, 0, "t");
    (34972, 0, "o");
    (34973, 0, "r");
    (34974, 0, ",");
    (34975, 0, " ");
    (34976, 0, "b");
    (34977, 0, "u");
    (34978, 0, "t");
    (34979, 0, " ");
    (34980, 0, "h");
    (34981, 0, "o");
    (34982, 0, "p");
    (34983, 0, "e");
    (34980, 4, "t");
    (34981, 0, "h");
    (34982, 0, "e");
    (34983, 0, " ");
    (34984, 0, "r");
    (34985, 0, "u");
    (34986, 0, "s");
    (34987, 0, "t");
    (34984, 4, "o");
    (34985, 0, "p");
    (34986, 0, "t");
    (34987, 0, "i");
    (34988, 0, "m");
    (34989, 0, "i");
    (34990, 0, "z");
    (34991, 0, "e");
    (34992, 0, "r");
    (34993, 0, " ");
    (34994, 0, "s");
    (34995, 0, "h");
    (34996, 0, "o");
    (34997, 0, "u");
    (34998, 0, "l");
    (34999, 0, "d");
    (35000, 0, " ");
    (35001, 0, "m");
    (35002, 0, "a");
    (35003, 0, "k");
    (35004, 0, "e");
    (35005, 0, " ");
    (35006, 0, "t");
    (35007, 0, "h");
    (35008, 0, "i");
    (35009, 0, "s");
    (35010, 0, " ");
    (35011, 0, "f");
    (35012, 0, "a");
    (35013, 0, "s");
    (35014, 0, "t");
    (35015, 0, ".");
    ( 34902,
      114,
      "            // Then copy in the new items. Can't memcpy from an \
       iterator, but\n\
      \            // the optimizer should make this fast." );
    ( 34474,
      120,
      "                // Can't use copy_within because we aren't sure if the \
       type\n\
      \                // implements Copy. Memmove the existing items." );
    (35083, 4, "");
    (35083, 0, "c");
    (35084, 0, "[");
    (35085, 0, "i");
    (35086, 0, "t");
    (35087, 0, "e");
    (35088, 0, "m");
    (35085, 4, "item_idx");
    (35093, 0, "]");
    (35093, 0, ".");
    (35094, 0, ".");
    (35095, 0, "i");
    (35096, 0, "t");
    (35097, 0, "e");
    (35098, 0, "m");
    (35095, 4, "item_idx");
    (35103, 0, " ");
    (35104, 0, "+");
    (35105, 0, " ");
    (35106, 0, "n");
    (35107, 0, "u");
    (35108, 0, "m");
    (35106, 3, "num_inserted_items");
    (35141, 4, "c");
    (35142, 0, "o");
    (35143, 0, "n");
    (35144, 0, "t");
    (35141, 4, "contents");
    (35388, 0, "\n            ");
    (35401, 0, "l");
    (35402, 0, "e");
    (35403, 0, "t");
    (35404, 0, " ");
    (35405, 0, "n");
    (35406, 0, "u");
    (35407, 0, "m");
    (35408, 0, "_");
    (35409, 0, "i");
    (35410, 0, "n");
    (35411, 0, "s");
    (35412, 0, "e");
    (35413, 0, "r");
    (35414, 0, "t");
    (35415, 0, "e");
    (35416, 0, "d");
    (35417, 0, "_");
    (35418, 0, "u");
    (35419, 0, "s");
    (35420, 0, "e");
    (35421, 0, "r");
    (35422, 0, "c");
    (35423, 0, "o");
    (35424, 0, "u");
    (35425, 0, "n");
    (35426, 0, "t");
    (35427, 0, " ");
    (35428, 0, "=");
    (35429, 0, " ");
    (35430, 0, "C::userlen_of_slice(contents);");
    (35450, 8, "");
    (35450, 0, "c");
    (35451, 0, "[");
    (35452, 0, "item_idx..item_idx + num_inserted_items]");
    (35450, 0, "&");
    (35050, 0, "\n            ");
    (35063, 0, "l");
    (35064, 0, "e");
    (35065, 0, "t");
    (35066, 0, " ");
    (35067, 0, "n");
    (35068, 0, "e");
    (35069, 0, "w");
    (35067, 3, "n");
    (35067, 1, "");
    (35067, 0, "m");
    (35068, 0, "u");
    (35069, 0, "t");
    (35070, 0, " ");
    (35071, 0, "n");
    (35072, 0, "e");
    (35073, 0, "w");
    (35074, 0, "_");
    (35071, 4, "d");
    (35072, 0, "e");
    (35073, 0, "s");
    (35074, 0, "t");
    (35075, 0, "_");
    (35076, 0, "c");
    (35077, 0, "o");
    (35078, 0, "n");
    (35079, 0, "t");
    (35080, 0, "e");
    (35081, 0, "n");
    (35082, 0, "t");
    (35083, 0, "_");
    (35084, 0, "s");
    (35085, 0, "l");
    (35086, 0, "i");
    (35087, 0, "c");
    (35088, 0, "e");
    (35089, 0, " ");
    (35090, 0, "=");
    (35091, 0, " ");
    (35092, 0, "item_idx..item_idx + num_inserted_items]");
    (35092, 0, "&");
    (35093, 0, "m");
    (35094, 0, "u");
    (35095, 0, "t");
    (35096, 0, " ");
    (35097, 0, "c");
    (35098, 0, "[");
    (35139, 0, ";");
    (35173, 42, "d");
    (35174, 0, "e");
    (35175, 0, "s");
    (35176, 0, "t");
    (35173, 4, "dest_content_slice");
    (35516, 43, "d");
    (35517, 0, "e");
    (35518, 0, "s");
    (35519, 0, "t");
    (35516, 4, "dest_content_slice");
    (36240, 8, "d");
    (36241, 0, "e");
    (36242, 0, "s");
    (36243, 0, "t");
    (36240, 4, "dest_content_slice");
    (38436, 6, "t");
    (38437, 0, "a");
    (38438, 0, "k");
    (38439, 0, "e");
    (38475, 0, "// ");
    (38571, 9, "");
    (28498, 20, "");
    (29329, 0, "\n        ");
    (29338, 0, "l");
    (29339, 0, "e");
    (29340, 0, "t");
    (29341, 0, " ");
    (29368, 11, "");
    (29342, 0, "new_userlen");
    (29353, 0, " ");
    (29354, 0, "=");
    (29355, 0, " ");
    (29384, 45, "");
    (29356, 0, "C::userlen_of_slice(new_node.content_slice())");
    (29400, 1, "");
    (29400, 0, ")");
    (29401, 0, ";");
    (29411, 0, "// ");
    (29403, 32, "");
    (29402, 1, "");
    (28480, 18, "");
    (28826, 0, "// ");
    (28780, 0, "// ");
    (28875, 0, "\n        ");
    (28884, 0, "a");
    (28885, 0, "s");
    (28886, 0, "s");
    (28887, 0, "e");
    (28888, 0, "r");
    (28889, 0, "t");
    (28890, 0, "!");
    (28891, 0, "(");
    (28875, 0, "\n        ");
    (28884, 0, "l");
    (28885, 0, "e");
    (28886, 0, "t");
    (28887, 0, " ");
    (28888, 0, "n");
    (28889, 0, "u");
    (28890, 0, "m");
    (28891, 0, "_");
    (28892, 0, "i");
    (28893, 0, "t");
    (28894, 0, "e");
    (28895, 0, "m");
    (28896, 0, "s");
    (28897, 0, " ");
    (28898, 0, "=");
    (28899, 0, " ");
    (28900, 0, "c");
    (28901, 0, "o");
    (28902, 0, "n");
    (28903, 0, "t");
    (28904, 0, "e");
    (28905, 0, "n");
    (28906, 0, "t");
    (28907, 0, "s");
    (28908, 0, ".");
    (28909, 0, "l");
    (28910, 0, "e");
    (28911, 0, "n");
    (28912, 0, "(");
    (28913, 0, ")");
    (28914, 0, ";");
    (28932, 0, "n");
    (28933, 0, "u");
    (28934, 0, "m");
    (28932, 3, "num_items");
    (28941, 0, " ");
    (28942, 0, "<");
    (28943, 0, "=");
    (28944, 0, " ");
    (28945, 0, "N");
    (28946, 0, "O");
    (28947, 0, "D");
    (28948, 0, "E");
    (28949, 0, "_");
    (28945, 5, "NODE_NUM_ITEMS");
    (28959, 0, ")");
    (28960, 0, ";");
    (28472, 5, "");
    (28472, 0, "&mut ");
    (28472, 5, "");
    (28472, 0, "&mut ");
    (28959, 2, "");
    (28959, 0, ");");
    (28959, 2, "");
    (28945, 14, "NODE_");
    (28944, 6, "");
    (28941, 3, "");
    (28932, 9, "num");
    (28932, 3, "");
    (28899, 16, "");
    (28897, 2, "");
    (28887, 10, "");
    (28875, 12, "");
    (28875, 17, "");
    (28829, 3, "");
    (28780, 3, "");
    (28480, 0, "num_items: usize, ");
    (29402, 0, "\n");
    (29402, 1, "");
    (29402, 0, "\n");
    (29403, 0, "        // debug_assert_eq!(, );");
    (29411, 3, "");
    (29400, 2, "");
    (29400, 0, ");");
    (29411, 0, "// ");
    (29403, 32, "");
    (29402, 1, "");
    (28480, 18, "");
    (28480, 0, "num_items: usize, ");
    (28601, 17, "I");
    (28602, 0, "t");
    (28603, 0, "e");
    (28604, 0, "r");
    (28605, 0, "a");
    (28606, 0, "t");
    (28607, 0, "o");
    (28608, 0, "r");
    (28858, 5, "");
    (28858, 0, "s");
    (28859, 0, "i");
    (28860, 0, "z");
    (28861, 0, "e");
    (28858, 4, "size_hint()");
    (28869, 0, ".");
    (28870, 0, "0");
    (32227, 14, "n");
    (32067, 14, "n");
    (32215, 0, "u");
    (32068, 0, "u");
    (32217, 0, "m");
    (32069, 0, "m");
    (32219, 0, "_");
    (32070, 0, "_");
    (32221, 0, "i");
    (32071, 0, "i");
    (32218, 5, "num_items");
    (32067, 5, "num_items");
    (38357, 0, "l");
    (38358, 0, "e");
    (38359, 0, "t");
    (38360, 0, " ");
    (38361, 0, "m");
    (38362, 0, "u");
    (38363, 0, "t");
    (38364, 0, " ");
    (38365, 0, "n");
    (38366, 0, "u");
    (38367, 0, "m");
    (38368, 0, "_");
    (38365, 4, "num_inserted_items");
    (38383, 0, " ");
    (38384, 0, "=");
    (38385, 0, " ");
    (38386, 0, "n");
    (38387, 0, "u");
    (38388, 0, "m");
    (38389, 0, "_");
    (38386, 4, "num_inserted_items");
    (38404, 0, ";");
    (38405, 0, "\n            ");
    (38418, 0, "w");
    (38419, 0, "h");
    (38420, 0, "i");
    (38421, 0, "l");
    (38422, 0, "e");
    (38423, 0, " ");
    (38424, 0, "n");
    (38425, 0, "u");
    (38426, 0, "m");
    (38427, 0, "_");
    (38424, 4, "num_inserted_items");
    (38442, 0, " ");
    (38443, 0, ">");
    (38444, 0, " ");
    (38445, 0, "0");
    (38446, 0, " ");
    (38447, 0, "{");
    (38448, 0, "\n                ");
    (38465, 0, "\n                ");
    (38449, 16, "");
    (38450, 16, "            }");
    (38660, 0, "// ");
    (38594, 0, "// ");
    (38533, 0, "// ");
    (38476, 0, "// ");
    ( 38656,
      0,
      "\n            //     self.insert_node_at(cursor, chunk, true, notify);"
    );
    ( 38656,
      0,
      "\n            //     // let userlen = C::userlen_of_slice(chunk);" );
    (38588, 12, "                ");
    (38524, 64, "");
    (38596, 0, "\n            // for chunk in contents.take(NODE_NUM_ITEMS) {");
    (38524, 16, "            ");
    (38464, 60, "");
    (38532, 0, "\n            }");
    (38464, 12, "                ");
    (38450, 14, "");
    (38522, 0, "\n");
    (38449, 1, "");
    (38449, 16, "            ");
    (38461, 3, "");
    (38514, 1, "");
    (38493, 5, "c");
    (38494, 0, "o");
    (38495, 0, "n");
    (38496, 0, "t");
    (38497, 0, "e");
    (38498, 0, "n");
    (38499, 0, "t");
    (38493, 7, "contents");
    (38501, 0, ",");
    (38502, 0, " ");
    (38448, 0, "\n                ");
    (38465, 0, "l");
    (38466, 0, "e");
    (38467, 0, "t");
    (38468, 0, " ");
    (38469, 0, "i");
    (38470, 0, "n");
    (38471, 0, "s");
    (38472, 0, "e");
    (38473, 0, "r");
    (38474, 0, "t");
    (38475, 0, "+");
    (38475, 1, "");
    (38475, 0, "_");
    (38476, 0, "h");
    (38477, 0, "e");
    (38478, 0, "r");
    (38479, 0, "e");
    (38480, 0, " ");
    (38481, 0, "=");
    (38482, 0, " ");
    (38483, 0, "u");
    (38484, 0, "s");
    (38485, 0, "i");
    (38486, 0, "z");
    (38487, 0, "e");
    (38488, 0, ":");
    (38489, 0, ":");
    (38490, 0, "M");
    (38490, 1, "");
    (38490, 0, "m");
    (38491, 0, "a");
    (38492, 0, "x");
    (38493, 0, "(");
    (38494, 0, "n");
    (38495, 0, "u");
    (38494, 2, "num_inserted_items");
    (38512, 0, ",");
    (38513, 0, " ");
    (38514, 0, "M");
    (38515, 0, "A");
    (38516, 0, "X");
    (38516, 1, "");
    (38515, 1, "");
    (38514, 1, "");
    (38514, 0, "N");
    (38515, 0, "U");
    (38516, 0, "M");
    (38514, 3, "NODE_NUM_ITEMS");
    (38528, 0, ")");
    (38529, 0, ";");
    (38490, 3, "m");
    (38491, 0, "i");
    (38492, 0, "n");
    (38585, 0, "i");
    (38586, 0, "n");
    (38587, 0, "s");
    (38588, 0, "e");
    (38589, 0, "r");
    (38585, 5, "insert_here");
    (38612, 0, "\n                ");
    (38629, 0, "n");
    (38630, 0, "u");
    (38631, 0, "m");
    (38629, 3, "num_inserted_items");
    (38647, 0, " ");
    (38648, 0, "-");
    (38649, 0, "=");
    (38650, 0, " ");
    (38651, 0, "i");
    (38652, 0, "n");
    (38653, 0, "s");
    (38654, 0, "e");
    (38655, 0, "r");
    (38651, 5, "insert_here");
    (38662, 0, ";");
    (38646, 1, "aining");
    (38642, 2, "r");
    (38640, 1, "ms");
    (38634, 4, "");
    (38629, 4, "");
    (38511, 1, "aining");
    (38507, 2, "r");
    (38505, 1, "ms");
    (38499, 4, "");
    (38494, 4, "");
    (38441, 1, "aining");
    (38437, 2, "r");
    (38435, 1, "ms");
    (38429, 4, "");
    (38424, 4, "");
    (38382, 1, "aining");
    (38378, 2, "r");
    (38376, 1, "ms");
    (38370, 4, "");
    (38365, 4, "");
    (38291, 53, "");
    (38291, 0, ",");
    (38292, 0, " ");
    (38293, 0, "b");
    (38294, 0, "u");
    (38295, 0, "t");
    (38296, 0, " ");
    (38297, 0, "w");
    (38298, 0, "e");
    (38291, 8, ".");
    (39296, 0, ".");
    (39297, 0, "t");
    (39297, 1, "");
    (39297, 0, "i");
    (39298, 0, "t");
    (39299, 0, "e");
    (39300, 0, "r");
    (39301, 0, "(");
    (39302, 0, ")");
    (16566, 0, "\n");
    (16567, 0, "\n");
    (16568, 0, "\n");
    (16568, 0, "s");
    (16569, 0, "t");
    (16570, 0, "r");
    (16571, 0, "u");
    (16572, 0, "c");
    (16573, 0, "t");
    (16574, 0, " ");
    (16575, 0, "I");
    (16576, 0, "n");
    (16577, 0, "i");
    (16578, 0, "t");
    (16579, 0, "i");
    (16579, 1, "");
    (16575, 4, "U");
    (16576, 0, "n");
    (16577, 0, "i");
    (16578, 0, "n");
    (16579, 0, "i");
    (16580, 0, "t");
    (16581, 0, "I");
    (16582, 0, "t");
    (16583, 0, "e");
    (16584, 0, "r");
    (16581, 0, "O");
    (16582, 0, "w");
    (16583, 0, "n");
    (16584, 0, "e");
    (16585, 0, "d");
    (16590, 0, " ");
    (16591, 0, "{");
    (16592, 0, "\n    ");
    (16593, 4, "");
    (16592, 1, "");
    (16591, 1, "");
    (16591, 0, "{");
    (16592, 0, "\n    ");
    (16597, 0, "\n    ");
    (16593, 4, "");
    (16594, 4, "}");
    (16593, 0, "    ");
    (16597, 0, "p");
    (16598, 0, "t");
    (16599, 0, "r");
    (16600, 0, ":");
    (16601, 0, " ");
    (16602, 0, "N");
    (16603, 0, "o");
    (16604, 0, "n");
    (16605, 0, "N");
    (16606, 0, "u");
    (16607, 0, "l");
    (16608, 0, "l");
    (16609, 0, "<");
    (16590, 0, "<");
    (16591, 0, "'");
    (16592, 0, "a");
    (16593, 0, ",");
    (16594, 0, " ");
    (16595, 0, "T");
    (16596, 0, ":");
    (16597, 0, " ");
    (16598, 0, "'");
    (16599, 0, "a");
    (16600, 0, ">");
    (16621, 0, "T");
    (16622, 0, ">");
    (16623, 0, ",");
    (16624, 0, "\n    ");
    (16629, 0, "e");
    (16630, 0, "n");
    (16631, 0, "d");
    (16632, 0, ":");
    (16633, 0, " ");
    (16634, 0, "*");
    (16635, 0, "c");
    (16636, 0, "o");
    (16637, 0, "n");
    (16638, 0, "s");
    (16639, 0, "t");
    (16640, 0, " ");
    (16641, 0, "T");
    (16642, 0, ",");
    (16643, 0, "\n    ");
    (16648, 0, "_");
    (16649, 0, "m");
    (16650, 0, "a");
    (16651, 0, "r");
    (16652, 0, "k");
    (16653, 0, "e");
    (16654, 0, "r");
    (16655, 0, ":");
    (16656, 0, " ");
    (16657, 0, "m");
    (16657, 1, "");
    (16657, 0, "p");
    (16658, 0, "h");
    (16659, 0, "a");
    (16660, 0, "n");
    (16657, 4, "PhantomData");
    (16668, 0, "<");
    (16669, 0, "*");
    (16669, 1, "");
    (16669, 0, "&");
    (16670, 0, "'");
    (16671, 0, "a");
    (16672, 0, " ");
    (16673, 0, "T");
    (16674, 0, ">");
    (16648, 0, "// ");
    (782, 0, "\n");
    (783, 0, "u");
    (784, 0, "s");
    (785, 0, "e");
    (786, 0, " ");
    (787, 0, "s");
    (788, 0, "t");
    (789, 0, "d");
    (790, 0, ":");
    (791, 0, ":");
    (792, 0, "p");
    (793, 0, "t");
    (794, 0, "r");
    (795, 0, ":");
    (796, 0, ":");
    (797, 0, "N");
    (798, 0, "o");
    (799, 0, "n");
    (797, 3, "NonNull");
    (804, 0, ";");
    (16671, 3, "");
    (16696, 1, "");
    (16696, 0, "S");
    (16697, 0, "k");
    (16698, 0, "i");
    (16699, 0, "p");
    (16696, 4, "SkipList");
    (16704, 0, "<");
    (16705, 0, "T");
    (16706, 0, ">");
    (16706, 1, "");
    (16705, 1, "");
    (16704, 1, "");
    (16617, 7, ", C: ListConfig>");
    (16617, 16, " T: 'a>");
    (16614, 4, "");
    (16615, 4, "");
    (16663, 0, "// ");
    (16658, 0, "\n    ");
    (16663, 0, "/");
    (16664, 0, "/");
    (16665, 0, " ");
    (16666, 0, "T");
    (16667, 0, "O");
    (16668, 0, "D");
    (16669, 0, "O");
    (16670, 0, ":");
    (16671, 0, " ");
    (16672, 0, "A");
    (16673, 0, "d");
    (16674, 0, "d");
    (16675, 0, " ");
    (16676, 0, "a");
    (16677, 0, " ");
    (16678, 0, "p");
    (16679, 0, "h");
    (16680, 0, "a");
    (16681, 0, "n");
    (16682, 0, "t");
    (16683, 0, "o");
    (16684, 0, "m");
    (16685, 0, "d");
    (16686, 0, "a");
    (16687, 0, "t");
    (16688, 0, "a");
    (16689, 0, " ");
    (16690, 0, "t");
    (16691, 0, "o");
    (16692, 0, " ");
    (16693, 0, "t");
    (16694, 0, "h");
    (16695, 0, "i");
    (16696, 0, "s");
    (16697, 0, ".");
    (16590, 0, "\n");
    (16591, 0, "/");
    (16592, 0, "/");
    (16593, 0, " ");
    (16594, 0, "T");
    (16595, 0, "h");
    (16596, 0, "i");
    (16596, 1, "");
    (16595, 1, "");
    (16594, 1, "");
    (16594, 0, "N");
    (16595, 0, "o");
    (16596, 0, "n");
    (16597, 0, "e");
    (16598, 0, " ");
    (16599, 0, "o");
    (16600, 0, "f");
    (16601, 0, " ");
    (16602, 0, "t");
    (16603, 0, "h");
    (16604, 0, "e");
    (16605, 0, " ");
    (16606, 0, "b");
    (16607, 0, "u");
    (16608, 0, "i");
    (16609, 0, "l");
    (16610, 0, "t");
    (16611, 0, "i");
    (16612, 0, "n");
    (16613, 0, "s");
    (16606, 0, "r");
    (16607, 0, "u");
    (16608, 0, "s");
    (16609, 0, "t");
    (16610, 0, " ");
    (16619, 0, " ");
    (16620, 0, "g");
    (16621, 0, "i");
    (16622, 0, "v");
    (16623, 0, "e");
    (16624, 0, " ");
    (16625, 0, "m");
    (16626, 0, "e");
    (16627, 0, " ");
    (16628, 0, "w");
    (16629, 0, "h");
    (16630, 0, "a");
    (16631, 0, "t");
    (16632, 0, " ");
    (16633, 0, "I");
    (16634, 0, " ");
    (16635, 0, "w");
    (16636, 0, "a");
    (16637, 0, "n");
    (16638, 0, "t");
    (16639, 0, ":");
    (16640, 0, "\n");
    (16641, 0, "-");
    (16642, 0, " ");
    (16642, 1, "");
    (16641, 1, "");
    (16641, 0, "/");
    (16642, 0, "/");
    (16643, 0, " ");
    (16644, 0, "-");
    (16645, 0, " ");
    (16646, 0, "W");
    (16647, 0, "O");
    (16647, 1, "");
    (16646, 1, "");
    (16646, 0, "O");
    (16647, 0, "w");
    (16648, 0, "n");
    (16649, 0, "e");
    (16650, 0, "d");
    (16646, 5, "I");
    (16647, 0, "t");
    (16648, 0, "e");
    (16649, 0, "r");
    (16650, 0, " ");
    (16651, 0, "t");
    (16652, 0, "o");
    (16653, 0, " ");
    (16654, 0, "o");
    (16655, 0, "w");
    (16656, 0, "n");
    (16657, 0, "e");
    (16658, 0, "d");
    (16659, 0, " ");
    (16660, 0, "i");
    (16661, 0, "t");
    (16662, 0, "e");
    (16663, 0, "m");
    (16664, 0, "s");
    (16665, 0, "\n");
    (16666, 0, "/");
    (16667, 0, "/");
    (16668, 0, " ");
    (16669, 0, "-");
    (16670, 0, " ");
    (16671, 0, "W");
    (16672, 0, "h");
    (16673, 0, "e");
    (16674, 0, "r");
    (16675, 0, "e");
    (16676, 0, " ");
    (16677, 0, "i");
    (16678, 0, "t");
    (16679, 0, " ");
    (16680, 0, "d");
    (16681, 0, "o");
    (16682, 0, "e");
    (16683, 0, "s");
    (16684, 0, "n");
    (16685, 0, "'");
    (16686, 0, "t");
    (16666, 21, "");
    (16665, 1, "");
    (16639, 1, "");
    (16639, 0, ",");
    (16640, 0, " ");
    (16641, 0, "w");
    (16642, 0, "h");
    (16643, 0, "i");
    (16644, 0, "c");
    (16645, 0, "h");
    (16646, 0, " ");
    (16647, 0, "i");
    (16648, 0, "s");
    (16649, 0, " ");
    (16650, 0, "a");
    (16651, 0, " ");
    (16652, 0, "z");
    (16653, 0, "e");
    (16654, 0, "r");
    (16655, 0, "o");
    (16656, 0, "-");
    (16657, 0, "c");
    (16658, 0, "o");
    (16659, 0, "p");
    (16660, 0, "y");
    (16661, 0, " ");
    (16662, 0, "i");
    (16663, 0, "t");
    (16664, 0, "e");
    (16665, 0, "r");
    (16666, 0, "a");
    (16667, 0, "t");
    (16668, 0, "o");
    (16669, 0, "r");
    (16670, 0, " ");
    (16671, 0, "t");
    (16672, 0, "o");
    (16673, 0, " ");
    (16674, 0, "o");
    (16675, 0, "w");
    (16676, 0, "n");
    (16677, 0, "e");
    (16678, 0, "d");
    (16652, 5, "");
    (16656, 0, "-");
    (16657, 0, "f");
    (16658, 0, "r");
    (16659, 0, "e");
    (16660, 0, "e");
    (16679, 0, " ");
    (16680, 0, "i");
    (16681, 0, "t");
    (16682, 0, "e");
    (16683, 0, "m");
    (16684, 0, "s");
    (16685, 0, " ");
    (16686, 0, "t");
    (16687, 0, "h");
    (16688, 0, "a");
    (16689, 0, "t");
    (16690, 0, " ");
    (16691, 0, "d");
    (16692, 0, "o");
    (16693, 0, "e");
    (16694, 0, "s");
    (16695, 0, "n");
    (16696, 0, "'");
    (16697, 0, "t");
    (16698, 0, " ");
    (16686, 13, "i");
    (16687, 0, "n");
    (16688, 0, " ");
    (16689, 0, "a");
    (16690, 0, "n");
    (16691, 0, " ");
    (16691, 1, "");
    (16690, 1, "");
    (16690, 0, " ");
    (16691, 0, "M");
    (16692, 0, "a");
    (16693, 0, "y");
    (16694, 0, "b");
    (16695, 0, "e");
    (16696, 0, "U");
    (16697, 0, "n");
    (16698, 0, "i");
    (16699, 0, "n");
    (16700, 0, "i");
    (16701, 0, "t");
    (16702, 0, " ");
    (16703, 0, "a");
    (16704, 0, "r");
    (16705, 0, "r");
    (16706, 0, "a");
    (16707, 0, "y");
    (16708, 0, ".");
    (16709, 25, "");
    ( 16591,
      118,
      "// None of the rust builtins give me what I want, which is a copy-free \
       iterator\n\
       // to owned items in a MaybeUninit array." );
    (16712, 0, " ");
    (16713, 0, "E");
    (16714, 0, "h");
    (16715, 0, ".");
    (16715, 1, "");
    (16715, 0, ";");
    (16716, 0, " ");
    (16717, 0, "i");
    (16718, 0, "t");
    (16719, 0, "s");
    (16720, 0, " ");
    (16721, 0, "e");
    (16722, 0, "a");
    (16723, 0, "s");
    (16724, 0, "y");
    (16725, 0, " ");
    (16726, 0, "e");
    (16727, 0, "n");
    (16728, 0, "o");
    (16729, 0, "u");
    (16730, 0, "g");
    (16731, 0, "h");
    (16732, 0, " ");
    (16733, 0, "t");
    (16734, 0, "o");
    (16735, 0, " ");
    (16736, 0, "m");
    (16737, 0, "k");
    (16737, 1, "");
    (16737, 0, "a");
    (16738, 0, "k");
    (16739, 0, "e");
    (16740, 0, " ");
    (16741, 0, "m");
    (16742, 0, "y");
    (16743, 0, " ");
    (16744, 0, "o");
    (16745, 0, "w");
    (16746, 0, "n");
    (16747, 0, ".");
    (16900, 0, "\n");
    (16901, 0, "\n");
    (16902, 0, "i");
    (16903, 0, "m");
    (16904, 0, "p");
    (16905, 0, "l");
    (16906, 0, " ");
    (16907, 0, "I");
    (16908, 0, "t");
    (16909, 0, "e");
    (16910, 0, "r");
    (16911, 0, "a");
    (16907, 5, "Iterator");
    (16902, 0, "// ");
    (32733, 0, "\n    ");
    (32738, 0, "\n    ");
    (32734, 4, "");
    (32739, 0, "u");
    (32740, 0, "n");
    (32741, 0, "s");
    (32742, 0, "a");
    (32743, 0, "f");
    (32744, 0, "e");
    (32745, 0, " ");
    (32746, 0, "f");
    (32747, 0, "n");
    (32748, 0, " ");
    (32749, 0, "O");
    (32749, 1, "");
    (32749, 0, "o");
    (32750, 0, "w");
    (32751, 0, "n");
    (32752, 0, "e");
    (32753, 0, "d");
    (32754, 0, "_");
    (32755, 0, "i");
    (32756, 0, "t");
    (32757, 0, "e");
    (32758, 0, "r");
    (32759, 0, "_");
    (32760, 0, "f");
    (32761, 0, "r");
    (32762, 0, "o");
    (32763, 0, "m");
    (32764, 0, "_");
    (32765, 0, "s");
    (32766, 0, "l");
    (32767, 0, "i");
    (32768, 0, "c");
    (32769, 0, "e");
    (32770, 0, "(");
    (32770, 1, "");
    (32770, 0, "<");
    (32771, 0, "T");
    (32772, 0, ">");
    (32735, 38, "");
    (32734, 1, "");
    (32733, 1, "");
    (16901, 0, "\n");
    (16902, 0, "    unsafe fn owned_iter_from_slice<T>");
    (16902, 4, "");
    (16901, 0, "\n");
    (16913, 11, "");
    (16902, 0, "i");
    (16903, 0, "m");
    (16904, 0, "p");
    (16905, 0, "l");
    (16906, 0, " ");
    (16907, 0, "U");
    (16907, 1, "UninitOwnedIter");
    (16906, 0, "<");
    (16907, 0, "T");
    (16908, 0, ">");
    (16925, 0, " ");
    (16926, 0, "{");
    (16928, 0, "    ");
    (16956, 16, "");
    (16955, 1, "");
    (16955, 0, " ");
    (16956, 0, "-");
    (16957, 0, ">");
    (16958, 0, " ");
    (16958, 1, "");
    (16957, 1, "");
    (16956, 1, "");
    (16955, 1, "");
    (16954, 1, "");
    (16953, 1, "");
    (16952, 1, "");
    (16952, 0, "(");
    (16953, 0, "&");
    (16954, 0, "[");
    (16955, 0, "M");
    (16956, 0, "a");
    (16957, 0, "y");
    (16958, 0, "b");
    (16955, 4, "MaybeUninit");
    (16966, 0, "<");
    (16967, 0, "T");
    (16968, 0, ">");
    (16969, 0, "]");
    (16970, 0, ")");
    (16971, 0, " ");
    (16972, 0, "-");
    (16973, 0, ".");
    (16973, 1, "");
    (16973, 0, " ");
    (16973, 1, "");
    (16973, 0, ">");
    (16974, 0, " ");
    (16975, 0, "U");
    (16976, 0, "n");
    (16977, 0, "i");
    (16978, 0, "n");
    (16979, 0, "i");
    (16975, 5, "UninitOwnedIter");
    (16990, 0, " ");
    (16991, 0, "{");
    (16992, 0, "\n        ");
    (17001, 0, "\n        ");
    (16993, 8, "");
    (16994, 8, "    }");
    (16953, 0, "s");
    (16954, 0, "l");
    (16955, 0, "i");
    (16956, 0, "c");
    (16957, 0, "e");
    (16958, 0, ":");
    (16959, 0, " ");
    ( 16999,
      0,
      "\n\
      \    unsafe fn from_slice(slice: &[MaybeUninit<T>]) -> UninitOwnedIter {"
    );
    (16932, 0, "// ");
    (17037, 12, "");
    (17038, 1, "");
    ( 17062,
      0,
      "      unsafe {\n\
      \            let ptr = self.as_ptr();\n\
      \            assume(!ptr.is_null());\n\n\
      \            let end = if mem::size_of::<T>() == 0 {\n\
      \                (ptr as *const u8).wrapping_add(self.len()) as *const T\n\
      \            } else {\n\
      \                ptr.add(self.len())\n\
      \            };\n\n\
      \            Iter { ptr: NonNull::new_unchecked(ptr as *mut T), end, \
       _marker: marker::PhantomData }\n\
      \        }" );
    (17062, 6, "        ");
    (17101, 4, "s");
    (17102, 0, "l");
    (17103, 0, "i");
    (17104, 0, "c");
    (17105, 0, "e");
    (17117, 35, "");
    (17116, 1, "");
    (17116, 0, "\n");
    (17117, 0, "            assume(!ptr.is_null());");
    (17117, 35, "");
    (17116, 1, "");
    (16908, 0, ":");
    (16909, 0, " ");
    (16910, 0, "S");
    (16911, 0, "i");
    (16912, 0, "z");
    (16913, 0, "e");
    (16914, 0, "d");
    (17125, 145, "");
    (17125, 16, "            ");
    (17125, 12, "                ");
    ( 17125,
      0,
      "            let end = if mem::size_of::<T>() == 0 {\n\
      \                (ptr as *const u8).wrapping_add(self.len()) as *const T\n\
      \            } else {\n" );
    (17147, 139, "");
    (17167, 14, "");
    (17166, 1, "");
    (17166, 0, ";");
    (17155, 4, "s");
    (17156, 0, "l");
    (17157, 0, "i");
    (17158, 0, "c");
    (17159, 0, "e");
    (17123, 1, "");
    (17181, 4, "U");
    (17181, 1, "UninitOwnedIter");
    (17246, 30, "");
    (17198, 1, "");
    (17198, 0, "\n                ");
    (17258, 1, "");
    (17258, 0, "\n                ");
    (17278, 1, "");
    (17278, 0, "\n            ");
    (17066, 0, "<");
    (17067, 0, "T");
    (17068, 0, ">");
    (17311, 0, "\n    ");
    (17312, 4, "}");
    (16932, 0, "<");
    (16933, 0, "T");
    (16934, 0, ">");
    (17054, 15, "S");
    (17055, 0, "e");
    (17056, 0, "l");
    (17057, 0, "f");
    (17058, 3, "");
    ( 17013,
      0,
      "    unsafe fn from_slice(slice: &[T]) -> Self {\n\
      \        unsafe {\n\
      \            let ptr = slice.as_ptr();\n\
      \            let end = ptr.add(slice.len());\n\n\
      \            UninitOwnedIter {\n\
      \                ptr: NonNull::new_unchecked(ptr as *mut T),\n\
      \                end\n\
      \            }\n\
      \        }\n\
      \    }\n" );
    (17587, 0, "// ");
    (17577, 0, "// ");
    (17563, 0, "// ");
    (17543, 0, "// ");
    (17483, 0, "// ");
    (17453, 0, "// ");
    (17408, 0, "// ");
    (17370, 0, "// ");
    (17353, 0, "// ");
    (17305, 0, "// ");
    (782, 0, "\n");
    (783, 0, "s");
    (784, 0, "e");
    (784, 1, "");
    (783, 1, "");
    (783, 0, "u");
    (784, 0, "s");
    (785, 0, "e");
    (786, 0, " ");
    (787, 0, "s");
    (788, 0, "t");
    (789, 0, "d");
    (790, 0, ":");
    (791, 0, ":");
    (792, 0, "m");
    (793, 0, "e");
    (794, 0, "m");
    (795, 0, ":");
    (796, 0, ":");
    (797, 0, "M");
    (798, 0, "a");
    (799, 0, "y");
    (797, 3, "MaybeUninit");
    (808, 0, ";");
    (797, 12, "");
    (797, 0, "m");
    (798, 0, "a");
    (799, 0, "t");
    (799, 1, "");
    (799, 0, "t");
    (797, 3, "");
    (797, 0, "MaybeUninit;");
    (17074, 0, "M");
    (17075, 0, "a");
    (17076, 0, "y");
    (17077, 0, "b");
    (17078, 0, "e");
    (17079, 0, "U");
    (17080, 0, "n");
    (17081, 0, "i");
    (17082, 0, "n");
    (17083, 0, "i");
    (17084, 0, "t");
    (17085, 0, "<");
    (17087, 0, ">");
    (17154, 0, ".");
    (17155, 0, "a");
    (17156, 0, "s");
    (17157, 0, "_");
    (17158, 0, "p");
    (17159, 0, "t");
    (17160, 0, "r");
    (17161, 0, "(");
    (17162, 0, ")");
    (17040, 310, "");
    (16965, 75, "");
    (17278, 3, "");
    (17265, 3, "");
    (17248, 3, "");
    (17225, 3, "");
    (17162, 3, "");
    (17129, 3, "");
    (17081, 3, "");
    (17040, 3, "");
    (17020, 3, "");
    (16969, 3, "");
    (17255, 0, "\n");
    (17255, 0, "\n");
    (17256, 0, "i");
    (17257, 0, "m");
    (17258, 0, "p");
    (17259, 0, "l");
    (17260, 0, " ");
    (17261, 0, "I");
    (17262, 0, "t");
    (17263, 0, "e");
    (17264, 0, "r");
    (17265, 0, "a");
    (17266, 0, "t");
    (17267, 0, "o");
    (17268, 0, "r");
    (17269, 0, " ");
    (17270, 0, "f");
    (17271, 0, "o");
    (17272, 0, "r");
    (17273, 0, " ");
    (17274, 0, "U");
    (17275, 0, "n");
    (17276, 0, "i");
    (17277, 0, "n");
    (17274, 4, "UninitOwnedIter");
    (17289, 0, " ");
    (17290, 0, "{");
    (17291, 0, "\n    ");
    (17296, 0, "\n    ");
    (17292, 4, "");
    (17293, 4, "}");
    (17260, 0, "<");
    (17261, 0, "T");
    (17262, 0, ">");
    (17292, 0, "<");
    (17293, 0, "T");
    (17294, 0, ">");
    (17298, 0, "    ");
    (17302, 0, "t");
    (17303, 0, "y");
    (17304, 0, "p");
    (17305, 0, "e");
    (17306, 0, " ");
    (17307, 0, "I");
    (17308, 0, "t");
    (17309, 0, "e");
    (17310, 0, "m");
    (17311, 0, " ");
    (17312, 0, "=");
    (17313, 0, " ");
    (17314, 0, "T");
    (17315, 0, ";");
    (17316, 0, "\n    ");
    (17321, 0, "\n    ");
    (17317, 4, "");
    (17322, 0, "f");
    (17323, 0, "n");
    (17324, 0, " ");
    (17325, 0, "n");
    (17326, 0, "e");
    (17327, 0, "x");
    (17328, 0, "t");
    (17329, 0, "(");
    (17330, 0, "&");
    (17331, 0, "m");
    (17332, 0, "u");
    (17333, 0, "t");
    (17334, 0, " ");
    (17335, 0, "s");
    (17336, 0, "e");
    (17337, 0, "l");
    (17338, 0, "f");
    (17339, 0, ")");
    (17340, 0, " ");
    (17341, 0, "-");
    (17342, 0, ">");
    (17343, 0, " ");
    (17344, 0, "O");
    (17345, 0, "p");
    (17346, 0, "t");
    (17347, 0, "i");
    (17348, 0, "o");
    (17349, 0, "n");
    (17350, 0, "<");
    (17351, 0, "S");
    (17352, 0, "e");
    (17353, 0, "l");
    (17354, 0, "f");
    (17355, 0, ":");
    (17356, 0, ":");
    (17357, 0, "I");
    (17358, 0, "t");
    (17359, 0, "e");
    (17360, 0, "m");
    (17361, 0, ">");
    (17362, 0, " ");
    (17363, 0, "{");
    (17364, 0, "\n        ");
    (17373, 0, "\n        ");
    (17365, 8, "");
    (17366, 8, "    }");
    (17365, 0, "        ");
    (17373, 0, "N");
    (17374, 0, "o");
    (17375, 0, "n");
    (17376, 0, "e");
    (16835, 5, "m");
    (16836, 0, "n");
    (16837, 0, "u");
    (16838, 0, "t");
    (16838, 1, "");
    (16837, 1, "");
    (16836, 1, "");
    (16836, 0, "u");
    (16837, 0, "t");
    (16803, 0, "\n    ");
    (16808, 0, "/");
    (16809, 0, "/");
    (16810, 0, " ");
    (16811, 0, "B");
    (16812, 0, "a");
    (16813, 0, "s");
    (16814, 0, "e");
    (16815, 0, "d");
    (16816, 0, " ");
    (16817, 0, "o");
    (16818, 0, "n");
    (16819, 0, " ");
    (16820, 0, "s");
    (16821, 0, "l");
    (16822, 0, "i");
    (16823, 0, "c");
    (16824, 0, "e");
    (16825, 0, ".");
    (16825, 1, "");
    (16820, 0, "c");
    (16821, 0, "o");
    (16822, 0, "r");
    (16823, 0, "e");
    (16824, 0, " ");
    (16830, 0, " ");
    (16831, 0, "i");
    (16832, 0, "t");
    (16833, 0, "e");
    (16834, 0, "r");
    (16831, 4, "I");
    (16832, 0, "t");
    (16833, 0, "e");
    (16834, 0, "R");
    (16835, 0, "M");
    (16836, 0, "u");
    (16837, 0, "t");
    (16820, 0, "t");
    (16821, 0, "h");
    (16822, 0, "e");
    (16823, 0, " ");
    (16835, 7, "I");
    (16836, 0, "t");
    (16837, 0, "e");
    (16838, 0, "r");
    (16839, 0, "M");
    (16840, 0, "u");
    (16841, 0, "t");
    (16842, 0, " ");
    (16843, 0, "i");
    (16844, 0, "m");
    (16845, 0, "e");
    (16846, 0, "p");
    (16847, 0, "l");
    (16848, 0, "m");
    (16849, 0, "e");
    (16843, 7, "i");
    (16844, 0, "m");
    (16845, 0, "p");
    (16846, 0, "l");
    (16847, 0, "e");
    (16848, 0, "m");
    (16849, 0, "e");
    (16850, 0, "n");
    (16851, 0, "t");
    (16852, 0, "a");
    (16853, 0, "t");
    (16854, 0, "i");
    (16855, 0, "o");
    (16856, 0, "n");
    (16857, 0, ".");
    (17163, 0, " ");
    (17164, 0, "a");
    (17165, 0, "s");
    (17166, 0, " ");
    (17167, 0, "*");
    (17168, 0, "m");
    (17169, 0, "u");
    (17170, 0, "t");
    (17171, 0, " ");
    (17172, 0, "_");
    (17163, 10, "");
    (17114, 0, "m");
    (17115, 0, "u");
    (17116, 0, "t");
    (17117, 0, ")");
    (17117, 1, "");
    (17117, 0, ")");
    (17117, 1, "");
    (17117, 0, "_");
    (17247, 10, "");
    (17420, 4, "");
    (17420, 0, "i");
    (17421, 0, "f");
    (17422, 0, " ");
    (17423, 0, "s");
    (17424, 0, "e");
    (17425, 0, "l");
    (17426, 0, "f");
    (17427, 0, ".");
    (17428, 0, "p");
    (17429, 0, "t");
    (17430, 0, "r");
    (17431, 0, " ");
    (17432, 0, "=");
    (17433, 0, "=");
    (17434, 0, " ");
    (17435, 0, "e");
    (17436, 0, "n");
    (17437, 0, "d");
    (17438, 0, " ");
    (17439, 0, "{");
    (17440, 0, " ");
    (17441, 0, "N");
    (17442, 0, "o");
    (17443, 0, "n");
    (17444, 0, "e");
    (17445, 0, " ");
    (17446, 0, "}");
    (17447, 0, " ");
    (17440, 1, "");
    (17440, 0, "\n            ");
    (17458, 1, "");
    (17457, 1, "");
    (17457, 0, "\n            ");
    (17458, 12, "        }");
    (17467, 0, " ");
    (17468, 0, "e");
    (17469, 0, "l");
    (17470, 0, "s");
    (17471, 0, "e");
    (17472, 0, " ");
    (17473, 0, "{");
    (17474, 0, "\n            ");
    (17487, 1, "\n            ");
    (17488, 12, "        }");
    (17487, 0, "    ");
    (17487, 4, "");
    (17487, 0, "S");
    (17488, 0, "o");
    (17489, 0, "m");
    (17490, 0, "e");
    (17491, 0, "(");
    (17492, 0, "p");
    (17493, 0, "t");
    (17494, 0, "r");
    (17495, 0, ".");
    (17435, 0, "s");
    (17436, 0, "e");
    (17437, 0, "l");
    (17438, 0, "f");
    (17439, 0, ".");
    (17492, 0, "// ");
    (17504, 0, "\n                ");
    (17505, 16, "            ");
    (17517, 0, "N");
    (17518, 0, "o");
    (17519, 0, "n");
    (17520, 0, "e");
    (17431, 0, ".");
    (17432, 0, "a");
    (17433, 0, "s");
    (17434, 0, "_");
    (17432, 3, "as_ptr()");
    (17514, 16, "");
    (17513, 1, "");
    (17501, 3, "");
    (17506, 0, "s");
    (17507, 0, "e");
    (17508, 0, "l");
    (17509, 0, "f");
    (17510, 0, ".");
    (17515, 0, "r");
    (17516, 0, "e");
    (17517, 0, "a");
    (17518, 0, "d");
    (17519, 0, "(");
    (17520, 0, ")");
    (17521, 0, ")");
    (17515, 0, "a");
    (17516, 0, "s");
    (17517, 0, "_");
    (17518, 0, "p");
    (17519, 0, "r");
    (17519, 1, "");
    (17519, 0, "t");
    (17520, 0, "r");
    (17521, 0, "(");
    (17522, 0, ")");
    (17523, 0, ",");
    (17524, 0, ".");
    (17524, 1, "");
    (17523, 1, "");
    (17523, 0, ".");
    (17369, 0, "u");
    (17370, 0, "n");
    (17371, 0, "s");
    (17372, 0, "a");
    (17373, 0, "f");
    (17374, 0, "e");
    (17375, 0, " ");
    (17375, 1, "");
    (17369, 6, "");
    (17369, 0, "unsafe");
    (17375, 0, " ");
    (17375, 1, "");
    (17369, 6, "");
    (16799, 0, "'");
    (16800, 0, "a");
    (16801, 0, ",");
    (16802, 0, " ");
    (16803, 1, "");
    (16803, 0, "C");
    (16804, 0, ":");
    (16805, 0, ":");
    (16805, 1, "");
    (16805, 0, " ");
    (16806, 0, "C");
    (16807, 0, "o");
    (16808, 0, "n");
    (16808, 1, "");
    (16807, 1, "");
    (16806, 1, "");
    (16806, 0, "L");
    (16807, 0, "i");
    (16808, 0, "s");
    (16809, 0, "t");
    (16810, 0, "C");
    (16806, 5, "ListConfig");
    (16892, 1, "");
    (16892, 0, "C");
    (16893, 0, ":");
    (16894, 0, ":");
    (16895, 0, "I");
    (16896, 0, "t");
    (16897, 0, "e");
    (16898, 0, "m");
    (16916, 1, "");
    (16916, 0, "C::Item");
    (16969, 3, "");
    (17002, 0, "<");
    (17003, 0, "C");
    (17004, 0, ">");
    (17297, 0, ",");
    (17298, 0, "\n                ");
    (17315, 0, "_");
    (17316, 0, "m");
    (17317, 0, "a");
    (17318, 0, "r");
    (17319, 0, "k");
    (17315, 5, "_marker");
    (17322, 0, ":");
    (17323, 0, " ");
    (17324, 0, "P");
    (17325, 0, "h");
    (17326, 0, "a");
    (17324, 3, "PhantomData");
    (17015, 0, "'");
    (17016, 0, "a");
    (17017, 0, ",");
    (17018, 0, " ");
    (17019, 8, "C: ListConfig");
    (17050, 1, "");
    (17050, 0, "C");
    (17089, 1, "");
    (17089, 0, "C");
    (17090, 0, ":");
    (17091, 0, ":");
    (17092, 0, "I");
    (17093, 0, "t");
    (17094, 0, "e");
    (17095, 0, "m");
    (17050, 0, "'");
    (17051, 0, "a");
    (17052, 0, ",");
    (17053, 0, " ");
    (17388, 8, "impl<'a, C: ListConfig> ");
    (17441, 0, "'");
    (17442, 0, "a");
    (17443, 0, ",");
    (17444, 0, " ");
    (17445, 0, "C");
    (17446, 1, "");
    (17466, 1, "");
    (17466, 0, "C");
    (17467, 0, ":");
    (17468, 0, ":");
    (17469, 0, "I");
    (17470, 0, "t");
    (17471, 0, "e");
    (17472, 0, "m");
    (16929, 35, "");
    (16925, 4, "");
    (16924, 1, "");
    (40352, 6, "");
    (40351, 1, "");
    (40350, 1, "");
    (40350, 0, "s");
    (40341, 0, " ");
    (40342, 0, "U");
    (40343, 0, "n");
    (40344, 0, "i");
    (40345, 0, "n");
    (40346, 0, "i");
    (40342, 5, "UninitOwnedIter");
    (40357, 0, "<");
    (40358, 0, "C");
    (40359, 0, ">");
    (40359, 1, "");
    (40358, 1, "");
    (40357, 1, "");
    (40356, 1, "");
    (40356, 0, ".");
    (40357, 0, "f");
    (40358, 0, "r");
    (40359, 0, "o");
    (40360, 0, "m");
    (40361, 0, "_");
    (40362, 0, "s");
    (40363, 0, "l");
    (40364, 0, "i");
    (40365, 0, "c");
    (40366, 0, "e");
    (40367, 0, "(");
    (40368, 1, "");
    (40377, 0, ")");
    (40342, 14, "UninitOwnedIter");
    (40357, 1, "");
    (40357, 0, ":");
    (40358, 0, ":");
    (30288, 1, "");
    (30288, 0, "(");
    (30293, 0, " ");
    (30294, 0, "a");
    (30295, 0, "s");
    (30296, 0, " ");
    (30297, 0, "*");
    (30298, 0, "m");
    (30299, 0, "u");
    (30300, 0, "t");
    (30301, 0, " ");
    (30302, 0, "_");
    (30303, 0, "(");
    (30303, 1, "");
    (30303, 0, ")");
    (30304, 0, ".");
    (30305, 0, "w");
    (30306, 0, "r");
    (30307, 0, "i");
    (30308, 0, "t");
    (30309, 0, "e");
    (30310, 0, "(");
    (30311, 1, "");
    (30311, 1, "");
    (30311, 1, "");
    (30315, 0, ")");
    (30317, 0, " ");
    (30318, 0, "/");
    (30319, 0, "/");
    (30320, 0, " ");
    (30321, 0, "N");
    (30321, 1, "");
    (30321, 0, "D");
    (30322, 0, "o");
    (30323, 0, " ");
    (30324, 0, "n");
    (30325, 0, "o");
    (30326, 0, "t");
    (30327, 0, " ");
    (30328, 0, "c");
    (30329, 0, "a");
    (30330, 0, "l");
    (30331, 0, "l");
    (30332, 0, " ");
    (30333, 0, "d");
    (30334, 0, "r");
    (30335, 0, "a");
    (30335, 1, "");
    (30335, 0, "o");
    (30336, 0, "p");
    (30337, 0, "(");
    (30338, 0, ")");
    (30339, 0, " ");
    (30340, 0, "o");
    (30341, 0, "n");
    (30342, 0, " ");
    (30343, 0, "c");
    (30344, 0, "o");
    (30345, 0, "n");
    (30346, 0, "t");
    (30343, 4, "j");
    (30344, 0, "u");
    (30345, 0, "n");
    (30346, 0, "k");
    (30347, 0, ".");
    (30302, 1, "");
    (30302, 0, "C");
    (30303, 0, ":");
    (30304, 0, ":");
    (30305, 0, "I");
    (30306, 0, "t");
    (30307, 0, "e");
    (30308, 0, "m");
    (30293, 17, "");
    (30288, 1, "");
    (30288, 0, "(");
    (30293, 0, " as *mut C::Item)");
    ( 30276,
      0,
      "            (slot as *mut C::Item).write(item); // Do not call drop() \
       on junk.\n" );
    (30367, 0, "// ");
    (30288, 22, "");
    (30288, 0, "*");
    (30289, 13, "");
    (30289, 0, "s");
    (30290, 0, "l");
    (30291, 0, "o");
    (30292, 0, "t");
    (30293, 0, " ");
    (30294, 0, "=");
    (30295, 0, " ");
    (30296, 0, "i");
    (30297, 0, "t");
    (30298, 0, "e");
    (30299, 0, "m");
    (30300, 0, ";");
    (30301, 31, "");
    (30215, 60, "");
    (30214, 1, "");
    (30321, 1, "");
    (30321, 0, "?");
    (40363, 0, "&");
    (40364, 0, "m");
    (40365, 0, "u");
    (40366, 0, "t");
    (40367, 0, " ");
    (40383, 0, "<");
    (40384, 0, "C");
    (40385, 0, ">");
    (40383, 0, ":");
    (40384, 0, ":");
    (42652, 0, "// ");
    (42631, 0, "\n                    ");
    ( 42652,
      0,
      "                ptr::copy(\n\
      \                    &c[item_idx],\n\
      \                    &mut c[item_idx + num_inserted_items],\n\
      \                    (*e).num_items as usize - item_idx);" );
    (42772, 20, "                        ");
    (42713, 20, "                        ");
    (42679, 20, "                        ");
    (42632, 36, "                    ");
    ( 42632,
      192,
      "                    ptr::copy(\n\
      \                        &c[leading_bytes + removed_bytes],\n\
      \                        &mut c[leading_bytes],\n\
      \                        trailing_bytes);" );
    (42690, 29, "item_idx + removed_here");
    (42690, 23, "leading_bytes + removed_bytes");
    (42690, 29, "item_idx + removed_here");
    (42747, 13, "i");
    (42748, 0, "t");
    (42749, 0, "e");
    (42750, 0, "m");
    (42751, 0, "_");
    (42752, 0, "i");
    (42747, 6, "item_idx");
    (42661, 0, "_");
    (42661, 1, "");
    (42782, 14, "t");
    (42783, 0, "r");
    (42784, 0, "a");
    (42785, 0, "i");
    (42786, 0, "l");
    (42787, 0, "i");
    (42788, 0, "n");
    (42782, 7, "trailing_items");
    (46554, 34, ", I: ExactSizeIterator<Item=C::Item>");
    (46554, 36, ", mut inserted_content: &[C::Item]");
    (46668, 0, ",");
    (46669, 0, " ");
    (46670, 0, ", I: ExactSizeIterator<Item=C::Item>");
    (46670, 36, "");
    (46669, 1, "");
    (46668, 1, "");
    (46668, 0, ", I: ExactSizeIterator<Item=C::Item>");
    (46493, 0, ",");
    (46494, 0, " ");
    (46495, 0, "I");
    (46581, 10, "");
    (46581, 0, "&");
    (46582, 0, "M");
    (46582, 1, "");
    (46582, 0, "m");
    (46583, 0, "u");
    (46584, 0, "t");
    (46585, 0, " ");
    (46586, 0, "I");
    (47895, 0, "// ");
    (47882, 0, "\n            ");
    ( 47895,
      0,
      "        for (slot, item) in \
       new_node.items[..num_items].iter_mut().zip(contents) {\n\
      \            *slot = item;\n\
      \            // (slot as *mut C::Item).write(item); // Do not call \
       drop() on junk?\n\
      \        }\n" );
    (48096, 0, "    ");
    (48086, 8, "            ");
    (48004, 12, "                ");
    (47978, 12, "                ");
    (47883, 20, "            ");
    (47958, 8, "i");
    (47959, 0, "n");
    (47960, 0, "s");
    (47961, 0, "e");
    (47962, 0, "r");
    (47963, 0, "t");
    (47964, 0, "e");
    (47965, 0, "d");
    (47966, 0, "_");
    (47967, 0, "c");
    (47968, 0, "o");
    (47969, 0, "n");
    (47970, 0, "t");
    (47971, 0, "e");
    (47972, 0, "n");
    (47973, 0, "t");
    (47915, 27, "");
    (47915, 0, "o");
    (47916, 0, "l");
    (47917, 0, "d");
    (47918, 0, "_");
    (47919, 0, "i");
    (47920, 0, "t");
    (47921, 0, "e");
    (47922, 0, "m");
    (47923, 0, "s");
    (47990, 85, "");
    (47989, 1, "");
    (47989, 0, "/");
    (47990, 0, " ");
    (47990, 1, "");
    (47989, 1, "");
    (47989, 0, " ");
    (47990, 0, "/");
    (47991, 0, "/");
    (47992, 0, " ");
    (47993, 0, "I");
    (47994, 0, "n");
    (47994, 1, "");
    (47993, 1, "");
    (47992, 1, "");
    (47991, 1, "");
    (47991, 0, "/");
    (47992, 0, " ");
    (47993, 0, "T");
    (47994, 0, "i");
    (47995, 0, "s");
    (47995, 1, "");
    (47994, 1, "");
    (47994, 0, "h");
    (47995, 0, "i");
    (47996, 0, "s");
    (47997, 0, " ");
    (47998, 0, "d");
    (47999, 0, "r");
    (48000, 0, "o");
    (48001, 0, "p");
    (48002, 0, "s");
    (48003, 0, " ");
    (48004, 0, "t");
    (48005, 0, "h");
    (48006, 0, "e");
    (48007, 0, " ");
    (48008, 0, "o");
    (48009, 0, "l");
    (48010, 0, "d");
    (48011, 0, " ");
    (48008, 4, "r");
    (48009, 0, "e");
    (48010, 0, "m");
    (48011, 0, "o");
    (48012, 0, "v");
    (48013, 0, "e");
    (48014, 0, "d");
    (48015, 0, " ");
    (48016, 0, "c");
    (48017, 0, "o");
    (48018, 0, "n");
    (48019, 0, "t");
    (48020, 0, "e");
    (48021, 0, "n");
    (48022, 0, "t");
    (48023, 0, ".");
    (47645, 162, "");
    (47877, 4, "\n            ");
    ( 47890,
      0,
      "            let new_usersize = C::userlen_of_slice(new_items);\n\
      \            let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\n" );
    (47878, 24, "            ");
    (47573, 71, "");
    ( 47807,
      0,
      "            let new_items = &inserted_content[0..replaced_items_here];\n"
    );
    (47836, 16, "");
    (47836, 0, "inserted_content");
    (47836, 16, "");
    (47836, 0, "(");
    (47837, 0, "*");
    (47837, 1, "");
    (47836, 1, "");
    (47836, 0, "(");
    (47837, 0, "*");
    (47838, 0, "e");
    (47839, 0, ")");
    (47840, 0, ".");
    (47841, 0, "i");
    (47842, 0, "t");
    (47843, 0, "e");
    (47844, 0, "m");
    (47845, 0, "s");
    (47835, 36, "o");
    (47836, 0, "d");
    (47835, 2, "old_items");
    (47844, 0, ";");
    (47844, 1, "");
    (47835, 9, "od");
    (47835, 2, "&(*e).items[0..replaced_items_here];");
    (47836, 10, "");
    (47836, 0, "(*");
    (47836, 2, "");
    (47836, 0, "inserted_content");
    (47807, 71, "");
    ( 47573,
      0,
      "            let new_items = &inserted_content[0..replaced_items_here];\n"
    );
    (47878, 12, "                        ");
    (47890, 162, "");
    (47877, 13, "    ");
    ( 47645,
      0,
      "            let new_usersize = C::userlen_of_slice(new_items);\n\
      \            let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\n" );
    (47645, 162, "");
    (47877, 4, "\n            ");
    ( 47890,
      0,
      "            let new_usersize = C::userlen_of_slice(new_items);\n\
      \            let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\n" );
    (47878, 24, "            ");
    (47573, 71, "");
    ( 47807,
      0,
      "            let new_items = &inserted_content[0..replaced_items_here];\n"
    );
    (47836, 16, "");
    (47836, 0, "(*");
    (47836, 2, "");
    (47836, 0, "(*e).items");
    (47835, 36, "od");
    (47835, 2, "old_items");
    (47844, 0, ";");
    (47572, 0, "\n            ");
    (47585, 0, "l");
    (47586, 0, "e");
    (47587, 0, "t");
    (47588, 0, " ");
    (47589, 0, "o");
    (47590, 0, "l");
    (47591, 0, "d");
    (47592, 0, "_");
    (47593, 0, "s");
    (47594, 0, "i");
    (47594, 1, "");
    (47593, 1, "");
    (47592, 1, "");
    (47592, 0, "_");
    (47593, 0, "u");
    (47594, 0, "s");
    (47595, 0, "e");
    (47596, 0, "r");
    (47597, 0, "s");
    (47598, 0, "i");
    (47599, 0, "z");
    (47600, 0, "e");
    (47601, 0, " ");
    (47602, 0, "=");
    (47603, 0, " ");
    (47604, 0, "C::userlen_of_slice(old_items)");
    (47634, 0, ";");
    (48029, 30, "o");
    (48030, 0, "l");
    (48031, 0, "d");
    (48032, 0, "_");
    (48033, 0, "u");
    (48029, 5, "old_usersize");
    (48051, 1, "");
    (47907, 0, "t");
    (47905, 1, "");
    (47901, 3, "");
    (47898, 2, "");
    (47754, 0, "t");
    (47752, 1, "");
    (47748, 3, "");
    (47745, 2, "");
    (47633, 0, "t");
    (47631, 1, "");
    (47627, 3, "");
    (47624, 2, "");
    (47517, 0, "t");
    (47515, 1, "");
    (47511, 3, "");
    (47508, 2, "");
    (48828, 3, "");
    (48824, 3, "s");
    (48822, 1, "d");
    (47946, 3, "");
    (47942, 3, "s");
    (47940, 1, "d");
    (47877, 3, "");
    (47873, 3, "s");
    (47871, 1, "d");
    (47855, 28, "");
    (47854, 1, "");
    (48312, 0, "// ");
    (47018, 0, "\n            ");
    (47031, 0, "d");
    (47032, 0, "e");
    (47033, 0, "b");
    (47034, 0, "u");
    (47031, 4, "debug_assert!");
    (47044, 0, "(");
    (47045, 0, "i");
    (47046, 0, "n");
    (47047, 0, "s");
    (47048, 0, "e");
    (47049, 0, "r");
    (47050, 0, "t");
    (47051, 0, "e");
    (47052, 0, "d");
    (47053, 0, "_");
    (47054, 0, "c");
    (47055, 0, "o");
    (47056, 0, "n");
    (47045, 12, "inserted_content");
    (47061, 0, ".");
    (47062, 0, "l");
    (47063, 0, "e");
    (47064, 0, "n");
    (47065, 0, "(");
    (47066, 0, ")");
    (47067, 0, " ");
    (47068, 0, ">");
    (47069, 0, "=");
    (47070, 0, " ");
    (47071, 0, "r");
    (47072, 0, "e");
    (47073, 0, "p");
    (47074, 0, "l");
    (47075, 0, "a");
    (47076, 0, "c");
    (47071, 6, "replaced_items");
    (47085, 0, ")");
    (47086, 0, ";");
    (49937, 0, " ");
    (49938, 0, "w");
    (49939, 0, "h");
    (49940, 0, "e");
    (49941, 0, "r");
    (49942, 0, "e");
    (49943, 0, " ");
    (49944, 0, "C");
    (49945, 0, ":");
    (49946, 0, ":");
    (49947, 0, "I");
    (49948, 0, "t");
    (49949, 0, "e");
    (49950, 0, "m");
    (49951, 0, ":");
    (49952, 0, " ");
    (49953, 0, "C");
    (49954, 0, "l");
    (49955, 0, "o");
    (49956, 0, "n");
    (49957, 0, "e");
    (49953, 5, "C");
    (49954, 0, "o");
    (49955, 0, "p");
    (49956, 0, "y");
    (50248, 0, ".");
    (50249, 0, "i");
    (50250, 0, "n");
    (50251, 0, "t");
    (50252, 0, "o");
    (50249, 4, "");
    (50248, 1, "");
    (50248, 0, ".");
    (50249, 0, "i");
    (50250, 0, "t");
    (50251, 0, "e");
    (50252, 0, "r");
    (50253, 0, "(");
    (50254, 0, ")");
    (50255, 0, ".");
    (50256, 0, "c");
    (50257, 0, "l");
    (50258, 0, "o");
    (50259, 0, "n");
    (50260, 0, "e");
    (50261, 0, "d");
    (50262, 0, "(");
    (50263, 0, ")");
    (50256, 6, "c");
    (50257, 0, "o");
    (50258, 0, "p");
    (50259, 0, "i");
    (50260, 0, "e");
    (50261, 0, "d");
    (50232, 0, "&");
    (50233, 0, "m");
    (50234, 0, "u");
    (50235, 0, "t");
    (50236, 0, " ");
    (50634, 0, " ");
    (50635, 0, "w");
    (50636, 0, "h");
    (50637, 0, "e");
    (50638, 0, "r");
    (50639, 0, "e");
    (50640, 0, " ");
    (50641, 0, "C");
    (50642, 0, ":");
    (50643, 0, ":");
    (50644, 0, " ");
    (50644, 1, "");
    (50644, 0, "I");
    (50645, 0, "t");
    (50646, 0, "e");
    (50647, 0, "m");
    (50648, 0, ":");
    (50649, 0, " ");
    (50650, 0, "C");
    (50651, 0, "o");
    (50652, 0, "p");
    (50653, 0, "y");
    (50923, 8, "&mut inserted_content.iter().copied()");
    (50928, 16, "c");
    (50929, 0, "o");
    (50930, 0, "n");
    (50931, 0, "t");
    (50932, 0, "e");
    (50933, 0, "n");
    (50934, 0, "t");
    (50935, 0, "s");
    (51502, 1, "");
    (51501, 1, "");
    (51501, 0, "o");
    (51502, 0, "n");
    (51503, 0, "c");
    (51504, 0, "e");
    (51505, 0, "(");
    (51511, 1, "");
    (51511, 0, ")");
    (51501, 0, "s");
    (51502, 0, "t");
    (51503, 0, "d");
    (51504, 0, ":");
    (51505, 0, ":");
    (51506, 0, "i");
    (51507, 0, "t");
    (51508, 0, "e");
    (51509, 0, "r");
    (51510, 0, ":");
    (51511, 0, ":");
    (51501, 0, "&");
    (51502, 0, "m");
    (51503, 0, "u");
    (51504, 0, "t");
    (51505, 0, " ");
    (51506, 11, "");
    (51506, 0, "i");
    (51507, 0, "t");
    (51508, 0, "e");
    (51509, 0, "r");
    (51510, 0, ":");
    (51511, 0, ":");
    (923, 0, "\n");
    (924, 0, "u");
    (925, 0, "s");
    (926, 0, "e");
    (927, 0, " ");
    (928, 0, "s");
    (929, 0, "t");
    (930, 0, "d");
    (931, 0, ":");
    (932, 0, ":");
    (933, 0, "i");
    (934, 0, "t");
    (935, 0, "e");
    (936, 0, "r");
    (937, 0, ";");
    (18755, 0, " ");
    (18756, 0, "w");
    (18757, 0, "h");
    (18758, 0, "e");
    (18759, 0, "r");
    (18760, 0, "e");
    (18761, 0, " ");
    (18762, 0, "C");
    (18763, 0, ":");
    (18764, 0, ":");
    (18765, 0, "I");
    (18766, 0, "t");
    (18767, 0, "e");
    (18768, 0, "m");
    (18769, 0, ":");
    (18770, 0, " ");
    (18771, 0, "C");
    (18772, 0, "o");
    (18773, 0, "p");
    (18774, 0, "y");
    (51632, 8, "&mut contents.iter().copied()");
    (52022, 6, "&mut iter::once(start)");
    (52038, 5, "e");
    (52039, 0, "n");
    (52040, 0, "d");
    (53652, 0, " ");
    (53653, 0, "w");
    (53654, 0, "h");
    (53655, 0, "e");
    (53656, 0, "r");
    (53657, 0, "e");
    (53658, 0, " ");
    (53659, 0, "C");
    (53660, 0, ":");
    (53661, 0, ":");
    (53662, 0, "I");
    (53663, 0, "t");
    (53664, 0, "e");
    (53665, 0, "m");
    (53666, 0, ":");
    (53667, 0, " ");
    (53668, 0, "C");
    (53669, 0, "o");
    (53670, 0, "p");
    (53671, 0, "y");
    (53818, 0, " where C::Item: Copy");
    (53763, 0, "\n");
    (53764, 0, "/");
    (53765, 0, "/");
    (53766, 0, " ");
    (53767, 0, "T");
    (53768, 0, "O");
    (53769, 0, "D");
    (53770, 0, "O");
    (53771, 0, ":");
    (53772, 0, " ");
    (53773, 0, "R");
    (53774, 0, "e");
    (53775, 0, "m");
    (53776, 0, "o");
    (53777, 0, "v");
    (53778, 0, "e");
    (53779, 0, " ");
    (53780, 0, "I");
    (53781, 0, "t");
    (53782, 0, "e");
    (53783, 0, "m");
    (53784, 0, ":");
    (53785, 0, " ");
    (53786, 0, "C");
    (53787, 0, "o");
    (53788, 0, "p");
    (53789, 0, "y");
    (53790, 0, " ");
    (53791, 0, "c");
    (53792, 0, "o");
    (53793, 0, "n");
    (53794, 0, "s");
    (53795, 0, "t");
    (53796, 0, "r");
    (53797, 0, "a");
    (53798, 0, "i");
    (53799, 0, "n");
    (53800, 0, "t");
    (53801, 0, " ");
    (53802, 0, "h");
    (53803, 0, "e");
    (53804, 0, "r");
    (53805, 0, "e");
    (53806, 0, ".");
    (54104, 0, ":");
    (54105, 0, " ");
    (54106, 0, "V");
    (54107, 0, "e");
    (54108, 0, "c");
    (54109, 0, "<");
    (54110, 0, "<");
    (54110, 1, "");
    (54110, 0, "C");
    (54111, 0, ":");
    (54112, 0, ":");
    (54113, 0, "I");
    (54114, 0, "t");
    (54115, 0, "e");
    (54116, 0, "m");
    (54117, 0, ">");
    (54110, 8, "");
    (54110, 0, "<");
    (54105, 6, "");
    (54104, 1, "");
    (54042, 0, " ");
    (54043, 0, "w");
    (54044, 0, "h");
    (54045, 0, "e");
    (54046, 0, "r");
    (54047, 0, "e");
    (54048, 0, " ");
    (54049, 0, "C");
    (54050, 0, ":");
    (54051, 0, ":");
    (54052, 0, "I");
    (54053, 0, "t");
    (54054, 0, "e");
    (54055, 0, "m");
    (54056, 0, ":");
    (54057, 0, " ");
    (54058, 0, "C");
    (54059, 0, "o");
    (54060, 0, "p");
    (54061, 0, "y");
    (54124, 0, ":");
    (54125, 0, " ");
    (54126, 0, "V");
    (54127, 0, "e");
    (54128, 0, "c");
    (54129, 0, "<");
    (54130, 0, "<");
    (54130, 1, "");
    (54130, 0, "C");
    (54131, 0, ":");
    (54132, 0, ":");
    (54133, 0, "I");
    (54134, 0, "t");
    (54135, 0, "e");
    (54136, 0, "m");
    (54137, 0, ">");
    (5385, 0, "M");
    (5386, 0, "a");
    (5387, 0, "y");
    (5388, 0, "b");
    (5389, 0, "e");
    (5390, 0, "U");
    (5391, 0, "n");
    (5392, 0, "i");
    (5393, 0, "n");
    (5394, 0, "i");
    (5395, 0, "t");
    (5396, 0, "<");
    (5404, 0, ">");
    (9791, 18, "");
    (9791, 0, "M");
    (9792, 0, "a");
    (9793, 0, "y");
    (9794, 0, "b");
    (9795, 0, "e");
    (9791, 5, "MaybeUninit");
    (9802, 0, ":");
    (9803, 0, ":");
    (9804, 0, "u");
    (9805, 0, "n");
    (9806, 0, "i");
    (9806, 1, "");
    (9806, 0, "i");
    (9807, 0, "n");
    (9808, 0, "i");
    (9809, 0, "t");
    (9810, 0, "(");
    (9811, 0, ")");
    (10392, 0, "\n        ");
    (10401, 0, "\n        ");
    (10393, 8, "");
    (10394, 8, "");
    (10393, 1, "");
    (10393, 0, "        ");
    (10401, 0, "/");
    (10402, 0, "/");
    (10403, 0, " ");
    (10404, 0, "T");
    (10405, 0, "O");
    (10406, 0, "D");
    (10407, 0, "O");
    (10408, 0, ":");
    (10409, 0, " ");
    (10410, 0, "U");
    (10411, 0, "s");
    (10412, 0, "e");
    (10413, 0, " ");
    (10414, 0, "U");
    (10415, 0, "n");
    (10416, 0, "i");
    (10417, 0, "n");
    (10418, 0, "i");
    (10419, 0, "t");
    (10414, 6, "M");
    (10415, 0, "a");
    (10416, 0, "y");
    (10417, 0, "b");
    (10418, 0, "e");
    (10419, 0, "U");
    (10420, 0, "n");
    (10421, 0, "i");
    (10422, 0, "n");
    (10423, 0, "i");
    (10424, 0, "t");
    (10425, 0, ":");
    (10426, 0, ":");
    (10427, 0, "slice_get_ref");
    (10440, 0, " ");
    (10441, 0, "w");
    (10442, 0, "h");
    (10443, 0, "e");
    (10444, 0, "n");
    (10445, 0, " ");
    (10446, 0, "i");
    (10447, 0, "t");
    (10448, 0, "s");
    (10449, 0, " ");
    (10449, 1, "");
    (10448, 1, "");
    (10448, 0, " ");
    (10449, 0, "l");
    (10450, 0, "a");
    (10451, 0, "n");
    (10452, 0, "d");
    (10453, 0, "s");
    (10454, 0, ".");
    (10455, 0, "\n        ");
    (10464, 0, "\n        ");
    (10456, 8, "");
    ( 10465,
      0,
      "        // SAFETY: casting slice to a `*const [T]` is safe since the \
       caller guarantees that\n\
      \        // `slice` is initialized, and`MaybeUninit` is guaranteed to \
       have the same layout as `T`.\n\
      \        // The pointer obtained is valid since it refers to memory \
       owned by `slice` which is a\n\
      \        // reference and thus guaranteed to be valid for reads.\n\
      \        unsafe { &*(slice as *const [Self] as *const [T]) }" );
    (10457, 16, "            ");
    (10457, 12, "        ");
    (10455, 0, " ");
    (10456, 0, "T");
    (10457, 0, "h");
    (10458, 0, "i");
    (10459, 0, "s");
    (10460, 0, " ");
    (10461, 0, "c");
    (10462, 0, "o");
    (10463, 0, "d");
    (10464, 0, "e");
    (10465, 0, " ");
    (10466, 0, "i");
    (10467, 0, "s");
    (10468, 0, " ");
    (10469, 0, "s");
    (10470, 0, "t");
    (10471, 0, "i");
    (10472, 0, "l");
    (10472, 1, "");
    (10471, 1, "");
    (10471, 0, "o");
    (10472, 0, "l");
    (10473, 0, "e");
    (10474, 0, "d");
    (10475, 0, " ");
    (10475, 1, "");
    (10474, 1, "");
    (10474, 0, "n");
    (10475, 0, " ");
    (10476, 0, "f");
    (10477, 0, "r");
    (10478, 0, "o");
    (10479, 0, "m");
    (10480, 0, " ");
    (10481, 0, "t");
    (10482, 0, "h");
    (10483, 0, "a");
    (10484, 0, "t");
    (10485, 0, " ");
    (10486, 0, "i");
    (10487, 0, "m");
    (10488, 0, "p");
    (10489, 0, "l");
    (10490, 0, "e");
    (10491, 0, "m");
    (10492, 0, "e");
    (10493, 0, "n");
    (10494, 0, "t");
    (10495, 0, "a");
    (10496, 0, "t");
    (10497, 0, "i");
    (10498, 0, "o");
    (10499, 0, "n");
    (10500, 0, ".");
    (10920, 38, "");
    (10860, 0, "\n        ");
    (10860, 0, "l");
    (10861, 0, "e");
    (10862, 0, "t");
    (10863, 0, " ");
    (10864, 0, "s");
    (10865, 0, "l");
    (10866, 0, "i");
    (10867, 0, "c");
    (10868, 0, "e");
    (10869, 0, " ");
    (10870, 0, "=");
    (10871, 0, " ");
    (10872, 0, "&self.items[..self.num_items as usize]");
    (10910, 0, ";");
    (10976, 4, "");
    (10972, 4, "");
    (10971, 1, "");
    (10949, 4, "C::Item");
    (10949, 7, "Self");
    (10966, 1, "C::Item");
    (10949, 4, "");
    (10949, 0, "M");
    (10950, 0, "a");
    (10951, 0, "y");
    (10949, 3, "MaybeUninit");
    (10960, 0, "<");
    (10961, 0, "C::Item");
    (10968, 0, ">");
    (16021, 0, "*");
    (16022, 0, "(");
    (16065, 0, ".");
    (16066, 0, "a");
    (16067, 0, "s");
    (16068, 0, "_");
    (16069, 0, "m");
    (16070, 0, "u");
    (16071, 0, "t");
    (16072, 0, "_");
    (16072, 1, "");
    (16071, 1, "");
    (16070, 1, "");
    (16069, 1, "");
    (16068, 1, "");
    (16068, 0, "_");
    (16069, 0, "p");
    (16070, 0, "t");
    (16071, 0, "r");
    (16072, 0, "(");
    (16073, 0, ")");
    (16074, 0, ")");
    (16011, 0, "\n        ");
    (16020, 0, "/");
    (16021, 0, "/");
    (16022, 0, " ");
    (16023, 0, "T");
    (16024, 0, "h");
    (16025, 0, "i");
    (16026, 0, "s");
    (16027, 0, " ");
    (16028, 0, "i");
    (16029, 0, "s");
    (16030, 0, " ");
    (16031, 0, "s");
    (16032, 0, "o");
    (16033, 0, " ");
    (16034, 0, "g");
    (16035, 0, "r");
    (16036, 0, "o");
    (16037, 0, "s");
    (16038, 0, "s");
    (16039, 0, ".");
    (16023, 17, "S");
    (16024, 0, "o");
    (16025, 0, " ");
    (16026, 0, "g");
    (16027, 0, "o");
    (16028, 0, "r");
    (16028, 1, "");
    (16027, 1, "");
    (16027, 0, "r");
    (16028, 0, "o");
    (16029, 0, "s");
    (16030, 0, "s");
    (16031, 0, ".");
    (16044, 18, "");
    (16044, 0, "n");
    (16045, 0, "o");
    (16046, 0, "d");
    (16047, 0, "e");
    (16032, 0, "\n        ");
    (16041, 0, "l");
    (16042, 0, "e");
    (16043, 0, "t");
    (16044, 0, " ");
    (16045, 0, "n");
    (16046, 0, "o");
    (16047, 0, "d");
    (16048, 0, "e");
    (16049, 0, " ");
    (16050, 0, "=");
    (16051, 0, " ");
    (16052, 0, "(*self.here_ptr())");
    (16070, 0, ";");
    (16052, 0, "&");
    (16053, 1, "");
    (16069, 1, "");
    (16070, 0, "\n        ");
    (16079, 0, "d");
    (16080, 0, "e");
    (16081, 0, "b");
    (16082, 0, "u");
    (16083, 0, "g");
    (16079, 5, "debug_assert!");
    (16092, 0, "(");
    (16093, 0, "n");
    (16094, 0, "o");
    (16095, 0, "d");
    (16096, 0, "e");
    (16097, 0, ".");
    (16098, 0, "n");
    (16099, 0, "u");
    (16100, 0, "m");
    (16101, 0, "_");
    (16102, 0, "i");
    (16103, 0, "t");
    (16098, 6, "num_items");
    (16107, 0, " ");
    (16108, 0, ">");
    (16109, 0, "=");
    (16110, 0, " ");
    (16111, 0, "s");
    (16112, 0, "e");
    (16113, 0, "l");
    (16114, 0, "f");
    (16115, 0, ".");
    (16116, 0, "l");
    (16117, 0, "o");
    (16118, 0, "c");
    (16119, 0, "a");
    (16120, 0, "l");
    (16116, 5, "local_index");
    (16127, 0, ")");
    (16128, 0, ";");
    (16127, 0, " ");
    (16128, 0, "a");
    (16129, 0, "s");
    (16130, 0, " ");
    (16131, 0, "u");
    (16132, 0, "s");
    (16133, 0, "i");
    (16134, 0, "z");
    (16135, 0, "e");
    (16127, 9, "");
    (16107, 0, " as usize");
    (16070, 0, "\n        ");
    (16071, 8, "");
    (16070, 1, "");
    (16012, 20, "");
    (16011, 1, "");
    (16049, 0, "\n        ");
    (16058, 0, "/");
    (16059, 0, "/");
    (16060, 0, " ");
    (16061, 0, "T");
    (16062, 0, "O");
    (16063, 0, "D");
    (16064, 0, "O");
    (16065, 0, ":");
    (16066, 0, " ");
    (16067, 0, "I");
    (16068, 0, "t");
    (16069, 0, " ");
    (16070, 0, "m");
    (16071, 0, "i");
    (16072, 0, "g");
    (16073, 0, "h");
    (16074, 0, "t");
    (16075, 0, " ");
    (16076, 0, "b");
    (16077, 0, "e");
    (16078, 0, " ");
    (16079, 0, "m");
    (16080, 0, "o");
    (16081, 0, "r");
    (16082, 0, "e");
    (16083, 0, " ");
    (16084, 0, "r");
    (16085, 0, "u");
    (16086, 0, "s");
    (16087, 0, "t");
    (16088, 0, "y");
    (16089, 0, " ");
    (16090, 0, "t");
    (16091, 0, "o");
    (16092, 0, " ");
    (16050, 43, "");
    (16049, 1, "");
    (18524, 36, "[MaybeUninit::uninit(); NODE_NUM_ITEMS]");
    (18310, 0, "\n");
    (18311, 0, "f");
    (18312, 0, "n");
    (18313, 0, " ");
    (18314, 0, "f");
    (18315, 0, "o");
    (18316, 0, "o");
    ( 18317,
      0,
      "pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n\
      \        unsafe { MaybeUninit::<[MaybeUninit<T>; \
       LEN]>::uninit().assume_init() }\n\
      \    }" );
    (18454, 4, "");
    (18374, 8, "    ");
    (18311, 10, "");
    (18326, 18, "");
    (18390, 3, "M");
    (18339, 3, "M");
    (18389, 0, "A");
    (18340, 0, "A");
    (18391, 0, "X");
    (18341, 0, "X");
    (18390, 3, "N");
    (18339, 3, "N");
    (18389, 0, "U");
    (18340, 0, "U");
    (18391, 0, "M");
    (18341, 0, "M");
    (18390, 3, "NODE_NUM_ITEMS");
    (18339, 3, "NODE_NUM_ITEMS");
    (18326, 0, "<");
    (18327, 0, "T");
    (18328, 0, ">");
    (18336, 4, "M");
    (18337, 0, "a");
    (18338, 0, "y");
    (18339, 0, "b");
    (18340, 0, "e");
    (18336, 5, "MaybeUninit");
    (18347, 0, "<");
    (18348, 0, "T");
    (18349, 0, ">");
    (18321, 0, "i");
    (18322, 0, "t");
    (18323, 0, "e");
    (18324, 0, "m");
    (18325, 0, "s");
    (18326, 0, "_");
    (18678, 39, "");
    (18678, 0, "u");
    (18679, 0, "n");
    (18680, 0, "i");
    (18681, 0, "n");
    (18678, 4, "uninit_items_array");
    (18696, 0, "(");
    (18697, 0, ")");
    (18310, 0, "\n");
    (18311, 0, "/");
    (18312, 0, "/");
    (18313, 0, " ");
    (18314, 0, "T");
    (18315, 0, "O");
    (18316, 0, "D");
    (18317, 0, "O");
    (18318, 0, ":");
    (18319, 0, " ");
    (18320, 0, "S");
    (18321, 0, "t");
    (18322, 0, "o");
    (18323, 0, "l");
    (18324, 0, "e");
    (18325, 0, "n");
    (18326, 0, " ");
    (18327, 0, "f");
    (18328, 0, "r");
    (18329, 0, "o");
    (18330, 0, "m");
    (18331, 0, " ");
    (18332, 0, "uninit_array");
    (18331, 0, " ");
    (18332, 0, "M");
    (18333, 0, "a");
    (18334, 0, "y");
    (18335, 0, "b");
    (18336, 0, "e");
    (18337, 0, "U");
    (18338, 0, "n");
    (18339, 0, "i");
    (18340, 0, "n");
    (18341, 0, "i");
    (18342, 0, "t");
    (18343, 0, ":");
    (18344, 0, ":");
    (18345, 1, "");
    (18357, 0, ".");
    (18358, 0, " ");
    (18359, 0, "R");
    (18359, 1, "");
    (18359, 0, "C");
    (18360, 0, "a");
    (18361, 0, "l");
    (18362, 0, "l");
    (18363, 0, " ");
    (18364, 0, "t");
    (18365, 0, "h");
    (18366, 0, "a");
    (18367, 0, "t");
    (18368, 0, " ");
    (18369, 0, "w");
    (18370, 0, "h");
    (18371, 0, "e");
    (18372, 0, "n");
    (18373, 0, " ");
    (18374, 0, "t");
    (18375, 0, "h");
    (18376, 0, "i");
    (18377, 0, "s");
    (18359, 19, "R");
    (18360, 0, "e");
    (18361, 0, "p");
    (18362, 0, "l");
    (18363, 0, "a");
    (18364, 0, "c");
    (18365, 0, "e");
    (18366, 0, " ");
    (18367, 0, "w");
    (18368, 0, "i");
    (18369, 0, "t");
    (18370, 0, "h");
    (18371, 0, " ");
    (18372, 0, "MaybeUninit::uninit_array");
    (18397, 0, " ");
    (18398, 0, "w");
    (18399, 0, "h");
    (18400, 0, "e");
    (18401, 0, "n");
    (18402, 0, " ");
    (18372, 13, "");
    (18372, 0, "t");
    (18373, 0, "h");
    (18374, 0, "e");
    (18375, 0, " ");
    (18376, 0, "r");
    (18377, 0, "e");
    (18378, 0, "a");
    (18379, 0, "l");
    (18380, 0, " ");
    (18399, 0, "s");
    (18400, 0, "t");
    (18401, 0, "a");
    (18402, 0, "b");
    (18403, 0, "l");
    (18404, 0, "e");
    (18405, 0, ".");
    (9790, 39, "uninit_items_array");
    (9808, 0, "(");
    (9809, 0, ")");
    (21795, 1, "");
    (21797, 30, "");
    (21796, 1, "");
    (21796, 0, ".");
    (21797, 0, "c");
    (21798, 0, "o");
    (21799, 0, "n");
    (21800, 0, "t");
    (21801, 0, "e");
    (21802, 0, "n");
    (21803, 0, "t");
    (21797, 7, "content_slice");
    (21810, 0, "(");
    (21811, 0, ")");
    (27339, 0, ".");
    (27339, 1, "");
    (27324, 0, "*");
    (27323, 0, "u");
    (27324, 0, "n");
    (27325, 0, "s");
    (27326, 0, "a");
    (27327, 0, "f");
    (27328, 0, "e");
    (27329, 0, " ");
    (27330, 0, "{");
    (27331, 0, " ");
    (27349, 0, ".");
    (27350, 0, "a");
    (27350, 1, "");
    (27350, 0, "a");
    (27351, 0, "s");
    (27352, 0, "_");
    (27350, 3, "as_ptr");
    (27356, 0, "(");
    (27357, 0, ")");
    (27358, 0, " ");
    (27359, 0, "}");
    (31156, 1, "");
    (31160, 0, ".");
    (31161, 0, "w");
    (31162, 0, "r");
    (31163, 0, "i");
    (31164, 0, "t");
    (31165, 0, "e");
    (31166, 0, "(");
    (31167, 1, "");
    (31167, 1, "");
    (31167, 1, "");
    (31171, 0, ")");
    (31160, 0, ".");
    (31161, 0, "a");
    (31162, 0, "s");
    (31163, 0, "_");
    (31164, 0, "m");
    (31165, 0, "u");
    (31166, 0, "t");
    (31167, 0, "_");
    (31161, 7, "as_mut_ptr");
    (31171, 0, "(");
    (31172, 0, ")");
    (31179, 0, "<");
    (31180, 0, "C");
    (31181, 0, ":");
    (31182, 0, ":");
    (31183, 0, "I");
    (31184, 0, "t");
    (31185, 0, "e");
    (31186, 0, "m");
    (31187, 0, ">");
    (31179, 0, ":");
    (31180, 0, ":");
    (31179, 11, "");
    (31084, 0, ":");
    (31085, 0, " ");
    (31086, 0, "C");
    (31087, 0, ":");
    (31088, 0, ":");
    (31089, 0, "I");
    (31090, 0, "t");
    (31091, 0, "e");
    (31092, 0, "m");
    (31084, 9, "");
    (31085, 0, ":");
    (31086, 0, " ");
    (31087, 0, "_");
    (31087, 1, "");
    (31087, 0, "(");
    (31088, 0, "_");
    (31089, 0, ",");
    (31090, 0, " ");
    (31091, 0, "T");
    (31092, 0, ":");
    (31093, 0, ":");
    (31093, 1, "");
    (31092, 1, "");
    (31091, 1, "");
    (31091, 0, "C");
    (31092, 0, ":");
    (31093, 0, ":");
    (31094, 0, "I");
    (31095, 0, "t");
    (31096, 0, "e");
    (31097, 0, "m");
    (31098, 0, ">");
    (31098, 1, "");
    (31098, 0, ")");
    (31085, 14, "");
    (31156, 0, "(");
    (31174, 0, " ");
    (31175, 0, "a");
    (31176, 0, "s");
    (31177, 0, " ");
    (31178, 0, "*");
    (31179, 0, "m");
    (31180, 0, "u");
    (31181, 0, "t");
    (31182, 0, " ");
    (31183, 0, "C");
    (31184, 0, ":");
    (31185, 0, ":");
    (31186, 0, "I");
    (31187, 0, "t");
    (31188, 0, "e");
    (31189, 0, "m");
    (31190, 0, ")");
    (31205, 82, "");
    (31204, 0, " ");
    (31205, 0, "/");
    (31206, 0, "/");
    (31207, 0, " ");
    (31208, 0, "M");
    (31209, 0, "a");
    (31210, 0, "k");
    (31211, 0, "e");
    (31212, 0, " ");
    (31213, 0, "s");
    (31214, 0, "u");
    (31215, 0, "r");
    (31216, 0, "e");
    (31217, 0, " ");
    (31218, 0, "w");
    (31219, 0, "e");
    (31220, 0, " ");
    (31221, 0, "d");
    (31222, 0, "o");
    (31223, 0, "n");
    (31224, 0, "'");
    (31225, 0, "t");
    (31226, 0, " ");
    (31208, 19, "W");
    (31209, 0, "r");
    (31210, 0, "i");
    (31211, 0, "t");
    (31212, 0, "e");
    (31213, 0, " ");
    (31214, 0, "m");
    (31215, 0, "a");
    (31216, 0, "k");
    (31217, 0, "e");
    (31218, 0, "s");
    (31219, 0, " ");
    (31220, 0, "s");
    (31221, 0, "u");
    (31222, 0, "e");
    (31223, 0, " ");
    (31224, 0, "w");
    (31224, 1, "");
    (31223, 1, "");
    (31222, 1, "");
    (31222, 0, "r");
    (31223, 0, "e");
    (31224, 0, " ");
    (31225, 0, "w");
    (31226, 0, "e");
    (31227, 0, "o");
    (31228, 0, "n");
    (31229, 0, "'");
    (31230, 0, "t");
    (31231, 0, " ");
    (31225, 7, "w");
    (31226, 0, "e");
    (31227, 0, " ");
    (31228, 0, "d");
    (31229, 0, "o");
    (31230, 0, "n");
    (31231, 0, "'");
    (31232, 0, "t");
    (31233, 0, " ");
    (31234, 0, "d");
    (31235, 0, "r");
    (31236, 0, "o");
    (31237, 0, "p");
    (31238, 0, " ");
    (31239, 0, "t");
    (31240, 0, "h");
    (31241, 0, "e");
    (31242, 0, " ");
    (31243, 0, "o");
    (31244, 0, "l");
    (31245, 0, "d");
    (31246, 0, " ");
    (31247, 0, "v");
    (31248, 0, "a");
    (31249, 0, "l");
    (31250, 0, "u");
    (31251, 0, "e");
    (31252, 0, ".");
    (1987, 9, "");
    (31147, 0, "// ");
    (31134, 0, "\n            ");
    (31147, 0, "s");
    (31148, 0, "l");
    (31149, 0, "o");
    (31150, 0, "t");
    (31151, 0, ".");
    (31152, 0, "v");
    (31153, 0, "a");
    (31154, 0, "l");
    (31155, 0, "u");
    (31156, 0, "e");
    (31157, 0, " ");
    (31158, 0, "=");
    (31159, 0, " ");
    (31160, 0, "M");
    (31161, 0, "a");
    (31162, 0, "n");
    (31163, 0, "u");
    (31164, 0, "a");
    (31165, 0, "l");
    (31166, 0, "l");
    (31160, 0, "s");
    (31161, 0, "t");
    (31162, 0, "d");
    (31163, 0, ":");
    (31164, 0, ":");
    (31165, 0, "m");
    (31166, 0, "e");
    (31167, 0, "m");
    (31168, 0, "o");
    (31168, 1, "");
    (31168, 0, ":");
    (31169, 0, ":");
    (31170, 7, "ManuallyDrop");
    (31182, 0, ":");
    (31183, 0, ":");
    (31184, 0, "n");
    (31185, 0, "e");
    (31186, 0, "w");
    (31187, 0, "(");
    (31188, 0, "i");
    (31189, 0, "t");
    (31190, 0, "e");
    (31191, 0, "m");
    (31192, 0, ")");
    (31193, 0, ";");
    (31135, 59, "");
    (31134, 1, "");
    (31147, 3, "");
    (37172, 0, "\n                ");
    (37189, 0, "/");
    (37190, 0, "/");
    (37191, 0, " ");
    (37192, 0, "W");
    (37193, 0, "e");
    (37194, 0, " ");
    (37195, 0, "d");
    (37196, 0, "o");
    (37197, 0, " ");
    (37198, 0, "w");
    (37199, 0, "a");
    (37200, 0, "n");
    (37201, 0, "t");
    (37202, 0, " ");
    (37203, 0, "t");
    (37204, 0, "o");
    (37205, 0, " ");
    (37206, 0, "d");
    (37207, 0, "r");
    (37208, 0, "o");
    (37209, 0, "p");
    (37210, 0, " ");
    (37211, 0, "t");
    (37212, 0, "h");
    (37213, 0, "e");
    (37214, 0, " ");
    (37215, 0, "o");
    (37216, 0, "l");
    (37217, 0, "d");
    (37218, 0, " ");
    (37219, 0, "i");
    (37220, 0, "t");
    (37221, 0, "e");
    (37222, 0, "m");
    (37223, 0, ".");
    (37192, 32, "D");
    (37193, 0, "o");
    (37194, 0, " ");
    (37195, 0, "n");
    (37196, 0, "o");
    (37197, 0, "t");
    (37198, 0, " ");
    (37199, 0, "d");
    (37200, 0, "r");
    (37201, 0, "o");
    (37202, 0, "p");
    (37203, 0, " ");
    (37204, 0, "t");
    (37205, 0, "h");
    (37206, 0, "e");
    (37207, 0, " ");
    (37208, 0, "o");
    (37209, 0, "l");
    (37210, 0, "d");
    (37211, 0, " ");
    (37212, 0, "i");
    (37213, 0, "t");
    (37214, 0, "e");
    (37215, 0, "m");
    (37216, 0, "s");
    (37217, 0, ".");
    (37235, 13, "(slot.as_mut_ptr() as *mut C::Item).write(item);");
    (37112, 4, "s");
    (37113, 0, "l");
    (37114, 0, "o");
    (37115, 0, "t");
    (37217, 1, "");
    (37217, 0, " ");
    (37218, 0, "-");
    (37219, 0, " ");
    (37220, 0, "t");
    (37221, 0, "h");
    (37222, 0, "e");
    (37223, 0, "y");
    (37224, 0, " ");
    (37225, 0, "w");
    (37226, 0, "e");
    (37227, 0, "r");
    (37228, 0, "e");
    (37229, 0, " ");
    (37230, 0, "o");
    (37231, 0, "n");
    (37232, 0, "l");
    (37233, 0, "y");
    (37234, 0, " ");
    (37235, 0, "m");
    (37236, 0, "o");
    (37237, 0, "v");
    (37238, 0, "e");
    (37239, 0, "d");
    (37240, 0, ".");
    ( 37242,
      0,
      "                (slot.as_mut_ptr() as *mut C::Item).write(item);\n" );
    (37323, 0, "// ");
    (37276, 17, "");
    (37258, 1, "");
    (37289, 68, "");
    (37302, 0, "\n            ");
    (37315, 0, "l");
    (37316, 0, "e");
    (37317, 0, "t");
    (37318, 0, " ");
    (37319, 0, "d");
    (37320, 0, "e");
    (37321, 0, "s");
    (37322, 0, "t");
    (37319, 4, "dest_content_slice");
    (37337, 0, " ");
    (37338, 0, "=");
    (37339, 0, " ");
    (8805, 0, "\n");
    (8806, 0, "\n");
    (8807, 0, "f");
    (8808, 0, "n");
    (8809, 0, " ");
    (8810, 0, "s");
    (8811, 0, "l");
    (8812, 0, "i");
    (8813, 0, "c");
    (8814, 0, "e");
    (8815, 0, "_");
    (8810, 0, "u");
    (8811, 0, "n");
    (8812, 0, "i");
    (8813, 0, "n");
    (8814, 0, "i");
    (8815, 0, "t");
    (8816, 0, "_");
    (8810, 0, "m");
    (8811, 0, "a");
    (8812, 0, "y");
    (8813, 0, "b");
    (8814, 0, "e");
    (8815, 13, "m");
    (8815, 1, "");
    (8815, 0, "i");
    (8816, 0, "n");
    (8817, 0, "i");
    (8818, 0, "t");
    (8819, 0, "_");
    (8820, 0, "s");
    (8821, 0, "l");
    (8822, 0, "i");
    (8823, 0, "c");
    (8824, 0, "e");
    (8825, 0, "_");
    (8826, 0, "g");
    (8827, 0, "e");
    (8828, 0, "t");
    (8829, 0, "_");
    (8830, 0, "r");
    (8831, 0, "e");
    (8832, 0, "f");
    (8833, 0, "(");
    (8834, 0, "\n    ");
    (8839, 0, "\n    ");
    (8835, 4, "");
    ( 8840,
      0,
      "    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n\
      \        // SAFETY: casting slice to a `*const [T]` is safe since the \
       caller guarantees that\n\
      \        // `slice` is initialized, and`MaybeUninit` is guaranteed to \
       have the same layout as `T`.\n\
      \        // The pointer obtained is valid since it refers to memory \
       owned by `slice` which is a\n\
      \        // reference and thus guaranteed to be valid for reads.\n\
      \        unsafe { &*(slice as *const [Self] as *const [T]) }\n\
      \    }" );
    (8836, 8, "    ");
    (8806, 0, "\n");
    (8807, 0, "/");
    (8808, 0, "/");
    (8809, 0, " ");
    (8810, 0, "S");
    (8811, 0, "t");
    (8812, 0, "o");
    (8813, 0, "l");
    (8814, 0, "e");
    (8815, 0, "d");
    (8816, 0, " ");
    (8816, 1, "");
    (8815, 1, "");
    (8815, 0, "n");
    (8816, 0, " ");
    (8817, 0, "f");
    (8818, 0, "r");
    (8819, 0, "o");
    (8820, 0, "m");
    (8821, 0, " ");
    (8822, 0, "s");
    (8823, 0, "t");
    (8823, 1, "");
    (8822, 1, "");
    (8822, 0, "s");
    (8823, 0, "t");
    (8824, 0, "d");
    (8825, 0, ":");
    (8826, 0, ":");
    (8822, 5, "c");
    (8823, 0, "o");
    (8824, 0, "r");
    (8825, 0, "e");
    (8826, 0, ":");
    (8827, 0, ":");
    (8828, 0, "m");
    (8829, 0, "e");
    (8830, 0, "m");
    (8831, 0, ":");
    (8832, 0, ":");
    (8833, 0, "m");
    (8834, 0, "a");
    (8835, 0, "y");
    (8836, 0, "b");
    (8837, 0, "e");
    (8838, 0, "u");
    (8833, 6, "MaybeUninit");
    (8844, 0, ".");
    (8845, 0, " ");
    (8846, 0, "I");
    (8847, 0, "t");
    (8848, 0, "s");
    (8849, 0, " ");
    (8850, 0, "j");
    (8851, 0, "u");
    (8852, 0, "s");
    (8853, 0, "t");
    (8854, 0, " ");
    (8855, 0, "n");
    (8856, 0, "o");
    (8857, 0, "t");
    (8858, 0, " ");
    (8859, 0, "s");
    (8860, 0, "t");
    (8861, 0, "a");
    (8862, 0, "n");
    (8863, 0, "d");
    (8864, 0, "a");
    (8865, 0, "r");
    (8866, 0, "d");
    (8867, 0, "l");
    (8868, 0, "i");
    (8868, 1, "");
    (8867, 1, "");
    (8866, 1, "");
    (8865, 1, "");
    (8865, 0, "r");
    (8866, 0, "d");
    (8867, 0, "i");
    (8868, 0, "z");
    (8869, 0, "e");
    (8870, 0, "d");
    (8871, 0, " ");
    (8872, 0, "y");
    (8873, 0, "e");
    (8874, 0, "t");
    (8875, 0, ".");
    (8904, 34, "");
    (8903, 0, "<");
    (8904, 0, "T");
    (8905, 0, ">");
    (8916, 4, "M");
    (8917, 0, "a");
    (8918, 0, "y");
    (8919, 0, "b");
    (8920, 0, "e");
    (8916, 5, "MaybeUninit");
    (8927, 0, "<");
    (8928, 0, "T");
    (8929, 0, ">");
    (8877, 0, "u");
    (8878, 0, "n");
    (8879, 0, "s");
    (8880, 0, "a");
    (8881, 0, "f");
    (8882, 0, "e");
    (8883, 0, " ");
    (9359, 4, "");
    (9299, 8, "    ");
    (9235, 8, "    ");
    (9140, 8, "    ");
    (9042, 8, "    ");
    (8950, 8, "    ");
    (9316, 4, "");
    (9316, 0, "M");
    (9317, 0, "a");
    (9318, 0, "y");
    (9319, 0, "b");
    (9320, 0, "e");
    (9316, 5, "MaybeUninit");
    (9327, 0, "<");
    (9328, 0, "T");
    (9329, 0, ">");
    (8806, 545, "");
    (8805, 1, "");
    (8804, 1, "");
    (18530, 0, "\n");
    (18531, 0, "\n");
    ( 18532,
      0,
      "\n\
       // Stolen from core::mem::MaybeUninit. Its just not standardized yet.\n\
       unsafe fn maybeinit_slice_get_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {\n\
      \    // SAFETY: casting slice to a `*const [T]` is safe since the caller \
       guarantees that\n\
      \    // `slice` is initialized, and`MaybeUninit` is guaranteed to have \
       the same layout as `T`.\n\
      \    // The pointer obtained is valid since it refers to memory owned by \
       `slice` which is a\n\
      \    // reference and thus guaranteed to be valid for reads.\n\
      \    unsafe { &*(slice as *const [MaybeUninit<T>] as *const [T]) }\n\
       }\n" );
    (18531, 1, "");
    (8804, 0, "\n");
    (10882, 0, "\n        ");
    (10891, 0, "m");
    (10892, 0, "a");
    (10893, 0, "y");
    (10891, 3, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (10915, 24, "s");
    (10916, 0, "l");
    (10917, 0, "i");
    (10918, 0, "c");
    (10919, 0, "e");
    (10930, 0, "// ");
    (10922, 84, "");
    (10921, 1, "");
    (18334, 0, "\n");
    (18335, 0, "#[inline(always)]");
    (18335, 17, "");
    (18334, 1, "");
    (18559, 0, "\n");
    (18560, 0, "#[inline(always)]");
    (18334, 0, "\n");
    (18335, 0, "#[inline(always)]");
    (37878, 0, "m");
    (37879, 0, "a");
    (37880, 0, "y");
    (37881, 0, "b");
    (37882, 0, "e");
    (37878, 5, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (37902, 24, "d");
    (37903, 0, "e");
    (37904, 0, "s");
    (37905, 0, "t");
    (37906, 0, "_");
    (37907, 0, "c");
    (37908, 0, "o");
    (37909, 0, "n");
    (37910, 0, "t");
    (37911, 0, "e");
    (37912, 0, "n");
    (37913, 0, "t");
    (37914, 0, "_");
    (37915, 0, "s");
    (37916, 0, "l");
    (37917, 0, "i");
    (37918, 0, "c");
    (37919, 0, "e");
    (37921, 0, ";");
    ( 17636,
      0,
      "    unsafe fn from_slice(slice: &[C::Item]) -> Self {\n\
      \        unsafe {\n\
      \            let ptr = slice.as_mut_ptr();\n\
      \            let end = ptr.add(slice.len());\n\n\
      \            UninitOwnedIter {\n\
      \                ptr: NonNull::new_unchecked(ptr),\n\
      \                end,\n\
      \                _marker: PhantomData\n\
      \            }\n\
      \        }\n\
      \    }\n" );
    (18286, 0, "// ");
    (18276, 0, "// ");
    (18262, 0, "// ");
    (18225, 0, "// ");
    (18204, 0, "// ");
    (18154, 0, "// ");
    (18124, 0, "// ");
    (18079, 0, "// ");
    (18037, 0, "// ");
    (18020, 0, "// ");
    (17966, 0, "// ");
    (17655, 0, "m");
    (17656, 0, "a");
    (17657, 0, "y");
    (17658, 0, "b");
    (17659, 0, "e");
    (17655, 5, "");
    (17670, 0, "M");
    (17671, 0, "a");
    (17672, 0, "y");
    (17673, 0, "b");
    (17674, 0, "e");
    (17675, 0, "I");
    (17676, 0, "n");
    (17677, 0, "i");
    (17678, 0, "n");
    (17679, 0, "t");
    (17679, 1, "");
    (17678, 1, "");
    (17677, 1, "");
    (17677, 0, "i");
    (17678, 0, "t");
    (17679, 0, "<");
    (17680, 0, "<");
    (17680, 1, "");
    (17687, 0, ">");
    (17675, 0, "U");
    (17676, 0, "n");
    (17677, 1, "");
    (17677, 0, "i");
    (17747, 0, "[");
    (17748, 0, "0");
    (17749, 0, "]");
    (17749, 1, "");
    (17748, 1, "");
    (17747, 1, "");
    (17747, 0, "[0]");
    (17747, 3, "");
    (17760, 0, " ");
    (17761, 0, "a");
    (17762, 0, "s");
    (17763, 0, " ");
    (17764, 0, "*");
    (17765, 0, "m");
    (17766, 0, "u");
    (17767, 0, "t");
    (17768, 0, " ");
    (17769, 0, "C");
    (17770, 0, ":");
    (17771, 0, ":");
    (17772, 0, "I");
    (17773, 0, "t");
    (17774, 0, "e");
    (17775, 0, "m");
    (17777, 0, " ");
    (17778, 0, "/");
    (17779, 0, "/");
    (17780, 0, " ");
    (17781, 0, "s");
    (17781, 1, "");
    (17781, 0, "S");
    (17782, 0, "a");
    (17783, 0, "f");
    (17784, 0, "e");
    (17785, 0, ".");
    (17635, 0, "\n    ");
    (17640, 0, "/");
    (17641, 0, "/");
    (17642, 0, "/");
    (17643, 0, " ");
    (17643, 1, "");
    (17642, 1, "");
    (17642, 0, " ");
    (17643, 0, "M");
    (17644, 0, "a");
    (17645, 0, "k");
    (17646, 0, "e");
    (17647, 0, " ");
    (17648, 0, "a");
    (17649, 0, " ");
    (17650, 0, "l");
    (17651, 0, "c");
    (17652, 0, "i");
    (17652, 1, "");
    (17651, 1, "");
    (17650, 1, "");
    (17640, 0, "/");
    (17651, 0, "s");
    (17652, 0, "l");
    (17653, 0, "i");
    (17654, 0, "c");
    (17655, 0, "e");
    (17656, 0, " ");
    (17657, 0, "w");
    (17658, 0, "e");
    (17659, 0, " ");
    (17660, 0, "c");
    (17661, 0, "a");
    (17662, 0, "n");
    (17663, 0, " ");
    (17664, 0, "i");
    (17665, 0, "t");
    (17666, 0, "e");
    (17667, 0, "r");
    (17668, 0, "a");
    (17669, 0, "t");
    (17670, 0, "e");
    (17671, 0, " ");
    (17672, 0, "f");
    (17673, 0, "r");
    (17674, 0, "o");
    (17675, 0, "m");
    (17676, 0, " ");
    (17677, 0, "a");
    (17678, 0, "n");
    (17679, 0, "d");
    (17680, 0, " ");
    (17681, 0, "s");
    (17682, 0, "t");
    (17683, 0, "e");
    (17684, 0, "a");
    (17685, 0, "l");
    (17686, 0, " ");
    (17687, 0, "f");
    (17688, 0, "r");
    (17689, 0, "o");
    (17690, 0, "m");
    (17691, 0, ".");
    (17692, 0, " ");
    (17693, 0, "A");
    (17694, 0, "f");
    (17695, 0, "t");
    (17696, 0, "e");
    (17697, 0, "r");
    (17698, 0, " ");
    (17699, 0, "t");
    (17700, 0, "h");
    (17701, 0, "e");
    (17702, 0, " ");
    (17703, 0, "i");
    (17704, 0, "t");
    (17705, 0, "e");
    (17706, 0, "r");
    (17707, 0, "a");
    (17708, 0, "t");
    (17709, 0, "o");
    (17710, 0, "r");
    (17711, 0, " ");
    (17712, 0, "h");
    (17713, 0, "a");
    (17714, 0, "s");
    (17715, 0, " ");
    (17716, 0, "r");
    (17717, 0, "u");
    (17718, 0, "n");
    (17719, 0, ",");
    (17720, 0, " ");
    (17721, 0, "t");
    (17722, 0, "h");
    (17723, 0, "e");
    (17724, 0, " ");
    (17725, 0, "i");
    (17726, 0, "t");
    (17727, 0, "e");
    (17728, 0, "m");
    (17729, 0, "s");
    (17692, 0, " ");
    (17693, 0, "T");
    (17694, 0, "h");
    (17695, 0, "i");
    (17696, 0, "s");
    (17697, 0, " ");
    (17698, 0, "s");
    (17699, 0, "i");
    (17699, 1, "");
    (17698, 1, "");
    (17698, 0, "i");
    (17699, 0, "s");
    (17700, 0, " ");
    (17701, 0, "a");
    (17693, 9, "");
    (17692, 1, "");
    (17730, 0, " ");
    (17731, 0, "i");
    (17732, 0, "n");
    (17733, 0, "s");
    (17734, 0, "i");
    (17735, 0, "d");
    (17736, 0, "e");
    (17737, 0, " ");
    (17738, 0, "*");
    (17739, 0, "m");
    (17740, 0, "u");
    (17741, 0, "s");
    (17742, 0, "t");
    (17743, 0, "*");
    (17744, 0, " ");
    (17745, 0, "b");
    (17746, 0, "e");
    (17747, 0, " ");
    (17693, 55, "T");
    (17694, 0, "h");
    (17695, 0, "e");
    (17696, 0, " ");
    (17697, 0, "i");
    (17698, 0, "t");
    (17699, 0, "e");
    (17700, 0, "r");
    (17701, 0, "a");
    (17702, 0, "t");
    (17703, 0, "o");
    (17704, 0, "r");
    (17705, 0, " ");
    (17693, 13, "I");
    (17694, 0, "t");
    (17695, 0, "s");
    (17696, 0, " ");
    (17697, 0, "u");
    (17698, 0, "n");
    (17699, 0, "s");
    (17700, 0, "a");
    (17701, 0, "f");
    (17702, 0, "e");
    (17703, 0, " ");
    (17704, 0, "t");
    (17704, 1, "");
    (17704, 0, "i");
    (17705, 0, "f");
    (17706, 0, " ");
    (17707, 0, "t");
    (17708, 0, "h");
    (17709, 0, "e");
    (17710, 0, " ");
    (17711, 0, "i");
    (17712, 0, "t");
    (17713, 0, "e");
    (17714, 0, "r");
    (17715, 0, "a");
    (17716, 0, "t");
    (17717, 0, "o");
    (17718, 0, "r");
    (17719, 0, " ");
    (17720, 0, "i");
    (17721, 0, "s");
    (17722, 0, "n");
    (17723, 0, "'");
    (17724, 0, "t");
    (17725, 0, " ");
    (17726, 0, "d");
    (17727, 0, "r");
    (17728, 0, "a");
    (17729, 0, "i");
    (17730, 0, "n");
    (17731, 0, "e");
    (17732, 0, "d");
    (17706, 1, "");
    (17706, 0, "\n    /// ");
    (17706, 0, ":");
    (17716, 0, "\n    /// ");
    (17725, 0, "-");
    (17726, 0, " ");
    (17727, 1, "");
    (17727, 0, "T");
    (17753, 0, "\n    /// ");
    (17762, 0, "-");
    (17763, 0, " ");
    (17746, 0, "f");
    (17747, 0, "u");
    (17748, 0, "l");
    (17749, 0, "l");
    (17750, 0, "y");
    (17751, 0, " ");
    (17759, 0, " ");
    (17760, 0, "(");
    (17761, 0, "t");
    (17762, 0, "h");
    (17763, 0, "e");
    (17764, 0, "n");
    (17765, 0, " ");
    (17766, 0, "w");
    (17767, 0, "e");
    (17768, 0, " ");
    (17769, 0, "m");
    (17770, 0, "i");
    (17771, 0, "g");
    (17772, 0, "h");
    (17773, 0, "t");
    (17774, 0, " ");
    (17775, 0, "n");
    (17776, 0, "t");
    (17777, 0, "o");
    (17777, 1, "");
    (17776, 1, "");
    (17776, 0, "o");
    (17777, 0, "t");
    (17778, 0, " ");
    (17779, 0, "d");
    (17780, 0, "r");
    (17781, 0, "o");
    (17782, 0, "p");
    (17783, 0, " ");
    (17784, 0, "c");
    (17785, 0, "o");
    (17786, 0, "n");
    (17787, 0, "t");
    (17788, 0, "e");
    (17789, 0, "n");
    (17790, 0, "t");
    (17791, 0, "s");
    (17792, 0, ")");
    (17804, 0, "T");
    (17805, 0, "h");
    (17806, 0, "e");
    (17807, 0, " ");
    (17808, 0, "c");
    (17809, 0, "o");
    (17810, 0, "n");
    (17811, 0, "t");
    (17812, 0, "e");
    (17813, 0, "n");
    (17814, 0, "t");
    (17815, 0, "s");
    (17816, 0, " ");
    (17817, 0, "w");
    (17818, 0, "e");
    (17819, 0, " ");
    (17820, 0, "i");
    (17821, 0, "t");
    (17822, 0, "e");
    (17823, 0, "r");
    (17824, 0, "a");
    (17825, 0, "t");
    (17826, 0, " ");
    (17827, 0, "o");
    (17827, 1, "");
    (17827, 0, "e");
    (17828, 0, " ");
    (17828, 1, "");
    (17827, 1, "");
    (17827, 0, " ");
    (17827, 1, "");
    (17826, 1, "");
    (17826, 0, "e");
    (17827, 0, " ");
    (17828, 0, "o");
    (17829, 0, "v");
    (17830, 0, "e");
    (17831, 0, "r");
    (17832, 0, " ");
    (17833, 0, "a");
    (17834, 0, "r");
    (17835, 0, "e");
    (17836, 0, "n");
    (17837, 0, "'");
    (17838, 0, "t");
    (17839, 0, " ");
    (17840, 0, "i");
    (17841, 0, "n");
    (17842, 0, "i");
    (17843, 0, "t");
    (17844, 0, "i");
    (17845, 0, "a");
    (17846, 0, "l");
    (17847, 0, "i");
    (17848, 0, "e");
    (17848, 1, "");
    (17848, 0, "z");
    (17849, 0, "e");
    (17850, 0, "d");
    (17851, 0, ".");
    (17851, 1, "");
    (17851, 0, "\n    /// ");
    (17860, 0, "\n    /// ");
    (17869, 0, "A");
    (17870, 0, "f");
    (17871, 0, "t");
    (17872, 0, "e");
    (17873, 0, "r");
    (17874, 0, " ");
    (17875, 0, "i");
    (17876, 0, "t");
    (17877, 0, "e");
    (17878, 0, "r");
    (17879, 0, "a");
    (17880, 0, "t");
    (17881, 0, "i");
    (17882, 0, "n");
    (17883, 0, "g");
    (17884, 0, ",");
    (17885, 0, " ");
    (17886, 0, "t");
    (17887, 0, "h");
    (17888, 0, "e");
    (17889, 0, " ");
    (17890, 0, "c");
    (17891, 0, "o");
    (17892, 0, "n");
    (17893, 0, "t");
    (17894, 0, "e");
    (17895, 0, "n");
    (17896, 0, "t");
    (17897, 0, "s");
    (17898, 0, " ");
    (17899, 0, "a");
    (17900, 0, "r");
    (17901, 0, "e");
    (17902, 0, " ");
    (17902, 1, "");
    (17902, 0, "n");
    (17903, 0, "'");
    (17904, 0, "t");
    (17905, 0, " ");
    (17906, 0, "m");
    (17907, 0, "o");
    (17908, 0, "d");
    (17899, 10, "a");
    (17900, 0, "r");
    (17901, 0, "e");
    (17902, 0, " ");
    (17903, 0, "u");
    (17904, 0, "n");
    (17905, 0, "i");
    (17906, 0, "n");
    (17907, 0, "i");
    (17908, 0, "t");
    (17909, 0, " ");
    (17910, 0, "m");
    (17911, 0, "e");
    (17912, 0, "m");
    (17913, 0, "o");
    (17914, 0, "r");
    (17915, 0, "y");
    (17916, 0, ".");
    (44859, 0, " ");
    (44859, 0, "m");
    (44860, 0, "a");
    (44861, 0, "y");
    (44859, 3, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (44883, 24, "");
    (44883, 1, "");
    (44883, 1, "");
    (44921, 0, ")");
    (50020, 0, " ");
    (50020, 0, "m");
    (50021, 0, "a");
    (50022, 0, "y");
    (50023, 0, "b");
    (50020, 4, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (50044, 24, "");
    (50044, 1, "");
    (50044, 1, "");
    (50048, 0, ")");
    (50332, 0, "m");
    (50333, 0, "a");
    (50334, 0, "y");
    (50335, 0, "b");
    (50336, 0, " ");
    (50332, 4, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (50356, 24, "");
    (50356, 1, "");
    (50356, 1, "");
    (50360, 0, ")");
    (50217, 1, "");
    (50221, 0, ".");
    (50222, 0, "g");
    (50223, 0, "e");
    (50224, 0, "t");
    (50225, 0, "_");
    (50226, 0, "m");
    (50227, 0, "u");
    (50228, 0, "t");
    (50229, 0, "(");
    (50230, 0, ")");
    (50217, 0, "*");
    (50223, 7, "a");
    (50224, 0, "s");
    (50225, 0, "_");
    (50226, 0, "m");
    (50227, 0, "u");
    (50228, 0, "t");
    (50229, 0, "_");
    (50230, 0, "p");
    (50223, 8, "as_mut_ptr");
    (50218, 0, "(");
    (50218, 1, "");
    (50262, 7, "r");
    (50263, 0, "e");
    (50264, 0, "p");
    (50265, 0, "l");
    (50266, 0, "a");
    (50267, 0, "c");
    (50268, 0, "e");
    (50269, 0, "d");
    (50247, 5, "");
    (50247, 1, "");
    (50247, 0, "D");
    (50251, 1, "");
    (51245, 4, "maybeinit_slice_get_ref(dest)");
    (50340, 29, "");
    (50340, 0, "maybeinit_slice_get_ref(dest)");
    (51245, 29, "d");
    (50340, 29, "d");
    (51218, 0, "e");
    (50341, 0, "e");
    (51220, 0, "s");
    (50342, 0, "s");
    (51222, 0, "t");
    (50343, 0, "t");
    (51200, 0, "\n            ");
    (50288, 0, "\n            ");
    (51214, 12, "");
    (50301, 0, "l");
    (50302, 0, "e");
    (50303, 0, "t");
    (50304, 0, " ");
    (50305, 0, "d");
    (50306, 0, "e");
    (50307, 0, "s");
    (50308, 0, "t");
    (50309, 0, " ");
    (50310, 0, "=");
    (50311, 0, " ");
    (50312, 0, "maybeinit_slice_get_ref(dest)");
    (50341, 0, ";");
    (51254, 1, "");
    (10891, 0, "u");
    (10892, 0, "n");
    (10893, 0, "s");
    (10894, 0, "a");
    (10895, 0, "f");
    (10896, 0, "e");
    (10897, 0, " ");
    (10898, 0, "{");
    (10899, 0, " ");
    (10930, 0, " ");
    (10931, 0, "}");
    (18044, 4, "");
    (17996, 16, "");
    (17995, 1, "");
    (18242, 12, "        ");
    (18205, 16, "            ");
    (18184, 16, "            ");
    (18134, 16, "            ");
    (18104, 12, "        ");
    (18059, 12, "        ");
    (17996, 12, "        ");
    (18228, 9, "");
    (18227, 1, "");
    (18825, 0, "u");
    (18826, 0, "n");
    (18827, 0, "s");
    (18828, 0, "a");
    (18829, 0, "f");
    (18830, 0, "e");
    (18831, 0, " ");
    (18832, 0, "{");
    (18833, 0, " ");
    (18858, 0, " ");
    (18859, 0, "}");
    (50144, 0, "&");
    (50144, 1, "");
    (50249, 0, "// ");
    (50176, 0, "// ");
    (50104, 0, "// ");
    (50091, 0, "\n            ");
    (50104, 0, "/");
    (50105, 0, "/");
    (50106, 0, " ");
    (50107, 0, "W");
    (50108, 0, "o");
    (50109, 0, "u");
    (50110, 0, "l");
    (50111, 0, "d");
    (50112, 0, " ");
    (50113, 0, "p");
    (50114, 0, "r");
    (50115, 0, "e");
    (50116, 0, "f");
    (50117, 0, "e");
    (50118, 0, "r");
    (50119, 0, " ");
    (50120, 0, "t");
    (50121, 0, "o");
    (50122, 0, " ");
    (50123, 0, "u");
    (50124, 0, "s");
    (50125, 0, "e");
    (50126, 0, " ");
    (50127, 0, "z");
    (50128, 0, "i");
    (50129, 0, "p");
    (50130, 0, "(");
    (50131, 0, ")");
    (50132, 0, " ");
    (50133, 0, "b");
    (50134, 0, "u");
    (50135, 0, "t");
    (50136, 0, " ");
    (50137, 0, "i");
    (50138, 0, "t");
    (50139, 0, " ");
    (50140, 0, "g");
    (50141, 0, "i");
    (50142, 0, "v");
    (50143, 0, "e");
    (50144, 0, "s");
    (50140, 5, "t");
    (50141, 0, "a");
    (50142, 0, "k");
    (50143, 0, "e");
    (50144, 0, "s");
    (50145, 0, " ");
    (50146, 0, "o");
    (50147, 0, "w");
    (50148, 0, "n");
    (50149, 0, "e");
    (50150, 0, "r");
    (50151, 0, "s");
    (50152, 0, "h");
    (50153, 0, "i");
    (50154, 0, "p");
    (50155, 0, " ");
    (50156, 0, "o");
    (50157, 0, "f");
    (50158, 0, " ");
    (50159, 0, "i");
    (50160, 0, "n");
    (50161, 0, "s");
    (50162, 0, "e");
    (50163, 0, "r");
    (50164, 0, "t");
    (50165, 0, "e");
    (50166, 0, "d");
    (50167, 0, "_");
    (50168, 0, "c");
    (50169, 0, "o");
    (50170, 0, "n");
    (50171, 0, "t");
    (50172, 0, "e");
    (50173, 0, "n");
    (50174, 0, "t");
    (50175, 0, " ");
    (50176, 0, ":");
    (50177, 0, "/");
    (50178, 0, "\n            ");
    (50191, 0, "index..index + replaced_items_here");
    (50139, 6, " ");
    (50140, 0, "w");
    (50141, 0, "a");
    (50142, 0, "n");
    (50143, 0, "t");
    (50144, 0, "s");
    (50191, 0, "f");
    (50192, 0, "o");
    (50193, 0, "r");
    (50194, 0, " ");
    (50195, 0, "i");
    (50196, 0, " ");
    (50197, 0, "i");
    (50198, 0, "n");
    (50199, 0, " ");
    (50234, 0, " ");
    (50235, 0, "{");
    (50236, 0, "\n                ");
    (50253, 0, "\n                ");
    (50237, 16, "");
    (50238, 16, "            }");
    (50237, 0, "                ");
    (50237, 16, "");
    (50195, 39, "");
    (50195, 0, "&");
    (50196, 0, "m");
    (50197, 0, "u");
    (50198, 0, "t");
    (50199, 0, " ");
    (50200, 0, "s");
    (50201, 0, "l");
    (50202, 0, "o");
    (50203, 0, "t");
    (50204, 0, " ");
    (50205, 0, "=");
    (50206, 0, " ");
    (50206, 1, "");
    (50205, 1, "");
    (50205, 0, "i");
    (50206, 0, "n");
    (50207, 0, " ");
    (50208, 0, "d");
    (50209, 0, "e");
    (50210, 0, "s");
    (50211, 0, "t");
    (50215, 0, "                ");
    (50215, 16, "");
    (50194, 10, "");
    (50194, 0, " ");
    (50195, 0, "s");
    (50196, 0, "l");
    (50197, 0, "o");
    (50198, 0, "t");
    (50210, 0, "                ");
    (50226, 0, "*slot.as_mut_ptr() = item;");
    (50247, 5, "");
    (50247, 0, "i");
    (50248, 0, "n");
    (50249, 0, "s");
    (50250, 0, "e");
    (50251, 0, "r");
    (50252, 0, "t");
    (50247, 6, "inserted_content");
    (50263, 0, ".");
    (50264, 0, "n");
    (50265, 0, "e");
    (50266, 0, "x");
    (50264, 3, "next()");
    (50270, 0, "(");
    (50270, 1, "");
    (50270, 0, ".");
    (50271, 0, "u");
    (50272, 0, "n");
    (50273, 0, "w");
    (50274, 0, "r");
    (50275, 0, "a");
    (50276, 0, "p");
    (50277, 0, "(");
    (50278, 0, ")");
    (50279, 0, "/");
    (50280, 0, ";");
    (50280, 1, "");
    (50279, 1, "");
    (50279, 0, ";");
    (50293, 0, "// ");
    (50222, 0, "// ");
    (50191, 0, "// ");
    (50299, 3, "");
    (50225, 3, "");
    (50191, 3, "");
    (50207, 0, ".");
    (50208, 0, "i");
    (50209, 0, "t");
    (50210, 0, "e");
    (50211, 0, "r");
    (50212, 0, "(");
    (50213, 0, ")");
    (50212, 0, "_");
    (50213, 0, "m");
    (50214, 0, "u");
    (50215, 0, "t");
    (38227, 3, "");
    (38227, 1, "");
    (38227, 0, "mut ");
    (38200, 4, "");
    (19648, 9, "");
    (19699, 1, "");
    (19698, 1, "");
    (19698, 0, " }");
    (19698, 2, "");
    (48839, 3, "");
    (48839, 1, "");
    ( 783,
      55945,
      "use std::alloc::{alloc, dealloc, Layout};\n\
       use std::cmp::min;\n\
       use std::marker::PhantomData;\n\n\
       use std::fmt;\n\n\
       use rand::{RngCore, Rng, SeedableRng};\n\
       use rand::rngs::SmallRng;\n\n\
       /// The likelyhood a node will have height (n+1) instead of n\n\
       const BIAS: u8 = 100; // out of 256.\n\n\
       /// The number of items in each node. Must fit in a u8 thanks to Node.\n\
       #[cfg(debug_assertions)]\n\
       const NODE_NUM_ITEMS: usize = 10;\n\n\
       #[cfg(not(debug_assertions))]\n\
       const NODE_NUM_ITEMS: usize = 100;\n\n\
       /// Rope operations will move to linear time after NODE_STR_SIZE * 2 ^\n\
       /// MAX_HEIGHT length. (With a smaller constant the higher this is). On \
       the flip\n\
       /// side, cursors grow linearly with this number; so smaller is \
       marginally\n\
       /// better when the contents are smaller.\n\
       #[cfg(debug_assertions)]\n\
       const MAX_HEIGHT: usize = 5;\n\n\
       #[cfg(not(debug_assertions))]\n\
       const MAX_HEIGHT: usize = 10;\n\n\n\
       const MAX_HEIGHT_U8: u8 = MAX_HEIGHT as u8; // convenience.\n\n\
       pub struct ItemMarker<'a, C: ListConfig> {\n\
      \    ptr: *mut Node<C>,\n\
      \    _phantom: PhantomData<&'a SkipList<C>>\n\
       }\n\n\
       /// The whole list is configured through a single generic trait parameter\n\
       pub trait ListConfig {\n\
      \    type Item: Default + Copy; //+ std::fmt::Debug;\n\n\
      \    /// Applications which have custom sizes (or do their own\n\
      \    /// run-length-encoding) can define their own size function for \
       items. When\n\
      \    /// items are inserted or replaced, the position is specified using \
       the\n\
      \    /// custom size defined here.\n\
      \    fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\n\
      \    fn userlen_of_slice(items: &[Self::Item]) -> usize {\n\
      \        items.iter().fold(0, |acc, item| {\n\
      \            acc + Self::get_usersize(item)\n\
      \        })\n\
      \    }\n\n\
      \    fn split_item(_item: &Self::Item, _at: usize) -> (Self::Item, \
       Self::Item) {\n\
      \        unimplemented!(\"Cannot insert in the middle of an item - \
       split_item is not defined in trait\");\n\
      \    }\n\n\
      \    // fn notify(&mut self, _items: &[Self::Item], _at_marker: \
       ItemMarker<Self>) where Self: Sized {\n\
      \    // }\n\
      \    \n\
       }\n\n\
       pub trait Queryable {\n\
      \    type Query;\n\n\
      \    // Returns Some(offset) into the item if its contained. Otherwise \
       None.\n\
      \    fn contains_item(&self, query: &Self::Query) -> Option<usize>;\n\
       }\n\n\
       /// This represents a single entry in either the nexts pointers list or \
       in an\n\
       /// iterator.\n\
       #[derive(Debug, PartialEq, Eq)]\n\
       struct SkipEntry<C: ListConfig> {\n\
      \    /// The node being pointed to.\n\
      \    node: *mut Node<C>,\n\n\
      \    /// The number of *items* between the start of the current node and \
       the\n\
      \    /// start of the next node. That means nexts entry 0 contains the \
       length of\n\
      \    /// the current node.\n\
      \    skip_usersize: usize,\n\
       }\n\n\
       // We can't use #[derive()] here for Copy and Clone due to a bug in the \
       rust\n\
       // compiler: https://github.com/rust-lang/rust/issues/26925\n\
       impl<C: ListConfig> Copy for SkipEntry<C> {}\n\
       impl<C: ListConfig> Clone for SkipEntry<C> {\n\
      \    fn clone(&self) -> Self { *self }\n\
       }\n\n\
       impl<C: ListConfig> SkipEntry<C> {\n\
      \    fn new_null() -> Self {\n\
      \        SkipEntry { node: ptr::null_mut(), skip_usersize: 0 }\n\
      \    }\n\
       }\n\n\n\n\
       /// The node structure is designed in a very fancy way which would be \
       more at\n\
       /// home in C or something like that. The basic idea is that the node \
       structure\n\
       /// is fixed size in memory, but the proportion of that space taken up by\n\
       /// characters and by the height differ depending on a node's height. \
       This\n\
       /// results in a lot of `unsafe` blocks. I think the tradeoff is worth \
       it but I\n\
       /// could be wrong here. You probably wouldn't lose much performance in \
       practice\n\
       /// by replacing the inline structure with a smallvec - but that would \
       waste\n\
       /// memory in small nodes, and require extra pointer indirection on \
       large nodes.\n\
       /// It also wouldn't remove all the unsafe here.\n\
       ///\n\
       /// A different representation (which might be better or worse - I \
       can't tell)\n\
       /// would be to have the nodes all be the same size in memory and \
       change the\n\
       /// *proportion* of the node's memory that is used by the string field \
       vs the\n\
       /// next pointers. That might be lighter weight for the allocator \
       because the\n\
       /// struct itself would be a fixed size; but I'm not sure if it would \
       be better.\n\
       #[repr(C)] // Prevent parameter reordering.\n\
       struct Node<C: ListConfig> {\n\
      \    /// We start with the items themselves. Only the first `num_items` \
       of this\n\
      \    /// list is in use. The user specified length of the items in the \
       node is\n\
      \    /// stored in nexts[0].skip_items. This is initialized with\n\
      \    /// Default::default() for the type, but when MaybeUninit \
       completely lands,\n\
      \    /// it will be possible to make this a tiny bit faster by leaving \
       the list\n\
      \    /// initially uninitialized.\n\
      \    items: [C::Item; NODE_NUM_ITEMS],\n\n\
      \    /// Number of items in `items` in use / filled.\n\
      \    num_items: u8,\n\n\
      \    /// Height of nexts array.\n\
      \    height: u8,\n\n\
      \    /// With the heads array as is, we have no way to go from a marker \
       back to a\n\
      \    /// cursor (which is required to insert at that location in the \
       list). For\n\
      \    /// that we need to be able to figure out at each level of the nexts\n\
      \    /// pointers which object points to us, and the offset from that \
       element to\n\
      \    /// the current element. Anyway, for markers to work we need this.\n\
      \    parent: *mut Node<C>,\n\n\
      \    // #[repr(align(std::align_of::<SkipEntry>()))]\n\
      \    \n\
      \    /// In reality this array has the size of height, allocated using \
       more or\n\
      \    /// less direct calls to malloc() at runtime based on the randomly \
       generated\n\
      \    /// size. The size is always at least 1.\n\
      \    nexts: [SkipEntry<C>; 0],\n\
       }\n\n\
       // Make sure nexts uses correct alignment. This should be guaranteed by \
       repr(C)\n\
       // This test will fail if this ever stops being true.\n\
       #[test]\n\
       fn test_align() {\n\
      \    struct TestConfig;\n\
      \    impl ListConfig for TestConfig {\n\
      \        type Item = u8;\n\
      \        fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\
      \    }\n\
      \    #[repr(C)] struct Check([SkipEntry<TestConfig>; 0]);\n\
      \    assert!(mem::align_of::<Check>() >= \
       mem::align_of::<SkipEntry<TestConfig>>());\n\
      \    // TODO: It'd be good to also check the alignment of the nexts \
       field in Node.\n\
       }\n\n\
       fn random_height<R: RngCore>(rng: &mut R) -> u8 {\n\
      \    let mut h: u8 = 1;\n\
      \    // Should I use a csrng here? Does it matter?\n\
      \    while h < MAX_HEIGHT_U8 && rng.gen::<u8>() < BIAS { h+=1; }\n\
      \    h\n\
       }\n\n\
       #[repr(C)]\n\
       pub struct SkipList<C: ListConfig> {\n\
      \    // TODO: Consider putting the head item on the heap. For the use \
       case here\n\
      \    // its almost certainly fine either way. The code feels a bit \
       cleaner if its\n\
      \    // on the heap (and then iterators will be able to outlast a move \
       of the\n\
      \    // skiplist parent). But its also very nice having the code run \
       fast for\n\
      \    // small lists. Most lists are small, and it makes sense to \
       optimize for\n\
      \    // that.\n\n\
      \    // TODO: For safety, pointers in to this structure should be Pin<> \
       if we\n\
      \    // ever want to hold on to iterators.\n\n\
      \    /// The total number of items in the skip list. This is not used \
       internally -\n\
      \    /// just here for bookkeeping.\n\
      \    num_items: usize,\n\
      \    /// Size of the list in user specified units.\n\
      \    num_usercount: usize,\n\n\
      \    /// The RNG we use to generate node heights. Specifying it \
       explicitly allows\n\
      \    /// unit tests and randomizer runs to be predictable, which is very \
       helpful\n\
      \    /// during debugging. I'm still not sure how the type of this \
       should be\n\
      \    /// specified. Should it be a generic parameter? Box<dyn *>?\n\
      \    /// ??\n\
      \    rng: Option<SmallRng>,\n\n\
      \    /// The first node is inline. The height is 1 more than the max \
       height we've\n\
      \    /// ever used. The highest next entry points to {null, total \
       usersize}.\n\
      \    head: Node<C>,\n\n\
      \    /// This is so dirty. The first node is embedded in SkipList; but \
       we need to\n\
      \    /// allocate enough room for height to get arbitrarily large. I \
       could insist\n\
      \    /// on SkipList always getting allocated on the heap, but for small \
       lists its\n\
      \    /// much better to be on the stack.\n\
      \    ///\n\
      \    /// So this struct is repr(C) and I'm just padding out the struct \
       directly.\n\
      \    /// All accesses should go through head because otherwise I think \
       we violate\n\
      \    /// aliasing rules.\n\
      \    _nexts_padding: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\n\n\
       impl<C: ListConfig> Node<C> {\n\
      \    // Do I need to be explicit about the lifetime of the references \
       being tied\n\
      \    // to the lifetime of the node?\n\
      \    fn nexts(&self) -> &[SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts(self.nexts.as_ptr(), self.height \
       as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn nexts_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts_mut(self.nexts.as_mut_ptr(), \
       self.height as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn layout_with_height(height: u8) -> Layout {\n\
      \        Layout::from_size_align(\n\
      \            mem::size_of::<Node<C>>() + mem::size_of::<SkipEntry<C>>() \
       * (height as usize),\n\
      \            mem::align_of::<Node<C>>()).unwrap()\n\
      \    }\n\n\
      \    fn alloc_with_height(height: u8) -> *mut Node<C> {\n\
      \        assert!(height >= 1 && height <= MAX_HEIGHT_U8);\n\n\
      \        unsafe {\n\
      \            let node = alloc(Self::layout_with_height(height)) as *mut \
       Node<C>;\n\
      \            (*node) = Node {\n\
      \                items: [C::Item::default(); NODE_NUM_ITEMS],\n\
      \                num_items: 0,\n\
      \                height: height,\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            };\n\n\
      \            for next in (*node).nexts_mut() {\n\
      \                *next = SkipEntry::new_null();\n\
      \            }\n\n\
      \            node\n\
      \        }\n\
      \    }\n\n\
      \    fn alloc<R: RngCore>(rng: &mut R) -> *mut Node<C> {\n\
      \        Self::alloc_with_height(random_height(rng))\n\
      \    }\n\n\
      \    unsafe fn free(p: *mut Node<C>) {\n\
      \        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n\
      \    }\n\n\
      \    fn content_slice(&self) -> &[C::Item] {\n\
      \        &self.items[..self.num_items as usize]\n\
      \    }\n\n\
      \    // The height is at least 1, so this is always valid.\n\
      \    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n\
      \        unsafe { &*self.nexts.as_ptr() }\n\
      \    }\n\n\
      \    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n\
      \        unsafe { &mut *self.nexts.as_mut_ptr() }\n\
      \    }\n\n\
      \    // TODO: Rename to len() ?\n\
      \    fn get_userlen(&self) -> usize {\n\
      \        self.first_skip_entry().skip_usersize\n\
      \    }\n\
      \    \n\
      \    fn get_next_ptr(&self) -> *mut Node<C> {\n\
      \        self.first_skip_entry().node\n\
      \    }\n\
       }\n\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone)]\n\
       pub struct Cursor<C: ListConfig> {\n\
      \    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\n\n\
      \    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///\n\
      \    /// This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    /// the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    /// this.\n\
      \    userpos: usize,\n\n\
      \    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used to resolve that ambiguity.\n\
      \    local_index: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\
       impl<C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\
      \            self.local_index = 0;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    fn is_at_node_end(&self) -> bool {\n\
      \        self.local_index == unsafe { (*self.here_ptr()).num_items } as \
       usize\n\
      \    }\n\n\
      \    fn advance_item(&mut self, height: u8) {\n\
      \        if self.is_at_node_end() { self.advance_node(); }\n\
      \        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }\n\
      \        self.userpos += usersize;\n\
      \        self.local_index += 1;\n\
      \    }\n\n\
      \    fn advance_by_items(&mut self, num: usize, height: u8) {\n\
      \        for _ in 0..num { self.advance_item(height); }\n\
      \    }\n\n\
      \    fn move_to_item_start(&mut self, height: u8, offset: usize) {\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize -= offset;\n\
      \        }\n\
      \        self.userpos -= offset;\n\
      \    }\n\n\
      \    unsafe fn current_item(&mut self) -> &C::Item {\n\
      \        &(*self.here_ptr()).items[self.local_index]\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice.\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos\n\
      \            || self.local_index != other.local_index {return false; }\n\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> fmt::Debug for Cursor<C> {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_struct(\"Cursor\")\n\
      \            .field(\"userpos\", &self.userpos)\n\
      \            .field(\"local_index\", &self.local_index)\n\
      \            .finish()\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new() -> Self {\n\
      \        SkipList::<C> {\n\
      \            num_items: 0,\n\
      \            num_usercount: 0,\n\
      \            rng: None,\n\
      \            head: Node {\n\
      \                items: [C::Item::default(); NODE_NUM_ITEMS],\n\
      \                num_items: 0,\n\
      \                height: 1, // Stores max height of list nodes\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            },\n\
      \            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n\
      \        }\n\
      \    }\n\n\
      \    pub fn init_rng_from_seed(&mut self, seed: u64) {\n\
      \        self.rng = Some(SmallRng::seed_from_u64(seed));\n\
      \    }\n\n\
      \    fn get_rng(&mut self) -> &mut SmallRng {\n\
      \        // I'm sure there's a nicer way to implement this.\n\
      \        if self.rng.is_none() {\n\
      \            // We'll use a stable RNG in debug mode so the tests are \
       stable.\n\
      \            if cfg!(debug_assertions) {\n\
      \                self.init_rng_from_seed(123);\n\
      \            } else {\n\
      \                self.rng = Some(SmallRng::from_entropy());\n\
      \            }\n\
      \        }\n\
      \        self.rng.as_mut().unwrap()\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, s);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn get_userlen(&self) -> usize {\n\
      \        self.num_usercount\n\
      \    }\n\n\
      \    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn len_items(&self) -> usize {\n\
      \        self.num_items as usize\n\
      \    }\n\n\
      \    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            \
       std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), \
       self._nexts_padding.len())\n\
      \        }\n\
      \    }\n\n\
      \    fn is_head(&self, node: *const Node<C>) -> bool {\n\
      \        node as *const _ == &self.head as *const _\n\
      \    }\n\n\
      \    /// Walk the list and validate internal constraints. This is used for\n\
      \    /// testing the structure itself, and should generally not be \
       called by\n\
      \    /// users.\n\
      \    pub fn check(&self) {\n\
      \        // #[cfg(test)]\n\
      \        {\n\
      \            // self.print();\n\
      \            assert!(self.head.height >= 1);\n\
      \            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n\
      \            let head_ptr = &self.head as *const _ as *mut _;\n\
      \            // let skip_over = self.get_top_entry();\n\
      \            // println!(\"Skip over skip chars {}, num bytes {}\", \
       skip_over.skip_items, self.num_bytes);\n\n\
      \            let mut prev: [*const Node<C>; MAX_HEIGHT] = [ptr::null(); \
       MAX_HEIGHT];\n\n\
      \            let mut iter = [SkipEntry {\n\
      \                // Bleh.\n\
      \                node: head_ptr,\n\
      \                // The skips will store the total distance travelled \
       since the\n\
      \                // start of this traversal at each height. All the \
       entries above\n\
      \                // head.height are ignored though.\n\
      \                skip_usersize: 0\n\
      \            }; MAX_HEIGHT];\n\n\
      \            let mut num_items = 0;\n\
      \            let mut num_usercount = 0;\n\n\
      \            for (_i, n) in self.iter().enumerate() {\n\
      \                // println!(\"visiting {:?}\", n.as_str());\n\
      \                if !self.is_head(n) { assert!(n.num_items > 0); }\n\
      \                assert!(n.height <= MAX_HEIGHT_U8);\n\
      \                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n\
      \                // Make sure the number of items matches the count\n\
      \                let local_count = \
       C::userlen_of_slice(&n.items[0..n.num_items as usize]);\n\
      \                assert_eq!(local_count, n.get_userlen());\n\n\
      \                let expect_parent = if self.is_head(n) {\n\
      \                    ptr::null() // The head's parent is null\n\
      \                } else if n.height == self.head.height {\n\
      \                    &self.head as *const _ // Max height nodes point \
       back to head\n\
      \                } else {\n\
      \                    prev[n.height as usize]\n\
      \                };\n\n\
      \                // println!(\"visiting {} {:?}\", i, n as *const _);\n\
      \                // dbg!(n as *const _);\n\
      \                // dbg!((n as *const _, (*n).height));\n\
      \                // dbg!(n.parent);\n\
      \                // dbg!(&self.head as *const _);\n\n\
      \                assert_eq!(n.parent as *const _, expect_parent, \
       \"invalid parent\");\n\
      \                \n\
      \                for (i, entry) in iter[0..n.height as \
       usize].iter_mut().enumerate() {\n\
      \                    assert_eq!(entry.node as *const _, n as *const _);\n\
      \                    assert_eq!(entry.skip_usersize, num_usercount);\n\n\
      \                    // println!(\"replacing entry {:?} with {:?}\", \
       entry, n.nexts()[i].node);\n\
      \                    prev[i] = n;\n\
      \                    entry.node = n.nexts()[i].node;\n\
      \                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n\
      \                }\n\n\
      \                num_items += n.num_items as usize;\n\
      \                num_usercount += n.get_userlen();\n\n\
      \                // Check the value returned by the iterator functions \
       matches.\n\
      \                let (mut normal_iter, local_offset) = \
       self.iter_at_userpos(num_usercount);\n\
      \                assert_eq!(local_offset, 0);\n\n\
      \                // Dirty hack. If n has 0-sized elements at the end, \
       the normal\n\
      \                // cursor won't be at the end...\n\
      \                while normal_iter.here_ptr() != n as *const _ as *mut _ {\n\
      \                    normal_iter.advance_node();\n\
      \                }\n\
      \                normal_iter.local_index = n.num_items as usize;\n\
      \                let node_iter = unsafe { self.iter_at_node(n, \
       n.get_userlen(), n.num_items as usize) };\n\
      \                assert_eq!(normal_iter, node_iter);\n\
      \            }\n\n\
      \            for entry in iter[0..self.head.height as usize].iter() {\n\
      \                // println!(\"{:?}\", entry);\n\
      \                assert!(entry.node.is_null());\n\
      \                assert_eq!(entry.skip_usersize, num_usercount);\n\
      \            }\n\
      \            \n\
      \            // println!(\"self bytes: {}, count bytes {}\", \
       self.num_bytes, num_bytes);\n\
      \            assert_eq!(self.num_items, num_items);\n\
      \            assert_eq!(self.get_userlen(), num_usercount);\n\
      \        }\n\
      \    }\n\
      \    \n\
      \    \n\
      \    /// Internal function for creating a cursor at a particular \
       location in the\n\
      \    /// skiplist. The returned cursor contains list of nodes which \
       point past\n\
      \    /// the specified position, as well as offsets of how far into their\n\
      \    /// character lists the specified characters are.\n\
      \    ///\n\
      \    /// Sometimes a call to iter_at_userpos is ambiguous:\n\
      \    ///\n\
      \    /// - The item can contain items with zero usersize. The cursor \
       could point\n\
      \    ///   to any of them.\n\
      \    /// - If the location is at the end of a node, it is equally valid \
       to return\n\
      \    ///   a position at the start of the next node.\n\
      \    ///\n\
      \    /// Because its impossible to move backwards in the list, \
       iter_at_userpos\n\
      \    /// returns the first admissible location with the specified userpos.\n\
      \    /// \n\
      \    /// Returns (cursor, offset into the specified item).\n\
      \    ///\n\
      \    /// TODO: This should be Pin<&self>.\n\
      \    fn iter_at_userpos(&self, target_userpos: usize) -> (Cursor<C>, \
       usize) {\n\
      \        assert!(target_userpos <= self.get_userlen());\n\n\
      \        let mut e: *const Node<C> = &self.head;\n\
      \        let mut height = self.head.height as usize - 1;\n\
      \        \n\
      \        let mut offset = target_userpos; // How many more items to skip\n\n\
      \        // We're populating the head node pointer to simplify the case \
       when the\n\
      \        // iterator grows. We could put offset into the skip_usersize \
       but it\n\
      \        // would only be *mostly* correct, not always correct. (Since \
       cursor\n\
      \        // entries above height are not updated by insert.)\n\
      \        let mut cursor = Cursor {\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \            local_index: 0,\n\
      \            userpos: target_userpos,\n\
      \        };\n\n\
      \        loop { // while height >= 0\n\
      \            let en = unsafe { &*e };\n\
      \            let next = en.nexts()[height];\n\
      \            let skip = next.skip_usersize;\n\
      \            if offset > skip {\n\
      \                // Go right.\n\
      \                debug_assert!(e == &self.head || en.num_items > 0);\n\
      \                offset -= skip;\n\
      \                e = next.node;\n\
      \                assert!(!e.is_null(), \"Internal constraint violation: \
       Reached rope end prematurely\");\n\
      \            } else {\n\
      \                // Record this and go down.\n\
      \                cursor.entries[height] = SkipEntry {\n\
      \                    skip_usersize: offset,\n\
      \                    node: e as *mut Node<C>, // This is pretty gross\n\
      \                };\n\n\
      \                if height == 0 { break; } else { height -= 1; }\n\
      \            }\n\
      \        };\n\n\
      \        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n\n\
      \        // We've found the node. Now look for the index within the node.\n\
      \        let en = unsafe { &*e };\n\
      \        let mut index = 0;\n\n\
      \        while offset > 0 {\n\
      \            assert!(index < en.num_items as usize);\n\
      \            \n\
      \            let usersize = C::get_usersize(&en.items[index]);\n\
      \            if usersize > offset { break; } // We're in the middle of \
       an item.\n\
      \            offset -= usersize;\n\
      \            index += 1;\n\
      \        }\n\
      \        cursor.local_index = index;\n\n\
      \        (cursor, offset)\n\
      \    }\n\n\
      \    unsafe fn iter_at_node(&self, n: *const Node<C>, mut offset: usize, \
       local_index: usize) -> Cursor<C> {\n\
      \        let mut n = n as *mut Node<C>; // We don't mutate, but we need \
       a mut ptr.\n\n\
      \        let mut cursor = Cursor {\n\
      \            userpos: 0, // We'll set this later.\n\
      \            local_index: local_index,\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \        };\n\n\
      \        let mut h = 0;\n\
      \        loop {\n\
      \            while h < (*n).height as usize {\n\
      \                cursor.entries[h] = SkipEntry {\n\
      \                    node: n,\n\
      \                    skip_usersize: offset\n\
      \                };\n\n\
      \                h += 1;\n\
      \            }\n\n\
      \            let parent = (*n).parent;\n\
      \            // Reached the head.\n\
      \            if parent.is_null() { break; }\n\n\
      \            // If we're the same height as the parent its fine.\n\
      \            debug_assert!((*parent).height as usize > h\n\
      \                || (self.is_head(parent) && (*parent).height as usize \
       == h));\n\n\
      \            // Walk from parent back to n, figuring out the offset.\n\
      \            let mut c = parent;\n\
      \            // let walk_height = (*parent).height as usize - 2;\n\
      \            let walk_height = (*n).height as usize - 1;\n\
      \            while c != n {\n\
      \                let elem = (*c).nexts()[walk_height];\n\
      \                offset += elem.skip_usersize;\n\
      \                c = elem.node;\n\
      \            }\n\n\
      \            n = parent;\n\
      \        }\n\n\
      \        cursor.userpos = offset;\n\
      \        cursor\n\
      \    }\n\n\
      \    pub fn iter_at_marker(&mut self, marker: ItemMarker<C>, query: \
       &<C::Item as Queryable>::Query) -> Cursor<C> where C::Item: Queryable {\n\
      \        // The marker gives us a pointer into a node. Find the item.\n\
      \        unsafe {\n\
      \            let n = marker.ptr;\n\n\
      \            let mut offset: usize = 0;\n\
      \            let mut local_index = None;\n\
      \            for (i, item) in (*n).content_slice().iter().enumerate() {\n\
      \                if let Some(item_offset) = item.contains_item(query) {\n\
      \                    offset += item_offset;\n\
      \                    local_index = Some(i);\n\
      \                    break;\n\
      \                } else {\n\
      \                    offset += C::get_usersize(item);\n\
      \                }\n\
      \            }\n\n\
      \            let local_index = local_index.expect(\"Invalid marker - \
       item not found in node\");\n\
      \            self.iter_at_node(n, offset, local_index)\n\
      \        }\n\
      \    }\n\n\
      \    // Internal fn to create a new node at the specified iterator \
       filled with\n\
      \    // the specified content. The passed cursor should point at the end \
       of the\n\
      \    // previous node. It will be updated to point to the end of the newly\n\
      \    // inserted content.\n\
      \    // unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n\
      \    unsafe fn insert_node_at<Notify>(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool, notify: \
       &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n\n\
      \        // println!(\"Insert_node_at {} len {}\", contents.len(), \
       self.num_bytes);\n\
      \        debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n\
      \        assert!(contents.len() <= NODE_NUM_ITEMS);\n\n\
      \        let new_node_ptr = Node::alloc(self.get_rng());\n\
      \        let new_node = &mut *new_node_ptr;\n\
      \        new_node.num_items = contents.len() as u8;\n\
      \        new_node.items[..contents.len()].copy_from_slice(contents);\n\n\
      \        let new_height = new_node.height;\n\
      \        let new_height_usize = new_height as usize;\n\n\
      \        let mut head_height = self.head.height as usize;\n\
      \        while head_height < new_height_usize {\n\
      \            // This seems weird given we're about to overwrite these \
       values\n\
      \            // below. What we're doing is retroactively setting up the \
       cursor\n\
      \            // and head pointers *as if* the height had been this high \
       all\n\
      \            // along. This way we only have to populate the higher head \
       values\n\
      \            // lazily.\n\
      \            let total_userlen = self.num_usercount;\n\
      \            let nexts = self.heads_mut();\n\
      \            nexts[head_height].skip_usersize = total_userlen;\n\
      \            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n\
      \            head_height += 1; // This is ugly.\n\
      \            self.head.height += 1;\n\
      \        }\n\n\
      \        new_node.parent = if new_height_usize == MAX_HEIGHT {\n\
      \            &self.head as *const _ as *mut _\n\
      \        } else { cursor.entries[new_height_usize].node };\n\n\
      \        for i in 0..new_height_usize {\n\
      \            let prev_skip = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \            let new_nexts = new_node.nexts_mut();\n\n\
      \            // The new node points to the successor (or null)\n\
      \            new_nexts[i] = SkipEntry {\n\
      \                node: prev_skip.node,\n\
      \                skip_usersize: new_userlen + prev_skip.skip_usersize - \
       cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // The previous node points to the new node\n\
      \            *prev_skip = SkipEntry {\n\
      \                node: new_node_ptr,\n\
      \                skip_usersize: cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // Move the iterator to the end of the newly inserted node.\n\
      \            if move_cursor {\n\
      \                cursor.entries[i] = SkipEntry {\n\
      \                    node: new_node_ptr,\n\
      \                    skip_usersize: new_userlen\n\
      \                };\n\
      \            }\n\
      \        }\n\n\
      \        for i in new_height_usize..head_height {\n\
      \            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n\
      \            if move_cursor {\n\
      \                cursor.entries[i].skip_usersize += new_userlen;\n\
      \            }\n\
      \        }\n\n\
      \        // Update parents.\n\
      \        if new_height_usize > 1 {\n\n\
      \            let mut n = new_node_ptr;\n\
      \            let mut skip_height = 0;\n\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[skip_height].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\
      \                \n\
      \                (*n).parent = new_node_ptr;\n\
      \                skip_height = usize::max(skip_height, (*n).height as \
       usize - 1);\n\
      \            }\n\
      \        }\n\
      \        \n\
      \        self.num_items += contents.len();\n\
      \        self.num_usercount += new_userlen;\n\
      \        if move_cursor {\n\
      \            cursor.userpos += new_userlen;\n\
      \            cursor.local_index = contents.len();\n\
      \        }\n\n\
      \        notify(contents, ItemMarker {\n\
      \            ptr: new_node_ptr,\n\
      \            _phantom: PhantomData\n\
      \        });\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    unsafe fn insert_at_iter<Notify>(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n\
      \        // iter specifies where to insert.\n\n\
      \        let mut e = cursor.here_ptr();\n\n\
      \        // The insertion offset into the destination node.\n\
      \        assert!(cursor.userpos <= self.num_usercount);\n\
      \        assert!(cursor.local_index <= (*e).num_items as usize);\n\n\
      \        // We might be able to insert the new data into the current \
       node, depending on\n\
      \        // how big it is.\n\
      \        let num_inserted_items = contents.len();\n\
      \        let num_inserted_usercount = C::userlen_of_slice(contents);\n\n\
      \        // Can we insert into the current node?\n\
      \        let mut insert_here = (*e).num_items as usize + \
       num_inserted_items <= NODE_NUM_ITEMS;\n\n\
      \        // Can we insert into the start of the successor node?\n\
      \        if !insert_here && cursor.local_index == (*e).num_items as \
       usize && num_inserted_items <= NODE_NUM_ITEMS {\n\
      \            // We can insert into the subsequent node if:\n\
      \            // - We can't insert into the current node\n\
      \            // - There _is_ a next node to insert into\n\
      \            // - The insert would be at the start of the next node\n\
      \            // - There's room in the next node\n\
      \            if let Some(next) = \
       (*e).first_skip_entry_mut().node.as_mut() {\n\
      \                if next.num_items as usize + num_inserted_items <= \
       NODE_NUM_ITEMS {\n\
      \                    cursor.advance_node();\n\
      \                    e = next;\n\n\
      \                    insert_here = true;\n\
      \                }\n\
      \            }\n\
      \        }\n\n\
      \        let item_idx = cursor.local_index;\n\
      \        let e_num_items = (*e).num_items as usize; // convenience.\n\n\
      \        if insert_here {\n\
      \            // println!(\"insert_here {}\", contents);\n\
      \            // First push the current items later in the array\n\
      \            let c = &mut (*e).items;\n\
      \            if item_idx < e_num_items {\n\
      \                c[..].copy_within(item_idx..e_num_items,\n\
      \                    item_idx + num_inserted_items);\n\
      \            }\n\n\
      \            // Then copy in the new items\n\
      \            c[item_idx..item_idx + \
       num_inserted_items].copy_from_slice(contents);\n\n\
      \            (*e).num_items += num_inserted_items as u8;\n\
      \            self.num_items += num_inserted_items;\n\
      \            self.num_usercount += num_inserted_usercount;\n\n\
      \            // .... aaaand update all the offset amounts.\n\
      \            cursor.update_offsets(self.head.height as usize, \
       num_inserted_usercount as isize);\n\n\
      \            // Usually the cursor will be discarded after one change, \
       but for\n\
      \            // consistency of compound edits we'll update the cursor to \
       point to\n\
      \            // the end of the new content.\n\
      \            for entry in cursor.entries[0..self.head.height as \
       usize].iter_mut() {\n\
      \                entry.skip_usersize += num_inserted_usercount;\n\
      \            }\n\
      \            cursor.userpos += num_inserted_usercount;\n\
      \            cursor.local_index += num_inserted_items;\n\n\
      \            notify(contents, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData\n\
      \            });\n\
      \        } else {\n\
      \            // There isn't room. We'll need to add at least one new \
       node to the\n\
      \            // list. We could be a bit more careful here and copy as \
       much as\n\
      \            // possible into the current node - that would decrease the \
       number\n\
      \            // of new nodes in some cases, but I don't think the \
       performance\n\
      \            // difference will be large enough to justify the \
       complexity.\n\n\
      \            // If we're not at the end of the current node, we'll need \
       to remove\n\
      \            // the end of the current node's data and reinsert it later.\n\
      \            let num_end_items = e_num_items - item_idx;\n\n\
      \            let (end_items, end_usercount) = if num_end_items > 0 {\n\
      \                // We'll mark the items as deleted from the node, while \
       leaving\n\
      \                // the data itself there for now to avoid a copy.\n\n\
      \                // Note that if we wanted to, it would also be correct \
       (and\n\
      \                // slightly more space efficient) to pack some of the new\n\
      \                // string's characters into this node after trimming it.\n\
      \                let end_items = &(*e).items[item_idx..e_num_items];\n\
      \                (*e).num_items = item_idx as u8;\n\
      \                let end_usercount = (*e).get_userlen() - \
       cursor.entries[0].skip_usersize;\n\n\
      \                cursor.update_offsets(self.head.height as usize, \
       -(end_usercount as isize));\n\n\
      \                // We need to trim the size off because we'll add the \
       characters\n\
      \                // back with insert_node_at.\n\
      \                self.num_usercount -= end_usercount;\n\
      \                self.num_items -= num_end_items;\n\n\
      \                (Some(end_items), end_usercount)\n\
      \            } else {\n\
      \                (None, 0)\n\
      \            };\n\n\
      \            // Now we insert new nodes containing the new character \
       data. The\n\
      \            // data is broken into pieces with a maximum size of \
       NODE_NUM_ITEMS.\n\
      \            // As further optimization, we could try and fit the last \
       piece into\n\
      \            // the start of the subsequent node. That optimization \
       hasn't been\n\
      \            // added.\n\
      \            \n\
      \            for chunk in contents.chunks(NODE_NUM_ITEMS) {\n\
      \                let userlen = C::userlen_of_slice(chunk);\n\
      \                self.insert_node_at(cursor, chunk, userlen, true, \
       notify);\n\
      \            }\n\n\
      \            // TODO: Consider recursively calling insert_at_iter() here \
       instead\n\
      \            // of making a whole new node for the remaining content.\n\
      \            if let Some(end_items) = end_items {\n\
      \                // Passing false to indicate we don't want the cursor \
       updated\n\
      \                // after this - it should remain at the end of the newly\n\
      \                // inserted content, which is *before* this end bit.\n\
      \                self.insert_node_at(cursor, end_items, end_usercount, \
       false, notify);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    //     self.insert_at_iter_and_notify(cursor, contents, \
       Self::no_notify);\n\
      \    // }\n\n\
      \    /// Interestingly unlike the original, here we only care about \
       specifying\n\
      \    /// the number of removed items by counting them. We do not use \
       usersize in\n\
      \    /// the deleted item count.\n\
      \    ///\n\
      \    /// If the deleted content occurs at the start of a node, the \
       cursor passed\n\
      \    /// here must point to the end of the previous node, not the start \
       of the\n\
      \    /// current node.\n\
      \    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       num_deleted_items: usize) {\n\
      \        if num_deleted_items == 0 { return; }\n\n\
      \        let mut item_idx = cursor.local_index;\n\
      \        let mut e = cursor.here_ptr();\n\
      \        while num_deleted_items > 0 {\n\
      \            // self.print();\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \            if item_idx == (*e).num_items as usize {\n\
      \                let entry = (*e).first_skip_entry();\n\
      \                // End of current node. Skip to the start of the next \
       one. We're\n\
      \                // intentionally not updating the iterator because if \
       we delete\n\
      \                // a whole node we need the iterator to point to the \
       previous\n\
      \                // element. And if we only delete here, the iterator \
       doesn't\n\
      \                // need to be moved.\n\
      \                e = entry.node;\n\
      \                if e.is_null() { panic!(\"Cannot delete past the end of \
       the list\"); }\n\
      \                item_idx = 0;\n\
      \            }\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let removed_here = min(num_deleted_items, e_num_items - \
       item_idx);\n\
      \            \n\
      \            let height = (*e).height as usize;\n\
      \            let removed_userlen;\n\n\
      \            if removed_here < e_num_items || e as *const _ == \
       &self.head as *const _ {\n\
      \                // Just trim the node down.\n\
      \                let trailing_items = e_num_items - item_idx - \
       removed_here;\n\
      \                \n\
      \                let c = &mut (*e).items;\n\
      \                removed_userlen = \
       C::userlen_of_slice(&c[item_idx..item_idx + removed_here]);\n\
      \                if trailing_items > 0 {\n\
      \                    c[..].copy_within(item_idx + \
       removed_here..e_num_items, item_idx);\n\
      \                }\n\n\
      \                (*e).num_items -= removed_here as u8;\n\
      \                self.num_items -= removed_here;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                for s in (*e).nexts_mut() {\n\
      \                    s.skip_usersize -= removed_userlen;\n\
      \                }\n\
      \            } else {\n\
      \                // Remove the node from the skip list entirely. e \
       should be the\n\
      \                // next node after the position of the iterator.\n\
      \                assert_ne!(cursor.here_ptr(), e);\n\n\
      \                removed_userlen = (*e).get_userlen();\n\
      \                let next = (*e).first_skip_entry().node;\n\n\
      \                // println!(\"removing {:?} contents {:?} height {}\", \
       e, (*e).content_slice(), height);\n\n\
      \                for i in 0..height {\n\
      \                    let s = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                    s.node = (*e).nexts_mut()[i].node;\n\
      \                    s.skip_usersize += (*e).nexts()[i].skip_usersize - \
       removed_userlen;\n\
      \                }\n\n\
      \                self.num_items -= (*e).num_items as usize;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                // Update parents.\n\
      \                if height > 1 {\n\
      \                    let mut n = e;\n\
      \                    // let new_parent = cursor.entries[height - \
       1].node;\n\n\
      \                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents.\n\
      \                    let mut parent_height = 1;\n\
      \                    let cursor_node = cursor.here_ptr();\n\
      \                    let cursor_node_height = (*cursor_node).height as \
       usize;\n\
      \                    let mut new_parent = if height >= \
       cursor_node_height {\n\
      \                        cursor.entries[parent_height].node\n\
      \                    } else {\n\
      \                        cursor_node\n\
      \                    };\n\n\
      \                    loop {\n\
      \                        // dbg!(skip_height);\n\
      \                        // dbg!((*n).height as usize);\n\n\
      \                        n = (*n).nexts_mut()[parent_height - 1].node;\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }\n\
      \                        let n_height = (*n).height as usize;\n\n\
      \                        // dbg!((*n).content_slice());\n\
      \                        // dbg!((*n).height);\n\
      \                        \n\
      \                        assert_eq!((*n).parent, e);\n\
      \                        assert!(n_height >= parent_height - 1);\n\n\
      \                        if n_height > parent_height {\n\
      \                            parent_height = n_height;\n\
      \                            if n_height >= cursor_node_height {\n\
      \                                new_parent = \
       cursor.entries[parent_height].node\n\
      \                            }\n\
      \                        }\n\
      \                        \n\
      \                        (*n).parent = new_parent;\n\
      \                    }\n\
      \                }\n\n\
      \                Node::free(e);\n\
      \                e = next;\n\
      \            }\n\n\
      \            for i in height..self.head.height as usize {\n\
      \                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                s.skip_usersize -= removed_userlen;\n\
      \            }\n\n\
      \            num_deleted_items -= removed_here;\n\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter<Notify>(&mut self, cursor: &mut \
       Cursor<C>, contents: &[C::Item], mut notify: Notify)\n\
      \    // where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n\n\
      \    unsafe fn replace_at_iter<Notify>(&mut self, cursor: &mut \
       Cursor<C>, mut removed_items: usize, mut inserted_content: &[C::Item], \
       mut notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n\
      \        if removed_items == 0 && inserted_content.len() == 0 { return; \
       }\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \        removed_items -= replaced_items;\n\n\
      \        while replaced_items > 0 {\n\
      \            let mut e = cursor.here_ptr();\n\
      \            if cursor.local_index == (*e).num_items as usize {\n\
      \                // Move to the next item.\n\
      \                e = cursor.advance_node();\n\
      \                if e.is_null() { panic!(\"Cannot replace past the end \
       of the list\"); }\n\
      \            }\n\n\
      \            let index = cursor.local_index;\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let replaced_items_here = min(replaced_items, e_num_items - \
       index);\n\n\
      \            let old_items = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \            let new_items = &inserted_content[0..replaced_items_here];\n\n\
      \            let new_usersize = C::userlen_of_slice(new_items);\n\
      \            let usersize_delta = new_usersize as isize - \
       C::userlen_of_slice(old_items) as isize;\n\n\
      \            // Replace the items themselves. Everything else is \
       commentary.\n\
      \            old_items.copy_from_slice(new_items);\n\n\
      \            if usersize_delta != 0 {\n\
      \                cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \            }\n\
      \            // I hate this.\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\n\
      \            inserted_content = &inserted_content[replaced_items_here..];\n\
      \            replaced_items -= replaced_items_here;\n\
      \            // We'll hop to the next Node at the start of the next loop\n\
      \            // iteration if needed.\n\
      \            cursor.local_index += replaced_items_here;\n\n\
      \            for i in 0..self.head.height as usize {\n\
      \                cursor.entries[i].skip_usersize += new_usersize;\n\
      \            }\n\
      \            cursor.userpos += new_usersize;\n\n\
      \            notify(new_items, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });\n\
      \        }\n\n\
      \        // Ok now one of two things must be true. Either we've run out of\n\
      \        // items to remove, or we've run out of items to insert.\n\
      \        if inserted_content.len() > 0 {\n\
      \            // Insert!\n\
      \            debug_assert!(removed_items == 0);\n\
      \            self.insert_at_iter(cursor, inserted_content, &mut notify);\n\
      \        } else if removed_items > 0 {\n\
      \            self.del_at_iter(cursor, removed_items);\n\
      \        }\n\
      \    }\n\n\
      \    fn dbg_check_cursor_at(&self, cursor: &Cursor<C>, userpos: usize, \
       plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            // let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n\
      \    }\n\n\
      \    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}\n\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, \
       inserted_content, Self::no_notify); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(start_userpos);\n\
      \            c2.advance_by_items(inserted_content.len(), \
       self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       replace\"); }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn insert_at(&mut self, mut userpos: usize, contents: \
       &[C::Item]) {\n\
      \        if contents.len() == 0 { return; }\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        unsafe {\n\
      \            if offset == 0 {\n\
      \                self.insert_at_iter(&mut cursor, contents, &mut \
       Self::no_notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\
      \            } else {\n\
      \                let current_item = cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                cursor.move_to_item_start(self.head.height, offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.replace_at_iter(&mut cursor, 1, &[start], &mut \
       Self::no_notify);\n\
      \                self.insert_at_iter(&mut cursor, contents, &mut \
       Self::no_notify);\n\n\
      \                // There's no clean way to keep the cursor steady for \
       the final\n\
      \                // insert. We'll just make sure the cursor is in the \
       right\n\
      \                // position before that call for now.\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\n\
      \                self.insert_at_iter(&mut cursor, &[end], &mut \
       Self::no_notify);\n\
      \            }\n\
      \        }\n\n\
      \    }\n\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.iter_at_userpos(userpos);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> where C::Item: PartialEq {\n\
      \    pub fn eq_list(&self, other: &[C::Item]) -> bool {\n\
      \        let mut pos = 0;\n\
      \        let other_len = other.len();\n\n\
      \        for node in self.iter() {\n\
      \            let my_data = node.content_slice();\n\
      \            let my_len = my_data.len();\n\n\
      \            if pos + my_len > other_len || my_data != &other[pos..pos + \
       my_data.len()] {\n\
      \                return false\n\
      \            }\n\
      \            pos += my_data.len();\n\
      \        }\n\n\
      \        return pos == other_len;\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Drop for SkipList<C> {\n\
      \    fn drop(&mut self) {\n\
      \        let mut node = self.head.first_skip_entry().node;\n\
      \        unsafe {\n\
      \            while !node.is_null() {\n\
      \                let next = (*node).first_skip_entry().node;\n\
      \                Node::free(node);\n\
      \                node = next;\n\
      \            }\n\
      \        }\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> From<&[C::Item]> for SkipList<C> {\n\
      \    fn from(s: &[C::Item]) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s)\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> {\n\
      \    fn from(s: Vec<C::Item>) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s.as_slice())\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Into<Vec<C::Item>> for &SkipList<C> {\n\
      \    fn into(self) -> Vec<C::Item> {\n\
      \        let mut content = Vec::with_capacity(self.num_items);\n" );
    ( 783,
      50216,
      "use std::mem::MaybeUninit;\n\
       use std::ptr::NonNull;\n\
       use std::alloc::{alloc, dealloc, Layout};\n\
       use std::cmp::min;\n\
       use std::marker::PhantomData;\n\
       use std::iter;\n\n\
       use std::fmt;\n\n\
       use rand::{RngCore, Rng, SeedableRng};\n\
       use rand::rngs::SmallRng;\n\n\
       /// The likelyhood a node will have height (n+1) instead of n\n\
       const BIAS: u8 = 100; // out of 256.\n\n\
       /// The number of items in each node. Must fit in a u8 thanks to Node.\n\
       #[cfg(debug_assertions)]\n\
       const NODE_NUM_ITEMS: usize = 10;\n\n\
       #[cfg(not(debug_assertions))]\n\
       const NODE_NUM_ITEMS: usize = 100;\n\n\
       /// Rope operations will move to linear time after NODE_STR_SIZE * 2 ^\n\
       /// MAX_HEIGHT length. (With a smaller constant the higher this is). On \
       the flip\n\
       /// side, cursors grow linearly with this number; so smaller is \
       marginally\n\
       /// better when the contents are smaller.\n\
       #[cfg(debug_assertions)]\n\
       const MAX_HEIGHT: usize = 5;\n\n\
       #[cfg(not(debug_assertions))]\n\
       const MAX_HEIGHT: usize = 10;\n\n\n\
       const MAX_HEIGHT_U8: u8 = MAX_HEIGHT as u8; // convenience.\n\n\
       pub struct ItemMarker<'a, C: ListConfig> {\n\
      \    ptr: *mut Node<C>,\n\
      \    _phantom: PhantomData<&'a SkipList<C>>\n\
       }\n\n\
       /// The whole list is configured through a single generic trait parameter\n\
       pub trait ListConfig {\n\
      \    type Item; //+ std::fmt::Debug;\n\n\
      \    /// Applications which have custom sizes (or do their own\n\
      \    /// run-length-encoding) can define their own size function for \
       items. When\n\
      \    /// items are inserted or replaced, the position is specified using \
       the\n\
      \    /// custom size defined here.\n\
      \    fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\n\
      \    fn userlen_of_slice(items: &[Self::Item]) -> usize {\n\
      \        items.iter().fold(0, |acc, item| {\n\
      \            acc + Self::get_usersize(item)\n\
      \        })\n\
      \    }\n\n\
      \    fn split_item(_item: &Self::Item, _at: usize) -> (Self::Item, \
       Self::Item) {\n\
      \        unimplemented!(\"Cannot insert in the middle of an item - \
       split_item is not defined in trait\");\n\
      \    }\n\n\
      \    // fn notify(&mut self, _items: &[Self::Item], _at_marker: \
       ItemMarker<Self>) where Self: Sized {\n\
      \    // }\n\
      \    \n\
       }\n\n\
       pub trait Queryable {\n\
      \    type Query;\n\n\
      \    // Returns Some(offset) into the item if its contained. Otherwise \
       None.\n\
      \    fn contains_item(&self, query: &Self::Query) -> Option<usize>;\n\
       }\n\n\
       /// This represents a single entry in either the nexts pointers list or \
       in an\n\
       /// iterator.\n\
       #[derive(Debug, PartialEq, Eq)]\n\
       struct SkipEntry<C: ListConfig> {\n\
      \    /// The node being pointed to.\n\
      \    node: *mut Node<C>,\n\n\
      \    /// The number of *items* between the start of the current node and \
       the\n\
      \    /// start of the next node. That means nexts entry 0 contains the \
       length of\n\
      \    /// the current node.\n\
      \    skip_usersize: usize,\n\
       }\n\n\
       // We can't use #[derive()] here for Copy and Clone due to a bug in the \
       rust\n\
       // compiler: https://github.com/rust-lang/rust/issues/26925\n\
       impl<C: ListConfig> Copy for SkipEntry<C> {}\n\
       impl<C: ListConfig> Clone for SkipEntry<C> {\n\
      \    fn clone(&self) -> Self { *self }\n\
       }\n\n\
       impl<C: ListConfig> SkipEntry<C> {\n\
      \    fn new_null() -> Self {\n\
      \        SkipEntry { node: ptr::null_mut(), skip_usersize: 0 }\n\
      \    }\n\
       }\n\n\n\n\
       /// The node structure is designed in a very fancy way which would be \
       more at\n\
       /// home in C or something like that. The basic idea is that the node \
       structure\n\
       /// is fixed size in memory, but the proportion of that space taken up by\n\
       /// characters and by the height differ depending on a node's height. \
       This\n\
       /// results in a lot of `unsafe` blocks. I think the tradeoff is worth \
       it but I\n\
       /// could be wrong here. You probably wouldn't lose much performance in \
       practice\n\
       /// by replacing the inline structure with a smallvec - but that would \
       waste\n\
       /// memory in small nodes, and require extra pointer indirection on \
       large nodes.\n\
       /// It also wouldn't remove all the unsafe here.\n\
       ///\n\
       /// A different representation (which might be better or worse - I \
       can't tell)\n\
       /// would be to have the nodes all be the same size in memory and \
       change the\n\
       /// *proportion* of the node's memory that is used by the string field \
       vs the\n\
       /// next pointers. That might be lighter weight for the allocator \
       because the\n\
       /// struct itself would be a fixed size; but I'm not sure if it would \
       be better.\n\
       #[repr(C)] // Prevent parameter reordering.\n\
       struct Node<C: ListConfig> {\n\
      \    /// We start with the items themselves. Only the first `num_items` \
       of this\n\
      \    /// list is in use. The user specified length of the items in the \
       node is\n\
      \    /// stored in nexts[0].skip_items. This is initialized with\n\
      \    /// Default::default() for the type, but when MaybeUninit \
       completely lands,\n\
      \    /// it will be possible to make this a tiny bit faster by leaving \
       the list\n\
      \    /// initially uninitialized.\n\
      \    items: [MaybeUninit<C::Item>; NODE_NUM_ITEMS],\n\n\
      \    /// Number of items in `items` in use / filled.\n\
      \    num_items: u8,\n\n\
      \    /// Height of nexts array.\n\
      \    height: u8,\n\n\
      \    /// With the heads array as is, we have no way to go from a marker \
       back to a\n\
      \    /// cursor (which is required to insert at that location in the \
       list). For\n\
      \    /// that we need to be able to figure out at each level of the nexts\n\
      \    /// pointers which object points to us, and the offset from that \
       element to\n\
      \    /// the current element. Anyway, for markers to work we need this.\n\
      \    parent: *mut Node<C>,\n\n\
      \    // #[repr(align(std::align_of::<SkipEntry>()))]\n\
      \    \n\
      \    /// In reality this array has the size of height, allocated using \
       more or\n\
      \    /// less direct calls to malloc() at runtime based on the randomly \
       generated\n\
      \    /// size. The size is always at least 1.\n\
      \    nexts: [SkipEntry<C>; 0],\n\
       }\n\n\
       // Make sure nexts uses correct alignment. This should be guaranteed by \
       repr(C)\n\
       // This test will fail if this ever stops being true.\n\
       #[test]\n\
       fn test_align() {\n\
      \    struct TestConfig;\n\
      \    impl ListConfig for TestConfig {\n\
      \        type Item = u8;\n\
      \        fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\
      \    }\n\
      \    #[repr(C)] struct Check([SkipEntry<TestConfig>; 0]);\n\
      \    assert!(mem::align_of::<Check>() >= \
       mem::align_of::<SkipEntry<TestConfig>>());\n\
      \    // TODO: It'd be good to also check the alignment of the nexts \
       field in Node.\n\
       }\n\n\
       fn random_height<R: RngCore>(rng: &mut R) -> u8 {\n\
      \    let mut h: u8 = 1;\n\
      \    // Should I use a csrng here? Does it matter?\n\
      \    while h < MAX_HEIGHT_U8 && rng.gen::<u8>() < BIAS { h+=1; }\n\
      \    h\n\
       }\n\n\
       #[repr(C)]\n\
       pub struct SkipList<C: ListConfig> {\n\
      \    // TODO: Consider putting the head item on the heap. For the use \
       case here\n\
      \    // its almost certainly fine either way. The code feels a bit \
       cleaner if its\n\
      \    // on the heap (and then iterators will be able to outlast a move \
       of the\n\
      \    // skiplist parent). But its also very nice having the code run \
       fast for\n\
      \    // small lists. Most lists are small, and it makes sense to \
       optimize for\n\
      \    // that.\n\n\
      \    // TODO: For safety, pointers in to this structure should be Pin<> \
       if we\n\
      \    // ever want to hold on to iterators.\n\n\
      \    /// The total number of items in the skip list. This is not used \
       internally -\n\
      \    /// just here for bookkeeping.\n\
      \    num_items: usize,\n\
      \    /// Size of the list in user specified units.\n\
      \    num_usercount: usize,\n\n\
      \    /// The RNG we use to generate node heights. Specifying it \
       explicitly allows\n\
      \    /// unit tests and randomizer runs to be predictable, which is very \
       helpful\n\
      \    /// during debugging. I'm still not sure how the type of this \
       should be\n\
      \    /// specified. Should it be a generic parameter? Box<dyn *>?\n\
      \    /// ??\n\
      \    rng: Option<SmallRng>,\n\n\
      \    /// The first node is inline. The height is 1 more than the max \
       height we've\n\
      \    /// ever used. The highest next entry points to {null, total \
       usersize}.\n\
      \    head: Node<C>,\n\n\
      \    /// This is so dirty. The first node is embedded in SkipList; but \
       we need to\n\
      \    /// allocate enough room for height to get arbitrarily large. I \
       could insist\n\
      \    /// on SkipList always getting allocated on the heap, but for small \
       lists its\n\
      \    /// much better to be on the stack.\n\
      \    ///\n\
      \    /// So this struct is repr(C) and I'm just padding out the struct \
       directly.\n\
      \    /// All accesses should go through head because otherwise I think \
       we violate\n\
      \    /// aliasing rules.\n\
      \    _nexts_padding: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\n\
       impl<C: ListConfig> Node<C> {\n\
      \    // Do I need to be explicit about the lifetime of the references \
       being tied\n\
      \    // to the lifetime of the node?\n\
      \    fn nexts(&self) -> &[SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts(self.nexts.as_ptr(), self.height \
       as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn nexts_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            std::slice::from_raw_parts_mut(self.nexts.as_mut_ptr(), \
       self.height as usize)\n\
      \        }\n\
      \    }\n\n\
      \    fn layout_with_height(height: u8) -> Layout {\n\
      \        Layout::from_size_align(\n\
      \            mem::size_of::<Node<C>>() + mem::size_of::<SkipEntry<C>>() \
       * (height as usize),\n\
      \            mem::align_of::<Node<C>>()).unwrap()\n\
      \    }\n\n\
      \    fn alloc_with_height(height: u8) -> *mut Node<C> {\n\
      \        assert!(height >= 1 && height <= MAX_HEIGHT_U8);\n\n\
      \        unsafe {\n\
      \            let node = alloc(Self::layout_with_height(height)) as *mut \
       Node<C>;\n\
      \            (*node) = Node {\n\
      \                items: uninit_items_array(),\n\
      \                num_items: 0,\n\
      \                height: height,\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            };\n\n\
      \            for next in (*node).nexts_mut() {\n\
      \                *next = SkipEntry::new_null();\n\
      \            }\n\n\
      \            node\n\
      \        }\n\
      \    }\n\n\
      \    fn alloc<R: RngCore>(rng: &mut R) -> *mut Node<C> {\n\
      \        Self::alloc_with_height(random_height(rng))\n\
      \    }\n\n\
      \    unsafe fn free(p: *mut Node<C>) {\n\
      \        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n\
      \    }\n\n\
      \    fn content_slice(&self) -> &[C::Item] {\n\
      \        // TODO: Use MaybeUninit::slice_get_ref when it lands. This \
       code is stolen from that implementation.\n\n\
      \        // SAFETY: casting slice to a `*const [T]` is safe since the \
       caller guarantees that\n\
      \        // `slice` is initialized, and`MaybeUninit` is guaranteed to \
       have the same layout as `T`.\n\
      \        // The pointer obtained is valid since it refers to memory \
       owned by `slice` which is a\n\
      \        // reference and thus guaranteed to be valid for reads.\n\
      \        let slice = &self.items[..self.num_items as usize];\n\
      \        unsafe { maybeinit_slice_get_ref(slice) }\n\
      \    }\n\n\
      \    // The height is at least 1, so this is always valid.\n\
      \    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n\
      \        unsafe { &*self.nexts.as_ptr() }\n\
      \    }\n\n\
      \    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n\
      \        unsafe { &mut *self.nexts.as_mut_ptr() }\n\
      \    }\n\n\
      \    // TODO: Rename to len() ?\n\
      \    fn get_userlen(&self) -> usize {\n\
      \        self.first_skip_entry().skip_usersize\n\
      \    }\n\
      \    \n\
      \    fn get_next_ptr(&self) -> *mut Node<C> {\n\
      \        self.first_skip_entry().node\n\
      \    }\n\
       }\n\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone)]\n\
       pub struct Cursor<C: ListConfig> {\n\
      \    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\n\n\
      \    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///\n\
      \    /// This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    /// the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    /// this.\n\
      \    userpos: usize,\n\n\
      \    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used to resolve that ambiguity.\n\
      \    local_index: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\
       impl<C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\
      \            self.local_index = 0;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    fn is_at_node_end(&self) -> bool {\n\
      \        self.local_index == unsafe { (*self.here_ptr()).num_items } as \
       usize\n\
      \    }\n\n\
      \    fn advance_item(&mut self, height: u8) {\n\
      \        if self.is_at_node_end() { self.advance_node(); }\n\
      \        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }\n\
      \        self.userpos += usersize;\n\
      \        self.local_index += 1;\n\
      \    }\n\n\
      \    fn advance_by_items(&mut self, num: usize, height: u8) {\n\
      \        for _ in 0..num { self.advance_item(height); }\n\
      \    }\n\n\
      \    fn move_to_item_start(&mut self, height: u8, offset: usize) {\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize -= offset;\n\
      \        }\n\
      \        self.userpos -= offset;\n\
      \    }\n\n\
      \    unsafe fn current_item(&mut self) -> &C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &*(node.items[self.local_index].as_ptr())\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice.\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos\n\
      \            || self.local_index != other.local_index {return false; }\n\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> fmt::Debug for Cursor<C> {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_struct(\"Cursor\")\n\
      \            .field(\"userpos\", &self.userpos)\n\
      \            .field(\"local_index\", &self.local_index)\n\
      \            .finish()\n\
      \    }\n\
       }\n\n\
       // None of the rust builtins give me what I want, which is a copy-free \
       iterator\n\
       // to owned items in a MaybeUninit array. Eh; its easy enough to make \
       my own.\n\
       struct UninitOwnedIter<'a, C: ListConfig> {\n\
      \    // Based on the core slice IterMut implementation.\n\
      \    ptr: NonNull<C::Item>,\n\
      \    end: *mut C::Item,\n\
      \    _marker: PhantomData<&'a SkipList<C>>\n\
       }\n\n\
       impl<'a, C: ListConfig> UninitOwnedIter<'a, C> {\n\
      \    /// Make a slice we can iterate from and steal from. Its unsafe if:\n\
      \    /// \n\
      \    /// - The iterator isn't fully drained (then we might not drop \
       contents)\n\
      \    /// - The contents we iterate over aren't initialized\n\
      \    /// \n\
      \    /// After iterating, the contents are uninit memory.\n\
      \    unsafe fn from_slice(slice: &[MaybeUninit<C::Item>]) -> Self {\n\
      \        let ptr = slice.as_ptr() as *mut C::Item; // Safe.\n\
      \        let end = ptr.add(slice.len());\n\n\
      \        UninitOwnedIter {\n\
      \            ptr: NonNull::new_unchecked(ptr),\n\
      \            end,\n\
      \            _marker: PhantomData\n\
      \        }\n\
      \    }\n\
      \    // unsafe fn from_slice(slice: &[C::Item]) -> Self {\n\
      \    //     unsafe {\n\
      \    //         let ptr = slice.as_mut_ptr();\n\
      \    //         let end = ptr.add(slice.len());\n\n\
      \    //         UninitOwnedIter {\n\
      \    //             ptr: NonNull::new_unchecked(ptr),\n\
      \    //             end,\n\
      \    //             _marker: PhantomData\n\
      \    //         }\n\
      \    //     }\n\
      \    // }\n\
       }\n\n\
       impl<'a, C: ListConfig> Iterator for UninitOwnedIter<'a, C> {\n\
      \    type Item = C::Item;\n\n\
      \    fn next(&mut self) -> Option<Self::Item> {\n\
      \        if self.ptr.as_ptr() == self.end {\n\
      \            None\n\
      \        } else {\n\
      \            Some(unsafe { self.ptr.as_ptr().read() })\n\
      \        }\n\
      \    }\n\
       }\n\n\
       // TODO: Stolen from MaybeUninit::uninit_array. Replace with the real \
       uninit_array when stable.\n\
       #[inline(always)]\n\
       fn uninit_items_array<T>() -> [MaybeUninit<T>; NODE_NUM_ITEMS] {\n\
      \    unsafe { MaybeUninit::<[MaybeUninit<T>; \
       NODE_NUM_ITEMS]>::uninit().assume_init() }\n\
       }\n\n\
       // Stolen from core::mem::MaybeUninit. Its just not standardized yet.\n\
       #[inline(always)]\n\
       unsafe fn maybeinit_slice_get_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {\n\
      \    // SAFETY: casting slice to a `*const [T]` is safe since the caller \
       guarantees that\n\
      \    // `slice` is initialized, and`MaybeUninit` is guaranteed to have \
       the same layout as `T`.\n\
      \    // The pointer obtained is valid since it refers to memory owned by \
       `slice` which is a\n\
      \    // reference and thus guaranteed to be valid for reads.\n\
      \    &*(slice as *const [MaybeUninit<T>] as *const [T])\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new() -> Self {\n\
      \        SkipList::<C> {\n\
      \            num_items: 0,\n\
      \            num_usercount: 0,\n\
      \            rng: None,\n\
      \            head: Node {\n\
      \                items: uninit_items_array(),\n\
      \                num_items: 0,\n\
      \                height: 1, // Stores max height of list nodes\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            },\n\
      \            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n\
      \        }\n\
      \    }\n\n\
      \    pub fn init_rng_from_seed(&mut self, seed: u64) {\n\
      \        self.rng = Some(SmallRng::seed_from_u64(seed));\n\
      \    }\n\n\
      \    fn get_rng(&mut self) -> &mut SmallRng {\n\
      \        // I'm sure there's a nicer way to implement this.\n\
      \        if self.rng.is_none() {\n\
      \            // We'll use a stable RNG in debug mode so the tests are \
       stable.\n\
      \            if cfg!(debug_assertions) {\n\
      \                self.init_rng_from_seed(123);\n\
      \            } else {\n\
      \                self.rng = Some(SmallRng::from_entropy());\n\
      \            }\n\
      \        }\n\
      \        self.rng.as_mut().unwrap()\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, s);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn get_userlen(&self) -> usize {\n\
      \        self.num_usercount\n\
      \    }\n\n\
      \    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn len_items(&self) -> usize {\n\
      \        self.num_items as usize\n\
      \    }\n\n\
      \    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            \
       std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), \
       self._nexts_padding.len())\n\
      \        }\n\
      \    }\n\n\
      \    fn is_head(&self, node: *const Node<C>) -> bool {\n\
      \        node as *const _ == &self.head as *const _\n\
      \    }\n\n\
      \    /// Walk the list and validate internal constraints. This is used for\n\
      \    /// testing the structure itself, and should generally not be \
       called by\n\
      \    /// users.\n\
      \    pub fn check(&self) {\n\
      \        // #[cfg(test)]\n\
      \        {\n\
      \            // self.print();\n\
      \            assert!(self.head.height >= 1);\n\
      \            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n\
      \            let head_ptr = &self.head as *const _ as *mut _;\n\
      \            // let skip_over = self.get_top_entry();\n\
      \            // println!(\"Skip over skip chars {}, num bytes {}\", \
       skip_over.skip_items, self.num_bytes);\n\n\
      \            let mut prev: [*const Node<C>; MAX_HEIGHT] = [ptr::null(); \
       MAX_HEIGHT];\n\n\
      \            let mut iter = [SkipEntry {\n\
      \                // Bleh.\n\
      \                node: head_ptr,\n\
      \                // The skips will store the total distance travelled \
       since the\n\
      \                // start of this traversal at each height. All the \
       entries above\n\
      \                // head.height are ignored though.\n\
      \                skip_usersize: 0\n\
      \            }; MAX_HEIGHT];\n\n\
      \            let mut num_items = 0;\n\
      \            let mut num_usercount = 0;\n\n\
      \            for (_i, n) in self.iter().enumerate() {\n\
      \                // println!(\"visiting {:?}\", n.as_str());\n\
      \                if !self.is_head(n) { assert!(n.num_items > 0); }\n\
      \                assert!(n.height <= MAX_HEIGHT_U8);\n\
      \                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n\
      \                // Make sure the number of items matches the count\n\
      \                let local_count = C::userlen_of_slice(n.content_slice());\n\
      \                assert_eq!(local_count, n.get_userlen());\n\n\
      \                let expect_parent = if self.is_head(n) {\n\
      \                    ptr::null() // The head's parent is null\n\
      \                } else if n.height == self.head.height {\n\
      \                    &self.head as *const _ // Max height nodes point \
       back to head\n\
      \                } else {\n\
      \                    prev[n.height as usize]\n\
      \                };\n\n\
      \                // println!(\"visiting {} {:?}\", i, n as *const _);\n\
      \                // dbg!(n as *const _);\n\
      \                // dbg!((n as *const _, (*n).height));\n\
      \                // dbg!(n.parent);\n\
      \                // dbg!(&self.head as *const _);\n\n\
      \                assert_eq!(n.parent as *const _, expect_parent, \
       \"invalid parent\");\n\
      \                \n\
      \                for (i, entry) in iter[0..n.height as \
       usize].iter_mut().enumerate() {\n\
      \                    assert_eq!(entry.node as *const _, n as *const _);\n\
      \                    assert_eq!(entry.skip_usersize, num_usercount);\n\n\
      \                    // println!(\"replacing entry {:?} with {:?}\", \
       entry, n.nexts()[i].node);\n\
      \                    prev[i] = n;\n\
      \                    entry.node = n.nexts()[i].node;\n\
      \                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n\
      \                }\n\n\
      \                num_items += n.num_items as usize;\n\
      \                num_usercount += n.get_userlen();\n\n\
      \                // Check the value returned by the iterator functions \
       matches.\n\
      \                let (mut normal_iter, local_offset) = \
       self.iter_at_userpos(num_usercount);\n\
      \                assert_eq!(local_offset, 0);\n\n\
      \                // Dirty hack. If n has 0-sized elements at the end, \
       the normal\n\
      \                // cursor won't be at the end...\n\
      \                while normal_iter.here_ptr() != n as *const _ as *mut _ {\n\
      \                    normal_iter.advance_node();\n\
      \                }\n\
      \                normal_iter.local_index = n.num_items as usize;\n\
      \                let node_iter = unsafe { self.iter_at_node(n, \
       n.get_userlen(), n.num_items as usize) };\n\
      \                assert_eq!(normal_iter, node_iter);\n\
      \            }\n\n\
      \            for entry in iter[0..self.head.height as usize].iter() {\n\
      \                // println!(\"{:?}\", entry);\n\
      \                assert!(entry.node.is_null());\n\
      \                assert_eq!(entry.skip_usersize, num_usercount);\n\
      \            }\n\
      \            \n\
      \            // println!(\"self bytes: {}, count bytes {}\", \
       self.num_bytes, num_bytes);\n\
      \            assert_eq!(self.num_items, num_items);\n\
      \            assert_eq!(self.get_userlen(), num_usercount);\n\
      \        }\n\
      \    }\n\
      \    \n\
      \    \n\
      \    /// Internal function for creating a cursor at a particular \
       location in the\n\
      \    /// skiplist. The returned cursor contains list of nodes which \
       point past\n\
      \    /// the specified position, as well as offsets of how far into their\n\
      \    /// character lists the specified characters are.\n\
      \    ///\n\
      \    /// Sometimes a call to iter_at_userpos is ambiguous:\n\
      \    ///\n\
      \    /// - The item can contain items with zero usersize. The cursor \
       could point\n\
      \    ///   to any of them.\n\
      \    /// - If the location is at the end of a node, it is equally valid \
       to return\n\
      \    ///   a position at the start of the next node.\n\
      \    ///\n\
      \    /// Because its impossible to move backwards in the list, \
       iter_at_userpos\n\
      \    /// returns the first admissible location with the specified userpos.\n\
      \    /// \n\
      \    /// Returns (cursor, offset into the specified item).\n\
      \    ///\n\
      \    /// TODO: This should be Pin<&self>.\n\
      \    fn iter_at_userpos(&self, target_userpos: usize) -> (Cursor<C>, \
       usize) {\n\
      \        assert!(target_userpos <= self.get_userlen());\n\n\
      \        let mut e: *const Node<C> = &self.head;\n\
      \        let mut height = self.head.height as usize - 1;\n\
      \        \n\
      \        let mut offset = target_userpos; // How many more items to skip\n\n\
      \        // We're populating the head node pointer to simplify the case \
       when the\n\
      \        // iterator grows. We could put offset into the skip_usersize \
       but it\n\
      \        // would only be *mostly* correct, not always correct. (Since \
       cursor\n\
      \        // entries above height are not updated by insert.)\n\
      \        let mut cursor = Cursor {\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \            local_index: 0,\n\
      \            userpos: target_userpos,\n\
      \        };\n\n\
      \        loop { // while height >= 0\n\
      \            let en = unsafe { &*e };\n\
      \            let next = en.nexts()[height];\n\
      \            let skip = next.skip_usersize;\n\
      \            if offset > skip {\n\
      \                // Go right.\n\
      \                debug_assert!(e == &self.head || en.num_items > 0);\n\
      \                offset -= skip;\n\
      \                e = next.node;\n\
      \                assert!(!e.is_null(), \"Internal constraint violation: \
       Reached rope end prematurely\");\n\
      \            } else {\n\
      \                // Record this and go down.\n\
      \                cursor.entries[height] = SkipEntry {\n\
      \                    skip_usersize: offset,\n\
      \                    node: e as *mut Node<C>, // This is pretty gross\n\
      \                };\n\n\
      \                if height == 0 { break; } else { height -= 1; }\n\
      \            }\n\
      \        };\n\n\
      \        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n\n\
      \        // We've found the node. Now look for the index within the node.\n\
      \        let en = unsafe { &*e };\n\
      \        let mut index = 0;\n\n\
      \        while offset > 0 {\n\
      \            assert!(index < en.num_items as usize);\n\
      \            \n\
      \            let usersize = C::get_usersize(unsafe { \
       &*en.items[index].as_ptr() });\n\
      \            if usersize > offset { break; } // We're in the middle of \
       an item.\n\
      \            offset -= usersize;\n\
      \            index += 1;\n\
      \        }\n\
      \        cursor.local_index = index;\n\n\
      \        (cursor, offset)\n\
      \    }\n\n\
      \    unsafe fn iter_at_node(&self, n: *const Node<C>, mut offset: usize, \
       local_index: usize) -> Cursor<C> {\n\
      \        let mut n = n as *mut Node<C>; // We don't mutate, but we need \
       a mut ptr.\n\n\
      \        let mut cursor = Cursor {\n\
      \            userpos: 0, // We'll set this later.\n\
      \            local_index: local_index,\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \        };\n\n\
      \        let mut h = 0;\n\
      \        loop {\n\
      \            while h < (*n).height as usize {\n\
      \                cursor.entries[h] = SkipEntry {\n\
      \                    node: n,\n\
      \                    skip_usersize: offset\n\
      \                };\n\n\
      \                h += 1;\n\
      \            }\n\n\
      \            let parent = (*n).parent;\n\
      \            // Reached the head.\n\
      \            if parent.is_null() { break; }\n\n\
      \            // If we're the same height as the parent its fine.\n\
      \            debug_assert!((*parent).height as usize > h\n\
      \                || (self.is_head(parent) && (*parent).height as usize \
       == h));\n\n\
      \            // Walk from parent back to n, figuring out the offset.\n\
      \            let mut c = parent;\n\
      \            // let walk_height = (*parent).height as usize - 2;\n\
      \            let walk_height = (*n).height as usize - 1;\n\
      \            while c != n {\n\
      \                let elem = (*c).nexts()[walk_height];\n\
      \                offset += elem.skip_usersize;\n\
      \                c = elem.node;\n\
      \            }\n\n\
      \            n = parent;\n\
      \        }\n\n\
      \        cursor.userpos = offset;\n\
      \        cursor\n\
      \    }\n\n\
      \    pub fn iter_at_marker(&mut self, marker: ItemMarker<C>, query: \
       &<C::Item as Queryable>::Query) -> Cursor<C> where C::Item: Queryable {\n\
      \        // The marker gives us a pointer into a node. Find the item.\n\
      \        unsafe {\n\
      \            let n = marker.ptr;\n\n\
      \            let mut offset: usize = 0;\n\
      \            let mut local_index = None;\n\
      \            for (i, item) in (*n).content_slice().iter().enumerate() {\n\
      \                if let Some(item_offset) = item.contains_item(query) {\n\
      \                    offset += item_offset;\n\
      \                    local_index = Some(i);\n\
      \                    break;\n\
      \                } else {\n\
      \                    offset += C::get_usersize(item);\n\
      \                }\n\
      \            }\n\n\
      \            let local_index = local_index.expect(\"Invalid marker - \
       item not found in node\");\n\
      \            self.iter_at_node(n, offset, local_index)\n\
      \        }\n\
      \    }\n\n\
      \    // Internal fn to create a new node at the specified iterator \
       filled with\n\
      \    // the specified content. The passed cursor should point at the end \
       of the\n\
      \    // previous node. It will be updated to point to the end of the newly\n\
      \    // inserted content.\n\
      \    // unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n\
      \    unsafe fn insert_node_at<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, num_items: usize, move_cursor: bool, \
       notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       Iterator<Item=C::Item> {\n\n\
      \        // println!(\"Insert_node_at {} len {}\", contents.len(), \
       self.num_bytes);\n\
      \        // debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n\
      \        assert!(num_items <= NODE_NUM_ITEMS);\n\
      \        debug_assert!(contents.size_hint().0 >= num_items);\n\n\
      \        let new_node_ptr = Node::alloc(self.get_rng());\n\
      \        let new_node = &mut *new_node_ptr;\n\
      \        // let num_items = contents.len();\n\
      \        new_node.num_items = num_items as u8;\n\n\
      \        for (slot, item) in \
       new_node.items[..num_items].iter_mut().zip(contents) {\n\
      \            (slot.as_mut_ptr() as *mut C::Item).write(item); // Write \
       makes sure we don't drop the old value.\n\
      \        }\n\
      \        // new_node.items[..contents.len()].copy_from_slice(contents);\n\n\
      \        let new_userlen = \
       C::userlen_of_slice(new_node.content_slice());\n\n\
      \        let new_height = new_node.height;\n\
      \        let new_height_usize = new_height as usize;\n\n\
      \        let mut head_height = self.head.height as usize;\n\
      \        while head_height < new_height_usize {\n\
      \            // This seems weird given we're about to overwrite these \
       values\n\
      \            // below. What we're doing is retroactively setting up the \
       cursor\n\
      \            // and head pointers *as if* the height had been this high \
       all\n\
      \            // along. This way we only have to populate the higher head \
       values\n\
      \            // lazily.\n\
      \            let total_userlen = self.num_usercount;\n\
      \            let nexts = self.heads_mut();\n\
      \            nexts[head_height].skip_usersize = total_userlen;\n\
      \            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n\
      \            head_height += 1; // This is ugly.\n\
      \            self.head.height += 1;\n\
      \        }\n\n\
      \        new_node.parent = if new_height_usize == MAX_HEIGHT {\n\
      \            &self.head as *const _ as *mut _\n\
      \        } else { cursor.entries[new_height_usize].node };\n\n\
      \        for i in 0..new_height_usize {\n\
      \            let prev_skip = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \            let new_nexts = new_node.nexts_mut();\n\n\
      \            // The new node points to the successor (or null)\n\
      \            new_nexts[i] = SkipEntry {\n\
      \                node: prev_skip.node,\n\
      \                skip_usersize: new_userlen + prev_skip.skip_usersize - \
       cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // The previous node points to the new node\n\
      \            *prev_skip = SkipEntry {\n\
      \                node: new_node_ptr,\n\
      \                skip_usersize: cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // Move the iterator to the end of the newly inserted node.\n\
      \            if move_cursor {\n\
      \                cursor.entries[i] = SkipEntry {\n\
      \                    node: new_node_ptr,\n\
      \                    skip_usersize: new_userlen\n\
      \                };\n\
      \            }\n\
      \        }\n\n\
      \        for i in new_height_usize..head_height {\n\
      \            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n\
      \            if move_cursor {\n\
      \                cursor.entries[i].skip_usersize += new_userlen;\n\
      \            }\n\
      \        }\n\n\
      \        // Update parents.\n\
      \        if new_height_usize > 1 {\n\n\
      \            let mut n = new_node_ptr;\n\
      \            let mut skip_height = 0;\n\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[skip_height].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\
      \                \n\
      \                (*n).parent = new_node_ptr;\n\
      \                skip_height = usize::max(skip_height, (*n).height as \
       usize - 1);\n\
      \            }\n\
      \        }\n\
      \        \n\
      \        self.num_items += num_items;\n\
      \        self.num_usercount += new_userlen;\n\
      \        if move_cursor {\n\
      \            cursor.userpos += new_userlen;\n\
      \            cursor.local_index = num_items;\n\
      \        }\n\n\
      \        notify(new_node.content_slice(), ItemMarker {\n\
      \            ptr: new_node_ptr,\n\
      \            _phantom: PhantomData\n\
      \        });\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    unsafe fn insert_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        // iter specifies where to insert.\n\n\
      \        let mut e = cursor.here_ptr();\n\n\
      \        // The insertion offset into the destination node.\n\
      \        assert!(cursor.userpos <= self.num_usercount);\n\
      \        assert!(cursor.local_index <= (*e).num_items as usize);\n\n\
      \        // We might be able to insert the new data into the current \
       node, depending on\n\
      \        // how big it is.\n\
      \        let num_inserted_items = contents.len();\n\
      \        // let num_inserted_usercount = C::userlen_of_slice(contents);\n\n\
      \        // Can we insert into the current node?\n\
      \        let mut insert_here = (*e).num_items as usize + \
       num_inserted_items <= NODE_NUM_ITEMS;\n\n\
      \        // Can we insert into the start of the successor node?\n\
      \        if !insert_here && cursor.local_index == (*e).num_items as \
       usize && num_inserted_items <= NODE_NUM_ITEMS {\n\
      \            // We can insert into the subsequent node if:\n\
      \            // - We can't insert into the current node\n\
      \            // - There _is_ a next node to insert into\n\
      \            // - The insert would be at the start of the next node\n\
      \            // - There's room in the next node\n\
      \            if let Some(next) = \
       (*e).first_skip_entry_mut().node.as_mut() {\n\
      \                if next.num_items as usize + num_inserted_items <= \
       NODE_NUM_ITEMS {\n\
      \                    cursor.advance_node();\n\
      \                    e = next;\n\n\
      \                    insert_here = true;\n\
      \                }\n\
      \            }\n\
      \        }\n\n\
      \        let item_idx = cursor.local_index;\n\
      \        let e_num_items = (*e).num_items as usize; // convenience.\n\n\
      \        if insert_here {\n\
      \            // println!(\"insert_here {}\", contents);\n\
      \            // First push the current items later in the array\n\
      \            let c = &mut (*e).items;\n\
      \            if item_idx < e_num_items {\n\
      \                // Can't use copy_within because we aren't sure if the \
       type\n\
      \                // implements Copy. Memmove the existing items.\n\
      \                ptr::copy(\n\
      \                    &c[item_idx],\n\
      \                    &mut c[item_idx + num_inserted_items],\n\
      \                    (*e).num_items as usize - item_idx);\n\
      \                // c[..].copy_within(item_idx..e_num_items,\n\
      \                //     item_idx + num_inserted_items);\n\
      \            }\n\n\
      \            // Then copy in the new items. Can't memcpy from an \
       iterator, but\n\
      \            // the optimizer should make this fast.\n\
      \            let dest_content_slice = &mut c[item_idx..item_idx + \
       num_inserted_items];\n\
      \            for (slot, item) in \
       dest_content_slice.iter_mut().zip(contents) {\n\
      \                // Do not drop the old items - they were only moved.\n\
      \                slot.as_mut_ptr().write(item);\n\
      \            }\n\
      \            let dest_content_slice = \
       maybeinit_slice_get_ref(dest_content_slice);\n\
      \            // c[item_idx..item_idx + \
       num_inserted_items].copy_from_slice(contents);\n\n\
      \            (*e).num_items += num_inserted_items as u8;\n\
      \            self.num_items += num_inserted_items;\n\
      \            let num_inserted_usercount = \
       C::userlen_of_slice(dest_content_slice);\n\
      \            self.num_usercount += num_inserted_usercount;\n\n\
      \            // .... aaaand update all the offset amounts.\n\
      \            cursor.update_offsets(self.head.height as usize, \
       num_inserted_usercount as isize);\n\n\
      \            // Usually the cursor will be discarded after one change, \
       but for\n\
      \            // consistency of compound edits we'll update the cursor to \
       point to\n\
      \            // the end of the new content.\n\
      \            for entry in cursor.entries[0..self.head.height as \
       usize].iter_mut() {\n\
      \                entry.skip_usersize += num_inserted_usercount;\n\
      \            }\n\
      \            cursor.userpos += num_inserted_usercount;\n\
      \            cursor.local_index += num_inserted_items;\n\n\
      \            notify(dest_content_slice, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData\n\
      \            });\n\
      \        } else {\n\
      \            // There isn't room. We'll need to add at least one new \
       node to the\n\
      \            // list. We could be a bit more careful here and copy as \
       much as\n\
      \            // possible into the current node - that would decrease the \
       number\n\
      \            // of new nodes in some cases, but I don't think the \
       performance\n\
      \            // difference will be large enough to justify the \
       complexity.\n\n\
      \            // If we're not at the end of the current node, we'll need \
       to remove\n\
      \            // the end of the current node's data and reinsert it later.\n\
      \            let num_end_items = e_num_items - item_idx;\n\n\
      \            let (end_items, end_usercount) = if num_end_items > 0 {\n\
      \                // We'll mark the items as deleted from the node, while \
       leaving\n\
      \                // the data itself there for now to avoid a copy.\n\n\
      \                // Note that if we wanted to, it would also be correct \
       (and\n\
      \                // slightly more space efficient) to pack some of the new\n\
      \                // string's characters into this node after trimming it.\n\
      \                let end_items = &(*e).items[item_idx..e_num_items];\n\
      \                (*e).num_items = item_idx as u8;\n\
      \                let end_usercount = (*e).get_userlen() - \
       cursor.entries[0].skip_usersize;\n\n\
      \                cursor.update_offsets(self.head.height as usize, \
       -(end_usercount as isize));\n\n\
      \                // We need to trim the size off because we'll add the \
       characters\n\
      \                // back with insert_node_at.\n\
      \                self.num_usercount -= end_usercount;\n\
      \                self.num_items -= num_end_items;\n\n\
      \                (Some(end_items), end_usercount)\n\
      \            } else {\n\
      \                (None, 0)\n\
      \            };\n\n\
      \            // Now we insert new nodes containing the new character \
       data. The\n\
      \            // data is broken into pieces with a maximum size of \
       NODE_NUM_ITEMS.\n\
      \            // As further optimization, we could try and fit the last \
       piece into\n\
      \            // the start of the subsequent node.\n\
      \            let mut items_remaining = num_inserted_items;\n\
      \            while items_remaining > 0 {\n\
      \                let insert_here = usize::min(items_remaining, \
       NODE_NUM_ITEMS);\n\
      \                self.insert_node_at(cursor, contents, insert_here, \
       true, notify);\n\
      \                items_remaining -= insert_here;\n\
      \            }\n\
      \            // for chunk in contents.take(NODE_NUM_ITEMS) {\n\
      \            //     // let userlen = C::userlen_of_slice(chunk);\n\
      \            //     self.insert_node_at(cursor, chunk, true, notify);\n\
      \            // }\n\n\
      \            // TODO: Consider recursively calling insert_at_iter() here \
       instead\n\
      \            // of making a whole new node for the remaining content.\n\
      \            if let Some(end_items) = end_items {\n\
      \                // Passing false to indicate we don't want the cursor \
       updated\n\
      \                // after this - it should remain at the end of the newly\n\
      \                // inserted content, which is *before* this end bit.\n\
      \                self.insert_node_at(cursor, &mut \
       UninitOwnedIter::<C>::from_slice(end_items), end_usercount, false, \
       notify);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    //     self.insert_at_iter_and_notify(cursor, contents, \
       Self::no_notify);\n\
      \    // }\n\n\
      \    /// Interestingly unlike the original, here we only care about \
       specifying\n\
      \    /// the number of removed items by counting them. We do not use \
       usersize in\n\
      \    /// the deleted item count.\n\
      \    ///\n\
      \    /// If the deleted content occurs at the start of a node, the \
       cursor passed\n\
      \    /// here must point to the end of the previous node, not the start \
       of the\n\
      \    /// current node.\n\
      \    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       num_deleted_items: usize) {\n\
      \        if num_deleted_items == 0 { return; }\n\n\
      \        let mut item_idx = cursor.local_index;\n\
      \        let mut e = cursor.here_ptr();\n\
      \        while num_deleted_items > 0 {\n\
      \            // self.print();\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \            if item_idx == (*e).num_items as usize {\n\
      \                let entry = (*e).first_skip_entry();\n\
      \                // End of current node. Skip to the start of the next \
       one. We're\n\
      \                // intentionally not updating the iterator because if \
       we delete\n\
      \                // a whole node we need the iterator to point to the \
       previous\n\
      \                // element. And if we only delete here, the iterator \
       doesn't\n\
      \                // need to be moved.\n\
      \                e = entry.node;\n\
      \                if e.is_null() { panic!(\"Cannot delete past the end of \
       the list\"); }\n\
      \                item_idx = 0;\n\
      \            }\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let removed_here = min(num_deleted_items, e_num_items - \
       item_idx);\n\
      \            \n\
      \            let height = (*e).height as usize;\n\
      \            let removed_userlen;\n\n\
      \            if removed_here < e_num_items || e as *const _ == \
       &self.head as *const _ {\n\
      \                // Just trim the node down.\n\
      \                let trailing_items = e_num_items - item_idx - \
       removed_here;\n\
      \                \n\
      \                let c = &mut (*e).items;\n\
      \                removed_userlen = \
       C::userlen_of_slice(maybeinit_slice_get_ref(&c[item_idx..item_idx + \
       removed_here]));\n\
      \                if trailing_items > 0 {\n\
      \                    ptr::copy(\n\
      \                        &c[item_idx + removed_here],\n\
      \                        &mut c[item_idx],\n\
      \                        trailing_items);\n\
      \                    // c[..].copy_within(item_idx + \
       removed_here..e_num_items, item_idx);\n\
      \                }\n\n\
      \                (*e).num_items -= removed_here as u8;\n\
      \                self.num_items -= removed_here;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                for s in (*e).nexts_mut() {\n\
      \                    s.skip_usersize -= removed_userlen;\n\
      \                }\n\
      \            } else {\n\
      \                // Remove the node from the skip list entirely. e \
       should be the\n\
      \                // next node after the position of the iterator.\n\
      \                assert_ne!(cursor.here_ptr(), e);\n\n\
      \                removed_userlen = (*e).get_userlen();\n\
      \                let next = (*e).first_skip_entry().node;\n\n\
      \                // println!(\"removing {:?} contents {:?} height {}\", \
       e, (*e).content_slice(), height);\n\n\
      \                for i in 0..height {\n\
      \                    let s = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                    s.node = (*e).nexts_mut()[i].node;\n\
      \                    s.skip_usersize += (*e).nexts()[i].skip_usersize - \
       removed_userlen;\n\
      \                }\n\n\
      \                self.num_items -= (*e).num_items as usize;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                // Update parents.\n\
      \                if height > 1 {\n\
      \                    let mut n = e;\n\
      \                    // let new_parent = cursor.entries[height - \
       1].node;\n\n\
      \                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents.\n\
      \                    let mut parent_height = 1;\n\
      \                    let cursor_node = cursor.here_ptr();\n\
      \                    let cursor_node_height = (*cursor_node).height as \
       usize;\n\
      \                    let mut new_parent = if height >= \
       cursor_node_height {\n\
      \                        cursor.entries[parent_height].node\n\
      \                    } else {\n\
      \                        cursor_node\n\
      \                    };\n\n\
      \                    loop {\n\
      \                        // dbg!(skip_height);\n\
      \                        // dbg!((*n).height as usize);\n\n\
      \                        n = (*n).nexts_mut()[parent_height - 1].node;\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }\n\
      \                        let n_height = (*n).height as usize;\n\n\
      \                        // dbg!((*n).content_slice());\n\
      \                        // dbg!((*n).height);\n\
      \                        \n\
      \                        assert_eq!((*n).parent, e);\n\
      \                        assert!(n_height >= parent_height - 1);\n\n\
      \                        if n_height > parent_height {\n\
      \                            parent_height = n_height;\n\
      \                            if n_height >= cursor_node_height {\n\
      \                                new_parent = \
       cursor.entries[parent_height].node\n\
      \                            }\n\
      \                        }\n\
      \                        \n\
      \                        (*n).parent = new_parent;\n\
      \                    }\n\
      \                }\n\n\
      \                Node::free(e);\n\
      \                e = next;\n\
      \            }\n\n\
      \            for i in height..self.head.height as usize {\n\
      \                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                s.skip_usersize -= removed_userlen;\n\
      \            }\n\n\
      \            num_deleted_items -= removed_here;\n\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter<Notify>(&mut self, cursor: &mut \
       Cursor<C>, contents: &[C::Item], mut notify: Notify)\n\
      \    // where Notify: FnMut(&[C::Item], ItemMarker<C>) {\n\n\
      \    unsafe fn replace_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, mut removed_items: usize, inserted_content: &mut I, mut \
       notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        if removed_items == 0 && inserted_content.len() == 0 { return; \
       }\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \        removed_items -= replaced_items;\n\n\
      \        while replaced_items > 0 {\n\
      \            debug_assert!(inserted_content.len() >= replaced_items);\n\
      \            let mut e = cursor.here_ptr();\n\
      \            if cursor.local_index == (*e).num_items as usize {\n\
      \                // Move to the next item.\n\
      \                e = cursor.advance_node();\n\
      \                if e.is_null() { panic!(\"Cannot replace past the end \
       of the list\"); }\n\
      \            }\n\n\
      \            let index = cursor.local_index;\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let replaced_items_here = min(replaced_items, e_num_items - \
       index);\n\n\
      \            let dest = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \            let old_usersize = \
       C::userlen_of_slice(maybeinit_slice_get_ref(dest));\n\n\
      \            // Replace the items themselves. Everything else is \
       commentary.\n\
      \            // Would prefer to use zip() but it wants ownership of \
       inserted_content :/\n\
      \            for slot in dest.iter_mut() {\n\
      \                *slot.as_mut_ptr() = inserted_content.next().unwrap();\n\
      \            }\n\
      \            // for (slot, item) in \
       dest.iter_mut().zip(inserted_content) {\n\
      \            //     *slot.as_mut_ptr() = item; // Drop the replaced \
       content.\n\
      \            // }\n\n\
      \            let dest = maybeinit_slice_get_ref(dest);\n\
      \            let new_usersize = C::userlen_of_slice(dest);\n\
      \            let usersize_delta = new_usersize as isize - old_usersize \
       as isize;\n\n\
      \            // old_items.copy_from_slice(new_items);\n\n\
      \            if usersize_delta != 0 {\n\
      \                cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \            }\n\
      \            // I hate this.\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\n\
      \            // inserted_content = \
       &inserted_content[replaced_items_here..];\n\
      \            replaced_items -= replaced_items_here;\n\
      \            // We'll hop to the next Node at the start of the next loop\n\
      \            // iteration if needed.\n\
      \            cursor.local_index += replaced_items_here;\n\n\
      \            for i in 0..self.head.height as usize {\n\
      \                cursor.entries[i].skip_usersize += new_usersize;\n\
      \            }\n\
      \            cursor.userpos += new_usersize;\n\n\
      \            notify(dest, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });\n\
      \        }\n\n\
      \        // Ok now one of two things must be true. Either we've run out of\n\
      \        // items to remove, or we've run out of items to insert.\n\
      \        if inserted_content.len() > 0 {\n\
      \            // Insert!\n\
      \            debug_assert!(removed_items == 0);\n\
      \            self.insert_at_iter(cursor, inserted_content, &mut notify);\n\
      \        } else if removed_items > 0 {\n\
      \            self.del_at_iter(cursor, removed_items);\n\
      \        }\n\
      \    }\n\n\
      \    fn dbg_check_cursor_at(&self, cursor: &Cursor<C>, userpos: usize, \
       plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            // let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n\
      \    }\n\n\
      \    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}\n\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, &mut \
       inserted_content.iter().copied(), Self::no_notify); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(start_userpos);\n\
      \            c2.advance_by_items(inserted_content.len(), \
       self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       replace\"); }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn insert_at(&mut self, mut userpos: usize, contents: \
       &[C::Item]) where C::Item: Copy {\n\
      \        if contents.len() == 0 { return; }\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        unsafe {\n\
      \            if offset == 0 {\n\
      \                self.insert_at_iter(&mut cursor, &mut \
       contents.iter().copied(), &mut Self::no_notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\
      \            } else {\n\
      \                let current_item = cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                cursor.move_to_item_start(self.head.height, offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.replace_at_iter(&mut cursor, 1, &mut \
       iter::once(start), &mut Self::no_notify);\n\
      \                self.insert_at_iter(&mut cursor, &mut \
       contents.iter().copied(), &mut Self::no_notify);\n\n\
      \                // There's no clean way to keep the cursor steady for \
       the final\n\
      \                // insert. We'll just make sure the cursor is in the \
       right\n\
      \                // position before that call for now.\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\n\
      \                self.insert_at_iter(&mut cursor, &mut iter::once(end), \
       &mut Self::no_notify);\n\
      \            }\n\
      \        }\n\n\
      \    }\n\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.iter_at_userpos(userpos);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> where C::Item: PartialEq {\n\
      \    pub fn eq_list(&self, other: &[C::Item]) -> bool {\n\
      \        let mut pos = 0;\n\
      \        let other_len = other.len();\n\n\
      \        for node in self.iter() {\n\
      \            let my_data = node.content_slice();\n\
      \            let my_len = my_data.len();\n\n\
      \            if pos + my_len > other_len || my_data != &other[pos..pos + \
       my_data.len()] {\n\
      \                return false\n\
      \            }\n\
      \            pos += my_data.len();\n\
      \        }\n\n\
      \        return pos == other_len;\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Drop for SkipList<C> {\n\
      \    fn drop(&mut self) {\n\
      \        let mut node = self.head.first_skip_entry().node;\n\
      \        unsafe {\n\
      \            while !node.is_null() {\n\
      \                let next = (*node).first_skip_entry().node;\n\
      \                Node::free(node);\n\
      \                node = next;\n\
      \            }\n\
      \        }\n\
      \    }\n\
       }\n\n\n\
       impl<C: ListConfig> From<&[C::Item]> for SkipList<C> where C::Item: \
       Copy {\n\
      \    fn from(s: &[C::Item]) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s)\n\
      \    }\n\
       }\n\n\
       // TODO: Remove Item: Copy constraint here.\n\
       impl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> where C::Item: \
       Copy {\n\
      \    fn from(s: Vec<C::Item>) -> SkipList<C> {\n\
      \        SkipList::new_from_slice(s.as_slice())\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Into<Vec<C::Item>> for &SkipList<C> where C::Item: \
       Copy {\n\
      \    fn into(self) -> Vec<C::Item> {\n\
      \        let mut content: Vec<C::Item> = \
       Vec::with_capacity(self.num_items);\n" );
    (18233, 0, "\n    ");
    (18238, 0, "\n    ");
    (18234, 4, "");
    (18239, 0, "f");
    (18240, 0, "n");
    (18241, 0, " ");
    (18239, 3, "");
    (18235, 4, "");
    (18234, 1, "");
    (18878, 0, "\n    ");
    (18883, 0, "\n    ");
    (18879, 4, "");
    (18884, 0, "f");
    (18885, 0, "n");
    (18886, 0, " ");
    (18887, 0, "i");
    (18888, 0, "z");
    (18888, 1, "");
    (18887, 1, "");
    (18887, 0, "s");
    (18888, 0, "i");
    (18889, 0, "z");
    (18890, 0, "e");
    (18891, 0, "_");
    (18892, 0, "h");
    (18893, 0, "i");
    (18894, 0, "n");
    (18895, 0, "t");
    (18896, 0, "(");
    (18897, 0, "&");
    (18898, 0, "s");
    (18899, 0, "e");
    (18900, 0, "l");
    (18901, 0, "f");
    (18902, 0, ")");
    (18903, 0, " ");
    (18904, 0, "-");
    (18905, 0, ">");
    (18906, 0, " ");
    (18907, 0, "(");
    (18908, 0, "u");
    (18909, 0, "s");
    (18910, 0, "e");
    (18911, 0, "i");
    (18911, 1, "");
    (18910, 1, "");
    (18910, 0, "i");
    (18911, 0, "z");
    (18912, 0, "e");
    (18913, 0, ",");
    (18914, 0, " ");
    (18915, 0, "O");
    (18916, 0, "p");
    (18917, 0, "t");
    (18918, 0, "i");
    (18919, 0, "o");
    (18920, 0, "n");
    (18921, 0, "<");
    (18922, 0, "u");
    (18923, 0, "s");
    (18924, 0, "i");
    (18925, 0, "z");
    (18926, 0, "e");
    (18927, 0, ">");
    (18928, 0, ")");
    (18929, 0, " ");
    (18930, 0, "{");
    (18931, 0, " ");
    (18932, 0, "\n        ");
    (18941, 0, "\n        ");
    (18933, 8, "");
    (18934, 8, "    }");
    (18931, 1, "");
    (18932, 0, "        ");
    (18940, 0, "l");
    (18941, 0, "e");
    (18942, 0, "t");
    (18943, 0, " ");
    (18944, 0, "s");
    (18945, 0, "i");
    (18946, 0, "e");
    (18946, 1, "");
    (18946, 0, "z");
    (18947, 0, "e");
    (18948, 0, " ");
    (18949, 0, "=");
    (18950, 0, " ");
    (18951, 0, "s");
    (18952, 0, "e");
    (18953, 0, "l");
    (18954, 0, "f");
    (18955, 0, ".");
    (18956, 0, "e");
    (18957, 0, "n");
    (18958, 0, "d");
    (18959, 0, " ");
    (18960, 0, "-");
    (18961, 0, " ");
    (18962, 0, "s");
    (18963, 0, "e");
    (18964, 0, "l");
    (18965, 0, "f");
    (18966, 0, ".");
    (18967, 0, "p");
    (18968, 0, "t");
    (18969, 0, "r");
    (18970, 0, ";");
    (18970, 0, ".");
    (18971, 0, "a");
    (18972, 0, "s");
    (18971, 2, "as_ptr()");
    (18960, 1, "");
    (18959, 1, "");
    (18959, 0, ".");
    (18960, 0, "s");
    (18961, 0, "u");
    (18962, 0, "b");
    (18963, 0, "(");
    (18964, 1, "");
    (18981, 0, ")");
    (18951, 32, "");
    (18951, 0, "s");
    (18952, 0, "e");
    (18953, 0, "l");
    (18954, 0, "f");
    (18955, 0, ".");
    (18956, 0, "e");
    (18957, 0, "n");
    (18958, 0, "d");
    (18959, 0, " ");
    (18960, 0, "a");
    (18961, 0, "s");
    (18962, 0, " ");
    (18963, 0, "u");
    (18964, 0, "s");
    (18965, 0, "i");
    (18966, 0, "z");
    (18967, 0, "e");
    (18968, 0, " ");
    (18969, 0, "-");
    (18970, 0, " ");
    (18971, 0, "s");
    (18972, 0, "e");
    (18973, 0, "l");
    (18974, 0, "f");
    (18975, 0, ".");
    (18976, 0, "p");
    (18977, 0, "t");
    (18978, 0, "r");
    (18979, 0, " ");
    (18980, 0, "a");
    (18981, 0, "s");
    (18982, 0, " ");
    (18983, 0, "u");
    (18984, 0, "s");
    (18985, 0, "i");
    (18986, 0, "z");
    (18987, 0, "e");
    (18951, 0, "(");
    (18989, 0, ")");
    (18990, 0, ".");
    (18990, 1, "");
    (18990, 0, " ");
    (18991, 0, "/");
    (18992, 0, " ");
    (18993, 0, "s");
    (18994, 0, "i");
    (18995, 0, "z");
    (18996, 0, "e");
    (18997, 0, "_");
    (18998, 0, "o");
    (18999, 0, "f");
    (19000, 0, ":");
    (19001, 0, ":");
    (19002, 0, "<");
    (19003, 0, "C");
    (19004, 0, ":");
    (19005, 0, ":");
    (19006, 0, "I");
    (19007, 0, "t");
    (19008, 0, "e");
    (19009, 0, "m");
    (19010, 0, ">");
    (19011, 0, "(");
    (19012, 0, ")");
    (19013, 0, ";");
    (19014, 0, "\n        ");
    (19023, 0, "(");
    (19024, 0, "s");
    (19025, 0, "i");
    (19026, 0, "z");
    (19027, 0, "e");
    (19028, 0, ",");
    (19029, 0, " ");
    (19030, 0, "S");
    (19031, 0, "o");
    (19032, 0, "m");
    (19033, 0, "e");
    (19034, 0, "(");
    (19035, 0, "s");
    (19036, 0, "i");
    (19037, 0, "z");
    (19038, 0, "e");
    (19039, 0, ")");
    (19040, 0, ")");
    (19011, 0, ":");
    (19012, 0, ":");
    (19011, 2, "");
    (18980, 0, ".");
    (18981, 0, "a");
    (18982, 0, "s");
    (18983, 0, "_");
    (18984, 0, "p");
    (18985, 0, "t");
    (18986, 0, "r");
    (18987, 0, "(");
    (18988, 0, ")");
    (19002, 0, "m");
    (19003, 0, "e");
    (19004, 0, "m");
    (19005, 0, ":");
    (19006, 0, ":");
    (1247, 2, "2");
    (32176, 0, "d");
    (32177, 0, "b");
    (32178, 0, "g");
    (32179, 0, "!");
    (32180, 0, "(");
    (32203, 0, ")");
    (32205, 1, "");
    (32205, 0, "<");
    (32203, 1, "");
    (32180, 1, "");
    (32179, 1, "");
    (32178, 1, "");
    (32177, 1, "");
    (32176, 1, "");
    (32175, 1, "");
    (32175, 0, "(");
    (32162, 0, "// ");
    (1973, 0, "    type Item; //+ std::fmt::Debug;\n");
    (1987, 21, "");
    (1977, 0, "// ");
    (2007, 1, "");
    (2006, 1, "");
    (2005, 1, "");
    (2004, 1, "");
    (2004, 0, ":");
    (2005, 1, "");
    (54333, 0, "\n                ");
    (54350, 0, "s");
    (54351, 0, "e");
    (54352, 0, "l");
    (54353, 0, "f");
    (54354, 0, ".");
    (54355, 0, "p");
    (54356, 0, "r");
    (54357, 0, "i");
    (54355, 3, "print()");
    (54362, 0, "(");
    (54363, 0, ")");
    (54363, 1, "");
    (54362, 1, "");
    (54362, 0, ";");
    (54466, 0, "\n                ");
    (54483, 0, "self.print();");
    (54877, 0, "\n                ");
    (54894, 0, "self.print();");
    (42868, 13, "e");
    (42869, 0, "n");
    (42870, 0, "d");
    (42871, 0, "_");
    (42872, 0, "i");
    (42873, 0, "t");
    (42874, 0, "e");
    (42875, 0, "m");
    (42876, 0, "s");
    (32216, 1, "");
    (32216, 0, ">");
    (32176, 3, "");
    (42874, 0, ".");
    (42875, 0, "l");
    (42876, 0, "e");
    (42877, 0, "n");
    (42878, 0, "(");
    (42879, 0, ")");
    (1247, 1, "");
    (1247, 0, "1");
    (1247, 1, "");
    (1247, 0, "1");
    (1248, 0, "0");
    (18822, 0, "\n            ");
    (18835, 0, "l");
    (18836, 0, "e");
    (18837, 0, "t");
    (18838, 0, " ");
    (18839, 0, "p");
    (18840, 0, "t");
    (18841, 0, "r");
    (18842, 0, " ");
    (18843, 0, "=");
    (18844, 0, " ");
    (18845, 0, "s");
    (18846, 0, "e");
    (18847, 0, "l");
    (18848, 0, "f");
    (18849, 0, ".");
    (18850, 0, "p");
    (18851, 0, "t");
    (18852, 0, "r");
    (18853, 0, ";");
    (18881, 5, "");
    (18854, 0, "\n            ");
    (18867, 0, "s");
    (18868, 0, "e");
    (18869, 0, "l");
    (18870, 0, "f");
    (18871, 0, ".");
    (18872, 0, "p");
    (18873, 0, "t");
    (18874, 0, "r");
    (18875, 0, " ");
    (18876, 0, "+");
    (18877, 0, "=");
    (18878, 0, " ");
    (18879, 0, "1");
    (18880, 0, ";");
    (18876, 1, "");
    (18878, 0, "s");
    (18879, 0, "e");
    (18880, 0, "l");
    (18881, 0, "f");
    (18882, 0, ".");
    (18883, 0, "p");
    (18884, 0, "t");
    (18885, 0, "r");
    (18886, 0, ".");
    (18887, 0, "o");
    (18888, 0, "f");
    (18889, 0, "f");
    (18890, 0, "s");
    (18891, 0, "e");
    (18892, 0, "t");
    (18893, 0, "(");
    (18895, 0, ")");
    (18886, 0, ".");
    (18887, 0, "a");
    (18888, 0, "s");
    (18889, 0, "_");
    (18890, 0, "p");
    (18891, 0, "t");
    (18892, 0, "r");
    (18893, 0, "(");
    (18894, 0, ")");
    (18877, 0, " ");
    (18878, 0, "N");
    (18879, 0, "o");
    (18880, 0, "n");
    (18881, 0, "N");
    (18882, 0, "u");
    (18883, 0, "l");
    (18878, 6, "NonNull");
    (18885, 0, ":");
    (18886, 0, ":");
    (18887, 0, "new_unchecked(ptr: *mut T)");
    (18901, 11, "");
    (18901, 1, "");
    (18901, 1, "");
    (18928, 0, ")");
    (18877, 0, " ");
    (18878, 0, "u");
    (18879, 0, "n");
    (18880, 0, "s");
    (18881, 0, "a");
    (18882, 0, "f");
    (18883, 0, "e");
    (18884, 0, " ");
    (18885, 0, "{");
    (18938, 0, " ");
    (18939, 0, "}");
    (10488, 349, "");
    (10487, 1, "");
    (10378, 109, "");
    (17789, 359, "");
    (17788, 1, "");
    (17257, 0, " ");
    (17258, 0, "w");
    (17259, 0, "i");
    (17260, 0, "t");
    (17261, 0, "h");
    (17262, 0, "o");
    (17263, 0, "u");
    (17264, 0, "t");
    (17265, 0, " ");
    (17266, 0, "d");
    (17267, 0, "r");
    (17268, 0, "o");
    (17269, 0, "p");
    (17270, 0, "p");
    (17271, 0, "i");
    (17272, 0, "n");
    (17273, 0, "g");
    (17274, 0, " ");
    (17275, 0, "c");
    (17276, 0, "o");
    (17277, 0, "n");
    (17278, 0, "t");
    (17279, 0, "e");
    (17280, 0, "n");
    (17281, 0, "t");
    ( 17202,
      249,
      "    /// Make a slice we can iterate from and steal from without dropping\n\
      \    /// content. Its unsafe if:\n\
      \    ///\n\
      \    /// - The iterator isn't fully drained (then we might not drop \
       contents)\n\
      \    /// - The contents we iterate over aren't initialized\n\
      \    ///" );
    (17253, 0, "d");
    (17254, 0, "a");
    (17255, 0, "t");
    (17256, 0, "a");
    (17257, 0, " ");
    (17297, 14, "T");
    (17298, 0, "h");
    (17299, 0, "i");
    (17300, 0, "s");
    (17301, 0, " ");
    (17302, 0, "i");
    (17303, 0, "s");
    (17304, 0, " ");
    (17305, 0, "v");
    (17306, 0, "e");
    (17307, 0, "r");
    (17308, 0, "y");
    (17309, 0, " ");
    (17310, 0, "u");
    (17311, 0, "n");
    (17312, 0, "s");
    (17313, 0, "a");
    (17314, 0, "f");
    (17315, 0, "e");
    (17316, 0, ":");
    (17305, 5, "");
    (17331, 4, "I");
    (17332, 0, "f");
    (17333, 0, " ");
    (17334, 0, "t");
    (17335, 0, "h");
    (17336, 0, "e");
    (17337, 0, " ");
    (17366, 34, " ");
    (17367, 0, "t");
    (17368, 0, "h");
    (17369, 0, "e");
    (17370, 0, "n");
    (17371, 0, " ");
    (17372, 0, "t");
    (17373, 0, "h");
    (17374, 0, "e");
    (17375, 0, " ");
    (17372, 4, "r");
    (17373, 0, "e");
    (17374, 0, "a");
    (17375, 0, "m");
    (17375, 1, "");
    (17374, 1, "");
    (17374, 0, "m");
    (17375, 0, "a");
    (17376, 0, "i");
    (17377, 0, "n");
    (17378, 0, "i");
    (17379, 0, "n");
    (17380, 0, "g");
    (17381, 0, " ");
    (17382, 0, "i");
    (17383, 0, "t");
    (17384, 0, "e");
    (17385, 0, "m");
    (17386, 0, "s");
    (17387, 0, " ");
    (17388, 0, "a");
    (17389, 0, "r");
    (17390, 0, "e");
    (17391, 0, " ");
    (17392, 0, "f");
    (17393, 0, "o");
    (17394, 0, "r");
    (17395, 0, "g");
    (17396, 0, "o");
    (17397, 0, "t");
    (17398, 0, "t");
    (17399, 0, "e");
    (17400, 0, "n");
    (17401, 0, " ");
    (17402, 0, "(");
    (17403, 0, "n");
    (17404, 0, "o");
    (17405, 0, "t");
    (17406, 0, " ");
    (17407, 0, "d");
    (17408, 0, "r");
    (17409, 0, "o");
    (17410, 0, "p");
    (17411, 0, "p");
    (17412, 0, "e");
    (17413, 0, "d");
    (17414, 0, ")");
    ( 17321,
      94,
      "    /// - If the iterator isn't fully drained then remaining items are \
       forgotten\n\
      \    ///   (not dropped)" );
    (17388, 4, "w");
    (17389, 0, "i");
    (17390, 0, "l");
    (17391, 0, "l");
    (17392, 0, " ");
    (17393, 0, "b");
    (17394, 0, "e");
    (17395, 0, " ");
    ( 17321,
      108,
      "    /// - If the iterator isn't fully drained then remaining items will \
       be\n\
      \    ///   forgotten (not dropped)" );
    (17417, 3, "t");
    (17418, 0, "h");
    (17419, 0, "e");
    (17420, 0, "y");
    (17421, 0, " ");
    (17422, 0, "a");
    (17423, 0, "r");
    (17424, 0, "e");
    (17425, 0, " ");
    (17426, 0, "n");
    (17427, 0, "o");
    (17428, 0, "t");
    (17438, 0, ".");
    (17450, 47, "T");
    (17451, 0, "h");
    (17452, 0, "e");
    (17453, 0, " ");
    (17454, 0, "s");
    (17455, 0, "l");
    (17456, 0, "i");
    (17457, 0, "c");
    (17458, 0, "e");
    (17459, 0, " ");
    (17460, 0, "p");
    (17461, 0, "a");
    (17462, 0, "d");
    (17462, 1, "");
    (17462, 0, "s");
    (17463, 0, "s");
    (17464, 0, "e");
    (17465, 0, "d");
    (17466, 0, " ");
    (17467, 0, "i");
    (17468, 0, "n");
    (17469, 0, " ");
    (17470, 0, "h");
    (17471, 0, "e");
    (17472, 0, "r");
    (17473, 0, "e");
    (17474, 0, " ");
    (17475, 0, "m");
    (17476, 0, "u");
    (17477, 0, "s");
    (17478, 0, "t");
    (17479, 0, " ");
    (17480, 0, "b");
    (17481, 0, "e");
    (17482, 0, " ");
    (17483, 0, "i");
    (17484, 0, "n");
    (17485, 0, "i");
    (17486, 0, "t");
    (17487, 0, "i");
    (17488, 0, "a");
    (17489, 0, "l");
    (17490, 0, "i");
    (17491, 0, "z");
    (17492, 0, "e");
    (17493, 0, "d");
    (17494, 0, ".");
    (17494, 1, "");
    (17494, 0, " ");
    (17495, 0, "o");
    (17496, 0, "r");
    (17497, 0, " ");
    (17498, 0, "t");
    (17499, 0, "h");
    (17500, 0, "e");
    (17501, 0, " ");
    (17502, 0, "v");
    (17503, 0, "a");
    (17504, 0, "l");
    (17505, 0, "u");
    (17506, 0, "e");
    (17507, 0, "s");
    (17498, 10, "u");
    (17499, 0, "n");
    (17500, 0, "d");
    (17501, 0, "e");
    (17502, 0, "f");
    (17503, 0, "i");
    (17504, 0, "n");
    (17505, 0, "e");
    (17506, 0, "d");
    (17507, 0, " ");
    (17508, 0, "v");
    (17509, 0, "a");
    (17510, 0, "l");
    (17511, 0, "u");
    (17512, 0, "e");
    (17513, 0, "s");
    (17514, 0, " ");
    (17514, 1, "");
    (17507, 7, "");
    (17507, 0, " ");
    (17508, 0, "b");
    (17509, 0, "e");
    (17510, 0, "h");
    (17511, 0, "a");
    (17512, 0, "v");
    (17513, 0, "i");
    (17514, 0, "o");
    (17515, 0, "u");
    (17516, 0, "r");
    (17517, 0, " ");
    (17518, 0, "w");
    (17519, 0, "i");
    (17520, 0, "l");
    (17521, 0, "l");
    (17522, 0, " ");
    (17523, 0, "h");
    (17524, 0, "i");
    (17525, 0, "t");
    (17526, 0, " ");
    (17527, 0, "u");
    (17528, 0, "s");
    (17529, 0, ".");
    ( 17440,
      90,
      "    /// - The slice passed in here must be initialized or undefined \
       behaviour\n\
      \    ///   will hit us." );
    (18768, 0, "T");
    (18769, 0, "O");
    (18770, 0, "D");
    (18771, 0, "O");
    (18772, 0, ":");
    (18773, 0, " ");
    (18809, 31, "");
    (18809, 0, " ");
    (18810, 0, "R");
    (18811, 0, "e");
    (18812, 0, "p");
    (18813, 0, "l");
    (18814, 0, "a");
    (18815, 0, "c");
    (18816, 0, "e");
    (18817, 0, " ");
    (18818, 0, "w");
    (18819, 0, "h");
    (18820, 0, "e");
    (18821, 0, "n");
    (18822, 0, " ");
    (18823, 0, "a");
    (18824, 0, "v");
    (18825, 0, "a");
    (18826, 0, "l");
    (18827, 0, "i");
    (18828, 0, "a");
    (18829, 0, "b");
    (18830, 0, "l");
    (18831, 0, "e");
    (18823, 9, "a");
    (18824, 0, "v");
    (18825, 0, "a");
    (18826, 0, "i");
    (18827, 0, "l");
    (18828, 0, "a");
    (18829, 0, "b");
    (18830, 0, "l");
    (18831, 0, "e");
    (18832, 0, ".");
    (18786, 11, "");
    (18797, 0, ":");
    (18798, 0, ":");
    (18799, 0, "s");
    (18800, 0, "l");
    (18801, 0, "i");
    (18802, 0, "c");
    (18803, 0, "e");
    (18804, 0, "_");
    (18805, 0, "g");
    (18806, 0, "e");
    (18807, 0, "t");
    (18808, 0, "_");
    (18809, 0, "r");
    (18810, 0, "e");
    (18811, 0, "f");
    (20373, 0, "\n    ");
    (20378, 0, "/");
    (20379, 0, ";");
    (20380, 0, " ");
    (20380, 1, "");
    (20379, 1, "");
    (20379, 0, "/");
    (20380, 0, " ");
    (20381, 0, "T");
    (20382, 0, "O");
    (20383, 0, "D");
    (20384, 0, "O");
    (20385, 0, ":");
    (20386, 0, " ");
    (20387, 0, "R");
    (20388, 0, "e");
    (20389, 0, "m");
    (20390, 0, "o");
    (20391, 0, "v");
    (20392, 0, "e");
    (20393, 0, " ");
    (20374, 20, "");
    (20373, 1, "");
    (31749, 43, "");
    (31999, 71, "");
    (35780, 71, "");
    (37347, 115, "");
    (37079, 18, "");
    (37079, 3, "I");
    (37080, 0, "t");
    (37081, 0, "e");
    (37082, 0, "m");
    (37083, 5, "");
    (37083, 0, " ");
    (37084, 0, "d");
    (37085, 0, "o");
    (37086, 0, "e");
    (37087, 0, "s");
    (37088, 0, "n");
    (37089, 0, "'");
    (37090, 0, "t");
    (37091, 0, " ");
    (37092, 0, "n");
    (37093, 0, "e");
    (37094, 0, "c");
    (37095, 0, "e");
    (37096, 0, "s");
    (37097, 0, "s");
    (37098, 0, "a");
    (37099, 0, "r");
    (37100, 0, "i");
    (37101, 0, "l");
    (37102, 0, "y");
    (37103, 0, " ");
    (37104, 0, "i");
    (37104, 1, "");
    (37103, 1, "");
    (37132, 1, "");
    (37865, 84, "");
    (37864, 1, "");
    (41174, 210, "");
    (44100, 90, "");
    (46121, 102, "");
    (46334, 101, "");
    (46333, 1, "");
    (47290, 173, "");
    (48841, 168, "");
    (49035, 53, "");
    (49034, 1, "");
    (49287, 76, "");
    (50362, 64, "");
    (52327, 30, "");
    (52430, 30, "");
    (52811, 30, "");
    (1996, 0, "// ");
    (1978, 3, "");
    (39512, 0, "_");
    (8981, 0, "m");
    (8982, 0, "u");
    (8983, 0, "t");
    (8984, 0, " ");
    (22182, 0, "m");
    (22183, 0, "u");
    (22184, 0, "t");
    (22185, 0, " ");
    (22185, 1, "");
    (22182, 3, "");
    (22197, 0, "_");
    (22198, 0, "m");
    (22199, 0, "u");
    (22200, 0, "t");
    (22197, 4, "");
    (8984, 1, "");
    (8981, 3, "");
    (6222, 0, "    nexts: [SkipEntry<C>; 0],\n");
    (6256, 0, "// ");
    (6248, 1, "");
    (6248, 0, "M");
    (6249, 0, "A");
    (6250, 0, "X");
    (6248, 3, "MAX_HEIGHT");
    (6248, 10, "MAX");
    (6248, 3, "");
    (6248, 0, "0");
    (6256, 3, "");
    (6222, 30, "");
    (6222, 0, "    nexts: [SkipEntry<C>; 0],\n");
    (6256, 0, "// ");
    (6248, 1, "");
    (6248, 0, "M");
    (6249, 0, "A");
    (6250, 0, "X");
    (6248, 3, "MAX_HEIGHT");
    (9985, 0, "S");
    (9986, 0, "k");
    (9987, 0, "i");
    (9988, 0, "p");
    (9985, 4, "SkipEntry");
    (9994, 0, ":");
    (9995, 0, ":");
    (9996, 0, "n");
    (9997, 0, "e");
    (9996, 2, "new_null()");
    (10006, 0, ";");
    (10007, 0, " ");
    (10008, 0, "M");
    (10009, 0, "A");
    (10010, 0, "X");
    (10008, 3, "MAX_HEIGHT");
    (19787, 0, "S");
    (19788, 0, "k");
    (19789, 0, "i");
    (19790, 0, "p");
    (19787, 4, "SkipEntry");
    (19796, 0, ":");
    (19797, 0, ":");
    (19798, 0, "new_null()");
    (19808, 0, ";");
    (19809, 0, " ");
    (19810, 0, "M");
    (19811, 0, "X");
    (19811, 1, "");
    (19811, 0, "A");
    (19812, 0, "X");
    (19810, 3, "MAX_HEIGHT");
    (9157, 0, "// ");
    (9075, 0, "// ");
    (9058, 0, "// ");
    (9049, 0, "\n        ");
    (9058, 0, "s");
    (9059, 0, "e");
    (9060, 0, "l");
    (9061, 0, "f");
    (9062, 0, ".");
    (9063, 0, "n");
    (9064, 0, "e");
    (9065, 0, "x");
    (9063, 3, "nexts()");
    (9070, 0, "[");
    (9071, 0, ".");
    (9072, 0, ".");
    (9073, 0, "]");
    (9073, 1, "");
    (9072, 1, "");
    (9071, 1, "");
    (9070, 1, "");
    (9069, 1, "");
    (9068, 1, "");
    (9068, 0, "[");
    (9069, 0, ".");
    (9070, 0, ".");
    (9071, 0, "]");
    (9058, 0, "#");
    (9058, 1, "");
    (9058, 0, "$");
    (9058, 1, "");
    (9058, 0, "&");
    (9367, 0, "// ");
    (9277, 0, "// ");
    (9260, 0, "// ");
    (9251, 0, "\n        ");
    (9260, 0, "&self.nexts[..]");
    (9261, 0, "m");
    (9262, 0, "u");
    (9263, 0, "t");
    (9264, 0, " ");
    (9264, 1, "");
    (9261, 3, "");
    (9260, 15, "");
    (9251, 9, "");
    (9373, 3, "");
    (9280, 3, "");
    (9260, 3, "");
    (9058, 1, "");
    (9058, 0, "$");
    (9058, 1, "");
    (9058, 0, "#");
    (9058, 1, "");
    (9068, 4, "");
    (9068, 0, "()");
    (9070, 0, "[..]");
    (9070, 4, "");
    (9063, 7, "nex");
    (9049, 17, "");
    (9163, 3, "");
    (9078, 3, "");
    (9058, 3, "");
    (19810, 10, "MAX");
    (19811, 2, "");
    (19811, 0, "X");
    (19809, 3, "");
    (19808, 1, "");
    (19798, 10, "");
    (19796, 2, "");
    (19787, 9, "Skip");
    (19787, 4, "");
    (10008, 10, "MAX");
    (10007, 4, "");
    (10006, 1, "");
    (9996, 10, "ne");
    (9994, 4, "");
    (9985, 9, "Skip");
    (9985, 4, "");
    (6248, 10, "MAX");
    (6248, 3, "");
    (6248, 0, "0");
    (6256, 3, "");
    (6222, 30, "");
    (39512, 1, "");
    (39512, 0, "_");
    (18382, 0, "u");
    (18383, 0, "n");
    (18384, 0, "c");
    (18385, 0, "k");
    (18386, 0, "e");
    (18387, 0, "d");
    (18388, 0, "l");
    (18382, 7, "s");
    (18383, 0, "t");
    (18384, 0, "d");
    (18385, 0, ":");
    (18386, 0, ":");
    (18387, 0, "i");
    (18388, 0, "n");
    (18389, 0, "t");
    (18390, 0, "r");
    (18387, 4, "intrinsics");
    (18397, 0, ":");
    (18398, 0, ":");
    (18399, 0, "u");
    (18400, 0, "n");
    (18401, 0, "c");
    (18402, 0, "h");
    (18399, 4, "unchecked_sub(x: T, y: T)");
    (18413, 12, "");
    (18431, 1, "");
    (18430, 1, "");
    (18430, 0, ",");
    (18382, 30, "u");
    (18383, 0, "s");
    (18384, 0, "i");
    (18385, 0, "z");
    (18386, 0, "e");
    (18387, 0, ":");
    (18388, 0, ":");
    (18382, 7, "");
    (39511, 1, "");
    (18401, 0, " -");
    (18400, 1, "");
    (52842, 0, "\n    ");
    (52847, 0, "\n    ");
    (52843, 4, "");
    ( 52848,
      0,
      "pub fn insert_at(&mut self, mut userpos: usize, contents: &[C::Item]) \
       where C::Item: Copy" );
    (52864, 0, "_");
    (52865, 0, "s");
    (52866, 0, "l");
    (52867, 0, "i");
    (52868, 0, "c");
    (52869, 0, "e");
    (52943, 0, " ");
    (52944, 0, " ");
    (52944, 1, "");
    (52944, 0, "{");
    (52945, 0, "\n        ");
    (52954, 0, "\n        ");
    (52946, 8, "");
    (52947, 8, "    }");
    (52946, 0, "        ");
    (52946, 8, "");
    (51361, 0, "<");
    (51362, 0, "I");
    (51363, 0, ">");
    (51406, 10, "I");
    (51428, 0, ",");
    (51429, 0, " ");
    (51430, 0, " I: ExactSizeIterator<Item=C::Item>");
    (51415, 16, "");
    (52397, 24, "c");
    (51723, 24, "c");
    (52375, 0, "o");
    (51724, 0, "o");
    (52377, 0, "n");
    (51725, 0, "n");
    (52379, 0, "t");
    (51726, 0, "t");
    (52381, 0, "e");
    (51727, 0, "e");
    (52383, 0, "n");
    (51728, 0, "n");
    (52385, 0, "t");
    (51729, 0, "t");
    (52387, 0, "s");
    (51730, 0, "s");
    (52381, 8, "contents.iter().copied()");
    (51723, 8, "contents.iter().copied()");
    (51415, 0, "C::Item: Copy,  ");
    (51415, 16, "");
    (52397, 24, "contents");
    (51723, 24, "contents");
    (52929, 0, "        ");
    (52937, 0, "s");
    (52938, 0, "e");
    (52939, 0, "l");
    (52940, 0, "f");
    (52941, 0, ".");
    (52942, 0, "i");
    (52943, 0, "n");
    (52944, 0, "s");
    (52945, 0, "e");
    (52946, 0, "r");
    (52947, 0, "t");
    ( 52942,
      6,
      "insert_at_iter(cursor: &mut Cursor<C>, contents: &mut I, notify: &mut \
       Notify)" );
    (52942, 77, "insert");
    (52948, 0, "_");
    (52949, 0, "a");
    (52950, 0, "t");
    (52951, 0, "(");
    (52952, 0, "u");
    (52953, 0, "s");
    (52954, 0, "e");
    (52955, 0, "r");
    (52956, 0, "p");
    (52957, 0, "o");
    (52958, 0, "s");
    (52959, 0, ",");
    (52960, 0, " ");
    (52864, 4, "");
    (52957, 0, "c");
    (52958, 0, "o");
    (52959, 0, "n");
    (52960, 0, "t");
    (52961, 0, "e");
    (52962, 0, "n");
    (52963, 0, "t");
    (52964, 0, "s");
    (52965, 0, ".");
    (52966, 0, "i");
    (52967, 0, "t");
    (52968, 0, "e");
    (52969, 0, "r");
    (52970, 0, "(");
    (52971, 0, ")");
    (52972, 0, ".");
    (52973, 0, "c");
    (52974, 0, "o");
    (52975, 0, "p");
    (52976, 0, "i");
    (52977, 0, "e");
    (52978, 0, "d");
    (52979, 0, "(");
    (52980, 0, ")");
    (52981, 0, ")");
    (52982, 0, ";");
    (52982, 1, "");
    (20503, 0, ")");
    (20504, 0, "s");
    (20505, 0, "l");
    (20506, 0, "i");
    (20506, 1, "");
    (20505, 1, "");
    (20504, 1, "");
    (20503, 1, "");
    (20502, 1, "");
    (20502, 0, "_");
    (20502, 1, "");
    (20502, 0, "t");
    (20503, 0, "_");
    (20504, 0, "s");
    (20505, 0, "l");
    (20506, 0, "i");
    (20507, 0, "c");
    (20508, 0, "e");
    (51402, 0, "n");
    (51402, 1, "");
    (51402, 0, "m");
    (51403, 0, "u");
    (51404, 0, "t");
    (51405, 0, " ");
    (51504, 0, "\n        ");
    (51513, 0, "l");
    (51514, 0, "e");
    (51515, 0, "t");
    (51516, 0, " ");
    (51517, 0, "n");
    (51518, 0, "u");
    (51519, 0, "m");
    (51520, 0, "_");
    (51521, 0, "i");
    (51522, 0, "n");
    (51523, 0, "s");
    (51524, 0, "e");
    (51525, 0, "r");
    (51526, 0, "t");
    (51517, 10, "num_inserted_items");
    (51535, 0, " ");
    (51536, 0, "=");
    (51537, 0, " ");
    (51538, 0, "c");
    (51539, 0, "o");
    (51540, 0, "n");
    (51541, 0, "t");
    (51542, 0, "e");
    (51543, 0, "n");
    (51544, 0, "t");
    (51545, 0, "s");
    (51546, 0, ".");
    (51547, 0, "l");
    (51548, 0, "e");
    (51549, 0, "n");
    (51550, 0, "(");
    (51551, 0, ")");
    (51552, 0, ";");
    (52742, 14, "n");
    (51875, 14, "n");
    (52730, 0, "u");
    (51876, 0, "u");
    (52732, 0, "m");
    (51877, 0, "m");
    (52734, 0, "_");
    (51878, 0, "_");
    (52732, 4, "num_inserted_items");
    (51875, 4, "num_inserted_items");
    (52746, 18, "num_");
    (51875, 18, "num_");
    (52732, 4, "contents.len()");
    (51875, 4, "contents.len()");
    (52742, 14, "num_");
    (51875, 14, "num_");
    (52732, 4, "num_inserted_items");
    (51875, 4, "num_inserted_items");
    (10256, 0, "\n        ");
    (10265, 0, "p");
    (10266, 0, "t");
    (10267, 0, "r");
    (10268, 0, ":");
    (10269, 0, ":");
    (10270, 0, "d");
    (10271, 0, "r");
    (10272, 0, "o");
    (10273, 0, "p");
    (10274, 0, "_");
    (10270, 5, "drop_in_place(to_drop: *mut T)");
    (10284, 15, "p");
    (10286, 0, ";");
    (10287, 0, " ");
    (10288, 0, "/");
    (10289, 0, "/");
    (10290, 0, " ");
    (10291, 0, "W");
    (10292, 0, "e");
    (10293, 0, "'");
    (10294, 0, "l");
    (10295, 0, "l");
    (10296, 0, " ");
    (10297, 0, "u");
    (10298, 0, "s");
    (10299, 0, "e");
    (10300, 0, " ");
    (10291, 10, "");
    (10291, 0, "W");
    (10292, 0, "e");
    (10293, 0, " ");
    (10294, 0, "c");
    (10295, 0, "o");
    (10296, 0, "u");
    (10297, 0, "l");
    (10298, 0, "d");
    (10299, 0, " ");
    (10300, 0, "j");
    (10301, 0, "u");
    (10302, 0, "s");
    (10303, 0, "t");
    (10304, 0, " ");
    (10305, 0, "i");
    (10306, 0, "m");
    (10307, 0, "p");
    (10308, 0, "e");
    (10309, 0, "l");
    (10310, 0, "e");
    (10311, 0, "m");
    (10312, 0, "n");
    (10313, 0, "t");
    (10305, 9, "i");
    (10306, 0, "m");
    (10307, 0, "p");
    (10308, 0, "l");
    (10309, 0, "e");
    (10310, 0, "m");
    (10311, 0, "e");
    (10312, 0, "n");
    (10313, 0, "t");
    (10314, 0, " ");
    (10315, 0, "d");
    (10316, 0, "r");
    (10317, 0, "o");
    (10318, 0, "p");
    (10319, 0, " ");
    (10320, 0, "h");
    (10321, 0, "e");
    (10322, 0, "r");
    (10323, 0, "e");
    (10324, 0, ",");
    (10325, 0, " ");
    (10326, 0, "b");
    (10327, 0, "u");
    (10328, 0, "t");
    (10329, 0, " ");
    (10330, 0, "t");
    (10331, 0, "h");
    (10332, 0, "i");
    (10333, 0, "s");
    (10334, 0, " ");
    (10335, 0, "i");
    (10336, 0, " ");
    (10336, 1, "");
    (10336, 0, "s");
    (10337, 0, " ");
    (10338, 0, "c");
    (10339, 0, "l");
    (10340, 0, "e");
    (10341, 0, "a");
    (10342, 0, "n");
    (10343, 0, "e");
    (10344, 0, "r");
    (10345, 0, ".");
    (11087, 0, "\n");
    (11088, 0, "\n");
    (11089, 0, "i");
    (11090, 0, "m");
    (11091, 0, "p");
    (11092, 0, "l");
    (11093, 0, " ");
    (11093, 1, "");
    (11093, 0, "<");
    (11094, 0, "C");
    (11095, 0, ":");
    (11096, 0, " ");
    (11097, 0, "L");
    (11098, 0, "i");
    (11099, 0, "s");
    (11100, 0, "t");
    (11097, 4, "ListConfig");
    (11107, 0, ">");
    (11108, 0, " ");
    (11109, 0, "D");
    (11110, 0, "r");
    (11111, 0, "o");
    (11112, 0, "p");
    (11113, 0, " ");
    (11114, 0, "f");
    (11115, 0, "o");
    (11116, 0, "r");
    (11117, 0, " ");
    (11118, 0, "N");
    (11119, 0, "o");
    (11120, 0, "d");
    (11121, 0, "e");
    (11122, 0, "<");
    (11123, 0, "C");
    (11124, 0, ">");
    (11125, 0, " ");
    (11126, 0, "{");
    (11127, 0, "\n    ");
    (11132, 0, "\n    ");
    (11128, 4, "");
    (11129, 4, "}");
    (11128, 0, "    ");
    (11132, 0, "f");
    (11133, 0, "n");
    (11134, 0, " ");
    (11135, 0, "D");
    (11135, 1, "");
    (11135, 0, "d");
    (11136, 0, "r");
    (11137, 0, "o");
    (11138, 0, "p");
    (11139, 0, "(");
    (11140, 0, "&");
    (11141, 0, "m");
    (11142, 0, "u");
    (11143, 0, "t");
    (11144, 0, " ");
    (11145, 0, "s");
    (11146, 0, "e");
    (11147, 0, "l");
    (11148, 0, "f");
    (11149, 0, ")");
    (11150, 0, " ");
    (11151, 0, "{");
    (11152, 0, "\n        ");
    (11153, 8, "    }");
    (11152, 0, "\n        ");
    (11161, 0, "self.nexts.as_ptr(), self.height as usize");
    (11161, 41, "");
    (11161, 0, "s");
    (11162, 0, "e");
    (11163, 0, "l");
    (11164, 0, "f");
    (11165, 0, ".");
    (11166, 0, "i");
    (11167, 0, "t");
    (11168, 0, "e");
    (11169, 0, "m");
    (11170, 0, "s");
    (11152, 0, "\n        ");
    (11161, 0, "f");
    (11162, 0, "o");
    (11163, 0, "r");
    (11164, 0, " ");
    (11165, 0, "l");
    (11166, 0, "e");
    (11167, 0, "t");
    (11168, 0, " ");
    (11168, 1, "");
    (11167, 1, "");
    (11166, 1, "");
    (11165, 1, "");
    (11165, 0, "i");
    (11166, 0, " ");
    (11167, 0, "i");
    (11168, 0, "n");
    (11169, 0, " ");
    (11170, 0, "0");
    (11171, 0, ".");
    (11172, 0, ".");
    (11173, 0, "s");
    (11174, 0, "e");
    (11175, 0, "l");
    (11176, 0, "f");
    (11177, 0, ".");
    (11178, 0, "l");
    (11179, 0, "e");
    (11179, 1, "");
    (11178, 1, "");
    (11178, 0, "n");
    (11179, 0, "u");
    (11180, 0, "m");
    (11178, 3, "num_items");
    (11187, 0, " ");
    (11187, 1, "");
    (11187, 0, " ");
    (11188, 0, "{");
    (11198, 0, "    ");
    (11212, 0, "\n            ");
    (11213, 12, "        }");
    (11212, 0, "[");
    (11213, 0, "i");
    (11214, 0, "]");
    (11215, 0, ".");
    (11152, 0, "\n        ");
    (11161, 0, "i");
    (11162, 0, "f");
    (11163, 0, " ");
    (11164, 0, "n");
    (11165, 0, "e");
    (11166, 0, "e");
    (11164, 3, "n");
    (11165, 0, "e");
    (11165, 1, "");
    (11164, 1, "");
    (11164, 0, "m");
    (11165, 0, "e");
    (11166, 0, "m");
    (11167, 0, ":");
    (11168, 0, ":");
    (11169, 0, "n");
    (11170, 0, "e");
    (11171, 0, "e");
    (11172, 0, "d");
    (11169, 4, "needs_drop()");
    (11179, 0, "<");
    (11180, 0, "C");
    (11181, 0, ":");
    (11182, 0, ":");
    (11183, 0, "I");
    (11184, 0, "t");
    (11185, 0, "e");
    (11186, 0, "m");
    (11187, 0, ">");
    (11179, 0, ":");
    (11180, 0, ":");
    (11192, 0, " ");
    (11193, 0, "{");
    (11268, 0, "\n        ");
    (11269, 8, "    }");
    (11269, 4, "        ");
    (11259, 8, "            ");
    (11232, 12, "                ");
    (11195, 8, "            ");
    (11265, 1, "");
    (11252, 0, " ");
    (11252, 0, "p");
    (11253, 0, "t");
    (11254, 0, "r");
    (11255, 0, ":");
    (11256, 0, ":");
    (11257, 0, "drop_in_place(to_drop: *mut T)");
    (11271, 15, "");
    (11271, 1, "");
    (11271, 1, "");
    (11284, 0, ")");
    (11271, 0, "&");
    (11285, 0, " ");
    (11286, 0, "a");
    (11287, 0, "s");
    (11288, 0, " ");
    (11289, 0, "*");
    (11290, 0, "m");
    (11291, 0, "u");
    (11292, 0, "t");
    (11293, 0, " ");
    (11294, 0, "_");
    (11296, 0, ";");
    (11272, 0, "m");
    (11273, 0, "u");
    (11274, 0, "t");
    (11275, 0, " ");
    (11271, 5, "");
    (11284, 0, ".");
    (11285, 0, "a");
    (11286, 0, "s");
    (11287, 0, "_");
    (11288, 0, "m");
    (11289, 0, "u");
    (11285, 5, "as_mut_ptr");
    (11295, 0, "(");
    (11296, 0, ")");
    (11297, 9, "");
    (11297, 1, "");
    (11153, 41, "");
    (11152, 1, "");
    (11272, 9, "");
    (11271, 1, "");
    (11258, 12, "        ");
    (11194, 16, "            ");
    (11153, 12, "        ");
    (11187, 0, " ");
    (11188, 0, "a");
    (11189, 0, "s");
    (11190, 0, " ");
    (11191, 0, "u");
    (11192, 0, "s");
    (11193, 0, "i");
    (11194, 0, "z");
    (11195, 0, "e");
    (11211, 0, "u");
    (11212, 0, "n");
    (11213, 0, "s");
    (11214, 0, "a");
    (11215, 0, "f");
    (11216, 0, "e");
    (11217, 0, " ");
    (11218, 0, "{");
    (11219, 0, " ");
    (11267, 0, " ");
    (11268, 0, "}");
    (11198, 0, "\n            ");
    (11211, 0, "/");
    (11212, 0, "/");
    (11213, 0, " ");
    (11214, 0, "C");
    (11215, 0, "o");
    (11216, 0, "u");
    (11217, 0, "l");
    (11218, 0, "d");
    (11219, 0, " ");
    (11220, 0, "i");
    (11221, 0, "n");
    (11222, 0, "s");
    (11223, 0, "t");
    (11224, 0, "e");
    (11225, 0, "a");
    (11226, 0, "d");
    (11227, 0, " ");
    (11228, 0, "c");
    (11229, 0, "a");
    (11230, 0, "l");
    (11231, 0, "l");
    (11232, 0, " ");
    (11233, 0, "a");
    (11234, 0, "s");
    (11235, 0, "s");
    (11236, 0, "u");
    (11237, 0, "m");
    (11238, 0, "e");
    (11239, 0, "_");
    (11240, 0, "i");
    (11241, 0, "n");
    (11242, 0, "i");
    (11243, 0, "t");
    (11244, 0, "(");
    (11245, 0, ")");
    (11246, 0, " ");
    (11247, 0, "o");
    (11248, 0, "n");
    (11249, 0, " ");
    (11250, 0, "e");
    (11251, 0, "a");
    (11252, 0, "c");
    (11253, 0, "h");
    (11254, 0, " ");
    (11255, 0, "i");
    (11256, 0, "t");
    (11257, 0, "e");
    (11258, 0, "m");
    (11259, 0, " ");
    (11260, 0, "b");
    (11261, 0, "u");
    (11262, 0, "t");
    (11263, 0, " ");
    (11264, 0, "I");
    (11265, 0, " ");
    (11266, 0, "t");
    (11267, 0, "h");
    (11268, 0, "i");
    (11269, 0, "n");
    (11270, 0, "k");
    (11271, 0, " ");
    (11272, 0, "t");
    (11273, 0, "h");
    (11274, 0, "i");
    (11275, 0, "s");
    (11276, 0, " ");
    (11277, 0, "i");
    (11278, 0, "s");
    (11279, 0, " ");
    (11264, 16, "t");
    (11265, 0, "h");
    (11266, 0, "i");
    (11267, 0, "s");
    (11268, 0, " ");
    (11269, 0, "i");
    (11270, 0, "s");
    (11271, 0, " ");
    (11272, 0, "f");
    (11273, 0, "r");
    (11274, 0, "i");
    (11275, 0, "e");
    (11276, 0, "n");
    (11277, 0, "d");
    (11278, 0, "l");
    (11279, 0, "i");
    (11280, 0, "e");
    (11281, 0, "r");
    (11282, 0, " ");
    (11283, 0, "t");
    (11284, 0, "o");
    (11285, 0, " ");
    (11286, 0, "t");
    (11287, 0, "h");
    (11288, 0, "e");
    (11289, 0, " ");
    (11290, 0, "o");
    (11291, 0, "p");
    (11292, 0, "t");
    (11293, 0, "i");
    (11294, 0, "m");
    (11295, 0, "i");
    (11296, 0, "z");
    (11297, 0, "e");
    (11298, 0, "r");
    (11299, 0, ".");
    ( 11199,
      101,
      "            // Could instead call assume_init() on each item but this is\n\
      \            // friendlier to the optimizer." );
    (51130, 20, " where I: ExactSizeIterator<Item=C::Item>");
    (51119, 10, "I");
    (51041, 0, "<");
    (51042, 0, "T");
    (51043, 0, ">");
    (51043, 1, "");
    (51042, 1, "");
    (51042, 0, "I");
    (51043, 0, ">");
    (51042, 2, "");
    (51042, 0, "T>");
    (51041, 3, "");
    (51119, 1, "&[C::Item]");
    (51130, 41, " where C::Item: Copy");
    ( 51152,
      0,
      "\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {" );
    (51152, 133, "");
    ( 51152,
      0,
      "\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {" );
    (51041, 0, "_");
    (51042, 0, "s");
    (51043, 0, "l");
    (51044, 0, "i");
    (51045, 0, "c");
    (51046, 0, "e");
    (51158, 0, "\n        ");
    (51159, 8, "    }");
    (51019, 145, "");
    (51752, 0, "\n    ");
    (51757, 0, "\n    ");
    (51753, 4, "");
    ( 51758,
      0,
      "\n\
      \    pub fn replace_at_slice(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \    }" );
    (51754, 4, "");
    (51753, 1, "");
    (51130, 20, " where I: ExactSizeIterator<Item=C::Item>");
    (51040, 0, "<");
    (51041, 1, "");
    (51040, 1, "");
    (51040, 0, "t");
    (51041, 0, "<");
    (51042, 0, "I");
    (51043, 0, ">");
    (51122, 10, "I");
    (51461, 16, "");
    (51104, 0, "m");
    (51105, 0, "u");
    (51106, 0, "t");
    (51107, 0, " ");
    (51377, 0, "\n        ");
    (51386, 0, "l");
    (51387, 0, "e");
    (51388, 0, "t");
    (51389, 0, " ");
    (51390, 0, "n");
    (51391, 0, "u");
    (51392, 0, "m");
    (51393, 0, "_");
    (51394, 0, "i");
    (51395, 0, "n");
    (51396, 0, "s");
    (51397, 0, "e");
    (51398, 0, "r");
    (51399, 0, "t");
    (51400, 0, "e");
    (51401, 0, "d");
    (51402, 0, "_");
    (51403, 0, "i");
    (51404, 0, "t");
    (51405, 0, "e");
    (51390, 16, "num_inserted_items");
    (51408, 0, " ");
    (51409, 0, "=");
    (51410, 0, " ");
    (51411, 0, "i");
    (51412, 0, "n");
    (51413, 0, "s");
    (51414, 0, "e");
    (51415, 0, "r");
    (51416, 0, "t");
    (51411, 6, "inserted_content");
    (51427, 0, ".");
    (51428, 0, "l");
    (51429, 0, "e");
    (51430, 0, "n");
    (51431, 0, "(");
    (51432, 0, ")");
    (51433, 0, ";");
    (51680, 22, "n");
    (51681, 0, "u");
    (51682, 0, "m");
    (51683, 0, "_");
    (51680, 4, "num_inserted_items");
    (51544, 0, "\n        ");
    (51553, 0, "\n        ");
    (51545, 8, "");
    ( 51554,
      0,
      "        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n" );
    (51546, 16, "        ");
    (51545, 208, "");
    (51544, 1, "");
    (51948, 0, "\n        ");
    (51957, 0, "s");
    (51958, 0, "e");
    (51959, 0, "l");
    (51960, 0, "f");
    (51961, 0, ".");
    (51962, 0, "r");
    (51963, 0, "e");
    (51964, 0, "p");
    (51965, 0, "l");
    ( 51962,
      4,
      "replace_at(mut start_userpos: usize, removed_items: usize, mut \
       inserted_content: I)" );
    (51973, 24, "s");
    (51974, 0, "t");
    (51975, 0, "a");
    (51976, 0, "r");
    (51977, 0, "t");
    (51978, 0, "_");
    (51979, 0, "u");
    (51980, 0, "s");
    (51981, 0, "e");
    (51982, 0, "r");
    (51983, 0, "p");
    (51984, 0, "o");
    (51985, 0, "s");
    (51988, 20, "r");
    (51989, 0, "e");
    (51990, 0, "m");
    (51991, 0, "o");
    (51992, 0, "v");
    (51993, 0, "e");
    (51994, 0, "d");
    (51995, 0, "_");
    (51996, 0, "i");
    (51997, 0, "t");
    (51998, 0, "e");
    (51999, 0, "m");
    (52000, 0, "s");
    (52003, 23, "i");
    (52004, 0, "n");
    (52005, 0, "s");
    (52006, 0, "e");
    (52007, 0, "r");
    (52008, 0, "t");
    (52009, 0, "e");
    (52010, 0, "d");
    (52011, 0, "_");
    (52012, 0, "c");
    (52013, 0, "o");
    (52014, 0, "n");
    (52015, 0, "t");
    (52016, 0, "e");
    (52017, 0, "n");
    (52018, 0, "t");
    (52019, 0, ".");
    (52020, 0, "s");
    (52021, 0, "l");
    (52022, 0, "i");
    (52023, 0, "c");
    (52020, 4, "i");
    (52021, 0, "t");
    (52022, 0, "e");
    (52023, 0, "r");
    (52024, 0, "(");
    (52025, 1, ")");
    (52026, 0, ".");
    (52027, 0, "c");
    (52028, 0, "o");
    (52029, 0, "p");
    (52030, 0, "i");
    (52031, 0, "e");
    (52032, 0, "d");
    (52033, 0, "(");
    (52034, 0, ")");
    (52035, 0, ")");
    (52036, 0, ";");
    (51849, 3, "");
    (51849, 1, "");
    (51849, 0, "mut ");
    (52020, 17, "slic)");
    (52003, 21, "mut inserted_content: I");
    (51988, 13, "removed_items: usize");
    (51973, 13, "mut start_userpos: usize");
    (51962, 83, "repl");
    (51948, 18, "");
    (51544, 0, "\n");
    ( 51545,
      0,
      "\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n" );
    (51546, 8, "                ");
    (51554, 207, "");
    (51545, 9, "");
    (51545, 0, "        ");
    (51544, 9, "");
    (51680, 18, "num_");
    (51680, 4, "inserted_content.len()");
    (51427, 7, "");
    (51411, 16, "insert");
    (51410, 7, "");
    (51408, 2, "");
    (51390, 18, "num_inserted_ite");
    (51389, 17, "");
    (51377, 12, "");
    (51107, 1, "");
    (51104, 3, "");
    (51461, 0, ".iter().copied()");
    (51122, 1, "&[C::Item]");
    (51040, 4, "");
    (51040, 0, "<t");
    (51040, 1, "");
    (51130, 41, " where C::Item: Copy");
    (51753, 0, "\n");
    (51754, 145, "");
    (51754, 0, "    ");
    (51753, 5, "");
    (51753, 0, "    ");
    (51752, 5, "");
    (51752, 0, "\n    ");
    (51757, 0, "\n    ");
    (51753, 4, "");
    ( 51758,
      0,
      "\n\
      \    pub fn replace_at_slice(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \    }" );
    (51754, 4, "");
    (51753, 1, "");
    (51130, 20, " where I: ExactSizeIterator<Item=C::Item>");
    (51040, 0, "<");
    (51040, 2, "");
    (51040, 0, "t<I>");
    (51122, 10, "I");
    (51461, 16, "");
    (51104, 0, "mut");
    (51107, 0, " ");
    (51377, 0, "\n        let");
    (51389, 0, " num_inserted_ite");
    (51390, 16, "num_inserted_items");
    (51408, 0, " =");
    (51410, 0, " insert");
    (51411, 6, "inserted_content");
    (51427, 0, ".len();");
    (51680, 22, "num_");
    (51680, 4, "num_inserted_items");
    (51544, 0, "\n        ");
    (51553, 0, "\n        ");
    (51545, 8, "");
    ( 51554,
      0,
      "        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n" );
    (51546, 16, "        ");
    (51545, 208, "");
    (51544, 1, "");
    (51948, 0, "\n        self.repl");
    ( 51962,
      4,
      "replace_at(mut start_userpos: usize, removed_items: usize, mut \
       inserted_content: I)" );
    (52021, 23, "inserted_content.slic");
    (51999, 20, "removed_items");
    (51973, 24, "start_userpos");
    (52020, 5, "iter().copied());");
    (51849, 4, "");
    (51849, 0, "mut ");
    (51849, 4, "");
    (10265, 0, "// ");
    (10265, 3, "");
    ( 10257,
      43487,
      "        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n\
      \    }\n\n\
      \    fn content_slice(&self) -> &[C::Item] {\n\
      \        let slice = &self.items[..self.num_items as usize];\n\
      \        unsafe { maybeinit_slice_get_ref(slice) }\n\
      \    }\n\n\
      \    // The height is at least 1, so this is always valid.\n\
      \    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n\
      \        unsafe { &*self.nexts.as_ptr() }\n\
      \    }\n\n\
      \    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n\
      \        unsafe { &mut *self.nexts.as_mut_ptr() }\n\
      \    }\n\n\
      \    // TODO: Rename to len() ?\n\
      \    fn get_userlen(&self) -> usize {\n\
      \        self.first_skip_entry().skip_usersize\n\
      \    }\n\
      \    \n\
      \    fn get_next_ptr(&self) -> *mut Node<C> {\n\
      \        self.first_skip_entry().node\n\
      \    }\n\
       }\n\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone)]\n\
       pub struct Cursor<C: ListConfig> {\n\
      \    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\n\n\
      \    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///\n\
      \    /// This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    /// the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    /// this.\n\
      \    userpos: usize,\n\n\
      \    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used to resolve that ambiguity.\n\
      \    local_index: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\
       impl<C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\
      \            self.local_index = 0;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    fn is_at_node_end(&self) -> bool {\n\
      \        self.local_index == unsafe { (*self.here_ptr()).num_items } as \
       usize\n\
      \    }\n\n\
      \    fn advance_item(&mut self, height: u8) {\n\
      \        if self.is_at_node_end() { self.advance_node(); }\n\
      \        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }\n\
      \        self.userpos += usersize;\n\
      \        self.local_index += 1;\n\
      \    }\n\n\
      \    fn advance_by_items(&mut self, num: usize, height: u8) {\n\
      \        for _ in 0..num { self.advance_item(height); }\n\
      \    }\n\n\
      \    fn move_to_item_start(&mut self, height: u8, offset: usize) {\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize -= offset;\n\
      \        }\n\
      \        self.userpos -= offset;\n\
      \    }\n\n\
      \    unsafe fn current_item(&mut self) -> &C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &*(node.items[self.local_index].as_ptr())\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice.\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos\n\
      \            || self.local_index != other.local_index {return false; }\n\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> fmt::Debug for Cursor<C> {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_struct(\"Cursor\")\n\
      \            .field(\"userpos\", &self.userpos)\n\
      \            .field(\"local_index\", &self.local_index)\n\
      \            .finish()\n\
      \    }\n\
       }\n\n\
       // None of the rust builtins give me what I want, which is a copy-free \
       iterator\n\
       // to owned items in a MaybeUninit array. Eh; its easy enough to make \
       my own.\n\
       struct UninitOwnedIter<'a, C: ListConfig> {\n\
      \    // Based on the core slice IterMut implementation.\n\
      \    ptr: NonNull<C::Item>,\n\
      \    end: *mut C::Item,\n\
      \    _marker: PhantomData<&'a SkipList<C>>\n\
       }\n\n\
       impl<'a, C: ListConfig> UninitOwnedIter<'a, C> {\n\
      \    /// Make a slice we can iterate from and steal data from without \
       dropping\n\
      \    /// content. This is unsafe:\n\
      \    ///\n\
      \    /// - If the iterator isn't fully drained then remaining items will \
       be\n\
      \    ///   forgotten (they are not dropped).\n\
      \    /// - The slice passed in here must be initialized or undefined \
       behaviour\n\
      \    ///   will hit us.\n\
      \    ///\n\
      \    /// After iterating, the contents are uninit memory.\n\
      \    unsafe fn from_slice(slice: &[MaybeUninit<C::Item>]) -> Self {\n\
      \        let ptr = slice.as_ptr() as *mut C::Item; // Safe.\n\
      \        let end = ptr.add(slice.len());\n\n\
      \        UninitOwnedIter {\n\
      \            ptr: NonNull::new_unchecked(ptr),\n\
      \            end,\n\
      \            _marker: PhantomData\n\
      \        }\n\
      \    }\n\
       }\n\n\
       impl<'a, C: ListConfig> Iterator for UninitOwnedIter<'a, C> {\n\
      \    type Item = C::Item;\n\n\
      \    fn next(&mut self) -> Option<Self::Item> {\n\
      \        if self.ptr.as_ptr() == self.end {\n\
      \            None\n\
      \        } else {\n\
      \            let ptr = self.ptr;\n\
      \            self.ptr = unsafe { \
       NonNull::new_unchecked(self.ptr.as_ptr().offset(1)) };\n\
      \            Some(unsafe { ptr.as_ptr().read() })\n\
      \        }\n\
      \    }\n\n\
      \    fn size_hint(&self) -> (usize, Option<usize>) {\n\
      \        let size = (self.end as usize - self.ptr.as_ptr() as usize) / \
       mem::size_of::<C::Item>();\n\
      \        (size, Some(size))\n\
      \    }\n\
       }\n\n\
       // TODO: Stolen from MaybeUninit::uninit_array. Replace with the real \
       uninit_array when stable.\n\
       #[inline(always)]\n\
       fn uninit_items_array<T>() -> [MaybeUninit<T>; NODE_NUM_ITEMS] {\n\
      \    unsafe { MaybeUninit::<[MaybeUninit<T>; \
       NODE_NUM_ITEMS]>::uninit().assume_init() }\n\
       }\n\n\
       // TODO: Stolen from MaybeUninit::slice_get_ref. Replace when available.\n\
       #[inline(always)]\n\
       unsafe fn maybeinit_slice_get_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {\n\
      \    // SAFETY: casting slice to a `*const [T]` is safe since the caller \
       guarantees that\n\
      \    // `slice` is initialized, and`MaybeUninit` is guaranteed to have \
       the same layout as `T`.\n\
      \    // The pointer obtained is valid since it refers to memory owned by \
       `slice` which is a\n\
      \    // reference and thus guaranteed to be valid for reads.\n\
      \    &*(slice as *const [MaybeUninit<T>] as *const [T])\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new() -> Self {\n\
      \        SkipList::<C> {\n\
      \            num_items: 0,\n\
      \            num_usercount: 0,\n\
      \            rng: None,\n\
      \            head: Node {\n\
      \                items: uninit_items_array(),\n\
      \                num_items: 0,\n\
      \                height: 1, // Stores max height of list nodes\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            },\n\
      \            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n\
      \        }\n\
      \    }\n\n\
      \    pub fn init_rng_from_seed(&mut self, seed: u64) {\n\
      \        self.rng = Some(SmallRng::seed_from_u64(seed));\n\
      \    }\n\n\
      \    fn get_rng(&mut self) -> &mut SmallRng {\n\
      \        // I'm sure there's a nicer way to implement this.\n\
      \        if self.rng.is_none() {\n\
      \            // We'll use a stable RNG in debug mode so the tests are \
       stable.\n\
      \            if cfg!(debug_assertions) {\n\
      \                self.init_rng_from_seed(123);\n\
      \            } else {\n\
      \                self.rng = Some(SmallRng::from_entropy());\n\
      \            }\n\
      \        }\n\
      \        self.rng.as_mut().unwrap()\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, s);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn get_userlen(&self) -> usize {\n\
      \        self.num_usercount\n\
      \    }\n\n\
      \    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn len_items(&self) -> usize {\n\
      \        self.num_items as usize\n\
      \    }\n\n\
      \    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            \
       std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), \
       self._nexts_padding.len())\n\
      \        }\n\
      \    }\n\n\
      \    fn is_head(&self, node: *const Node<C>) -> bool {\n\
      \        node as *const _ == &self.head as *const _\n\
      \    }\n\n\
      \    /// Walk the list and validate internal constraints. This is used for\n\
      \    /// testing the structure itself, and should generally not be \
       called by\n\
      \    /// users.\n\
      \    pub fn check(&self) {\n\
      \        // #[cfg(test)]\n\
      \        {\n\
      \            // self.print();\n\
      \            assert!(self.head.height >= 1);\n\
      \            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n\
      \            let head_ptr = &self.head as *const _ as *mut _;\n\
      \            // let skip_over = self.get_top_entry();\n\
      \            // println!(\"Skip over skip chars {}, num bytes {}\", \
       skip_over.skip_items, self.num_bytes);\n\n\
      \            let mut prev: [*const Node<C>; MAX_HEIGHT] = [ptr::null(); \
       MAX_HEIGHT];\n\n\
      \            let mut iter = [SkipEntry {\n\
      \                // Bleh.\n\
      \                node: head_ptr,\n\
      \                // The skips will store the total distance travelled \
       since the\n\
      \                // start of this traversal at each height. All the \
       entries above\n\
      \                // head.height are ignored though.\n\
      \                skip_usersize: 0\n\
      \            }; MAX_HEIGHT];\n\n\
      \            let mut num_items = 0;\n\
      \            let mut num_usercount = 0;\n\n\
      \            for (_i, n) in self.iter().enumerate() {\n\
      \                // println!(\"visiting {:?}\", n.as_str());\n\
      \                if !self.is_head(n) { assert!(n.num_items > 0); }\n\
      \                assert!(n.height <= MAX_HEIGHT_U8);\n\
      \                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n\
      \                // Make sure the number of items matches the count\n\
      \                let local_count = C::userlen_of_slice(n.content_slice());\n\
      \                assert_eq!(local_count, n.get_userlen());\n\n\
      \                let expect_parent = if self.is_head(n) {\n\
      \                    ptr::null() // The head's parent is null\n\
      \                } else if n.height == self.head.height {\n\
      \                    &self.head as *const _ // Max height nodes point \
       back to head\n\
      \                } else {\n\
      \                    prev[n.height as usize]\n\
      \                };\n\n\
      \                // println!(\"visiting {} {:?}\", i, n as *const _);\n\
      \                // dbg!(n as *const _);\n\
      \                // dbg!((n as *const _, (*n).height));\n\
      \                // dbg!(n.parent);\n\
      \                // dbg!(&self.head as *const _);\n\n\
      \                assert_eq!(n.parent as *const _, expect_parent, \
       \"invalid parent\");\n\
      \                \n\
      \                for (i, entry) in iter[0..n.height as \
       usize].iter_mut().enumerate() {\n\
      \                    assert_eq!(entry.node as *const _, n as *const _);\n\
      \                    assert_eq!(entry.skip_usersize, num_usercount);\n\n\
      \                    // println!(\"replacing entry {:?} with {:?}\", \
       entry, n.nexts()[i].node);\n\
      \                    prev[i] = n;\n\
      \                    entry.node = n.nexts()[i].node;\n\
      \                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n\
      \                }\n\n\
      \                num_items += n.num_items as usize;\n\
      \                num_usercount += n.get_userlen();\n\n\
      \                // Check the value returned by the iterator functions \
       matches.\n\
      \                let (mut normal_iter, local_offset) = \
       self.iter_at_userpos(num_usercount);\n\
      \                assert_eq!(local_offset, 0);\n\n\
      \                // Dirty hack. If n has 0-sized elements at the end, \
       the normal\n\
      \                // cursor won't be at the end...\n\
      \                while normal_iter.here_ptr() != n as *const _ as *mut _ {\n\
      \                    normal_iter.advance_node();\n\
      \                }\n\
      \                normal_iter.local_index = n.num_items as usize;\n\
      \                let node_iter = unsafe { self.iter_at_node(n, \
       n.get_userlen(), n.num_items as usize) };\n\
      \                assert_eq!(normal_iter, node_iter);\n\
      \            }\n\n\
      \            for entry in iter[0..self.head.height as usize].iter() {\n\
      \                // println!(\"{:?}\", entry);\n\
      \                assert!(entry.node.is_null());\n\
      \                assert_eq!(entry.skip_usersize, num_usercount);\n\
      \            }\n\
      \            \n\
      \            // println!(\"self bytes: {}, count bytes {}\", \
       self.num_bytes, num_bytes);\n\
      \            assert_eq!(self.num_items, num_items);\n\
      \            assert_eq!(self.get_userlen(), num_usercount);\n\
      \        }\n\
      \    }\n\
      \    \n\
      \    \n\
      \    /// Internal function for creating a cursor at a particular \
       location in the\n\
      \    /// skiplist. The returned cursor contains list of nodes which \
       point past\n\
      \    /// the specified position, as well as offsets of how far into their\n\
      \    /// character lists the specified characters are.\n\
      \    ///\n\
      \    /// Sometimes a call to iter_at_userpos is ambiguous:\n\
      \    ///\n\
      \    /// - The item can contain items with zero usersize. The cursor \
       could point\n\
      \    ///   to any of them.\n\
      \    /// - If the location is at the end of a node, it is equally valid \
       to return\n\
      \    ///   a position at the start of the next node.\n\
      \    ///\n\
      \    /// Because its impossible to move backwards in the list, \
       iter_at_userpos\n\
      \    /// returns the first admissible location with the specified userpos.\n\
      \    /// \n\
      \    /// Returns (cursor, offset into the specified item).\n\
      \    ///\n\
      \    /// TODO: This should be Pin<&self>.\n\
      \    fn iter_at_userpos(&self, target_userpos: usize) -> (Cursor<C>, \
       usize) {\n\
      \        assert!(target_userpos <= self.get_userlen());\n\n\
      \        let mut e: *const Node<C> = &self.head;\n\
      \        let mut height = self.head.height as usize - 1;\n\
      \        \n\
      \        let mut offset = target_userpos; // How many more items to skip\n\n\
      \        // We're populating the head node pointer to simplify the case \
       when the\n\
      \        // iterator grows. We could put offset into the skip_usersize \
       but it\n\
      \        // would only be *mostly* correct, not always correct. (Since \
       cursor\n\
      \        // entries above height are not updated by insert.)\n\
      \        let mut cursor = Cursor {\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \            local_index: 0,\n\
      \            userpos: target_userpos,\n\
      \        };\n\n\
      \        loop { // while height >= 0\n\
      \            let en = unsafe { &*e };\n\
      \            let next = en.nexts()[height];\n\
      \            let skip = next.skip_usersize;\n\
      \            if offset > skip {\n\
      \                // Go right.\n\
      \                debug_assert!(e == &self.head || en.num_items > 0);\n\
      \                offset -= skip;\n\
      \                e = next.node;\n\
      \                assert!(!e.is_null(), \"Internal constraint violation: \
       Reached rope end prematurely\");\n\
      \            } else {\n\
      \                // Record this and go down.\n\
      \                cursor.entries[height] = SkipEntry {\n\
      \                    skip_usersize: offset,\n\
      \                    node: e as *mut Node<C>, // This is pretty gross\n\
      \                };\n\n\
      \                if height == 0 { break; } else { height -= 1; }\n\
      \            }\n\
      \        };\n\n\
      \        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n\n\
      \        // We've found the node. Now look for the index within the node.\n\
      \        let en = unsafe { &*e };\n\
      \        let mut index = 0;\n\n\
      \        while offset > 0 {\n\
      \            assert!(index < en.num_items as usize);\n\
      \            \n\
      \            let usersize = C::get_usersize(unsafe { \
       &*en.items[index].as_ptr() });\n\
      \            if usersize > offset { break; } // We're in the middle of \
       an item.\n\
      \            offset -= usersize;\n\
      \            index += 1;\n\
      \        }\n\
      \        cursor.local_index = index;\n\n\
      \        (cursor, offset)\n\
      \    }\n\n\
      \    unsafe fn iter_at_node(&self, n: *const Node<C>, mut offset: usize, \
       local_index: usize) -> Cursor<C> {\n\
      \        let mut n = n as *mut Node<C>; // We don't mutate, but we need \
       a mut ptr.\n\n\
      \        let mut cursor = Cursor {\n\
      \            userpos: 0, // We'll set this later.\n\
      \            local_index: local_index,\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \        };\n\n\
      \        let mut h = 0;\n\
      \        loop {\n\
      \            while h < (*n).height as usize {\n\
      \                cursor.entries[h] = SkipEntry {\n\
      \                    node: n,\n\
      \                    skip_usersize: offset\n\
      \                };\n\n\
      \                h += 1;\n\
      \            }\n\n\
      \            let parent = (*n).parent;\n\
      \            // Reached the head.\n\
      \            if parent.is_null() { break; }\n\n\
      \            // If we're the same height as the parent its fine.\n\
      \            debug_assert!((*parent).height as usize > h\n\
      \                || (self.is_head(parent) && (*parent).height as usize \
       == h));\n\n\
      \            // Walk from parent back to n, figuring out the offset.\n\
      \            let mut c = parent;\n\
      \            // let walk_height = (*parent).height as usize - 2;\n\
      \            let walk_height = (*n).height as usize - 1;\n\
      \            while c != n {\n\
      \                let elem = (*c).nexts()[walk_height];\n\
      \                offset += elem.skip_usersize;\n\
      \                c = elem.node;\n\
      \            }\n\n\
      \            n = parent;\n\
      \        }\n\n\
      \        cursor.userpos = offset;\n\
      \        cursor\n\
      \    }\n\n\
      \    pub fn iter_at_marker(&mut self, marker: ItemMarker<C>, query: \
       &<C::Item as Queryable>::Query) -> Cursor<C> where C::Item: Queryable {\n\
      \        // The marker gives us a pointer into a node. Find the item.\n\
      \        unsafe {\n\
      \            let n = marker.ptr;\n\n\
      \            let mut offset: usize = 0;\n\
      \            let mut local_index = None;\n\
      \            for (i, item) in (*n).content_slice().iter().enumerate() {\n\
      \                if let Some(item_offset) = item.contains_item(query) {\n\
      \                    offset += item_offset;\n\
      \                    local_index = Some(i);\n\
      \                    break;\n\
      \                } else {\n\
      \                    offset += C::get_usersize(item);\n\
      \                }\n\
      \            }\n\n\
      \            let local_index = local_index.expect(\"Invalid marker - \
       item not found in node\");\n\
      \            self.iter_at_node(n, offset, local_index)\n\
      \        }\n\
      \    }\n\n\
      \    // Internal fn to create a new node at the specified iterator \
       filled with\n\
      \    // the specified content. The passed cursor should point at the end \
       of the\n\
      \    // previous node. It will be updated to point to the end of the newly\n\
      \    // inserted content.\n\
      \    // unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n\
      \    unsafe fn insert_node_at<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, num_items: usize, move_cursor: bool, \
       notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       Iterator<Item=C::Item> {\n\n\
      \        // println!(\"Insert_node_at {} len {}\", contents.len(), \
       self.num_bytes);\n\
      \        // debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n\
      \        assert!(num_items <= NODE_NUM_ITEMS);\n\
      \        debug_assert!(contents.size_hint().0 >= num_items);\n\n\
      \        let new_node_ptr = Node::alloc(self.get_rng());\n\
      \        let new_node = &mut *new_node_ptr;\n\
      \        new_node.num_items = num_items as u8;\n\n\
      \        for (slot, item) in \
       new_node.items[..num_items].iter_mut().zip(contents) {\n\
      \            (slot.as_mut_ptr() as *mut C::Item).write(item); // Write \
       makes sure we don't drop the old value.\n\
      \        }\n\n\
      \        let new_userlen = \
       C::userlen_of_slice(new_node.content_slice());\n\n\
      \        let new_height = new_node.height;\n\
      \        let new_height_usize = new_height as usize;\n\n\
      \        let mut head_height = self.head.height as usize;\n\
      \        while head_height < new_height_usize {\n\
      \            // This seems weird given we're about to overwrite these \
       values\n\
      \            // below. What we're doing is retroactively setting up the \
       cursor\n\
      \            // and head pointers *as if* the height had been this high \
       all\n\
      \            // along. This way we only have to populate the higher head \
       values\n\
      \            // lazily.\n\
      \            let total_userlen = self.num_usercount;\n\
      \            let nexts = self.heads_mut();\n\
      \            nexts[head_height].skip_usersize = total_userlen;\n\
      \            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n\
      \            head_height += 1; // This is ugly.\n\
      \            self.head.height += 1;\n\
      \        }\n\n\
      \        new_node.parent = if new_height_usize == MAX_HEIGHT {\n\
      \            &self.head as *const _ as *mut _\n\
      \        } else { cursor.entries[new_height_usize].node };\n\n\
      \        for i in 0..new_height_usize {\n\
      \            let prev_skip = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \            let new_nexts = new_node.nexts_mut();\n\n\
      \            // The new node points to the successor (or null)\n\
      \            new_nexts[i] = SkipEntry {\n\
      \                node: prev_skip.node,\n\
      \                skip_usersize: new_userlen + prev_skip.skip_usersize - \
       cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // The previous node points to the new node\n\
      \            *prev_skip = SkipEntry {\n\
      \                node: new_node_ptr,\n\
      \                skip_usersize: cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // Move the iterator to the end of the newly inserted node.\n\
      \            if move_cursor {\n\
      \                cursor.entries[i] = SkipEntry {\n\
      \                    node: new_node_ptr,\n\
      \                    skip_usersize: new_userlen\n\
      \                };\n\
      \            }\n\
      \        }\n\n\
      \        for i in new_height_usize..head_height {\n\
      \            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n\
      \            if move_cursor {\n\
      \                cursor.entries[i].skip_usersize += new_userlen;\n\
      \            }\n\
      \        }\n\n\
      \        // Update parents.\n\
      \        if new_height_usize > 1 {\n\n\
      \            let mut n = new_node_ptr;\n\
      \            let mut skip_height = 0;\n\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[skip_height].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\
      \                \n\
      \                (*n).parent = new_node_ptr;\n\
      \                skip_height = usize::max(skip_height, (*n).height as \
       usize - 1);\n\
      \            }\n\
      \        }\n\
      \        \n\
      \        self.num_items += num_items;\n\
      \        self.num_usercount += new_userlen;\n\
      \        if move_cursor {\n\
      \            cursor.userpos += new_userlen;\n\
      \            cursor.local_index = num_items;\n\
      \        }\n\n\
      \        notify(new_node.content_slice(), ItemMarker {\n\
      \            ptr: new_node_ptr,\n\
      \            _phantom: PhantomData\n\
      \        });\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    unsafe fn insert_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        // iter specifies where to insert.\n\n\
      \        let mut e = cursor.here_ptr();\n\n\
      \        // The insertion offset into the destination node.\n\
      \        assert!(cursor.userpos <= self.num_usercount);\n\
      \        assert!(cursor.local_index <= (*e).num_items as usize);\n\n\
      \        // We might be able to insert the new data into the current \
       node, depending on\n\
      \        // how big it is.\n\
      \        let num_inserted_items = contents.len();\n\n\
      \        // Can we insert into the current node?\n\
      \        let mut insert_here = (*e).num_items as usize + \
       num_inserted_items <= NODE_NUM_ITEMS;\n\n\
      \        // Can we insert into the start of the successor node?\n\
      \        if !insert_here && cursor.local_index == (*e).num_items as \
       usize && num_inserted_items <= NODE_NUM_ITEMS {\n\
      \            // We can insert into the subsequent node if:\n\
      \            // - We can't insert into the current node\n\
      \            // - There _is_ a next node to insert into\n\
      \            // - The insert would be at the start of the next node\n\
      \            // - There's room in the next node\n\
      \            if let Some(next) = \
       (*e).first_skip_entry_mut().node.as_mut() {\n\
      \                if next.num_items as usize + num_inserted_items <= \
       NODE_NUM_ITEMS {\n\
      \                    cursor.advance_node();\n\
      \                    e = next;\n\n\
      \                    insert_here = true;\n\
      \                }\n\
      \            }\n\
      \        }\n\n\
      \        let item_idx = cursor.local_index;\n\
      \        let e_num_items = (*e).num_items as usize; // convenience.\n\n\
      \        if insert_here {\n\
      \            // println!(\"insert_here {}\", contents);\n\
      \            // First push the current items later in the array\n\
      \            let c = &mut (*e).items;\n\
      \            if item_idx < e_num_items {\n\
      \                // Can't use copy_within because Item doesn't necessarily\n\
      \                // implement Copy. Memmove the existing items.\n\
      \                ptr::copy(\n\
      \                    &c[item_idx],\n\
      \                    &mut c[item_idx + num_inserted_items],\n\
      \                    (*e).num_items as usize - item_idx);\n\
      \            }\n\n\
      \            // Then copy in the new items. Can't memcpy from an \
       iterator, but\n\
      \            // the optimizer should make this fast.\n\
      \            let dest_content_slice = &mut c[item_idx..item_idx + \
       num_inserted_items];\n\
      \            for (slot, item) in \
       dest_content_slice.iter_mut().zip(contents) {\n\
      \                // Do not drop the old items - they were only moved.\n\
      \                slot.as_mut_ptr().write(item);\n\
      \            }\n\
      \            let dest_content_slice = \
       maybeinit_slice_get_ref(dest_content_slice);\n\n\
      \            (*e).num_items += num_inserted_items as u8;\n\
      \            self.num_items += num_inserted_items;\n\
      \            let num_inserted_usercount = \
       C::userlen_of_slice(dest_content_slice);\n\
      \            self.num_usercount += num_inserted_usercount;\n\n\
      \            // .... aaaand update all the offset amounts.\n\
      \            cursor.update_offsets(self.head.height as usize, \
       num_inserted_usercount as isize);\n\n\
      \            // Usually the cursor will be discarded after one change, \
       but for\n\
      \            // consistency of compound edits we'll update the cursor to \
       point to\n\
      \            // the end of the new content.\n\
      \            for entry in cursor.entries[0..self.head.height as \
       usize].iter_mut() {\n\
      \                entry.skip_usersize += num_inserted_usercount;\n\
      \            }\n\
      \            cursor.userpos += num_inserted_usercount;\n\
      \            cursor.local_index += num_inserted_items;\n\n\
      \            notify(dest_content_slice, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData\n\
      \            });\n\
      \        } else {\n\
      \            // There isn't room. We'll need to add at least one new \
       node to the\n\
      \            // list. We could be a bit more careful here and copy as \
       much as\n\
      \            // possible into the current node - that would decrease the \
       number\n\
      \            // of new nodes in some cases, but I don't think the \
       performance\n\
      \            // difference will be large enough to justify the \
       complexity.\n\n\
      \            // If we're not at the end of the current node, we'll need \
       to remove\n\
      \            // the end of the current node's data and reinsert it later.\n\
      \            let num_end_items = e_num_items - item_idx;\n\n\
      \            let (end_items, end_usercount) = if num_end_items > 0 {\n\
      \                // We'll mark the items as deleted from the node, while \
       leaving\n\
      \                // the data itself there for now to avoid a copy.\n\n\
      \                // Note that if we wanted to, it would also be correct \
       (and\n\
      \                // slightly more space efficient) to pack some of the new\n\
      \                // string's characters into this node after trimming it.\n\
      \                let end_items = &(*e).items[item_idx..e_num_items];\n\
      \                (*e).num_items = item_idx as u8;\n\
      \                let end_usercount = (*e).get_userlen() - \
       cursor.entries[0].skip_usersize;\n\n\
      \                cursor.update_offsets(self.head.height as usize, \
       -(end_usercount as isize));\n\n\
      \                // We need to trim the size off because we'll add the \
       characters\n\
      \                // back with insert_node_at.\n\
      \                self.num_usercount -= end_usercount;\n\
      \                self.num_items -= num_end_items;\n\n\
      \                (Some(end_items), end_usercount)\n\
      \            } else {\n\
      \                (None, 0)\n\
      \            };\n\n\
      \            // Now we insert new nodes containing the new character \
       data. The\n\
      \            // data is broken into pieces with a maximum size of \
       NODE_NUM_ITEMS.\n\
      \            // As further optimization, we could try and fit the last \
       piece into\n\
      \            // the start of the subsequent node.\n\
      \            let mut items_remaining = num_inserted_items;\n\
      \            while items_remaining > 0 {\n\
      \                let insert_here = usize::min(items_remaining, \
       NODE_NUM_ITEMS);\n\
      \                self.insert_node_at(cursor, contents, insert_here, \
       true, notify);\n\
      \                items_remaining -= insert_here;\n\
      \            }\n\n\
      \            // TODO: Consider recursively calling insert_at_iter() here \
       instead\n\
      \            // of making a whole new node for the remaining content.\n\
      \            if let Some(end_items) = end_items {\n\
      \                // Passing false to indicate we don't want the cursor \
       updated\n\
      \                // after this - it should remain at the end of the newly\n\
      \                // inserted content, which is *before* this end bit.\n\
      \                self.insert_node_at(cursor, &mut \
       UninitOwnedIter::<C>::from_slice(end_items), end_items.len(), false, \
       notify);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    //     self.insert_at_iter_and_notify(cursor, contents, \
       Self::no_notify);\n\
      \    // }\n\n\
      \    /// Interestingly unlike the original, here we only care about \
       specifying\n\
      \    /// the number of removed items by counting them. We do not use \
       usersize in\n\
      \    /// the deleted item count.\n\
      \    ///\n\
      \    /// If the deleted content occurs at the start of a node, the \
       cursor passed\n\
      \    /// here must point to the end of the previous node, not the start \
       of the\n\
      \    /// current node.\n\
      \    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       num_deleted_items: usize) {\n\
      \        if num_deleted_items == 0 { return; }\n\n\
      \        let mut item_idx = cursor.local_index;\n\
      \        let mut e = cursor.here_ptr();\n\
      \        while num_deleted_items > 0 {\n\
      \            // self.print();\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \            if item_idx == (*e).num_items as usize {\n\
      \                let entry = (*e).first_skip_entry();\n\
      \                // End of current node. Skip to the start of the next \
       one. We're\n\
      \                // intentionally not updating the iterator because if \
       we delete\n\
      \                // a whole node we need the iterator to point to the \
       previous\n\
      \                // element. And if we only delete here, the iterator \
       doesn't\n\
      \                // need to be moved.\n\
      \                e = entry.node;\n\
      \                if e.is_null() { panic!(\"Cannot delete past the end of \
       the list\"); }\n\
      \                item_idx = 0;\n\
      \            }\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let removed_here = min(num_deleted_items, e_num_items - \
       item_idx);\n\
      \            \n\
      \            let height = (*e).height as usize;\n\
      \            let removed_userlen;\n\n\
      \            if removed_here < e_num_items || e as *const _ == \
       &self.head as *const _ {\n\
      \                // Just trim the node down.\n\
      \                let trailing_items = e_num_items - item_idx - \
       removed_here;\n\
      \                \n\
      \                let c = &mut (*e).items;\n\
      \                removed_userlen = \
       C::userlen_of_slice(maybeinit_slice_get_ref(&c[item_idx..item_idx + \
       removed_here]));\n\
      \                if trailing_items > 0 {\n\
      \                    ptr::copy(\n\
      \                        &c[item_idx + removed_here],\n\
      \                        &mut c[item_idx],\n\
      \                        trailing_items);\n\
      \                }\n\n\
      \                (*e).num_items -= removed_here as u8;\n\
      \                self.num_items -= removed_here;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                for s in (*e).nexts_mut() {\n\
      \                    s.skip_usersize -= removed_userlen;\n\
      \                }\n\
      \            } else {\n\
      \                // Remove the node from the skip list entirely. e \
       should be the\n\
      \                // next node after the position of the iterator.\n\
      \                assert_ne!(cursor.here_ptr(), e);\n\n\
      \                removed_userlen = (*e).get_userlen();\n\
      \                let next = (*e).first_skip_entry().node;\n\n\
      \                // println!(\"removing {:?} contents {:?} height {}\", \
       e, (*e).content_slice(), height);\n\n\
      \                for i in 0..height {\n\
      \                    let s = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                    s.node = (*e).nexts_mut()[i].node;\n\
      \                    s.skip_usersize += (*e).nexts()[i].skip_usersize - \
       removed_userlen;\n\
      \                }\n\n\
      \                self.num_items -= (*e).num_items as usize;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                // Update parents.\n\
      \                if height > 1 {\n\
      \                    let mut n = e;\n\
      \                    // let new_parent = cursor.entries[height - \
       1].node;\n\n\
      \                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents.\n\
      \                    let mut parent_height = 1;\n\
      \                    let cursor_node = cursor.here_ptr();\n\
      \                    let cursor_node_height = (*cursor_node).height as \
       usize;\n\
      \                    let mut new_parent = if height >= \
       cursor_node_height {\n\
      \                        cursor.entries[parent_height].node\n\
      \                    } else {\n\
      \                        cursor_node\n\
      \                    };\n\n\
      \                    loop {\n\
      \                        n = (*n).nexts_mut()[parent_height - 1].node;\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }\n\
      \                        let n_height = (*n).height as usize;\n\
      \                        \n\
      \                        assert_eq!((*n).parent, e);\n\
      \                        assert!(n_height >= parent_height - 1);\n\n\
      \                        if n_height > parent_height {\n\
      \                            parent_height = n_height;\n\
      \                            if n_height >= cursor_node_height {\n\
      \                                new_parent = \
       cursor.entries[parent_height].node\n\
      \                            }\n\
      \                        }\n\
      \                        \n\
      \                        (*n).parent = new_parent;\n\
      \                    }\n\
      \                }\n\n\
      \                Node::free(e);\n\
      \                e = next;\n\
      \            }\n\n\
      \            for i in height..self.head.height as usize {\n\
      \                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                s.skip_usersize -= removed_userlen;\n\
      \            }\n\n\
      \            num_deleted_items -= removed_here;\n\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \        }\n\
      \    }\n\n\n\
      \    unsafe fn replace_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, mut removed_items: usize, inserted_content: &mut I, mut \
       notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        if removed_items == 0 && inserted_content.len() == 0 { return; \
       }\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \        removed_items -= replaced_items;\n\n\
      \        while replaced_items > 0 {\n\
      \            debug_assert!(inserted_content.len() >= replaced_items);\n\
      \            let mut e = cursor.here_ptr();\n\
      \            if cursor.local_index == (*e).num_items as usize {\n\
      \                // Move to the next item.\n\
      \                e = cursor.advance_node();\n\
      \                if e.is_null() { panic!(\"Cannot replace past the end \
       of the list\"); }\n\
      \            }\n\n\
      \            let index = cursor.local_index;\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let replaced_items_here = min(replaced_items, e_num_items - \
       index);\n\n\
      \            let dest = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \            let old_usersize = \
       C::userlen_of_slice(maybeinit_slice_get_ref(dest));\n\n\
      \            // Replace the items themselves. Everything else is \
       commentary.\n\
      \            // Would prefer to use zip() but it wants ownership of \
       inserted_content :/\n\
      \            for slot in dest.iter_mut() {\n\
      \                *slot.as_mut_ptr() = inserted_content.next().unwrap();\n\
      \            }\n\n\
      \            let dest = maybeinit_slice_get_ref(dest);\n\
      \            let new_usersize = C::userlen_of_slice(dest);\n\
      \            let usersize_delta = new_usersize as isize - old_usersize \
       as isize;\n\n\
      \            if usersize_delta != 0 {\n\
      \                cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \            }\n\
      \            // I hate this.\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\n\
      \            replaced_items -= replaced_items_here;\n\
      \            // We'll hop to the next Node at the start of the next loop\n\
      \            // iteration if needed.\n\
      \            cursor.local_index += replaced_items_here;\n\n\
      \            for i in 0..self.head.height as usize {\n\
      \                cursor.entries[i].skip_usersize += new_usersize;\n\
      \            }\n\
      \            cursor.userpos += new_usersize;\n\n\
      \            notify(dest, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });\n\
      \        }\n\n\
      \        // Ok now one of two things must be true. Either we've run out of\n\
      \        // items to remove, or we've run out of items to insert.\n\
      \        if inserted_content.len() > 0 {\n\
      \            // Insert!\n\
      \            debug_assert!(removed_items == 0);\n\
      \            self.insert_at_iter(cursor, inserted_content, &mut notify);\n\
      \        } else if removed_items > 0 {\n\
      \            self.del_at_iter(cursor, removed_items);\n\
      \        }\n\
      \    }\n\n\
      \    fn dbg_check_cursor_at(&self, cursor: &Cursor<C>, userpos: usize, \
       plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n\
      \    }\n\n\
      \    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}\n\n\
      \    pub fn replace_at(&mut self, mut start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, &mut \
       inserted_content.iter().copied(), Self::no_notify); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(start_userpos);\n\
      \            c2.advance_by_items(inserted_content.len(), \
       self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       replace\"); }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn insert_at(&mut self, mut userpos: usize, contents: \
       &[C::Item]) where C::Item: Copy {\n\
      \        if contents.len() == 0 { return; }\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        unsafe {\n\
      \            if offset == 0 {\n\
      \                self.insert_at_iter(&mut cursor, &mut \
       contents.iter().copied(), &mut Self::no_notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\
      \            } else {\n\
      \                let current_item = cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                cursor.move_to_item_start(self.head.height, offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.replace_at_iter(&mut cursor, 1, &mut \
       iter::once(start), &mut Self::no_notify);\n\
      \                self.insert_at_iter(&mut cursor, &mut \
       contents.iter().copied(), &mut Self::no_notify);\n\n\
      \                // There's no clean way to keep the cursor steady for \
       the final\n\
      \                // insert. We'll just make sure the cursor is in the \
       right\n\
      \                // position before that call for now.\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       contents.len());\n\n\
      \                self.insert_at_iter(&mut cursor, &mut iter::once(end), \
       &mut Self::no_notify);\n\
      \            }\n\
      \        }\n\n" );
    ( 10257,
      42579,
      "        ptr::drop_in_place(p); // We could just implement drop here, \
       but this is cleaner.\n\
      \        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n\
      \    }\n\n\
      \    fn content_slice(&self) -> &[C::Item] {\n\
      \        let slice = &self.items[..self.num_items as usize];\n\
      \        unsafe { maybeinit_slice_get_ref(slice) }\n\
      \    }\n\n\
      \    // The height is at least 1, so this is always valid.\n\
      \    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n\
      \        unsafe { &*self.nexts.as_ptr() }\n\
      \    }\n\n\
      \    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n\
      \        unsafe { &mut *self.nexts.as_mut_ptr() }\n\
      \    }\n\n\
      \    // TODO: Rename to len() ?\n\
      \    fn get_userlen(&self) -> usize {\n\
      \        self.first_skip_entry().skip_usersize\n\
      \    }\n\
      \    \n\
      \    fn get_next_ptr(&self) -> *mut Node<C> {\n\
      \        self.first_skip_entry().node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> Drop for Node<C> {\n\
      \    fn drop(&mut self) {\n\
      \        for i in 0..self.num_items as usize {\n\
      \            // Could instead call assume_init() on each item but this is\n\
      \            // friendlier to the optimizer.\n\
      \            unsafe { ptr::drop_in_place(self.items[i].as_mut_ptr()); }\n\
      \        }\n\
      \    }\n\
       }\n\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone)]\n\
       pub struct Cursor<C: ListConfig> {\n\
      \    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\n\n\
      \    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///\n\
      \    /// This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    /// the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    /// this.\n\
      \    userpos: usize,\n\n\
      \    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used to resolve that ambiguity.\n\
      \    local_index: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\
       }\n\n\
       impl<C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\
      \            self.local_index = 0;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    fn is_at_node_end(&self) -> bool {\n\
      \        self.local_index == unsafe { (*self.here_ptr()).num_items } as \
       usize\n\
      \    }\n\n\
      \    fn advance_item(&mut self, height: u8) {\n\
      \        if self.is_at_node_end() { self.advance_node(); }\n\
      \        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }\n\
      \        self.userpos += usersize;\n\
      \        self.local_index += 1;\n\
      \    }\n\n\
      \    fn advance_by_items(&mut self, num: usize, height: u8) {\n\
      \        for _ in 0..num { self.advance_item(height); }\n\
      \    }\n\n\
      \    fn move_to_item_start(&mut self, height: u8, offset: usize) {\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize -= offset;\n\
      \        }\n\
      \        self.userpos -= offset;\n\
      \    }\n\n\
      \    unsafe fn current_item(&mut self) -> &C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &*(node.items[self.local_index].as_ptr())\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice.\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos\n\
      \            || self.local_index != other.local_index {return false; }\n\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> fmt::Debug for Cursor<C> {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_struct(\"Cursor\")\n\
      \            .field(\"userpos\", &self.userpos)\n\
      \            .field(\"local_index\", &self.local_index)\n\
      \            .finish()\n\
      \    }\n\
       }\n\n\
       // None of the rust builtins give me what I want, which is a copy-free \
       iterator\n\
       // to owned items in a MaybeUninit array. Eh; its easy enough to make \
       my own.\n\
       struct UninitOwnedIter<'a, C: ListConfig> {\n\
      \    // Based on the core slice IterMut implementation.\n\
      \    ptr: NonNull<C::Item>,\n\
      \    end: *mut C::Item,\n\
      \    _marker: PhantomData<&'a SkipList<C>>\n\
       }\n\n\
       impl<'a, C: ListConfig> UninitOwnedIter<'a, C> {\n\
      \    /// Make a slice we can iterate from and steal data from without \
       dropping\n\
      \    /// content. This is unsafe:\n\
      \    ///\n\
      \    /// - If the iterator isn't fully drained then remaining items will \
       be\n\
      \    ///   forgotten (they are not dropped).\n\
      \    /// - The slice passed in here must be initialized or undefined \
       behaviour\n\
      \    ///   will hit us.\n\
      \    ///\n\
      \    /// After iterating, the contents are uninit memory.\n\
      \    unsafe fn from_slice(slice: &[MaybeUninit<C::Item>]) -> Self {\n\
      \        let ptr = slice.as_ptr() as *mut C::Item; // Safe.\n\
      \        let end = ptr.add(slice.len());\n\n\
      \        UninitOwnedIter {\n\
      \            ptr: NonNull::new_unchecked(ptr),\n\
      \            end,\n\
      \            _marker: PhantomData\n\
      \        }\n\
      \    }\n\
       }\n\n\
       impl<'a, C: ListConfig> Iterator for UninitOwnedIter<'a, C> {\n\
      \    type Item = C::Item;\n\n\
      \    fn next(&mut self) -> Option<Self::Item> {\n\
      \        if self.ptr.as_ptr() == self.end {\n\
      \            None\n\
      \        } else {\n\
      \            let ptr = self.ptr;\n\
      \            self.ptr = unsafe { \
       NonNull::new_unchecked(self.ptr.as_ptr().offset(1)) };\n\
      \            Some(unsafe { ptr.as_ptr().read() })\n\
      \        }\n\
      \    }\n\n\
      \    fn size_hint(&self) -> (usize, Option<usize>) {\n\
      \        let size = (self.end as usize - self.ptr.as_ptr() as usize) / \
       mem::size_of::<C::Item>();\n\
      \        (size, Some(size))\n\
      \    }\n\
       }\n\n\
       // TODO: Stolen from MaybeUninit::uninit_array. Replace with the real \
       uninit_array when stable.\n\
       #[inline(always)]\n\
       fn uninit_items_array<T>() -> [MaybeUninit<T>; NODE_NUM_ITEMS] {\n\
      \    unsafe { MaybeUninit::<[MaybeUninit<T>; \
       NODE_NUM_ITEMS]>::uninit().assume_init() }\n\
       }\n\n\
       // TODO: Stolen from MaybeUninit::slice_get_ref. Replace when available.\n\
       #[inline(always)]\n\
       unsafe fn maybeinit_slice_get_ref<T>(slice: &[MaybeUninit<T>]) -> &[T] {\n\
      \    // SAFETY: casting slice to a `*const [T]` is safe since the caller \
       guarantees that\n\
      \    // `slice` is initialized, and`MaybeUninit` is guaranteed to have \
       the same layout as `T`.\n\
      \    // The pointer obtained is valid since it refers to memory owned by \
       `slice` which is a\n\
      \    // reference and thus guaranteed to be valid for reads.\n\
      \    &*(slice as *const [MaybeUninit<T>] as *const [T])\n\
       }\n\n\n\
       impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new() -> Self {\n\
      \        SkipList::<C> {\n\
      \            num_items: 0,\n\
      \            num_usercount: 0,\n\
      \            rng: None,\n\
      \            head: Node {\n\
      \                items: uninit_items_array(),\n\
      \                num_items: 0,\n\
      \                height: 1, // Stores max height of list nodes\n\
      \                parent: ptr::null_mut(),\n\
      \                nexts: [],\n\
      \            },\n\
      \            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n\
      \        }\n\
      \    }\n\n\
      \    pub fn init_rng_from_seed(&mut self, seed: u64) {\n\
      \        self.rng = Some(SmallRng::seed_from_u64(seed));\n\
      \    }\n\n\
      \    fn get_rng(&mut self) -> &mut SmallRng {\n\
      \        // I'm sure there's a nicer way to implement this.\n\
      \        if self.rng.is_none() {\n\
      \            // We'll use a stable RNG in debug mode so the tests are \
       stable.\n\
      \            if cfg!(debug_assertions) {\n\
      \                self.init_rng_from_seed(123);\n\
      \            } else {\n\
      \                self.rng = Some(SmallRng::from_entropy());\n\
      \            }\n\
      \        }\n\
      \        self.rng.as_mut().unwrap()\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at_slice(0, s);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn get_userlen(&self) -> usize {\n\
      \        self.num_usercount\n\
      \    }\n\n\
      \    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn len_items(&self) -> usize {\n\
      \        self.num_items as usize\n\
      \    }\n\n\
      \    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n\
      \        unsafe {\n\
      \            \
       std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), \
       self._nexts_padding.len())\n\
      \        }\n\
      \    }\n\n\
      \    fn is_head(&self, node: *const Node<C>) -> bool {\n\
      \        node as *const _ == &self.head as *const _\n\
      \    }\n\n\
      \    /// Walk the list and validate internal constraints. This is used for\n\
      \    /// testing the structure itself, and should generally not be \
       called by\n\
      \    /// users.\n\
      \    pub fn check(&self) {\n\
      \        // #[cfg(test)]\n\
      \        {\n\
      \            // self.print();\n\
      \            assert!(self.head.height >= 1);\n\
      \            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n\
      \            let head_ptr = &self.head as *const _ as *mut _;\n\
      \            // let skip_over = self.get_top_entry();\n\
      \            // println!(\"Skip over skip chars {}, num bytes {}\", \
       skip_over.skip_items, self.num_bytes);\n\n\
      \            let mut prev: [*const Node<C>; MAX_HEIGHT] = [ptr::null(); \
       MAX_HEIGHT];\n\n\
      \            let mut iter = [SkipEntry {\n\
      \                // Bleh.\n\
      \                node: head_ptr,\n\
      \                // The skips will store the total distance travelled \
       since the\n\
      \                // start of this traversal at each height. All the \
       entries above\n\
      \                // head.height are ignored though.\n\
      \                skip_usersize: 0\n\
      \            }; MAX_HEIGHT];\n\n\
      \            let mut num_items = 0;\n\
      \            let mut num_usercount = 0;\n\n\
      \            for (_i, n) in self.iter().enumerate() {\n\
      \                // println!(\"visiting {:?}\", n.as_str());\n\
      \                if !self.is_head(n) { assert!(n.num_items > 0); }\n\
      \                assert!(n.height <= MAX_HEIGHT_U8);\n\
      \                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n\
      \                // Make sure the number of items matches the count\n\
      \                let local_count = C::userlen_of_slice(n.content_slice());\n\
      \                assert_eq!(local_count, n.get_userlen());\n\n\
      \                let expect_parent = if self.is_head(n) {\n\
      \                    ptr::null() // The head's parent is null\n\
      \                } else if n.height == self.head.height {\n\
      \                    &self.head as *const _ // Max height nodes point \
       back to head\n\
      \                } else {\n\
      \                    prev[n.height as usize]\n\
      \                };\n\n\
      \                // println!(\"visiting {} {:?}\", i, n as *const _);\n\
      \                // dbg!(n as *const _);\n\
      \                // dbg!((n as *const _, (*n).height));\n\
      \                // dbg!(n.parent);\n\
      \                // dbg!(&self.head as *const _);\n\n\
      \                assert_eq!(n.parent as *const _, expect_parent, \
       \"invalid parent\");\n\
      \                \n\
      \                for (i, entry) in iter[0..n.height as \
       usize].iter_mut().enumerate() {\n\
      \                    assert_eq!(entry.node as *const _, n as *const _);\n\
      \                    assert_eq!(entry.skip_usersize, num_usercount);\n\n\
      \                    // println!(\"replacing entry {:?} with {:?}\", \
       entry, n.nexts()[i].node);\n\
      \                    prev[i] = n;\n\
      \                    entry.node = n.nexts()[i].node;\n\
      \                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n\
      \                }\n\n\
      \                num_items += n.num_items as usize;\n\
      \                num_usercount += n.get_userlen();\n\n\
      \                // Check the value returned by the iterator functions \
       matches.\n\
      \                let (mut normal_iter, local_offset) = \
       self.iter_at_userpos(num_usercount);\n\
      \                assert_eq!(local_offset, 0);\n\n\
      \                // Dirty hack. If n has 0-sized elements at the end, \
       the normal\n\
      \                // cursor won't be at the end...\n\
      \                while normal_iter.here_ptr() != n as *const _ as *mut _ {\n\
      \                    normal_iter.advance_node();\n\
      \                }\n\
      \                normal_iter.local_index = n.num_items as usize;\n\
      \                let node_iter = unsafe { self.iter_at_node(n, \
       n.get_userlen(), n.num_items as usize) };\n\
      \                assert_eq!(normal_iter, node_iter);\n\
      \            }\n\n\
      \            for entry in iter[0..self.head.height as usize].iter() {\n\
      \                // println!(\"{:?}\", entry);\n\
      \                assert!(entry.node.is_null());\n\
      \                assert_eq!(entry.skip_usersize, num_usercount);\n\
      \            }\n\
      \            \n\
      \            // println!(\"self bytes: {}, count bytes {}\", \
       self.num_bytes, num_bytes);\n\
      \            assert_eq!(self.num_items, num_items);\n\
      \            assert_eq!(self.get_userlen(), num_usercount);\n\
      \        }\n\
      \    }\n\
      \    \n\
      \    \n\
      \    /// Internal function for creating a cursor at a particular \
       location in the\n\
      \    /// skiplist. The returned cursor contains list of nodes which \
       point past\n\
      \    /// the specified position, as well as offsets of how far into their\n\
      \    /// character lists the specified characters are.\n\
      \    ///\n\
      \    /// Sometimes a call to iter_at_userpos is ambiguous:\n\
      \    ///\n\
      \    /// - The item can contain items with zero usersize. The cursor \
       could point\n\
      \    ///   to any of them.\n\
      \    /// - If the location is at the end of a node, it is equally valid \
       to return\n\
      \    ///   a position at the start of the next node.\n\
      \    ///\n\
      \    /// Because its impossible to move backwards in the list, \
       iter_at_userpos\n\
      \    /// returns the first admissible location with the specified userpos.\n\
      \    /// \n\
      \    /// Returns (cursor, offset into the specified item).\n\
      \    ///\n\
      \    /// TODO: This should be Pin<&self>.\n\
      \    fn iter_at_userpos(&self, target_userpos: usize) -> (Cursor<C>, \
       usize) {\n\
      \        assert!(target_userpos <= self.get_userlen());\n\n\
      \        let mut e: *const Node<C> = &self.head;\n\
      \        let mut height = self.head.height as usize - 1;\n\
      \        \n\
      \        let mut offset = target_userpos; // How many more items to skip\n\n\
      \        // We're populating the head node pointer to simplify the case \
       when the\n\
      \        // iterator grows. We could put offset into the skip_usersize \
       but it\n\
      \        // would only be *mostly* correct, not always correct. (Since \
       cursor\n\
      \        // entries above height are not updated by insert.)\n\
      \        let mut cursor = Cursor {\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \            local_index: 0,\n\
      \            userpos: target_userpos,\n\
      \        };\n\n\
      \        loop { // while height >= 0\n\
      \            let en = unsafe { &*e };\n\
      \            let next = en.nexts()[height];\n\
      \            let skip = next.skip_usersize;\n\
      \            if offset > skip {\n\
      \                // Go right.\n\
      \                debug_assert!(e == &self.head || en.num_items > 0);\n\
      \                offset -= skip;\n\
      \                e = next.node;\n\
      \                assert!(!e.is_null(), \"Internal constraint violation: \
       Reached rope end prematurely\");\n\
      \            } else {\n\
      \                // Record this and go down.\n\
      \                cursor.entries[height] = SkipEntry {\n\
      \                    skip_usersize: offset,\n\
      \                    node: e as *mut Node<C>, // This is pretty gross\n\
      \                };\n\n\
      \                if height == 0 { break; } else { height -= 1; }\n\
      \            }\n\
      \        };\n\n\
      \        // We should always land within the node we're pointing to.\n\
      \        debug_assert!(offset <= unsafe { &*cursor.here_ptr() \
       }.get_userlen());\n\n\
      \        // We've found the node. Now look for the index within the node.\n\
      \        let en = unsafe { &*e };\n\
      \        let mut index = 0;\n\n\
      \        while offset > 0 {\n\
      \            assert!(index < en.num_items as usize);\n\
      \            \n\
      \            let usersize = C::get_usersize(unsafe { \
       &*en.items[index].as_ptr() });\n\
      \            if usersize > offset { break; } // We're in the middle of \
       an item.\n\
      \            offset -= usersize;\n\
      \            index += 1;\n\
      \        }\n\
      \        cursor.local_index = index;\n\n\
      \        (cursor, offset)\n\
      \    }\n\n\
      \    unsafe fn iter_at_node(&self, n: *const Node<C>, mut offset: usize, \
       local_index: usize) -> Cursor<C> {\n\
      \        let mut n = n as *mut Node<C>; // We don't mutate, but we need \
       a mut ptr.\n\n\
      \        let mut cursor = Cursor {\n\
      \            userpos: 0, // We'll set this later.\n\
      \            local_index: local_index,\n\
      \            entries: [SkipEntry {\n\
      \                node: &self.head as *const _ as *mut _,\n\
      \                skip_usersize: usize::MAX\n\
      \            }; MAX_HEIGHT],\n\
      \        };\n\n\
      \        let mut h = 0;\n\
      \        loop {\n\
      \            while h < (*n).height as usize {\n\
      \                cursor.entries[h] = SkipEntry {\n\
      \                    node: n,\n\
      \                    skip_usersize: offset\n\
      \                };\n\n\
      \                h += 1;\n\
      \            }\n\n\
      \            let parent = (*n).parent;\n\
      \            // Reached the head.\n\
      \            if parent.is_null() { break; }\n\n\
      \            // If we're the same height as the parent its fine.\n\
      \            debug_assert!((*parent).height as usize > h\n\
      \                || (self.is_head(parent) && (*parent).height as usize \
       == h));\n\n\
      \            // Walk from parent back to n, figuring out the offset.\n\
      \            let mut c = parent;\n\
      \            // let walk_height = (*parent).height as usize - 2;\n\
      \            let walk_height = (*n).height as usize - 1;\n\
      \            while c != n {\n\
      \                let elem = (*c).nexts()[walk_height];\n\
      \                offset += elem.skip_usersize;\n\
      \                c = elem.node;\n\
      \            }\n\n\
      \            n = parent;\n\
      \        }\n\n\
      \        cursor.userpos = offset;\n\
      \        cursor\n\
      \    }\n\n\
      \    pub fn iter_at_marker(&mut self, marker: ItemMarker<C>, query: \
       &<C::Item as Queryable>::Query) -> Cursor<C> where C::Item: Queryable {\n\
      \        // The marker gives us a pointer into a node. Find the item.\n\
      \        unsafe {\n\
      \            let n = marker.ptr;\n\n\
      \            let mut offset: usize = 0;\n\
      \            let mut local_index = None;\n\
      \            for (i, item) in (*n).content_slice().iter().enumerate() {\n\
      \                if let Some(item_offset) = item.contains_item(query) {\n\
      \                    offset += item_offset;\n\
      \                    local_index = Some(i);\n\
      \                    break;\n\
      \                } else {\n\
      \                    offset += C::get_usersize(item);\n\
      \                }\n\
      \            }\n\n\
      \            let local_index = local_index.expect(\"Invalid marker - \
       item not found in node\");\n\
      \            self.iter_at_node(n, offset, local_index)\n\
      \        }\n\
      \    }\n\n\
      \    // Internal fn to create a new node at the specified iterator \
       filled with\n\
      \    // the specified content. The passed cursor should point at the end \
       of the\n\
      \    // previous node. It will be updated to point to the end of the newly\n\
      \    // inserted content.\n\
      \    // unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n\
      \    unsafe fn insert_node_at<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, num_items: usize, move_cursor: bool, \
       notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       Iterator<Item=C::Item> {\n\n\
      \        // println!(\"Insert_node_at {} len {}\", contents.len(), \
       self.num_bytes);\n\
      \        // debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n\
      \        assert!(num_items <= NODE_NUM_ITEMS);\n\
      \        debug_assert!(contents.size_hint().0 >= num_items);\n\n\
      \        let new_node_ptr = Node::alloc(self.get_rng());\n\
      \        let new_node = &mut *new_node_ptr;\n\
      \        new_node.num_items = num_items as u8;\n\n\
      \        for (slot, item) in \
       new_node.items[..num_items].iter_mut().zip(contents) {\n\
      \            (slot.as_mut_ptr() as *mut C::Item).write(item); // Write \
       makes sure we don't drop the old value.\n\
      \        }\n\n\
      \        let new_userlen = \
       C::userlen_of_slice(new_node.content_slice());\n\n\
      \        let new_height = new_node.height;\n\
      \        let new_height_usize = new_height as usize;\n\n\
      \        let mut head_height = self.head.height as usize;\n\
      \        while head_height < new_height_usize {\n\
      \            // This seems weird given we're about to overwrite these \
       values\n\
      \            // below. What we're doing is retroactively setting up the \
       cursor\n\
      \            // and head pointers *as if* the height had been this high \
       all\n\
      \            // along. This way we only have to populate the higher head \
       values\n\
      \            // lazily.\n\
      \            let total_userlen = self.num_usercount;\n\
      \            let nexts = self.heads_mut();\n\
      \            nexts[head_height].skip_usersize = total_userlen;\n\
      \            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n\
      \            head_height += 1; // This is ugly.\n\
      \            self.head.height += 1;\n\
      \        }\n\n\
      \        new_node.parent = if new_height_usize == MAX_HEIGHT {\n\
      \            &self.head as *const _ as *mut _\n\
      \        } else { cursor.entries[new_height_usize].node };\n\n\
      \        for i in 0..new_height_usize {\n\
      \            let prev_skip = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \            let new_nexts = new_node.nexts_mut();\n\n\
      \            // The new node points to the successor (or null)\n\
      \            new_nexts[i] = SkipEntry {\n\
      \                node: prev_skip.node,\n\
      \                skip_usersize: new_userlen + prev_skip.skip_usersize - \
       cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // The previous node points to the new node\n\
      \            *prev_skip = SkipEntry {\n\
      \                node: new_node_ptr,\n\
      \                skip_usersize: cursor.entries[i].skip_usersize\n\
      \            };\n\n\
      \            // Move the iterator to the end of the newly inserted node.\n\
      \            if move_cursor {\n\
      \                cursor.entries[i] = SkipEntry {\n\
      \                    node: new_node_ptr,\n\
      \                    skip_usersize: new_userlen\n\
      \                };\n\
      \            }\n\
      \        }\n\n\
      \        for i in new_height_usize..head_height {\n\
      \            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += \
       new_userlen;\n\
      \            if move_cursor {\n\
      \                cursor.entries[i].skip_usersize += new_userlen;\n\
      \            }\n\
      \        }\n\n\
      \        // Update parents.\n\
      \        if new_height_usize > 1 {\n\n\
      \            let mut n = new_node_ptr;\n\
      \            let mut skip_height = 0;\n\n\
      \            loop {\n\
      \                n = (*n).nexts_mut()[skip_height].node;\n\
      \                if n.is_null() || (*n).height >= new_height { break; }\n\
      \                \n\
      \                (*n).parent = new_node_ptr;\n\
      \                skip_height = usize::max(skip_height, (*n).height as \
       usize - 1);\n\
      \            }\n\
      \        }\n\
      \        \n\
      \        self.num_items += num_items;\n\
      \        self.num_usercount += new_userlen;\n\
      \        if move_cursor {\n\
      \            cursor.userpos += new_userlen;\n\
      \            cursor.local_index = num_items;\n\
      \        }\n\n\
      \        notify(new_node.content_slice(), ItemMarker {\n\
      \            ptr: new_node_ptr,\n\
      \            _phantom: PhantomData\n\
      \        });\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    unsafe fn insert_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, contents: &mut I, notify: &mut Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        // iter specifies where to insert.\n\n\
      \        let mut e = cursor.here_ptr();\n\n\
      \        // The insertion offset into the destination node.\n\
      \        assert!(cursor.userpos <= self.num_usercount);\n\
      \        assert!(cursor.local_index <= (*e).num_items as usize);\n\n\
      \        // We might be able to insert the new data into the current \
       node, depending on\n\
      \        // how big it is.\n\
      \        let num_inserted_items = contents.len();\n\n\
      \        // Can we insert into the current node?\n\
      \        let mut insert_here = (*e).num_items as usize + \
       num_inserted_items <= NODE_NUM_ITEMS;\n\n\
      \        // Can we insert into the start of the successor node?\n\
      \        if !insert_here && cursor.local_index == (*e).num_items as \
       usize && num_inserted_items <= NODE_NUM_ITEMS {\n\
      \            // We can insert into the subsequent node if:\n\
      \            // - We can't insert into the current node\n\
      \            // - There _is_ a next node to insert into\n\
      \            // - The insert would be at the start of the next node\n\
      \            // - There's room in the next node\n\
      \            if let Some(next) = \
       (*e).first_skip_entry_mut().node.as_mut() {\n\
      \                if next.num_items as usize + num_inserted_items <= \
       NODE_NUM_ITEMS {\n\
      \                    cursor.advance_node();\n\
      \                    e = next;\n\n\
      \                    insert_here = true;\n\
      \                }\n\
      \            }\n\
      \        }\n\n\
      \        let item_idx = cursor.local_index;\n\
      \        let e_num_items = (*e).num_items as usize; // convenience.\n\n\
      \        if insert_here {\n\
      \            // println!(\"insert_here {}\", contents);\n\
      \            // First push the current items later in the array\n\
      \            let c = &mut (*e).items;\n\
      \            if item_idx < e_num_items {\n\
      \                // Can't use copy_within because Item doesn't necessarily\n\
      \                // implement Copy. Memmove the existing items.\n\
      \                ptr::copy(\n\
      \                    &c[item_idx],\n\
      \                    &mut c[item_idx + num_inserted_items],\n\
      \                    (*e).num_items as usize - item_idx);\n\
      \            }\n\n\
      \            // Then copy in the new items. Can't memcpy from an \
       iterator, but\n\
      \            // the optimizer should make this fast.\n\
      \            let dest_content_slice = &mut c[item_idx..item_idx + \
       num_inserted_items];\n\
      \            for (slot, item) in \
       dest_content_slice.iter_mut().zip(contents) {\n\
      \                // Do not drop the old items - they were only moved.\n\
      \                slot.as_mut_ptr().write(item);\n\
      \            }\n\
      \            let dest_content_slice = \
       maybeinit_slice_get_ref(dest_content_slice);\n\n\
      \            (*e).num_items += num_inserted_items as u8;\n\
      \            self.num_items += num_inserted_items;\n\
      \            let num_inserted_usercount = \
       C::userlen_of_slice(dest_content_slice);\n\
      \            self.num_usercount += num_inserted_usercount;\n\n\
      \            // .... aaaand update all the offset amounts.\n\
      \            cursor.update_offsets(self.head.height as usize, \
       num_inserted_usercount as isize);\n\n\
      \            // Usually the cursor will be discarded after one change, \
       but for\n\
      \            // consistency of compound edits we'll update the cursor to \
       point to\n\
      \            // the end of the new content.\n\
      \            for entry in cursor.entries[0..self.head.height as \
       usize].iter_mut() {\n\
      \                entry.skip_usersize += num_inserted_usercount;\n\
      \            }\n\
      \            cursor.userpos += num_inserted_usercount;\n\
      \            cursor.local_index += num_inserted_items;\n\n\
      \            notify(dest_content_slice, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData\n\
      \            });\n\
      \        } else {\n\
      \            // There isn't room. We'll need to add at least one new \
       node to the\n\
      \            // list. We could be a bit more careful here and copy as \
       much as\n\
      \            // possible into the current node - that would decrease the \
       number\n\
      \            // of new nodes in some cases, but I don't think the \
       performance\n\
      \            // difference will be large enough to justify the \
       complexity.\n\n\
      \            // If we're not at the end of the current node, we'll need \
       to remove\n\
      \            // the end of the current node's data and reinsert it later.\n\
      \            let num_end_items = e_num_items - item_idx;\n\n\
      \            let (end_items, _end_usercount) = if num_end_items > 0 {\n\
      \                // We'll mark the items as deleted from the node, while \
       leaving\n\
      \                // the data itself there for now to avoid a copy.\n\n\
      \                // Note that if we wanted to, it would also be correct \
       (and\n\
      \                // slightly more space efficient) to pack some of the new\n\
      \                // string's characters into this node after trimming it.\n\
      \                let end_items = &(*e).items[item_idx..e_num_items];\n\
      \                (*e).num_items = item_idx as u8;\n\
      \                let end_usercount = (*e).get_userlen() - \
       cursor.entries[0].skip_usersize;\n\n\
      \                cursor.update_offsets(self.head.height as usize, \
       -(end_usercount as isize));\n\n\
      \                // We need to trim the size off because we'll add the \
       characters\n\
      \                // back with insert_node_at.\n\
      \                self.num_usercount -= end_usercount;\n\
      \                self.num_items -= num_end_items;\n\n\
      \                (Some(end_items), end_usercount)\n\
      \            } else {\n\
      \                (None, 0)\n\
      \            };\n\n\
      \            // Now we insert new nodes containing the new character \
       data. The\n\
      \            // data is broken into pieces with a maximum size of \
       NODE_NUM_ITEMS.\n\
      \            // As further optimization, we could try and fit the last \
       piece into\n\
      \            // the start of the subsequent node.\n\
      \            let mut items_remaining = num_inserted_items;\n\
      \            while items_remaining > 0 {\n\
      \                let insert_here = usize::min(items_remaining, \
       NODE_NUM_ITEMS);\n\
      \                self.insert_node_at(cursor, contents, insert_here, \
       true, notify);\n\
      \                items_remaining -= insert_here;\n\
      \            }\n\n\
      \            // TODO: Consider recursively calling insert_at_iter() here \
       instead\n\
      \            // of making a whole new node for the remaining content.\n\
      \            if let Some(end_items) = end_items {\n\
      \                // Passing false to indicate we don't want the cursor \
       updated\n\
      \                // after this - it should remain at the end of the newly\n\
      \                // inserted content, which is *before* this end bit.\n\
      \                self.insert_node_at(cursor, &mut \
       UninitOwnedIter::<C>::from_slice(end_items), end_items.len(), false, \
       notify);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, \
       contents: &[C::Item]) {\n\
      \    //     self.insert_at_iter_and_notify(cursor, contents, \
       Self::no_notify);\n\
      \    // }\n\n\
      \    /// Interestingly unlike the original, here we only care about \
       specifying\n\
      \    /// the number of removed items by counting them. We do not use \
       usersize in\n\
      \    /// the deleted item count.\n\
      \    ///\n\
      \    /// If the deleted content occurs at the start of a node, the \
       cursor passed\n\
      \    /// here must point to the end of the previous node, not the start \
       of the\n\
      \    /// current node.\n\
      \    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut \
       num_deleted_items: usize) {\n\
      \        if num_deleted_items == 0 { return; }\n\n\
      \        let mut item_idx = cursor.local_index;\n\
      \        let mut e = cursor.here_ptr();\n\
      \        while num_deleted_items > 0 {\n\
      \            // self.print();\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \            if item_idx == (*e).num_items as usize {\n\
      \                let entry = (*e).first_skip_entry();\n\
      \                // End of current node. Skip to the start of the next \
       one. We're\n\
      \                // intentionally not updating the iterator because if \
       we delete\n\
      \                // a whole node we need the iterator to point to the \
       previous\n\
      \                // element. And if we only delete here, the iterator \
       doesn't\n\
      \                // need to be moved.\n\
      \                e = entry.node;\n\
      \                if e.is_null() { panic!(\"Cannot delete past the end of \
       the list\"); }\n\
      \                item_idx = 0;\n\
      \            }\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let removed_here = min(num_deleted_items, e_num_items - \
       item_idx);\n\
      \            \n\
      \            let height = (*e).height as usize;\n\
      \            let removed_userlen;\n\n\
      \            if removed_here < e_num_items || e as *const _ == \
       &self.head as *const _ {\n\
      \                // Just trim the node down.\n\
      \                let trailing_items = e_num_items - item_idx - \
       removed_here;\n\
      \                \n\
      \                let c = &mut (*e).items;\n\
      \                removed_userlen = \
       C::userlen_of_slice(maybeinit_slice_get_ref(&c[item_idx..item_idx + \
       removed_here]));\n\
      \                if trailing_items > 0 {\n\
      \                    ptr::copy(\n\
      \                        &c[item_idx + removed_here],\n\
      \                        &mut c[item_idx],\n\
      \                        trailing_items);\n\
      \                }\n\n\
      \                (*e).num_items -= removed_here as u8;\n\
      \                self.num_items -= removed_here;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                for s in (*e).nexts_mut() {\n\
      \                    s.skip_usersize -= removed_userlen;\n\
      \                }\n\
      \            } else {\n\
      \                // Remove the node from the skip list entirely. e \
       should be the\n\
      \                // next node after the position of the iterator.\n\
      \                assert_ne!(cursor.here_ptr(), e);\n\n\
      \                removed_userlen = (*e).get_userlen();\n\
      \                let next = (*e).first_skip_entry().node;\n\n\
      \                // println!(\"removing {:?} contents {:?} height {}\", \
       e, (*e).content_slice(), height);\n\n\
      \                for i in 0..height {\n\
      \                    let s = &mut \
       (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                    s.node = (*e).nexts_mut()[i].node;\n\
      \                    s.skip_usersize += (*e).nexts()[i].skip_usersize - \
       removed_userlen;\n\
      \                }\n\n\
      \                self.num_items -= (*e).num_items as usize;\n\
      \                self.num_usercount -= removed_userlen;\n\n\
      \                // Update parents.\n\
      \                if height > 1 {\n\
      \                    let mut n = e;\n\
      \                    // let new_parent = cursor.entries[height - \
       1].node;\n\n\
      \                    // If you imagine this node as a big building, we \
       need to\n\
      \                    // update the parent of all the nodes we cast a \
       shadow over.\n\
      \                    // So, if our height is 3 and the next nodes have \
       heights 1\n\
      \                    // and 2, they both need new parents.\n\
      \                    let mut parent_height = 1;\n\
      \                    let cursor_node = cursor.here_ptr();\n\
      \                    let cursor_node_height = (*cursor_node).height as \
       usize;\n\
      \                    let mut new_parent = if height >= \
       cursor_node_height {\n\
      \                        cursor.entries[parent_height].node\n\
      \                    } else {\n\
      \                        cursor_node\n\
      \                    };\n\n\
      \                    loop {\n\
      \                        n = (*n).nexts_mut()[parent_height - 1].node;\n\
      \                        if n.is_null() || (*n).height >= height as u8 { \
       break; }\n\
      \                        let n_height = (*n).height as usize;\n\
      \                        \n\
      \                        assert_eq!((*n).parent, e);\n\
      \                        assert!(n_height >= parent_height - 1);\n\n\
      \                        if n_height > parent_height {\n\
      \                            parent_height = n_height;\n\
      \                            if n_height >= cursor_node_height {\n\
      \                                new_parent = \
       cursor.entries[parent_height].node\n\
      \                            }\n\
      \                        }\n\
      \                        \n\
      \                        (*n).parent = new_parent;\n\
      \                    }\n\
      \                }\n\n\
      \                Node::free(e);\n\
      \                e = next;\n\
      \            }\n\n\
      \            for i in height..self.head.height as usize {\n\
      \                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n\
      \                s.skip_usersize -= removed_userlen;\n\
      \            }\n\n\
      \            num_deleted_items -= removed_here;\n\n\
      \            // if cfg!(debug_assertions) { self.check(); }\n\
      \        }\n\
      \    }\n\n\n\
      \    unsafe fn replace_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, mut removed_items: usize, inserted_content: &mut I, mut \
       notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        if removed_items == 0 && inserted_content.len() == 0 { return; \
       }\n\n\
      \        // Replace as many items from removed_items as we can with \
       inserted_content.\n\
      \        let mut replaced_items = min(removed_items, \
       inserted_content.len());\n\
      \        removed_items -= replaced_items;\n\n\
      \        while replaced_items > 0 {\n\
      \            debug_assert!(inserted_content.len() >= replaced_items);\n\
      \            let mut e = cursor.here_ptr();\n\
      \            if cursor.local_index == (*e).num_items as usize {\n\
      \                // Move to the next item.\n\
      \                e = cursor.advance_node();\n\
      \                if e.is_null() { panic!(\"Cannot replace past the end \
       of the list\"); }\n\
      \            }\n\n\
      \            let index = cursor.local_index;\n\n\
      \            let e_num_items = (*e).num_items as usize;\n\
      \            let replaced_items_here = min(replaced_items, e_num_items - \
       index);\n\n\
      \            let dest = &mut (*e).items[index..index + \
       replaced_items_here];\n\
      \            let old_usersize = \
       C::userlen_of_slice(maybeinit_slice_get_ref(dest));\n\n\
      \            // Replace the items themselves. Everything else is \
       commentary.\n\
      \            // Would prefer to use zip() but it wants ownership of \
       inserted_content :/\n\
      \            for slot in dest.iter_mut() {\n\
      \                *slot.as_mut_ptr() = inserted_content.next().unwrap();\n\
      \            }\n\n\
      \            let dest = maybeinit_slice_get_ref(dest);\n\
      \            let new_usersize = C::userlen_of_slice(dest);\n\
      \            let usersize_delta = new_usersize as isize - old_usersize \
       as isize;\n\n\
      \            if usersize_delta != 0 {\n\
      \                cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \            }\n\
      \            // I hate this.\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\n\
      \            replaced_items -= replaced_items_here;\n\
      \            // We'll hop to the next Node at the start of the next loop\n\
      \            // iteration if needed.\n\
      \            cursor.local_index += replaced_items_here;\n\n\
      \            for i in 0..self.head.height as usize {\n\
      \                cursor.entries[i].skip_usersize += new_usersize;\n\
      \            }\n\
      \            cursor.userpos += new_usersize;\n\n\
      \            notify(dest, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });\n\
      \        }\n\n\
      \        // Ok now one of two things must be true. Either we've run out of\n\
      \        // items to remove, or we've run out of items to insert.\n\
      \        if inserted_content.len() > 0 {\n\
      \            // Insert!\n\
      \            debug_assert!(removed_items == 0);\n\
      \            self.insert_at_iter(cursor, inserted_content, &mut notify);\n\
      \        } else if removed_items > 0 {\n\
      \            self.del_at_iter(cursor, removed_items);\n\
      \        }\n\
      \    }\n\n\
      \    fn dbg_check_cursor_at(&self, cursor: &Cursor<C>, userpos: usize, \
       plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n\
      \    }\n\n\
      \    fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}\n\n\
      \    pub fn replace_at<I>(&mut self, mut start_userpos: usize, \
       removed_items: usize, mut inserted_content: I) where I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        let num_inserted_items = inserted_content.len();\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, &mut \
       inserted_content, Self::no_notify); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(start_userpos);\n\
      \            c2.advance_by_items(num_inserted_items, self.head.height);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       replace\"); }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn replace_at_slice(&mut self, start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \        self.replace_at(start_userpos, removed_items, \
       inserted_content.iter().copied());\n\
      \    }\n\n\
      \    pub fn insert_at<I>(&mut self, mut userpos: usize, mut contents: I) \
       where I: ExactSizeIterator<Item=C::Item> {\n\
      \        if contents.len() == 0 { return; }\n\
      \        let num_inserted_items = contents.len();\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        unsafe {\n\
      \            if offset == 0 {\n\
      \                self.insert_at_iter(&mut cursor, &mut contents, &mut \
       Self::no_notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       num_inserted_items);\n\
      \            } else {\n\
      \                let current_item = cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                cursor.move_to_item_start(self.head.height, offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.replace_at_iter(&mut cursor, 1, &mut \
       iter::once(start), &mut Self::no_notify);\n\
      \                self.insert_at_iter(&mut cursor, &mut contents, &mut \
       Self::no_notify);\n\n\
      \                // There's no clean way to keep the cursor steady for \
       the final\n\
      \                // insert. We'll just make sure the cursor is in the \
       right\n\
      \                // position before that call for now.\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       num_inserted_items);\n\n\
      \                self.insert_at_iter(&mut cursor, &mut iter::once(end), \
       &mut Self::no_notify);\n\
      \            }\n\
      \        }\n\n\
      \    }\n\n\
      \    pub fn insert_at_slice(&mut self, userpos: usize, contents: \
       &[C::Item]) where C::Item: Copy {\n\
      \        self.insert_at(userpos, contents.iter().copied())\n" );
    (9755, 1, "");
    (9754, 1, "");
    (9758, 1, "");
    (9758, 0, ".");
    (9759, 0, "w");
    (9760, 0, "r");
    (9761, 0, "i");
    (9762, 0, "t");
    (9763, 0, "e");
    (9764, 0, "(");
    (9765, 1, "");
    (9765, 1, "");
    (9765, 1, "");
    (9960, 1, "");
    (9960, 0, ")");
    (9961, 0, ";");
    (10026, 1, "");
    (10030, 0, ".");
    (10031, 0, "w");
    (10032, 0, "r");
    (10033, 0, "i");
    (10034, 0, "t");
    (10035, 0, "e");
    (10036, 0, "(");
    (10037, 1, "");
    (10037, 1, "");
    (10037, 1, "");
    (10058, 0, ")");
    (11675, 1, "");
    (11680, 1, "");
    (11679, 1, "");
    (11679, 0, ".");
    (11680, 0, "w");
    (11681, 0, "r");
    (11682, 0, "i");
    (11683, 0, "t");
    (11684, 0, "e");
    (11685, 0, "(");
    (11686, 1, "");
    (11741, 0, ")");
    (13907, 1, "");
    (13911, 0, ".");
    (13912, 0, "w");
    (13913, 0, "r");
    (13911, 3, "");
    (13907, 0, "*");
    (10026, 0, "*");
    (10031, 6, " ");
    (10032, 0, "=");
    (10033, 0, " ");
    (10034, 1, "");
    (10055, 1, "");
    (11671, 11, "*");
    (11672, 0, "s");
    (11673, 0, "e");
    (11674, 0, "l");
    (11675, 0, "f");
    (11676, 0, " ");
    (11677, 0, "=");
    (11678, 0, " ");
    (11734, 1, "");
    (1247, 2, "2");
    (1247, 1, "10");
    (1638, 1, "2");
    (1638, 1, "5");
    (44190, 0, "\n                ");
    (44207, 0, "\n                ");
    (44191, 16, "");
    (44192, 16, "");
    (44191, 0, "\n                ");
    (44208, 0, "f");
    (44209, 0, "o");
    (44210, 0, "r");
    (44211, 0, " ");
    (44212, 0, "&");
    (44213, 0, "m");
    (44214, 0, "u");
    (44215, 0, "t");
    (44216, 0, " ");
    (44217, 0, "i");
    (44218, 0, "t");
    (44219, 0, "e");
    (44220, 0, "m");
    (44221, 0, " ");
    (44222, 0, "i");
    (44223, 0, "n");
    (44224, 0, " ");
    (44225, 0, "&c[item_idx..item_idx + removed_here])");
    (44262, 1, "");
    (44262, 0, " ");
    (44263, 0, "{");
    (44264, 0, "\n                    ");
    (44265, 20, "                }");
    (44226, 0, "m");
    (44227, 0, "u");
    (44228, 0, "t");
    (44229, 0, " ");
    (44213, 8, "");
    (44212, 1, "");
    (44211, 1, "");
    (44211, 0, "i");
    (44211, 1, "");
    (44211, 0, " ");
    (44212, 0, "i");
    (44213, 0, "t");
    (44214, 0, "e");
    (44215, 0, "m");
    (44263, 0, "\n                    ");
    (44284, 0, "i");
    (44285, 0, "t");
    (44286, 0, "e");
    (44287, 0, "m");
    (44288, 0, ".");
    (44289, 0, "a");
    (44290, 0, "s");
    (44291, 0, "_");
    (44289, 3, "as_mut_ptr");
    (44299, 0, "(");
    (44300, 0, ")");
    (44284, 0, " ");
    (44284, 0, "m");
    (44285, 0, "e");
    (44286, 0, "m");
    (44287, 0, ":");
    (44288, 0, ":");
    (44289, 0, "d");
    (44290, 0, "r");
    (44291, 0, "o");
    (44292, 0, "p");
    (44292, 1, "");
    (44291, 1, "");
    (44290, 1, "");
    (44289, 1, "");
    (44288, 1, "");
    (44287, 1, "");
    (44286, 1, "");
    (44285, 1, "");
    (44284, 1, "");
    (44284, 0, "p");
    (44285, 0, "t");
    (44286, 0, "r");
    (44287, 0, ":");
    (44288, 0, ":");
    (44289, 0, "d");
    (44290, 0, "r");
    (44291, 0, "p");
    (44289, 3, "drop_in_place(to_drop: *mut T)");
    (44303, 15, "");
    (44303, 1, "");
    (44303, 1, "");
    (44320, 0, ")");
    (44321, 0, ";");
    (44191, 0, "\n                ");
    (44208, 0, "i");
    (44209, 0, "f");
    (44210, 0, " ");
    (44211, 0, "C");
    (44212, 0, ":");
    (44213, 0, ":");
    (44213, 1, "");
    (44212, 1, "");
    (44211, 1, "");
    (44211, 0, "n");
    (44212, 0, "e");
    (44213, 0, "e");
    (44213, 1, "");
    (44212, 1, "");
    (44211, 1, "");
    (44211, 0, "p");
    (44212, 0, "t");
    (44213, 0, "r");
    (44214, 0, ":");
    (44215, 0, ":");
    (44216, 0, "n");
    (44217, 0, "e");
    (44218, 0, "e");
    (44211, 8, "m");
    (44212, 0, "e");
    (44213, 0, "m");
    (44214, 0, ":");
    (44215, 0, ":");
    (44216, 0, "n");
    (44217, 0, "e");
    (44218, 0, "e");
    (44216, 3, "needs_drop()");
    (44226, 0, ":");
    (44227, 0, ":");
    (44228, 0, "<");
    (44229, 0, "T");
    (44230, 0, ">");
    (44230, 1, "");
    (44229, 1, "");
    (44229, 0, "C");
    (44230, 0, ":");
    (44231, 0, ":");
    (44232, 0, "I");
    (44233, 0, "t");
    (44234, 0, "e");
    (44235, 0, "m");
    (44236, 0, ">");
    (44239, 0, " ");
    (44240, 0, "{");
    (44373, 16, "                    ");
    (44314, 20, "                        ");
    (44242, 16, "                    ");
    (44402, 0, "\n                    ");
    (44403, 20, "                }");
    (11154, 0, "\n        ");
    (11163, 0, "f");
    (11164, 0, "o");
    (11165, 0, "r");
    (11166, 0, " ");
    (11167, 0, "i");
    (11168, 0, "t");
    (11169, 0, "e");
    (11170, 0, "m");
    (11171, 0, " ");
    (11172, 0, "i");
    (11173, 0, "n");
    (11174, 0, " ");
    (11175, 0, "&");
    (11176, 0, "m");
    (11177, 0, "u");
    (11178, 0, "t");
    (11179, 0, " ");
    (11180, 0, "s");
    (11181, 0, "e");
    (11182, 0, "l");
    (11183, 0, "f");
    (11184, 0, ".");
    (11185, 0, "i");
    (11186, 0, "t");
    (11187, 0, "e");
    (11188, 0, "m");
    (11185, 4, "items");
    (11190, 0, "[");
    (11191, 0, "0");
    (11192, 0, ".");
    (11193, 0, ".");
    (11194, 0, "s");
    (11195, 0, "e");
    (11196, 0, "l");
    (11197, 0, "f");
    (11198, 0, ".");
    (11199, 0, "n");
    (11200, 0, "u");
    (11201, 0, "m");
    (11202, 0, "_");
    (11203, 0, "i");
    (11204, 0, "t");
    (11205, 0, "e");
    (11206, 0, "m");
    (11207, 0, "s");
    (11208, 0, " ");
    (11209, 0, "a");
    (11210, 0, "s");
    (11211, 0, " ");
    (11212, 0, "u");
    (11213, 0, "s");
    (11214, 0, "i");
    (11215, 0, "z");
    (11216, 0, "e");
    (11217, 0, "]");
    (11218, 0, " ");
    (11219, 0, "{");
    (11221, 45, "");
    (11220, 1, "");
    ( 11338,
      0,
      "            unsafe { ptr::drop_in_place(self.items[i].as_mut_ptr()); }\n"
    );
    (11350, 0, "// ");
    (11452, 13, "i");
    (11453, 0, "t");
    (11454, 0, "e");
    (11455, 0, "m");
    (11338, 73, "");
    (11337, 1, "");
    (55759, 20, "");
    (20792, 0, "\n    ");
    (20797, 0, "\n    ");
    (20793, 4, "");
    (20798, 0, "p");
    (20799, 0, "u");
    (20800, 0, "b");
    (20801, 0, " ");
    (20802, 0, "f");
    (20803, 0, "n");
    (20804, 0, " ");
    (20805, 0, "n");
    (20806, 0, "e");
    (20807, 0, "w");
    (20808, 0, "_");
    (20809, 0, "f");
    (20810, 0, "r");
    (20811, 0, "o");
    (20812, 0, "m");
    (20813, 0, "_");
    (20814, 0, "i");
    (20815, 0, "t");
    (20816, 0, "e");
    (20817, 0, "r");
    (20818, 0, "(");
    (20819, 0, "&");
    (20819, 1, "");
    (20818, 0, "<");
    (20819, 0, "I");
    (20820, 0, ">");
    (20822, 0, "i");
    (20823, 0, "t");
    (20824, 0, "e");
    (20825, 0, "r");
    (20826, 0, ":");
    (20827, 0, " ");
    (20828, 0, "I");
    (20829, 0, ")");
    (20819, 1, "");
    (20819, 0, "I: ExactSizeIterator<Item=C::Item> ");
    (20853, 1, "");
    (20863, 0, " ");
    (20864, 0, "{");
    (20865, 0, "\n        ");
    (20874, 0, "\n        ");
    (20866, 8, "");
    (20867, 8, "    }");
    (20945, 85, "");
    ( 20866,
      0,
      "        let mut rope = Self::new();\n\
      \        rope.insert_at_slice(0, s);\n\
      \        rope\n" );
    (20950, 1, "");
    (20929, 1, "");
    (20928, 1, "");
    (20927, 1, "");
    (20926, 1, "");
    (20925, 1, "");
    (20924, 1, "");
    (20928, 1, "");
    (20928, 0, "i");
    (20929, 0, "t");
    (20930, 0, "e");
    (20931, 0, "r");
    (20863, 0, " ");
    (20864, 0, "-");
    (20865, 0, ">");
    (20866, 0, " ");
    (20867, 0, "S");
    (20868, 0, "e");
    (20869, 0, "l");
    (20870, 0, "f");
    (21033, 0, "\n        ");
    (21042, 0, "s");
    (21043, 0, "e");
    (21044, 0, "l");
    (21045, 0, "f");
    (21042, 4, "S");
    (21043, 0, "e");
    (21044, 0, "l");
    (21045, 0, "f");
    (21046, 0, ":");
    (21047, 0, ":");
    (21048, 0, "n");
    (21049, 0, "e");
    (21050, 0, "w");
    (21051, 0, "_");
    (21048, 4, "new_from_iter(iter: I)");
    (21062, 7, "s");
    (21063, 0, ".");
    (21064, 0, "i");
    (21065, 0, "t");
    (21066, 0, "e");
    (21067, 0, "r");
    (21068, 0, "(");
    (21069, 1, ")");
    (21070, 0, ".");
    (21071, 0, "c");
    (21072, 0, "o");
    (21073, 0, "p");
    (21074, 0, "i");
    (21075, 0, "e");
    (21076, 0, "d");
    (21077, 0, "(");
    (21078, 0, ")");
    (21079, 0, ")");
    (21080, 0, ";");
    (21080, 1, "");
    (55969, 1, "");
    (55968, 1, "");
    (55967, 1, "");
    (55966, 1, "");
    (55965, 1, "");
    (55965, 0, "i");
    (55966, 0, "t");
    (55967, 0, "e");
    (55968, 0, "r");
    (55970, 12, "");
    (55970, 0, "s");
    (55971, 0, ".");
    (55972, 0, "i");
    (55973, 0, "n");
    (55974, 0, "t");
    (55975, 0, "o");
    (55972, 4, "into_iter()");
    (55791, 43, "");
    (55790, 1, "");
    ( 55791,
      0,
      "impl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> {\n\
      \    fn from(s: Vec<C::Item>) -> SkipList<C> {\n\
      \        SkipList::new_from_iter(s.into_iter())\n\
      \    }\n\
       }\n" );
    (55948, 0, "\n");
    (55968, 0, ",");
    (55969, 0, " ");
    ( 55970,
      0,
      "        let mut rope = Self::new();\n\
      \        rope.insert_at_slice(0, s);\n\
      \        rope\n" );
    (56042, 8, "");
    (56006, 8, "");
    (56034, 0, "        ");
    (56006, 0, "        ");
    (55970, 85, "");
    (55970, 0, "I");
    (55971, 0, ":");
    (55972, 0, " ");
    (55973, 0, "E");
    (55974, 0, "x");
    (55975, 0, "a");
    (55973, 3, "ExactSizeIterator");
    (55990, 0, "<");
    (55991, 0, "C");
    (55992, 0, ":");
    (55993, 0, ":");
    (55994, 0, "I");
    (55995, 0, "t");
    (55996, 0, "e");
    (55997, 0, "m");
    (55998, 0, ">");
    (55971, 28, "");
    (55978, 12, "I");
    (55997, 0, " ");
    (55998, 0, "w");
    (55998, 1, "");
    (55997, 1, "");
    (55997, 0, "w");
    (55998, 0, "h");
    (55999, 0, "e");
    (56000, 0, "r");
    (56001, 0, "e");
    (56002, 0, " ");
    (56003, 0, "I");
    (56004, 0, ":");
    (56005, 0, " ");
    (56006, 0, "E");
    (56007, 0, "x");
    (56008, 0, "a");
    (56006, 3, "ExactSizeIterator");
    (56023, 0, "<");
    (56024, 0, "C");
    (56025, 0, ":");
    (56026, 0, ":");
    (56027, 0, "I");
    (56028, 0, "t");
    (56029, 0, "e");
    (56030, 0, "m");
    (56031, 0, ">");
    (56032, 0, " ");
    (56024, 0, "I");
    (56025, 0, "t");
    (56026, 0, "e");
    (56027, 0, "m");
    (56028, 0, "=");
    (55788, 0, "// ");
    (55782, 0, "// ");
    (55746, 0, "// ");
    (55702, 0, "// ");
    (55627, 0, "// ");
    (55962, 0, "// ");
    (55956, 0, "// ");
    (55909, 0, "// ");
    (55863, 0, "// ");
    (55806, 0, "// ");
    ( 56070,
      98,
      "//     fn from(s: Vec<C::Item>) -> SkipList<C> {\n\
       //         SkipList::new_from_iter(s.into_iter())\n\
       //     }" );
    (56169, 3, "");
    (56119, 3, "");
    (56070, 3, "");
    (56082, 15, "i");
    (56083, 0, "t");
    (56084, 0, "e");
    (56085, 0, "r");
    (56086, 0, ":");
    (56087, 0, " ");
    (56088, 0, "I");
    (56140, 13, "i");
    (56141, 0, "t");
    (56142, 0, "e");
    (56143, 0, "r");
    (55800, 3, "");
    (55791, 3, "");
    (55752, 3, "");
    (55705, 3, "");
    (55627, 3, "");
    (55788, 0, "// ");
    (55782, 0, "// ");
    (55746, 0, "// ");
    (55702, 0, "// ");
    (55627, 0, "// ");
    (55626, 352, "");
    (55625, 1, "");
    (56185, 973, "");
    (56120, 68, "");
    (56119, 1, "");
    (54767, 0, "\n    ");
    (54772, 0, "\n    ");
    (54768, 4, "");
    ( 54773,
      0,
      "    // TODO: Don't export this.\n\
      \    pub fn print(&self) {\n\
      \        println!(\"items: {}\\tuserlen: {}, height: {}\", \
       self.num_items, self.get_userlen(), self.head.height);\n\n\
      \        print!(\"HEAD:\");\n\
      \        for s in self.head.nexts() {\n\
      \            print!(\" |{} \", s.skip_usersize);\n\
      \        }\n\
      \        println!(\"\");\n\n\
      \        use std::collections::HashMap;\n\
      \        let mut ptr_to_id = HashMap::new();\n\
      \        // ptr_to_id.insert(std::ptr::null(), usize::MAX);\n\
      \        for (i, node) in self.iter().enumerate() {\n\
      \            print!(\"{}:\", i);\n\
      \            ptr_to_id.insert(node as *const _, i);\n\
      \            for s in node.nexts() {\n\
      \                print!(\" |{} \", s.skip_usersize);\n\
      \            }\n\
      \            print!(\"      : {:?}\", node.content_slice());\n\
      \            if let Some(id) = ptr_to_id.get(&(node.parent as *const _)) {\n\
      \                print!(\" (parent: {})\", id);\n\
      \            }\n\
      \            print!(\" (pointer: {:?})\", node as *const _);\n\n\
      \            println!();\n\
      \        }\n\
      \    }" );
    (55741, 4, "        ");
    (55731, 8, "            ");
    (55707, 12, "                ");
    (55706, 0, "    ");
    (55648, 12, "                ");
    (55634, 12, "                ");
    (55589, 16, "                    ");
    (55515, 12, "                ");
    (55457, 12, "                ");
    (55443, 12, "                ");
    (55393, 16, "                    ");
    (55357, 12, "                ");
    (55306, 12, "                ");
    (55276, 12, "                ");
    (55225, 8, "            ");
    (55166, 8, "            ");
    (55122, 8, "            ");
    (55083, 8, "            ");
    (55082, 0, "    ");
    (55060, 8, "            ");
    (55050, 8, "            ");
    (55004, 12, "                ");
    (54967, 8, "            ");
    (54942, 8, "            ");
    (54941, 0, "    ");
    (54831, 8, "            ");
    (54805, 4, "        ");
    (55845, 8, "    ");
    (55831, 12, "        ");
    (55803, 16, "            ");
    (55798, 4, "");
    (55736, 16, "            ");
    (55718, 16, "            ");
    (55669, 20, "                ");
    (55591, 16, "            ");
    (55529, 16, "            ");
    (55511, 16, "            ");
    (55457, 20, "                ");
    (55417, 16, "            ");
    (55362, 16, "            ");
    (55328, 16, "            ");
    (55273, 12, "        ");
    (55210, 12, "        ");
    (55162, 12, "        ");
    (55119, 12, "        ");
    (55114, 4, "");
    (55088, 12, "        ");
    (55074, 12, "        ");
    (55024, 16, "            ");
    (54983, 12, "        ");
    (54954, 12, "        ");
    (54949, 4, "");
    (54835, 12, "        ");
    (54805, 8, "    ");
    (54769, 8, "    ");
    (54824, 0, " ");
    (54825, 0, "w");
    (54826, 0, "h");
    (54827, 0, "e");
    (54828, 0, "r");
    (54829, 0, "e");
    (54830, 0, " ");
    (54831, 0, "C");
    (54832, 0, ":");
    (54833, 0, ":");
    (54834, 0, "I");
    (54835, 0, "t");
    (54836, 0, "e");
    (54837, 0, "m");
    (54838, 0, ":");
    (54839, 0, " ");
    (54840, 0, "D");
    (54841, 0, "e");
    (54842, 0, "b");
    (54843, 0, "u");
    (54844, 0, "g");
    (54840, 0, "s");
    (54841, 0, "t");
    (54842, 0, "d");
    (54843, 0, ":");
    (54844, 0, ":");
    (54845, 0, "f");
    (54846, 0, "m");
    (54847, 0, "t");
    (54848, 0, ":");
    (54849, 0, ":");
    (52176, 0, "// ");
    (52102, 0, "// ");
    (52031, 0, "// ");
    (51964, 0, "// ");
    (51928, 0, "// ");
    (51919, 0, "\n        ");
    (51928, 0, "d");
    (51929, 0, "b");
    (51930, 0, "g");
    (51931, 0, "_");
    (51928, 4, "s");
    (51929, 0, "e");
    (51930, 0, "l");
    (51931, 0, "f");
    (51932, 0, ".");
    (51933, 0, "d");
    (51934, 0, "b");
    (51935, 0, "g");
    (51936, 0, "_");
    ( 51933,
      4,
      "dbg_check_cursor_at(cursor: &Cursor<C>, userpos: usize, plus_items: \
       usize)" );
    (51953, 18, "&");
    (51954, 0, "c");
    (51955, 0, "y");
    (51956, 0, "r");
    (51957, 0, "s");
    (51958, 0, "o");
    (51958, 1, "");
    (51957, 1, "");
    (51956, 1, "");
    (51955, 1, "");
    (51955, 0, "u");
    (51956, 0, "r");
    (51957, 0, "s");
    (51958, 0, "o");
    (51959, 0, "r");
    (51962, 14, "s");
    (51963, 0, "t");
    (51964, 0, "a");
    (51965, 0, "r");
    (51966, 0, "t");
    (51967, 0, "_");
    (51968, 0, "u");
    (51969, 0, "s");
    (51970, 0, "e");
    (51971, 0, "r");
    (51972, 0, "p");
    (51973, 0, "o");
    (51974, 0, "s");
    (51977, 17, "n");
    (51978, 0, "u");
    (51979, 0, "m");
    (51980, 0, "_");
    (51981, 0, "i");
    (51982, 0, "n");
    (51983, 0, "s");
    (51984, 0, "e");
    (51985, 0, "r");
    (51986, 0, "t");
    (51987, 0, "e");
    (51988, 0, "d");
    (51989, 0, "_");
    (51990, 0, "i");
    (51991, 0, "t");
    (51992, 0, "e");
    (51993, 0, "m");
    (51994, 0, "s");
    (51996, 0, ";");
    (51998, 273, "");
    (51023, 0, "\n    ");
    (51028, 0, "\n    ");
    (51024, 4, "");
    ( 51029,
      0,
      "    unsafe fn replace_at_iter<Notify, I>(&mut self, cursor: &mut \
       Cursor<C>, mut removed_items: usize, inserted_content: &mut I, mut \
       notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n" );
    (51177, 12, "    ");
    (51025, 8, "    ");
    (51223, 36, "");
    (51177, 0, "    ");
    (51229, 0, "\n            ");
    (51230, 12, "        }");
    (51230, 8, "    ");
    (51053, 1, "");
    (51052, 1, "");
    (51051, 1, "");
    (51050, 1, "");
    (51049, 1, "");
    (51048, 1, "");
    (51047, 1, "");
    (51047, 0, "i");
    (51048, 0, "t");
    (51049, 0, "e");
    (51050, 0, "m");
    (51058, 3, "");
    (51093, 52, "");
    (51093, 0, ",");
    (51094, 0, " ");
    (51095, 0, "n");
    (51096, 0, "e");
    (51097, 0, "w");
    (51098, 0, "I");
    (51099, 0, "t");
    (51100, 0, "e");
    (51101, 0, "m");
    (51101, 1, "");
    (51100, 1, "");
    (51099, 1, "");
    (51098, 1, "");
    (51098, 0, "_");
    (51099, 0, "i");
    (51100, 0, "t");
    (51101, 0, "e");
    (51102, 0, "m");
    (51103, 0, ":");
    (51104, 0, " ");
    (51105, 0, "C");
    (51106, 0, ":");
    (51107, 0, ":");
    (51108, 0, "I");
    (51109, 0, "t");
    (51110, 0, "e");
    (51111, 0, "m");
    (51190, 0, "\n            ");
    (51191, 12, "        ");
    ( 51025,
      165,
      "    unsafe fn replace_item<Notify>(&mut self, cursor: &mut Cursor<C>, \
       new_item: C::Item, mut notify: Notify) where Notify: FnMut(&[C::Item], \
       ItemMarker<C>) {" );
    ( 51025,
      157,
      "    unsafe fn replace_item<Notify>(&mut self, cursor: &mut Cursor<C>, \
       new_item: C::Item, mut notify: Notify)\n\
      \        where Notify: FnMut(&[C::Item], ItemMarker<C>) {" );
    (51134, 8, "    ");
    (51186, 0, "\n        ");
    (51195, 0, "s");
    (51196, 0, "e");
    (51197, 0, "l");
    (51198, 0, "f");
    (51199, 0, ".");
    (51200, 0, "r");
    (51201, 0, "e");
    (51202, 0, "p");
    (51203, 0, "l");
    (51204, 0, "a");
    ( 51200,
      5,
      "replace_at_iter(cursor: &mut Cursor<C>, mut removed_items: usize, \
       inserted_content: &mut I, mut notify: Notify)" );
    (51216, 22, "c");
    (51217, 0, "u");
    (51218, 0, "r");
    (51219, 0, "s");
    (51220, 0, "o");
    (51221, 0, "r");
    (51224, 24, "1");
    (51227, 24, "o");
    (51228, 0, "n");
    (51229, 0, "c");
    (51230, 0, "e");
    (51227, 4, "i");
    (51228, 0, "t");
    (51229, 0, "e");
    (51230, 0, "r");
    (51231, 0, ":");
    (51232, 0, ":");
    (51233, 0, "o");
    (51234, 0, "n");
    (51235, 0, "c");
    (51236, 0, "e");
    (51237, 0, "(");
    (51238, 0, "n");
    (51239, 0, "e");
    (51240, 0, "w");
    (51241, 0, "_");
    (51242, 0, "i");
    (51243, 0, "t");
    (51244, 0, "e");
    (51245, 0, "m");
    (51246, 0, ")");
    (51249, 18, "n");
    (51250, 0, "o");
    (51251, 0, "t");
    (51252, 0, "i");
    (51253, 0, "f");
    (51254, 0, "y");
    (51256, 0, ";");
    (51227, 0, "&");
    (51228, 0, "m");
    (51229, 0, "u");
    (51230, 0, "t");
    (51231, 0, " ");
    (51267, 4, "");
    (51263, 4, "");
    (51262, 1, "");
    (51186, 0, "\n        ");
    (51195, 0, "/");
    (51196, 0, "/");
    (51197, 0, " ");
    (51198, 0, "T");
    (51199, 0, "h");
    (51200, 0, "i");
    (51201, 0, "s");
    (51202, 0, " ");
    (51203, 0, "c");
    (51204, 0, "o");
    (51205, 0, "u");
    (51206, 0, "l");
    (51207, 0, "d");
    (51208, 0, " ");
    (51209, 0, "b");
    (51210, 0, "e");
    (51211, 0, " ");
    (51212, 0, "o");
    (51213, 0, "p");
    (51214, 0, "t");
    (51215, 0, "i");
    (51216, 0, "m");
    (51217, 0, "i");
    (51218, 0, "z");
    (51219, 0, "e");
    (51220, 0, "d");
    (51221, 0, ".");
    (51208, 0, " ");
    (51209, 0, "e");
    (51210, 0, "a");
    (51211, 0, "s");
    (51212, 0, "i");
    (51213, 0, "l");
    (51214, 0, "y");
    (51114, 4, "");
    (51308, 1, "");
    (53479, 0, "// ");
    (53462, 0, "\n                ");
    (53479, 0, "s");
    (53480, 0, "e");
    (53481, 0, "l");
    (53482, 0, "f");
    (53483, 0, ".");
    (53484, 0, "r");
    (53485, 0, "e");
    (53486, 0, "p");
    (53487, 0, "l");
    (53488, 0, "a");
    ( 53484,
      5,
      "replace_item(cursor: &mut Cursor<C>, new_item: C::Item, notify: Notify)"
    );
    (53497, 22, "&");
    (53498, 0, "m");
    (53499, 0, "u");
    (53500, 0, "t");
    (53501, 0, " ");
    (53502, 0, "c");
    (53503, 0, "u");
    (53504, 0, "r");
    (53505, 0, "s");
    (53506, 0, "o");
    (53507, 0, "r");
    (53508, 0, ",");
    (53509, 0, " ");
    (53509, 1, "");
    (53508, 1, "");
    (53510, 17, "s");
    (53511, 0, "t");
    (53512, 0, "a");
    (53513, 0, "r");
    (53514, 0, "t");
    (53516, 15, "&mut Self::no_notify");
    (53516, 0, " ");
    (53538, 0, ";");
    (53540, 103, "");
    (53539, 0, "\n                ");
    (53556, 0, "\n                ");
    (53540, 16, "");
    (53557, 0, "/");
    (53558, 0, "/");
    (53559, 0, " ");
    (53560, 0, "T");
    (53561, 0, "O");
    (53562, 0, "D");
    (53563, 0, "O");
    (53564, 0, ":");
    (53565, 0, " ");
    (53566, 0, "C");
    (53567, 0, "o");
    (53568, 0, "n");
    (53569, 0, "s");
    (53570, 0, "i");
    (53571, 0, "d");
    (53572, 0, "e");
    (53573, 0, "r");
    (53574, 0, " ");
    (53575, 0, "f");
    (53576, 0, "u");
    (53577, 0, "s");
    (53578, 0, "i");
    (53579, 0, "n");
    (53580, 0, "g");
    (53575, 6, "c");
    (53576, 0, "o");
    (53577, 0, "n");
    (53578, 0, "c");
    (53579, 0, "a");
    (53580, 0, "t");
    (53581, 0, "e");
    (53582, 0, "n");
    (53583, 0, "a");
    (53584, 0, "t");
    (53585, 0, "i");
    (53586, 0, "n");
    (53587, 0, "g");
    (53588, 0, " ");
    (53589, 0, "e");
    (53590, 0, "n");
    (53591, 0, "d");
    (53592, 0, " ");
    (53593, 0, "o");
    (53594, 0, "n");
    (53594, 1, "");
    (53593, 1, "");
    (53593, 0, "i");
    (53594, 0, "n");
    (53595, 0, "t");
    (53596, 0, "o");
    (53597, 0, " ");
    (53598, 0, "c");
    (53599, 0, "o");
    (53600, 0, "n");
    (53601, 0, "t");
    (53602, 0, "e");
    (53603, 0, "n");
    (53604, 0, "t");
    (53605, 0, "s");
    (53606, 0, ".");
    (53606, 1, "");
    (53606, 0, " ");
    (53606, 1, "");
    (53606, 0, " ");
    (53607, 0, "t");
    (53608, 0, "h");
    (53609, 0, "e");
    (53610, 0, "n");
    (53611, 0, " ");
    (53612, 0, "j");
    (53613, 0, "u");
    (53614, 0, "s");
    (53615, 0, "t");
    (53616, 0, " ");
    (53617, 0, "c");
    (53618, 0, "a");
    (53619, 0, "l");
    (53620, 0, "l");
    (53621, 0, " ");
    (53622, 0, "i");
    (53623, 0, "n");
    (53624, 0, "s");
    (53625, 0, "e");
    (53626, 0, "r");
    (53627, 0, "t");
    (53628, 0, "_");
    (53629, 0, "a");
    (53630, 0, "t");
    (53631, 0, "_");
    (53632, 0, "i");
    (53633, 0, "t");
    (53634, 0, "e");
    (53635, 0, "r");
    (53636, 0, " ");
    (53637, 0, "o");
    (53638, 0, "n");
    (53639, 0, "c");
    (53640, 0, "e");
    (53641, 0, ".");
    ( 53541,
      101,
      "                // TODO: Consider concatenating end into contents then \
       just call\n\
      \                // insert_at_iter once." );
    (53749, 209, "");
    (52518, 0, "\n    ");
    (52523, 0, "\n    ");
    (52519, 4, "");
    (52524, 0, "p");
    (52525, 0, "u");
    (52526, 0, "b");
    (52527, 0, " ");
    (52528, 0, "f");
    (52529, 0, "n");
    (52530, 0, " ");
    (52531, 0, "m");
    (52532, 0, "o");
    (52532, 1, "");
    (52532, 0, "o");
    (52533, 0, "d");
    (52534, 0, "i");
    (52535, 0, "f");
    (52536, 0, "y");
    (52537, 0, "_");
    (52538, 0, "a");
    (52539, 0, "t");
    (52540, 0, "(");
    (52541, 0, "&");
    (52542, 0, "m");
    (52543, 0, "u");
    (52544, 0, "t");
    (52545, 0, " ");
    (52546, 0, "s");
    (52547, 0, "e");
    (52548, 0, "l");
    (52549, 0, "f");
    (52550, 0, ",");
    (52551, 0, " ");
    (52552, 0, "m");
    (52553, 0, "o");
    (52554, 0, "d");
    (52555, 0, "i");
    (52556, 0, "f");
    (52557, 0, "y");
    (52558, 0, "_");
    (52559, 0, "f");
    (52560, 0, "n");
    (52561, 0, ":");
    (52562, 0, " ");
    (52563, 0, "F");
    (52540, 0, "<");
    (52541, 0, "F");
    (52542, 0, ">");
    (52554, 0, " ");
    (52555, 0, "u");
    (52556, 0, "s");
    (52557, 0, "e");
    (52558, 0, "r");
    (52559, 0, "s");
    (52560, 0, "i");
    (52560, 1, "");
    (52559, 1, "");
    (52559, 0, "p");
    (52560, 0, "o");
    (52561, 0, "s");
    (52562, 0, ":");
    (52563, 0, " ");
    (52564, 0, "u");
    (52565, 0, "s");
    (52566, 0, "i");
    (52567, 0, "z");
    (52568, 0, "e");
    (52569, 0, ",");
    (52583, 0, ")");
    (52584, 0, " ");
    (52585, 0, "{");
    (52586, 0, "\n        ");
    (52595, 0, "\n        ");
    (52587, 8, "");
    (52588, 8, "    }");
    (52584, 1, "");
    (52584, 0, "\n    ");
    (52589, 0, "w");
    (52590, 0, "h");
    (52591, 0, "e");
    (52592, 0, "r");
    (52593, 0, "e");
    (52594, 0, " ");
    (52595, 0, "F");
    (52596, 0, ":");
    (52597, 0, " ");
    (52598, 0, "F");
    (52599, 0, "n");
    (52600, 0, "O");
    (52601, 0, "n");
    (52602, 0, "c");
    (52603, 0, "e");
    (52604, 0, "(");
    (52605, 0, "&");
    (52606, 0, "m");
    (52607, 0, "u");
    (52608, 0, "t");
    (52609, 0, " ");
    (52610, 0, "C");
    (52611, 0, ":");
    (52612, 0, ":");
    (52613, 0, "I");
    (52614, 0, "t");
    (52615, 0, "e");
    (52616, 0, "m");
    (52605, 0, "i");
    (52606, 0, "t");
    (52607, 0, "e");
    (52608, 0, "m");
    (52609, 0, ":");
    (52610, 0, " ");
    (52623, 0, ")");
    (52624, 0, " ");
    (52605, 6, "");
    (52621, 0, "        ");
    (52629, 0, "let (mut cursor, offset) = self.iter_at_userpos(userpos);\n");
    (52617, 0, ",");
    (52618, 0, " ");
    (52619, 0, "i");
    (52620, 0, "n");
    (52620, 1, "");
    (52619, 1, "");
    (52619, 0, "u");
    (52620, 0, "s");
    (52621, 0, "i");
    (52622, 0, "z");
    (52623, 0, "e");
    (52694, 0, "        ");
    (52694, 8, "");
    ( 15874,
      0,
      "    unsafe fn current_item(&mut self) -> &C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &*(node.items[self.local_index].as_ptr())\n\
      \    }\n" );
    (16087, 0, "\n    ");
    (16119, 0, "_");
    (16088, 4, "");
    (16116, 0, "m");
    (16117, 0, "u");
    (16118, 0, "t");
    (16135, 0, "m");
    (16136, 0, "u");
    (16137, 0, "t");
    (16138, 0, " ");
    (16298, 0, "m");
    (16299, 0, "u");
    (16300, 0, "t");
    (16301, 0, "_");
    (16298, 4, "");
    (16264, 0, "m");
    (16265, 0, "u");
    (16266, 0, "t");
    (16267, 0, " ");
    (16087, 227, "");
    ( 16087,
      0,
      "\n\n\
      \    unsafe fn current_item_mut(&mut self) -> &mut C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &mut *(node.items[self.local_index].as_ptr())\n\
      \    }" );
    (16264, 4, "");
    (16169, 0, ",");
    (16170, 0, "u");
    (16171, 0, "t");
    (16171, 1, "");
    (16170, 1, "");
    (16169, 1, "");
    (16169, 0, "m");
    (16170, 0, "u");
    (16171, 0, "t");
    (16172, 0, " ");
    (16268, 0, "u");
    (16268, 1, "");
    (16268, 0, "m");
    (16269, 0, "u");
    (16270, 0, "t");
    (16271, 0, " ");
    (16303, 6, "a");
    (16304, 0, "s");
    (16305, 0, "_");
    (16306, 0, "m");
    (16307, 0, "u");
    (16308, 0, "t");
    (16303, 6, "as_mut_ptr");
    (52929, 0, "        ");
    (52937, 0, "l");
    (52938, 0, "e");
    (52939, 0, "t");
    (52940, 0, " ");
    (52941, 0, "i");
    (52942, 0, "t");
    (52943, 0, "e");
    (52944, 0, "m");
    (52945, 0, " ");
    (52946, 0, "=");
    (52947, 0, " ");
    (52948, 0, "c");
    (52949, 0, "u");
    (52950, 0, "r");
    (52951, 0, "s");
    (52952, 0, "o");
    (52953, 0, "r");
    (52954, 0, ".");
    (52955, 0, "c");
    (52956, 0, "u");
    (52957, 0, "r");
    (52958, 0, "r");
    (52959, 0, "e");
    (52955, 5, "current_item_mut()");
    (52973, 0, ";");
    (52974, 0, "\n        ");
    (52983, 0, "l");
    (52984, 0, "e");
    (52985, 0, "t");
    (52986, 0, " ");
    (52987, 0, "o");
    (52988, 0, "l");
    (52989, 0, "d");
    (52990, 0, "_");
    (52991, 0, "s");
    (52992, 0, "i");
    (52993, 0, "z");
    (52994, 0, "e");
    (52995, 0, " ");
    (52996, 0, "=");
    (52997, 0, " ");
    (52998, 0, "C");
    (52999, 0, ":");
    (53000, 0, ":");
    (53001, 0, "get_usersize(_item: &Self::Item)");
    (53014, 18, "i");
    (53015, 0, "t");
    (53016, 0, "e");
    (53017, 0, "m");
    (53019, 0, ";");
    (53020, 0, "\n        ");
    (53021, 8, "");
    (52947, 0, " ");
    (52948, 0, "u");
    (52949, 0, "n");
    (52950, 0, "s");
    (52951, 0, "a");
    (52952, 0, "f");
    (52953, 0, "e");
    (52954, 0, " ");
    (52955, 0, "{");
    (52982, 0, " ");
    (52983, 0, "}");
    (53032, 0, "        ");
    (53040, 0, "F");
    (53041, 0, "(");
    (53042, 0, "i");
    (53043, 0, "t");
    (53044, 0, "e");
    (53045, 0, "m");
    (53046, 0, ",");
    (53047, 0, " ");
    (53048, 0, "o");
    (53049, 0, "f");
    (53050, 0, "f");
    (53051, 0, "s");
    (53052, 0, "e");
    (53053, 0, "t");
    (53054, 0, ")");
    (53055, 0, ";");
    (53056, 0, "\n        ");
    (53057, 8, "");
    (53040, 1, "");
    (53040, 0, "m");
    (53041, 0, "o");
    (53042, 0, "d");
    (53043, 0, "i");
    (53044, 0, "f");
    (53045, 0, "y");
    (53040, 6, "modify_fn");
    (53065, 0, "        ");
    (53073, 0, "l");
    (53074, 0, "e");
    (53075, 0, "t");
    (53076, 0, " ");
    (53077, 0, "n");
    (53078, 0, "e");
    (53079, 0, "w");
    (53080, 0, "_");
    (53081, 0, "s");
    (53082, 0, "i");
    (53083, 0, "z");
    (53084, 0, "e");
    (53085, 0, " ");
    (53086, 0, "=");
    (53087, 0, " ");
    (53088, 0, "C::get_usersize(item);");
    (53110, 0, "\n        ");
    (53119, 0, "c");
    (53120, 0, "u");
    (53121, 0, "r");
    (53122, 0, "s");
    (53123, 0, "o");
    (53124, 0, "r");
    (53125, 0, ".");
    (53126, 0, "update_offsets(height: usize, by: isize)");
    (53141, 0, "s");
    (53142, 0, "e");
    (53143, 0, "l");
    (53144, 0, "f");
    (53145, 0, ".");
    (53146, 0, "n");
    (53147, 0, "o");
    (53148, 0, "d");
    (53149, 0, "e");
    (53150, 0, ".");
    (53157, 7, "");
    (53151, 6, "heights");
    (53157, 1, "");
    (53146, 4, "h");
    (53147, 0, "e");
    (53148, 0, "a");
    (53149, 0, "d");
    (53157, 0, " ");
    (53158, 0, "a");
    (53159, 0, "s");
    (53160, 0, " ");
    (53161, 0, "u");
    (53162, 0, "s");
    (53163, 0, "i");
    (53164, 0, "z");
    (53165, 0, "e");
    (53168, 9, "");
    (53168, 0, "n");
    (53169, 0, "e");
    (53170, 0, "w");
    (53171, 0, "_");
    (53172, 0, "s");
    (53173, 0, "i");
    (53174, 0, "z");
    (53175, 0, "e");
    (53176, 0, " ");
    (53177, 0, "a");
    (53178, 0, "s");
    (53179, 0, " ");
    (53180, 0, "u");
    (53181, 0, "i");
    (53181, 1, "");
    (53180, 1, "");
    (53180, 0, "i");
    (53181, 0, "s");
    (53182, 0, "i");
    (53183, 0, "z");
    (53184, 0, "e");
    (53185, 0, " ");
    (53186, 0, "-");
    (53187, 0, " ");
    (53188, 0, "o");
    (53189, 0, "l");
    (53190, 0, "d");
    (53191, 0, "_");
    (53192, 0, "s");
    (53193, 0, "i");
    (53194, 0, "e");
    (53194, 1, "");
    (53194, 0, "z");
    (53195, 0, "e");
    (53196, 0, " ");
    (53197, 0, "a");
    (53198, 0, "s");
    (53199, 0, " ");
    (53200, 0, "i");
    (53201, 0, "s");
    (53200, 2, "isize");
    (53206, 0, ";");
    (53119, 0, "// ");
    (53110, 0, "\n        ");
    ( 53119,
      0,
      "let usersize_delta = new_usersize as isize - old_usersize as isize;\n\n\
      \            if usersize_delta != 0 {\n\
      \                cursor.update_offsets(self.head.height as usize, \
       usersize_delta)\n\
      \            }\n\
      \            // I hate this.\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n" );
    (53110, 0, "\n        ");
    (53111, 8, "");
    (53081, 0, "u");
    (53002, 0, "u");
    (53083, 0, "s");
    (53003, 0, "s");
    (53085, 0, "e");
    (53004, 0, "e");
    (53087, 0, "r");
    (53005, 0, "r");
    (53315, 12, "        ");
    (53234, 16, "            ");
    (53197, 12, "        ");
    (53195, 1, "");
    (53316, 27, "");
    (53315, 1, "");
    (53406, 0, "\n        }");
    (53306, 10, "");
    (53305, 0, ";");
    (50310, 0, "\n            // I hate this.");
    (50192, 28, "");
    (50282, 0, "\n            }");
    (50192, 12, "                ");
    (50178, 14, "");
    (50177, 0, ";");
    (50315, 0, "\n            }");
    (50288, 12, "                ");
    (50274, 14, "");
    ( 50305,
      0,
      "\n\
      \                self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);" );
    (50179, 95, "");
    (53407, 8, "\n        ");
    (53408, 8, "\n        ");
    (53408, 9, "        ");
    (53407, 9, "        ");
    (53416, 0, "\n        ");
    (53425, 0, "\n        ");
    (53417, 8, "");
    ( 53426,
      0,
      "\n\
      \            notify(dest, ItemMarker {\n\
      \                ptr: e,\n\
      \                _phantom: PhantomData,\n\
      \            });" );
    (53418, 8, "");
    (53520, 12, "        ");
    (53481, 16, "            ");
    (53457, 16, "            ");
    (53419, 12, "        ");
    (53417, 1, "");
    ( 52827,
      0,
      ", mut notify: Notify)\n\
      \            where Notify: FnMut(&[C::Item], ItemMarker<C>)" );
    (52849, 12, "    ");
    (52786, 0, ",");
    (52787, 0, " ");
    (52788, 0, "N");
    (52788, 1, "");
    (52787, 1, "");
    (52786, 1, "");
    (52785, 0, "N");
    (52786, 0, "i");
    (52787, 0, "t");
    (52787, 1, "");
    (52786, 1, "");
    (52786, 0, "o");
    (52787, 0, "t");
    (52788, 0, "i");
    (52789, 0, "f");
    (52790, 0, "y");
    (52791, 0, ",");
    (52792, 0, " ");
    (52835, 20, "");
    (52821, 0, ", mut notify: Notify");
    (52907, 1, "");
    (52907, 0, ",");
    ( 52857,
      94,
      "    where Notify: FnMut(&[C::Item], ItemMarker<C>), where F: \
       FnOnce(&mut C::Item, usize) {" );
    (52908, 6, "");
    (53503, 4, "&");
    (53504, 0, "[");
    (53504, 1, "");
    (53503, 1, "");
    (53503, 0, "i");
    (53504, 0, "t");
    (53505, 0, "e");
    (53506, 0, "m");
    (53507, 0, ".");
    (53508, 0, "f");
    (53509, 0, "r");
    (53510, 0, "o");
    (53511, 0, "m");
    (53512, 0, "(");
    (53513, 0, ")");
    (53508, 4, "i");
    (53509, 0, "n");
    (53510, 0, "t");
    (53511, 0, "o");
    (53503, 0, "s");
    (53504, 0, "l");
    (53505, 0, "i");
    (53506, 0, "c");
    (53507, 0, "e");
    (53508, 0, ":");
    (53509, 0, ":");
    (53510, 0, "f");
    (53511, 0, "r");
    (53512, 0, "o");
    (53513, 0, "m");
    (53514, 0, "_");
    (53515, 0, "r");
    (53516, 0, "e");
    (53517, 0, "f");
    (53518, 0, "(");
    (53523, 7, "");
    (53523, 0, ")");
    (53503, 0, "s");
    (53504, 0, "t");
    (53505, 0, "d");
    (53506, 0, ":");
    (53507, 0, ":");
    (53561, 1, "");
    (53561, 0, "c");
    (53562, 0, "u");
    (53563, 0, "r");
    (53564, 0, "s");
    (53565, 0, "o");
    (53566, 0, "r");
    (53567, 0, ".");
    (53568, 0, "h");
    (53569, 0, "e");
    (53570, 0, "r");
    (53571, 0, "e");
    (53568, 4, "here_ptr()");
    (53487, 0, "}");
    (53198, 0, "{");
    (53488, 1, "");
    (53198, 1, "");
    (53487, 0, "\n        ");
    (53496, 0, "l");
    (53497, 0, "e");
    (53498, 0, "t");
    (53499, 0, " ");
    (53500, 0, "e");
    (53501, 0, " ");
    (53502, 0, "=");
    (53503, 0, " ");
    (53504, 0, "c");
    (53505, 0, "u");
    (53506, 0, "r");
    (53507, 0, "s");
    (53508, 0, "o");
    (53509, 0, "r");
    (53510, 0, ".");
    (53511, 0, "h");
    (53512, 0, "e");
    (53513, 0, "r");
    (53514, 0, "e");
    (53511, 4, "here_ptr()");
    (53521, 0, ";");
    (53596, 17, "e");
    (53496, 26, "");
    (53198, 0, "let e = cursor.here_ptr();");
    (53198, 0, "        ");
    (53232, 0, "\n        ");
    (53535, 4, "");
    (53233, 8, "");
    (53523, 4, "");
    (53522, 1, "");
    (53232, 0, "\n        let new_usersize = C::get_usersize(item);");
    (53148, 50, "");
    (53182, 0, "\n        modify_fn(item, offset);");
    (53115, 33, "");
    (53149, 0, "\n        let old_usersize = C::get_usersize(item);");
    (53065, 50, "");
    (53099, 0, "\n        let item = unsafe { cursor.current_item_mut() };");
    (53008, 57, "");
    (53642, 0, "// ");
    (53607, 0, "// ");
    (53587, 0, "// ");
    (53531, 0, "// ");
    (53098, 0, " ");
    (53099, 0, "a");
    (53100, 0, "s");
    (53101, 0, " ");
    (53102, 0, "*");
    (53103, 0, "m");
    (53104, 0, "u");
    (53105, 0, "t");
    (53106, 0, " ");
    (53107, 0, "_");
    (53106, 2, "");
    (53101, 5, "");
    (53098, 3, "");
    (53232, 0, "\n        ");
    (53241, 0, "l");
    (53242, 0, "e");
    (53243, 0, "t");
    (53244, 0, " ");
    (53245, 0, "s");
    (53246, 0, "l");
    (53247, 0, "i");
    (53248, 0, "c");
    (53249, 0, "e");
    (53250, 0, " ");
    (53251, 0, "=");
    (53252, 0, " ");
    (53253, 0, "std::slice::from_ref(item)");
    (53279, 0, ";");
    (53699, 3, "");
    (53661, 3, "");
    (53638, 3, "");
    (53579, 3, "");
    (53586, 26, "s");
    (53587, 0, "l");
    (53588, 0, "i");
    (53589, 0, "c");
    (53590, 0, "e");
    (53586, 5, "std::slice::from_ref(item)");
    (53233, 48, "");
    (12701, 0, "    ");
    (12705, 0, "_");
    (12706, 0, "m");
    (12707, 0, "a");
    (12708, 0, "r");
    (12709, 0, "k");
    (12710, 0, "e");
    (12711, 0, "r");
    (12712, 0, ":");
    (12713, 0, " ");
    (12714, 0, "P");
    (12715, 0, "h");
    (12716, 0, "n");
    (12714, 3, "PhantomData");
    (12617, 0, ",");
    (12618, 0, " ");
    (12618, 1, "");
    (12617, 1, "");
    (12604, 0, "'");
    (12605, 0, "a");
    (12606, 0, ",");
    (12607, 0, " ");
    (12729, 0, "<");
    (12730, 0, "S");
    (12731, 0, "k");
    (12732, 0, "i");
    (12733, 0, "p");
    (12730, 4, "SkipList");
    (12738, 0, "<");
    (12730, 0, "&");
    (12731, 0, "'");
    (12732, 0, "a");
    (12733, 0, " ");
    (12743, 0, "C");
    (12744, 0, ">");
    (12745, 0, ">");
    (12746, 0, ",");
    (12625, 124, "");
    (13326, 0, "\n    ");
    (13331, 0, "\n    ");
    (13327, 4, "");
    ( 13332,
      0,
      "    // TODO: Add a phantom lifetime reference to the skip list root for \
       safety.\n\
      \    _marker: PhantomData<&'a SkipList<C>>,\n\n" );
    (13412, 4, "        ");
    (13412, 8, "    ");
    (13328, 8, "    ");
    (13451, 1, "");
    (13450, 1, "");
    (13328, 79, "");
    (13327, 1, "");
    (13327, 0, "\n    ");
    (13332, 0, "/");
    (13333, 0, "/");
    (13334, 0, " ");
    (13335, 0, "T");
    (13336, 0, "h");
    (13337, 0, "e");
    (13338, 0, " ");
    (13339, 0, "c");
    (13340, 0, "u");
    (13341, 0, "r");
    (13342, 0, "s");
    (13343, 0, "o");
    (13344, 0, "r");
    (13345, 0, " ");
    (13346, 0, "c");
    (13347, 0, "a");
    (13348, 0, "n");
    (13349, 0, "'");
    (13350, 0, "t");
    (13351, 0, " ");
    (13352, 0, "o");
    (13353, 0, "u");
    (13354, 0, "t");
    (13355, 0, "l");
    (13356, 0, "i");
    (13357, 0, "v");
    (13358, 0, "e");
    (13359, 0, " ");
    (13360, 0, "t");
    (13361, 0, "h");
    (13362, 0, "e");
    (13363, 0, " ");
    (13364, 0, "s");
    (13365, 0, "k");
    (13366, 0, "i");
    (13367, 0, "p");
    (13368, 0, "l");
    (13369, 0, "i");
    (13370, 0, "s");
    (13371, 0, "t");
    (13372, 0, ".");
    (13425, 0, "'");
    (13426, 0, "a");
    (13427, 0, ",");
    (13428, 0, " ");
    (13451, 0, "'");
    (13452, 0, "a");
    (13453, 0, " ");
    (13453, 1, "");
    (13453, 0, ",");
    (13454, 0, " ");
    (15936, 0, "'");
    (15937, 0, "a");
    (15938, 0, " ");
    (16158, 0, "'");
    (16159, 0, "a");
    (16160, 0, " ");
    (16487, 0, "'");
    (16488, 0, "a");
    (16489, 0, ",");
    (16490, 0, " ");
    (16527, 0, "'");
    (16528, 0, "a");
    (16529, 0, " ");
    (16529, 1, "");
    (16529, 0, ",");
    (16530, 0, " ");
    (17182, 0, "'");
    (17183, 0, "a");
    (17184, 0, ",");
    (17185, 0, " ");
    (17215, 0, "'");
    (17216, 0, "a");
    (17217, 0, ",");
    (17218, 0, " ");
    (17231, 0, "'");
    (17232, 0, "a");
    (17233, 0, ",");
    (17234, 0, " ");
    (17272, 0, "'");
    (17273, 0, "a");
    (17274, 0, ",");
    (17275, 0, " ");
    (27721, 0, "\n            ");
    (27734, 0, "_");
    (27735, 0, "m");
    (27736, 0, "a");
    (27737, 0, "r");
    (27738, 0, "k");
    (27739, 0, "e");
    (27740, 0, "r");
    (27741, 0, ":");
    (27742, 0, " ");
    (27743, 0, "P");
    (27744, 0, "h");
    (27745, 0, "a");
    (27746, 0, "n");
    (27743, 4, "PhantomData");
    (27754, 0, ",");
    (29701, 0, "\n            ");
    (29714, 0, "_");
    (29715, 0, "m");
    (29716, 0, "a");
    (29717, 0, "r");
    (29718, 0, "k");
    (29714, 5, "_marker");
    (29721, 0, ":");
    (29722, 0, " ");
    (29723, 0, "P");
    (29724, 0, "h");
    (29725, 0, "a");
    (29726, 0, "n");
    (29723, 4, "PhantomData");
    (53762, 0, "\n        }");
    (53751, 8, "                    ");
    (53716, 12, "                        ");
    (53696, 12, "                        ");
    (53640, 8, "                    ");
    (53639, 0, "            ");
    (53629, 10, "");
    ( 53812,
      0,
      "\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);" );
    (53538, 91, "");
    ( 53721,
      0,
      "\n\
      \            cursor.update_offsets(self.head.height as usize, \
       usersize_delta);" );
    (53460, 78, "");
    (53643, 0, "\n        if usersize_delta != 0 {");
    (53620, 20, "                ");
    (53573, 24, "                    ");
    (53541, 24, "                    ");
    (53473, 20, "                ");
    (53460, 12, "        ");
    (53427, 33, "");
    (53571, 16, "            ");
    (53528, 20, "                ");
    (53500, 20, "                ");
    (53436, 16, "            ");
    (53427, 8, "    ");
    (53555, 12, "        ");
    (53516, 16, "            ");
    (53492, 16, "            ");
    (53432, 12, "        ");
    (53427, 4, "");
    (53550, 0, "\n        ");
    (53551, 8, "");
    (52573, 0, "// ");
    (52573, 3, "");
    (52573, 0, "// ");
    (52573, 3, "");
    (12621, 0, ",");
    (12622, 0, " ");
    (12623, 0, "S");
    (12624, 0, ":");
    (12625, 0, " ");
    (12626, 0, "&");
    (12626, 1, "");
    (12625, 1, "");
    (12624, 1, "");
    (12623, 1, "");
    (12622, 1, "");
    (12621, 1, "");
    (12621, 0, ",");
    (12622, 0, " ");
    (12623, 0, "S");
    (12624, 0, ":");
    (12625, 0, " ");
    (12626, 0, "S");
    (12627, 0, "k");
    (12628, 0, "i");
    (12629, 0, "p");
    (12626, 4, "SkipList");
    (12634, 0, "<");
    (12635, 0, "c");
    (12636, 0, "'");
    (12636, 1, "");
    (12635, 1, "");
    (12635, 0, "C");
    (12636, 0, ">");
    (12626, 0, "&");
    (12638, 0, "'");
    (12626, 0, "'");
    (12627, 12, "a");
    (12628, 1, "");
    (12628, 0, " ");
    (12629, 0, "+");
    (12630, 0, " ");
    (12631, 0, "S");
    (12632, 0, "k");
    (12633, 0, "i");
    (12634, 0, "p");
    (12631, 4, "SkipList");
    (12639, 0, "<");
    (12640, 0, "C");
    (12641, 0, ">");
    (12628, 14, "");
    (12625, 0, " + SkipList<C>");
    (12639, 0, " ");
    (12640, 0, "+");
    (12627, 1, "");
    (12626, 1, "");
    (12625, 1, "");
    (12625, 0, " ");
    (12625, 1, "");
    (12625, 0, " + ");
    (12639, 2, "");
    (12625, 14, "");
    (12628, 0, " + SkipList<C>");
    (12628, 14, "");
    (12625, 0, " + SkipList<C>");
    (12639, 0, " +");
    (12625, 3, "");
    (12625, 0, " ");
    (12626, 0, "&");
    (12621, 22, "");
    (13378, 0, "// ");
    (12604, 4, "");
    (13368, 1, "");
    (13368, 0, ",");
    (13369, 0, " ");
    (13370, 0, "b");
    (13371, 0, "u");
    (13372, 0, "t");
    (13373, 0, " ");
    (13374, 0, "d");
    (13375, 0, "o");
    (13376, 0, "i");
    (13377, 0, "n");
    (13378, 0, "g");
    (13379, 0, " ");
    (13380, 0, "t");
    (13381, 0, "h");
    (13382, 0, "i");
    (13383, 0, "s");
    (13384, 0, " ");
    (13385, 0, "m");
    (13386, 0, "a");
    (13387, 0, "k");
    (13388, 0, "e");
    (13389, 0, "s");
    (13390, 0, " ");
    (13391, 0, "i");
    (13392, 0, "t");
    (13393, 0, " ");
    (13394, 0, "t");
    (13395, 0, "r");
    (13396, 0, "i");
    (13397, 0, "c");
    (13398, 0, "k");
    (13399, 0, "y");
    (13400, 0, " ");
    (13401, 0, "t");
    (13402, 0, "o");
    (13403, 0, " ");
    (13404, 0, "a");
    (13405, 0, "p");
    (13406, 0, "s");
    (13407, 0, "s");
    (13404, 4, "p");
    (13405, 0, "a");
    (13406, 0, "s");
    (13407, 0, "s");
    (13408, 0, " ");
    (13409, 0, "c");
    (13410, 0, "u");
    (13411, 0, "r");
    (13412, 0, "s");
    (13413, 0, "o");
    (13414, 0, "r");
    (13415, 0, "s");
    (13416, 0, " ");
    (13417, 0, "a");
    (13418, 0, "r");
    (13419, 0, "o");
    (13420, 0, "u");
    (13421, 0, "n");
    (13422, 0, "d");
    (13423, 0, " ");
    (13424, 0, "i");
    (13425, 0, "n");
    (13426, 0, "t");
    (13427, 0, " ");
    (13428, 0, "h");
    (13429, 0, "e");
    (13430, 0, " ");
    (13424, 7, "i");
    (13425, 0, "n");
    (13426, 0, " ");
    (13427, 0, "t");
    (13428, 0, "h");
    (13429, 0, "e");
    (13430, 0, " ");
    (13431, 0, "S");
    (13432, 0, "k");
    (13433, 0, "i");
    (13434, 0, "p");
    (13435, 0, "l");
    (13436, 0, "i");
    (13437, 0, "s");
    (13438, 0, "t");
    (13439, 0, " ");
    (13440, 0, "t");
    (13441, 0, "y");
    (13442, 0, "p");
    (13443, 0, "e");
    (13444, 0, ".");
    (13445, 0, " ");
    (13446, 0, "I");
    (13447, 0, "'");
    (13446, 2, "T");
    (13447, 0, "h");
    (13448, 0, "e");
    (13449, 0, "r");
    (13450, 0, "e");
    (13451, 0, "'");
    (13452, 0, "s");
    (13453, 0, " ");
    (13454, 0, "p");
    (13455, 0, "r");
    (13456, 0, "o");
    (13457, 0, "b");
    (13458, 0, "a");
    (13459, 0, "b");
    (13460, 0, "l");
    (13461, 0, "y");
    (13462, 0, " ");
    (13463, 0, "a");
    (13464, 0, " ");
    (13465, 0, "w");
    (13466, 0, "a");
    (13467, 0, "y");
    (13468, 0, " ");
    (13469, 0, "o");
    (13470, 0, "u");
    (13471, 0, "t");
    (13472, 0, " ");
    (13473, 0, "o");
    (13474, 0, "f");
    (13475, 0, " ");
    (13476, 0, "t");
    (13477, 0, "h");
    (13478, 0, "i");
    (13479, 0, "s");
    (13480, 0, " ");
    (13481, 0, "m");
    (13482, 0, "e");
    (13483, 0, "s");
    (13484, 0, "s");
    (13485, 0, ",");
    (13486, 0, " ");
    (13487, 0, "b");
    (13488, 0, "u");
    (13489, 0, "t");
    (13490, 0, " ");
    (13491, 0, "I");
    (13492, 0, "'");
    (13493, 0, "m");
    (13494, 0, " ");
    (13495, 0, "n");
    (13496, 0, "o");
    (13497, 0, "t");
    (13498, 0, " ");
    (13499, 0, "g");
    (13500, 0, "o");
    (13501, 0, "o");
    (13502, 0, "d");
    (13503, 0, " ");
    (13504, 0, "e");
    (13505, 0, "n");
    (13506, 0, "o");
    (13507, 0, "u");
    (13508, 0, "g");
    (13509, 0, "h");
    (13510, 0, " ");
    (13511, 0, "a");
    (13512, 0, "t");
    (13513, 0, " ");
    (13514, 0, "R");
    (13515, 0, "u");
    (13516, 0, "s");
    (13517, 0, "t");
    (13518, 0, " ");
    (13514, 5, "r");
    (13515, 0, "u");
    (13516, 0, "s");
    (13517, 0, "t");
    (13518, 0, " ");
    (13519, 0, "t");
    (13520, 0, "o");
    (13521, 0, " ");
    (13522, 0, "f");
    (13523, 0, "i");
    (13524, 0, "g");
    (13525, 0, "u");
    (13526, 0, "r");
    (13527, 0, "e");
    (13528, 0, " ");
    (13529, 0, "i");
    (13530, 0, "t");
    (13531, 0, " ");
    (13532, 0, "o");
    (13533, 0, "u");
    (13534, 0, "t");
    (13535, 0, ".");
    (13536, 0, "\n    ");
    (13537, 4, "");
    (13331, 0, "T");
    (13332, 0, "O");
    (13333, 0, "D");
    (13334, 0, "O");
    (13335, 0, ":");
    (13336, 0, " ");
    ( 13324,
      218,
      "    // TODO: The cursor can't outlive the skiplist, but doing this \
       makes it\n\
      \    // tricky to pass cursors around in the Skiplist type. There's \
       probably a\n\
      \    // way out of this mess, but I'm not good enough at rust to figure \
       it out." );
    (13556, 1, "");
    (13640, 1, "");
    (13639, 1, "");
    (13638, 1, "");
    (13637, 1, "");
    (16712, 1, "");
    (16711, 1, "");
    (16710, 1, "");
    (16709, 1, "");
    (17453, 1, "");
    (17396, 1, "");
    (17451, 1, "");
    (17395, 1, "");
    (17449, 1, "");
    (17394, 1, "");
    (17447, 1, "");
    (17393, 1, "");
    (27904, 0, "// ");
    (29887, 0, "// ");
    (53603, 124, "");
    ( 53816,
      0,
      "\n\
      \        notify(std::slice::from_ref(item), ItemMarker {\n\
      \            ptr: e,\n\
      \            _phantom: PhantomData,\n\
      \        });\n" );
    (13614, 1, "");
    (13613, 1, "");
    (13612, 1, "");
    (13611, 1, "");
    (16115, 1, "");
    (16115, 0, "s");
    (16116, 0, "t");
    (16117, 0, "a");
    (16118, 0, "t");
    (16119, 0, "i");
    (16120, 0, "c");
    (16342, 1, "");
    (16342, 0, "s");
    (16343, 0, "t");
    (16344, 0, "a");
    (16345, 0, "t");
    (16346, 0, "i");
    (16347, 0, "c");
    (16342, 6, "");
    (16342, 0, "a");
    (16115, 6, "");
    (16115, 0, "a");
    (13611, 0, "'a, ");
    (52155, 0, "p");
    (52156, 0, "u");
    (52157, 0, "b");
    (52158, 0, " ");
    (17405, 4, "");
    (17360, 4, "");
    (16669, 4, "");
    (11778, 5885, "");
    ( 11778,
      0,
      "\n\
       /// This is a set of pointers with metadata into a location in the list \
       needed\n\
       /// to skip ahead, delete and insert in items. A cursor is reasonably \
       heavy\n\
       /// weight - we fill in and maintain as many entries as the height of \
       the list\n\
       /// dictates.\n\
       ///\n\
       /// This is not needed for simply iterating sequentially through nodes \
       and data.\n\
       /// For that look at NodeIter.\n\
       ///\n\
       /// Note most/all methods using cursors are unsafe. This is because \
       cursors use\n\
       /// raw mutable pointers into the list, so when used the following \
       rules have to\n\
       /// be followed:\n\
       ///\n\
       /// - Whenever a write happens (insert/remove/replace), any cursor not \
       passed to\n\
       ///   the write function is invalid.\n\
       /// - While a cursor is held the SkipList struct should be considered \
       pinned and\n\
       ///   must not be moved or deleted\n\
       #[derive(Copy, Clone)]\n\
       pub struct Cursor<C: ListConfig> {\n\
      \    /// The global user position of the cursor in the entire list. This \
       is used\n\
      \    /// for when the max seen height increases, so we can populate \
       previously\n\
      \    /// unused entries in the cursor and in the head node.\n\
      \    ///\n\
      \    /// This field isn't strictly necessary - earlier versions tacked \
       this on to\n\
      \    /// the last item in entries... I'm still not sure the cleanest way \
       to do\n\
      \    /// this.\n\
      \    userpos: usize,\n\n\
      \    /// When the userpos of an entry is 0 (totally valid and useful), a \
       cursor\n\
      \    /// becomes ambiguous with regard to where exactly its pointing in \
       the\n\
      \    /// current entry. This is used to resolve that ambiguity.\n\
      \    local_index: usize,\n\n\
      \    entries: [SkipEntry<C>; MAX_HEIGHT],\n\n\
      \    // TODO: The cursor can't outlive the skiplist, but doing this \
       makes it\n\
      \    // tricky to pass cursors around in the Skiplist type. There's \
       probably a\n\
      \    // way out of this mess, but I'm not good enough at rust to figure \
       it out.\n\
      \    // _marker: PhantomData<&'a SkipList<C>>,\n\
       }\n\n\
       impl<'a, C: ListConfig> Cursor<C> {\n\
      \    fn update_offsets(&mut self, height: usize, by: isize) {\n\
      \        for i in 0..height {\n\
      \            unsafe {\n\
      \                // This is weird but makes sense when you realise the \
       nexts in\n\
      \                // the cursor are pointers into the elements that have \
       the\n\
      \                // actual pointers.\n\
      \                // Also adding a usize + isize is awful in rust :/\n\
      \                let skip = &mut \
       (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n\
      \                *skip = skip.wrapping_add(by as usize);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Move a cursor to the start of the next node. Returns the new \
       node (or a\n\
      \    /// nullptr if this is the end of the list).\n\
      \    fn advance_node(&mut self) -> *mut Node<C> {\n\
      \        unsafe {\n\
      \            let SkipEntry { node: e, skip_usersize: offset } = \
       self.entries[0];\n\
      \            // offset tells us how far into the current element we are \
       (in\n\
      \            // usersize). We need to increment the offsets by the entry's\n\
      \            // remaining length to get to the start of the next node.\n\
      \            let advance_by = (*e).get_userlen() - offset;\n\
      \            let next = (*e).get_next_ptr();\n\
      \            let height = (*next).height as usize;\n\n\
      \            for i in 0..height {\n\
      \                self.entries[i] = SkipEntry {\n\
      \                    node: next,\n\
      \                    skip_usersize: 0\n\
      \                };\n\
      \            }\n\n\
      \            for i in height..self.entries.len() {\n\
      \                self.entries[i].skip_usersize += advance_by;\n\
      \            }\n\n\
      \            self.userpos += advance_by;\n\
      \            self.local_index = 0;\n\n\
      \            next\n\
      \        }\n\
      \    }\n\n\
      \    fn is_at_node_end(&self) -> bool {\n\
      \        self.local_index == unsafe { (*self.here_ptr()).num_items } as \
       usize\n\
      \    }\n\n\
      \    fn advance_item(&mut self, height: u8) {\n\
      \        if self.is_at_node_end() { self.advance_node(); }\n\
      \        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize += usersize;\n\
      \        }\n\
      \        self.userpos += usersize;\n\
      \        self.local_index += 1;\n\
      \    }\n\n\
      \    fn advance_by_items(&mut self, num: usize, height: u8) {\n\
      \        for _ in 0..num { self.advance_item(height); }\n\
      \    }\n\n\
      \    fn move_to_item_start(&mut self, height: u8, offset: usize) {\n\
      \        for entry in &mut self.entries[0..height as usize] {\n\
      \            entry.skip_usersize -= offset;\n\
      \        }\n\
      \        self.userpos -= offset;\n\
      \    }\n\n\
      \    unsafe fn current_item(&mut self) -> &'a C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &*(node.items[self.local_index].as_ptr())\n\
      \    }\n\n\
      \    unsafe fn current_item_mut(&mut self) -> &'a mut C::Item {\n\
      \        let node = &mut *self.here_ptr();\n\
      \        debug_assert!(node.num_items as usize >= self.local_index);\n\
      \        &mut *(node.items[self.local_index].as_mut_ptr())\n\
      \    }\n\n\
      \    /// Get the pointer to the cursor's current node\n\
      \    fn here_ptr(&self) -> *mut Node<C> {\n\
      \        self.entries[0].node\n\
      \    }\n\
       }\n\n\
       impl<C: ListConfig> PartialEq for Cursor<C> {\n\
      \    /// Warning: This returns false if one cursor is at the end of a \
       node, and\n\
      \    /// the other at the start of the next node. Almost all code in \
       this library\n\
      \    /// leaves cursors at the end of nodes, so this shouldn't matter \
       too much in\n\
      \    /// practice.\n\
      \    fn eq(&self, other: &Self) -> bool {\n\
      \        if self.userpos != other.userpos\n\
      \            || self.local_index != other.local_index {return false; }\n\n\
      \        for i in 0..MAX_HEIGHT {\n\
      \            let a = &self.entries[i];\n\
      \            let b = &other.entries[i];\n\
      \            if a.node != b.node || a.skip_usersize != b.skip_usersize { \
       return false; }\n\
      \        }\n\
      \        true\n\
      \    }\n\
       }\n\
       impl<C: ListConfig> Eq for Cursor<C> {}\n\n\
       impl<C: ListConfig> fmt::Debug for Cursor<C> {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_struct(\"Cursor\")\n\
      \            .field(\"userpos\", &self.userpos)\n\
      \            .field(\"local_index\", &self.local_index)\n\
      \            .finish()\n\
      \    }\n\
       }\n" );
    (1835, 0, "// ");
    (1790, 1, "");
    (1789, 1, "");
    (1788, 1, "");
    (1787, 1, "");
    (36084, 0, "// ");
    (39905, 0, "// ");
    (51076, 0, "// ");
    (53905, 0, "// ");
    (30972, 0, "u");
    (30973, 0, "n");
    (30974, 0, "s");
    (30975, 0, "a");
    (30976, 0, "f");
    (30977, 0, "e");
    (30978, 0, " ");
    (30972, 7, "");
    (30976, 0, "u");
    (30977, 0, "n");
    (30978, 0, "s");
    (30979, 0, "a");
    (30980, 0, "f");
    (30981, 0, "e");
    (30982, 0, " ");
    (31183, 17, "");
    (31754, 12, "        ");
    (31661, 12, "        ");
    (31646, 12, "        ");
    (31628, 16, "            ");
    (31575, 20, "                ");
    (31550, 16, "            ");
    (31523, 20, "                ");
    (31480, 20, "                ");
    (31437, 20, "                ");
    (31366, 16, "            ");
    (31295, 12, "        ");
    (31255, 12, "        ");
    (31216, 12, "        ");
    (31183, 12, "        ");
    (31752, 10, "");
    (30967, 0, "\n    ");
    (30972, 0, "/");
    (30973, 0, "/");
    (30974, 0, "/");
    (30975, 0, " ");
    (30976, 0, "S");
    (30977, 0, "A");
    (30978, 0, "F");
    (30979, 0, "E");
    (30980, 0, "T");
    (30981, 0, "Y");
    (30982, 0, ":");
    (30983, 0, " ");
    (30984, 0, "T");
    (30985, 0, "h");
    (30986, 0, "e");
    (30987, 0, " ");
    (30988, 0, "m");
    (30988, 1, "");
    (30984, 4, "S");
    (30985, 0, "e");
    (30986, 0, "l");
    (30987, 0, "f");
    (30988, 0, " ");
    (30989, 0, "m");
    (30990, 0, "u");
    (30991, 0, "s");
    (30992, 0, "t");
    (30993, 0, " ");
    (30994, 0, "o");
    (30995, 0, "u");
    (30996, 0, "t");
    (30997, 0, "l");
    (30998, 0, "a");
    (30999, 0, "s");
    (31000, 0, " ");
    (31001, 0, "t");
    (31001, 1, "");
    (31000, 1, "");
    (31000, 0, "t");
    (31001, 0, " ");
    (31002, 0, "t");
    (31003, 0, "h");
    (31004, 0, "e");
    (31005, 0, " ");
    (31006, 0, "l");
    (31007, 0, "i");
    (31008, 0, "f");
    (31009, 0, "e");
    (31010, 0, "t");
    (31011, 0, "i");
    (31012, 0, "m");
    (31013, 0, "e");
    (31006, 8, "m");
    (31007, 0, "a");
    (31008, 0, "r");
    (31009, 0, "k");
    (31010, 0, "e");
    (31011, 0, "r");
    (31012, 0, " ");
    (31013, 0, "a");
    (31014, 0, "n");
    (31015, 0, "d");
    (31016, 0, " ");
    (31017, 0, "n");
    (31018, 0, "o");
    (31019, 0, "t");
    (31020, 0, " ");
    (31021, 0, "h");
    (31022, 0, "a");
    (31023, 0, "v");
    (31024, 0, "e");
    (31025, 0, " ");
    (31026, 0, "b");
    (31027, 0, "e");
    (31028, 0, "e");
    (31029, 0, "n");
    (31030, 0, " ");
    (31031, 0, "m");
    (31032, 0, "o");
    (31033, 0, "v");
    (31034, 0, "e");
    (31035, 0, "d");
    (31036, 0, " ");
    (31037, 0, "s");
    (31038, 0, "i");
    (31039, 0, "n");
    (31040, 0, "c");
    (31041, 0, "e");
    (31042, 0, " ");
    (31043, 0, "t");
    (31044, 0, "h");
    (31045, 0, "e");
    (31046, 0, " ");
    (31047, 0, "m");
    (31048, 0, "a");
    (31049, 0, "r");
    (31050, 0, "k");
    (31051, 0, "e");
    (31052, 0, "r");
    (31053, 0, " ");
    (31054, 0, "w");
    (31055, 0, "a");
    (31056, 0, "s");
    (31057, 0, " ");
    (31058, 0, "c");
    (31059, 0, "r");
    (31060, 0, "e");
    (31061, 0, "a");
    (31062, 0, "t");
    (31063, 0, "e");
    (31064, 0, "d");
    (31065, 0, ".");
    (31066, 0, " ");
    (31067, 0, "S");
    (31068, 0, "e");
    (31069, 0, "l");
    (31070, 0, "f");
    (31071, 0, " ");
    (31072, 0, "s");
    (31073, 0, "h");
    (31074, 0, "o");
    (31075, 0, "u");
    (31076, 0, "l");
    (31077, 0, "d");
    (31078, 0, " ");
    (31079, 0, "r");
    (31080, 0, "e");
    (31081, 0, "a");
    (31082, 0, "l");
    (31083, 0, "l");
    (31084, 0, "y");
    (31085, 0, " ");
    (31086, 0, "b");
    (31087, 0, "e");
    (31088, 0, " ");
    (31089, 0, "P");
    (31090, 0, "i");
    (31091, 0, "n");
    (31092, 0, "<");
    (31093, 0, "*");
    (31093, 1, "");
    (31093, 0, "&");
    (31093, 1, "");
    (31093, 0, ">");
    (31094, 0, "!");
    ( 30968,
      127,
      "    /// SAFETY: Self must outlast the marker and not have been moved \
       since the\n\
      \    /// marker was created. Self should really be Pin<>!" );
    (1764, 0, "\n");
    (1765, 0, "#");
    (1766, 0, "[");
    (1767, 0, "d");
    (1768, 0, "e");
    (1769, 0, "r");
    (1770, 0, "i");
    (1771, 0, "v");
    (1772, 0, "e");
    (1773, 0, "(");
    (1774, 0, "C");
    (1774, 1, "Clone");
    (1779, 0, ",");
    (1780, 0, " ");
    (1780, 1, "");
    (1780, 0, " ");
    (1781, 0, "C");
    (1782, 0, "o");
    (1783, 0, "p");
    (1784, 0, "y");
    (1785, 0, ")");
    (1786, 0, "]");
    (53052, 0, "// ");
    (53135, 0, "\n        ");
    (53144, 0, "s");
    (53145, 0, "e");
    (53146, 0, "l");
    (53147, 0, "f");
    (53148, 0, ".");
    (53149, 0, "m");
    (53150, 0, "o");
    (53151, 0, "d");
    (53152, 0, "i");
    (53153, 0, "f");
    (53149, 5, "modify_at(userpos: usize, mut notify: Notify, modify_fn: F)");
    (53159, 14, "s");
    (53160, 0, "t");
    (53161, 0, "a");
    (53162, 0, "r");
    (53163, 0, "t");
    (53164, 0, "_");
    (53165, 0, "u");
    (53166, 0, "s");
    (53167, 0, "e");
    (53168, 0, "r");
    (53169, 0, "p");
    (53170, 0, "o");
    (53171, 0, "s");
    (53174, 18, "S");
    (53175, 0, "e");
    (53176, 0, "l");
    (53177, 0, "f");
    (53178, 0, ":");
    (53179, 0, ":");
    (53180, 0, "N");
    (53180, 1, "");
    (53180, 0, "n");
    (53181, 0, "o");
    (53180, 2, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (53190, 18, "");
    (53190, 1, "");
    (53189, 1, "");
    (53189, 24, "");
    (53191, 12, "");
    (53191, 0, "|");
    (53192, 0, "i");
    (53193, 0, "t");
    (53194, 0, "e");
    (53195, 0, "m");
    (53196, 0, ",");
    (53197, 0, " ");
    (53198, 0, "o");
    (53199, 0, "f");
    (53200, 0, "f");
    (53201, 0, "s");
    (53202, 0, "e");
    (53203, 0, "t");
    (53204, 0, "|");
    (53205, 0, " ");
    (53206, 0, "{");
    (53207, 0, "\n            ");
    (53220, 0, "\n        ");
    (53221, 8, "        }");
    (53220, 0, "a");
    (53221, 0, "s");
    (53222, 0, "s");
    (53220, 3, "assert_eq!");
    (53230, 0, "(");
    (53231, 0, "o");
    (53232, 0, "f");
    (53233, 0, "f");
    (53234, 0, "s");
    (53235, 0, "e");
    (53236, 0, "t");
    (53237, 0, ",");
    (53238, 0, " ");
    (53239, 0, "0");
    (53240, 0, ",");
    (53241, 0, " ");
    (53242, 0, "\"");
    (53243, 0, "r");
    (53244, 0, "e");
    (53245, 0, "p");
    (53246, 0, "l");
    (53247, 0, "a");
    (53248, 0, "c");
    (53249, 0, "e");
    (53250, 0, "_");
    (53251, 0, "a");
    (53252, 0, "t");
    (53253, 0, " ");
    (53254, 0, "c");
    (53255, 0, "a");
    (53256, 0, "n");
    (53257, 0, "n");
    (53258, 0, "o");
    (53259, 0, "t");
    (53260, 0, " ");
    (53254, 7, "m");
    (53255, 0, "u");
    (53256, 0, "s");
    (53257, 0, "t");
    (53258, 0, " ");
    (53259, 0, "m");
    (53260, 0, "o");
    (53261, 0, "d");
    (53262, 0, "i");
    (53263, 0, "f");
    (53264, 0, "y");
    (53265, 0, " ");
    (53266, 0, "t");
    (53267, 0, "h");
    (53268, 0, "e");
    (53269, 0, " ");
    (53270, 0, "e");
    (53271, 0, "n");
    (53272, 0, "t");
    (53273, 0, "i");
    (53274, 0, "r");
    (53275, 0, "e");
    (53276, 0, " ");
    (53277, 0, "i");
    (53278, 0, "t");
    (53279, 0, "e");
    (53280, 0, "m");
    (53281, 0, "\"");
    (53282, 0, ")");
    (53283, 0, ";");
    (53284, 0, "\n            ");
    (53297, 0, "*");
    (53298, 0, "i");
    (53299, 0, "t");
    (53300, 0, "e");
    (53301, 0, "m");
    (53302, 0, " ");
    (53303, 0, " ");
    (53303, 1, "");
    (53303, 0, "=");
    (53304, 0, " ");
    (53136, 180, "");
    (53135, 1, "");
    (53052, 3, "");
    (51850, 0, "// ");
    (51920, 0, "\n        ");
    (51929, 0, "\n        ");
    (51921, 8, "");
    ( 51930,
      0,
      "        self.modify_at(start_userpos, Self::no_notify, |item, offset| {\n\
      \            assert_eq!(offset, 0, \"replace_at must modify the entire \
       item\");\n\
      \            *item = \n\
      \        })" );
    (51922, 16, "        ");
    (51922, 8, "                ");
    (51922, 16, "        ");
    (52100, 0, "// ");
    (52079, 0, "// ");
    (52002, 0, "// ");
    (51930, 0, "// ");
    (51850, 3, "");
    (54399, 1, "");
    (54399, 0, "\n    ");
    (54404, 0, "where Notify: FnMut(&[C::Item], ItemMarker<C>), ");
    (54452, 6, "");
    (54383, 0, "mut notify: Notify, ");
    (54349, 0, "N");
    (54350, 0, "o");
    (54351, 0, "t");
    (54352, 0, "i");
    (54353, 0, "f");
    (54354, 0, "y");
    (54355, 0, ",");
    (54356, 0, " ");
    (54391, 19, "");
    (54390, 1, "");
    (54406, 0, "mut notify: Notify,");
    (54424, 1, "");
    (54406, 0, ",");
    (54407, 0, " ");
    (55993, 0, ",");
    (55994, 0, " ");
    (55995, 0, "S");
    (55996, 0, "e");
    (55997, 0, "l");
    (55998, 0, "f");
    (55999, 0, ":");
    (56000, 0, ":");
    (56001, 0, "n");
    (56002, 0, "o");
    (56001, 2, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56011, 18, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 1, "");
    (56011, 17, "");
    (56010, 1, "");
    (56010, 1, "");
    (55784, 20, "&");
    (55608, 20, "&");
    (55399, 20, "&");
    (54847, 20, "&");
    (55728, 0, "n");
    (55571, 0, "n");
    (55381, 0, "n");
    (54848, 0, "n");
    (55732, 0, "o");
    (55574, 0, "o");
    (55383, 0, "o");
    (54849, 0, "o");
    (55736, 0, "t");
    (55577, 0, "t");
    (55385, 0, "t");
    (54850, 0, "t");
    (55740, 0, "i");
    (55580, 0, "i");
    (55387, 0, "i");
    (54851, 0, "i");
    (55744, 0, "f");
    (55583, 0, "f");
    (55389, 0, "f");
    (54852, 0, "f");
    (55748, 0, "y");
    (55586, 0, "y");
    (55391, 0, "y");
    (54853, 0, "y");
    (55746, 0, "m");
    (55583, 0, "m");
    (55387, 0, "m");
    (54848, 0, "m");
    (55750, 0, "u");
    (55586, 0, "u");
    (55389, 0, "u");
    (54849, 0, "u");
    (55754, 0, "t");
    (55589, 0, "t");
    (55391, 0, "t");
    (54850, 0, "t");
    (55758, 0, " ");
    (55592, 0, " ");
    (55393, 0, " ");
    (54851, 0, " ");
    (21405, 0, ",");
    (21406, 0, " ");
    (21407, 0, "S");
    (21408, 0, "e");
    (21409, 0, "l");
    (21410, 0, "f");
    (21411, 0, ":");
    (21412, 0, ":");
    (21413, 0, "n");
    (21414, 0, "o");
    (21413, 2, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (21422, 44, "");
    (56641, 0, "\n    ");
    (56646, 0, "\n    ");
    (56642, 4, "");
    (56647, 0, "p");
    (56648, 0, "u");
    (56649, 0, "b");
    (56650, 0, " ");
    (56651, 0, "f");
    (56652, 0, "n");
    (56653, 0, " ");
    (56654, 0, "e");
    (56655, 0, "i");
    (56656, 0, "d");
    (56656, 1, "");
    (56655, 1, "");
    (56655, 0, "d");
    (56656, 0, "i");
    (56657, 0, "t");
    (56658, 0, "(");
    (56659, 0, "&");
    (56660, 0, "m");
    (56661, 0, "u");
    (56662, 0, "t");
    (56663, 0, " ");
    (56664, 0, "s");
    (56665, 0, "e");
    (56666, 0, "l");
    (56667, 0, "f");
    (56668, 0, ")");
    (56668, 0, ",");
    (56669, 0, " ");
    (56658, 0, "<");
    (56659, 0, "R");
    (56660, 0, ">");
    (56674, 0, " ");
    (56675, 0, "-");
    (56676, 0, ">");
    (56677, 0, " ");
    (56678, 0, "R");
    (56659, 0, "F");
    (56660, 0, ",");
    (56661, 0, " ");
    (56676, 0, "f");
    (56677, 0, ":");
    (56678, 0, " ");
    (56679, 0, "F");
    (56686, 0, " ");
    (56686, 1, "");
    (56686, 0, "\n    ");
    (56691, 0, "w");
    (56692, 0, "h");
    (56693, 0, "e");
    (56694, 0, "r");
    (56695, 0, "e");
    (56696, 0, " ");
    (56697, 0, "F");
    (56698, 0, ":");
    (56699, 0, " ");
    (56700, 0, "F");
    (56701, 0, "n");
    (56702, 0, "O");
    (56703, 0, "n");
    (56700, 4, "FnOnce");
    (56706, 0, "(");
    (56707, 0, "E");
    (56708, 0, "d");
    (56709, 0, "i");
    (56710, 0, "t");
    (56711, 0, "<");
    (56712, 0, "C");
    (56713, 0, ">");
    (56714, 0, ")");
    (56707, 0, "&");
    (56708, 0, "m");
    (56709, 0, "u");
    (56710, 0, "t");
    (56711, 0, " ");
    (56720, 0, " ");
    (56721, 0, "{");
    (56722, 0, "\n        ");
    (56731, 0, "\n        ");
    (56723, 8, "");
    (56724, 8, "    }");
    (56723, 0, "        ");
    (56723, 8, "");
    (56675, 0, " ");
    (56676, 0, "u");
    (56677, 0, "s");
    (56678, 0, "e");
    (56679, 0, "r");
    (56680, 0, "p");
    (56681, 0, "o");
    (56682, 0, "s");
    (56683, 0, ":");
    (56684, 0, " ");
    (56685, 0, "u");
    (56686, 0, "s");
    (56687, 0, "i");
    (56688, 0, "z");
    (56689, 0, "e");
    (56690, 0, ",");
    (57754, 0, "\n");
    (57755, 0, "\n");
    (57756, 0, "\n");
    (57757, 0, "\n");
    (57758, 0, "\n");
    (57755, 0, "s");
    (57756, 0, "t");
    (57757, 0, "r");
    (57758, 0, "u");
    (57759, 0, "c");
    (57760, 0, "t");
    (57761, 0, " ");
    (57762, 0, "E");
    (57763, 0, "d");
    (57764, 0, "i");
    (57765, 0, "t");
    (57766, 0, " ");
    (57755, 0, "p");
    (57756, 0, "u");
    (57757, 0, "b");
    (57758, 0, " ");
    (57771, 0, "{");
    (57772, 0, "\n    ");
    (57777, 0, "\n    ");
    (57773, 4, "");
    (57774, 4, "}");
    (57773, 0, "    ");
    (57777, 0, "&");
    (57777, 1, "");
    (57777, 0, "l");
    (57778, 0, "i");
    (57779, 0, "s");
    (57780, 0, "t");
    (57781, 0, ":");
    (57782, 0, " ");
    (57783, 0, "&");
    (57784, 0, "m");
    (57785, 0, "u");
    (57786, 0, "t");
    (57787, 0, " ");
    (57770, 0, "<");
    (57771, 0, "'");
    (57772, 0, "a");
    (57773, 0, ">");
    (57788, 0, "'");
    (57789, 0, "a");
    (57790, 0, " ");
    (57795, 0, "C");
    (57796, 0, "R");
    (57797, 0, "D");
    (57798, 0, "T");
    (57795, 4, "S");
    (57796, 0, "k");
    (57797, 0, "i");
    (57798, 0, "l");
    (57795, 4, "SkipList");
    (57773, 0, ",");
    (57774, 0, " ");
    (57775, 0, "C");
    (57776, 0, ":");
    (57777, 0, " ");
    (57778, 0, "L");
    (57779, 0, "i");
    (57780, 0, "s");
    (57778, 3, "ListConfig");
    (57818, 0, "<");
    (57819, 0, "C");
    (57820, 0, ">");
    (57821, 0, ",");
    (57822, 0, "\n    ");
    (57827, 0, "c");
    (57828, 0, "u");
    (57829, 0, "r");
    (57830, 0, "s");
    (57831, 0, "o");
    (57832, 0, "r");
    (57833, 0, ":");
    (57834, 0, " ");
    (57835, 0, "C");
    (57836, 0, "u");
    (57837, 0, "r");
    (57835, 3, "Cursor");
    (57841, 0, "<");
    (57842, 0, "C");
    (57843, 0, ">");
    (57844, 0, ",");
    (57845, 0, "\n    ");
    (57850, 0, "l");
    (57851, 0, "o");
    (57852, 0, "c");
    (57853, 0, "a");
    (57854, 0, "l");
    (57855, 0, "_");
    (57856, 0, "o");
    (57857, 0, "f");
    (57858, 0, "f");
    (57859, 0, "s");
    (57860, 0, "e");
    (57861, 0, "t");
    (57862, 0, ":");
    (57863, 0, " ");
    (57864, 0, "u");
    (57865, 0, "s");
    (57866, 0, "i");
    (57867, 0, "z");
    (57868, 0, "e");
    (57869, 0, ",");
    (57870, 0, " ");
    (57871, 0, "/");
    (57872, 0, "/");
    (57873, 0, " ");
    (57874, 0, "O");
    (57875, 0, "f");
    (57876, 0, "f");
    (57877, 0, "s");
    (57878, 0, "e");
    (57879, 0, "t");
    (57880, 0, " ");
    (57881, 0, "i");
    (57882, 0, "n");
    (57883, 0, "t");
    (57884, 0, "o");
    (57885, 0, " ");
    (57886, 0, "t");
    (57887, 0, "h");
    (57888, 0, "e");
    (57889, 0, " ");
    (57890, 0, "c");
    (57891, 0, "u");
    (57892, 0, "r");
    (57893, 0, "r");
    (57894, 0, "e");
    (57895, 0, "n");
    (57896, 0, "t");
    (57897, 0, " ");
    (57898, 0, "i");
    (57899, 0, "t");
    (57900, 0, "e");
    (57901, 0, "m");
    (57902, 0, ".");
    (57907, 0, "i");
    (57908, 0, "m");
    (57909, 0, "p");
    (57910, 0, "l");
    (57911, 0, " ");
    (57912, 0, "E");
    (57913, 0, "d");
    (57914, 0, "i");
    (57915, 0, "t");
    (57911, 0, "<");
    (57912, 0, "'");
    (57913, 0, "a");
    (57914, 0, ",");
    (57915, 0, " ");
    (57916, 0, "C");
    (57917, 0, ":");
    (57918, 0, " ");
    (57919, 0, "L");
    (57920, 0, "i");
    (57921, 0, "s");
    (57922, 0, "t");
    (57919, 4, "ListConfig");
    (57929, 0, ">");
    (57935, 0, "<");
    (57936, 0, "'");
    (57937, 0, "a");
    (57938, 0, ",");
    (57939, 0, " ");
    (57940, 0, "C");
    (57941, 0, ">");
    (57942, 0, " ");
    (57943, 0, "{");
    (57944, 0, "\n    ");
    (57949, 0, "\n    ");
    (57945, 4, "");
    (57946, 4, "}");
    (56739, 0, "        ");
    (56747, 0, "l");
    (56748, 0, "e");
    (56749, 0, "t");
    (56750, 0, " ");
    (56751, 0, "e");
    (56752, 0, "d");
    (56753, 0, "i");
    (56754, 0, "t");
    (56755, 0, " ");
    (56756, 0, "=");
    (56757, 0, " ");
    (56758, 0, "E");
    (56759, 0, "d");
    (56760, 0, "i");
    (56761, 0, "t");
    (56762, 0, " ");
    (56763, 0, "{");
    (56764, 0, "\n            ");
    (56765, 12, "        }");
    (56764, 0, "\n            ");
    (56777, 0, "l");
    (56778, 0, "i");
    (56779, 0, "s");
    (56780, 0, "t");
    (56781, 0, ":");
    (56782, 0, " ");
    (56783, 0, "s");
    (56784, 0, "e");
    (56785, 0, "l");
    (56786, 0, "f");
    (56787, 0, ",");
    (56788, 0, "\n            ");
    (56801, 0, "c");
    (56802, 0, "u");
    (56803, 0, "r");
    (56804, 0, "s");
    (56805, 0, "o");
    (56806, 0, "r");
    (56807, 0, ":");
    (56808, 0, " ");
    (56809, 0, "c");
    (56810, 0, "u");
    (56811, 0, "r");
    (56812, 0, "s");
    (56809, 4, "t");
    (56810, 0, "h");
    (56811, 0, "i");
    (56812, 0, "s");
    (56813, 0, ".");
    (56814, 0, "c");
    (56809, 6, "s");
    (56810, 0, "e");
    (56811, 0, "l");
    (56812, 0, "f");
    (56813, 0, ".");
    (56814, 0, "c");
    (56815, 0, "u");
    (56816, 0, "r");
    (56816, 1, "");
    (56815, 1, "");
    (56738, 0, "\n        ");
    (56747, 0, "l");
    (56748, 0, "e");
    (56749, 0, "t");
    (56750, 0, " ");
    (56751, 0, "(");
    (56752, 0, "c");
    (56753, 0, "u");
    (56754, 0, "r");
    (56755, 0, "s");
    (56756, 0, "o");
    (56757, 0, "r");
    (56758, 0, ",");
    (56759, 0, " ");
    (56760, 0, "o");
    (56761, 0, "f");
    (56762, 0, "f");
    (56763, 0, "s");
    (56764, 0, "e");
    (56765, 0, "t");
    (56766, 0, ")");
    (56767, 0, " ");
    (56768, 0, "=");
    (56769, 0, " ");
    (56770, 0, "s");
    (56771, 0, "e");
    (56772, 0, "l");
    (56773, 0, "f");
    (56774, 0, ".");
    (56775, 0, "i");
    (56776, 0, "t");
    (56777, 0, "e");
    (56778, 0, "r");
    (56779, 0, "_");
    (56775, 5, "iter_at_userpos(target_userpos: usize)");
    (56791, 21, "u");
    (56792, 0, "s");
    (56793, 0, "e");
    (56794, 0, "r");
    (56795, 0, "p");
    (56796, 0, "o");
    (56797, 0, "s");
    (56799, 0, ";");
    (56871, 6, "c");
    (56872, 0, "u");
    (56873, 0, "r");
    (56874, 0, "s");
    (56875, 0, "o");
    (56876, 0, "r");
    (56877, 0, ",");
    (56878, 0, "\n            ");
    (56891, 0, "l");
    (56892, 0, "o");
    (56893, 0, "c");
    (56894, 0, "a");
    (56895, 0, "l");
    (56891, 5, "local_offset");
    (56903, 0, ":");
    (56904, 0, " ");
    (56905, 0, "o");
    (56906, 0, "f");
    (56907, 0, "f");
    (56908, 0, "s");
    (56909, 0, "e");
    (56910, 0, "t");
    (56921, 0, ";");
    (56922, 0, "\n        ");
    (56931, 0, "\n        ");
    (56923, 8, "");
    (56932, 0, "f");
    (56933, 0, "(");
    (56934, 0, "e");
    (56935, 0, "d");
    (56936, 0, "i");
    (56937, 0, "t");
    (56938, 0, ")");
    (56934, 0, "*");
    (56934, 1, "");
    (56934, 0, "&");
    (56935, 0, "m");
    (56936, 0, "u");
    (56937, 0, "t");
    (56938, 0, " ");
    (56736, 0, " ");
    (56737, 0, "-");
    (56738, 0, ">");
    (56739, 0, " ");
    (56740, 0, "R");
    (56817, 0, " ");
    (56818, 0, "m");
    (56819, 0, "u");
    (56820, 0, "t");
    (56821, 0, " ");
    (56821, 1, "");
    (56932, 0, "\n        ");
    (56941, 0, "/");
    (56942, 0, "/");
    (56943, 0, " ");
    (56944, 0, "T");
    (56945, 0, "O");
    (56946, 0, "D");
    (56947, 0, "O");
    (56948, 0, ":");
    (56949, 0, " ");
    (56950, 0, "O");
    (56951, 0, "r");
    (56952, 0, " ");
    (56953, 0, "m");
    (56954, 0, "a");
    (56955, 0, "y");
    (56956, 0, "b");
    (56957, 0, "e");
    (56958, 0, " ");
    (56959, 0, "I");
    (56960, 0, " ");
    (56961, 0, "s");
    (56962, 0, "h");
    (56963, 0, "o");
    (56964, 0, "u");
    (56965, 0, "l");
    (56966, 0, "d");
    (56967, 0, " ");
    (56968, 0, "p");
    (56969, 0, "a");
    (56970, 0, "s");
    (56971, 0, "s");
    (56972, 0, " ");
    (56973, 0, "o");
    (56974, 0, "w");
    (56975, 0, "n");
    (56976, 0, "e");
    (56977, 0, "r");
    (56978, 0, "s");
    (56979, 0, "h");
    (56980, 0, "i");
    (56981, 0, "p");
    (56982, 0, " ");
    (56983, 0, "h");
    (56984, 0, "e");
    (56985, 0, "r");
    (56986, 0, "e");
    (56987, 0, "?");
    (55999, 643, "");
    ( 57572,
      0,
      "\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.iter_at_userpos(userpos);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n" );
    (57572, 643, "");
    ( 55999,
      0,
      "\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.iter_at_userpos(userpos);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n" );
    (56640, 0, "// ");
    (56630, 0, "// ");
    (56557, 0, "// ");
    (56500, 0, "// ");
    (56464, 0, "// ");
    (56402, 0, "// ");
    (56333, 0, "// ");
    (56267, 0, "// ");
    (56228, 0, "// ");
    (56168, 0, "// ");
    (56125, 0, "// ");
    (56073, 0, "// ");
    (56004, 0, "// ");
    ( 58254,
      0,
      "\n\
      \    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        // We can't easily trim num_items.\n\
      \        // num_items = min(length, self.num_chars() - pos);\n\
      \        if num_items == 0 { return; }\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.iter_at_userpos(userpos);\n\
      \            if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n" );
    (58282, 20, "");
    (58304, 194, "");
    (58304, 66, "");
    (58304, 68, "");
    ( 58304,
      0,
      "        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n"
    );
    (58323, 0, "s");
    (58324, 0, "e");
    (58325, 0, "l");
    (58326, 0, "f");
    (58327, 0, ".");
    (58328, 0, "l");
    (58329, 0, "o");
    (58330, 0, "c");
    (58331, 0, "a");
    (58332, 0, "l");
    (58333, 0, "_");
    (58328, 5, "item");
    (58159, 5, "item");
    (56939, 5, "item");
    (58402, 0, ".");
    (58403, 0, "l");
    (58404, 0, "i");
    (58405, 0, "s");
    (58406, 0, "t");
    (58425, 6, "s");
    (58426, 0, "e");
    (58427, 0, "l");
    (58428, 0, "f");
    (58429, 0, ".");
    (58430, 0, "c");
    (58431, 0, "u");
    (58432, 0, "r");
    (58433, 0, "s");
    (58434, 0, "o");
    (58435, 0, "r");
    (58515, 4, "s");
    (58516, 0, "e");
    (58517, 0, "l");
    (58518, 0, "f");
    (58519, 0, ".");
    (58520, 0, "l");
    (58521, 0, "i");
    (58522, 0, "s");
    (58523, 0, "t");
    (58541, 7, "s");
    (58542, 0, "e");
    (58543, 0, "l");
    (58544, 0, "f");
    (58545, 0, ".");
    (58541, 5, "userpos");
    (58632, 0, "// ");
    (58559, 0, "// ");
    (58497, 0, "// ");
    (58461, 0, "// ");
    (58421, 3, "");
    (58421, 1, "");
    (43534, 4, "");
    (58445, 193, "");
    (58444, 1, "");
    (58248, 1, "");
    (58442, 0, "\n        ");
    (58451, 0, "\n        ");
    (58443, 8, "");
    (58452, 0, "/");
    (58453, 0, "/");
    (58454, 0, " ");
    (58455, 0, "T");
    (58456, 0, "O");
    (58457, 0, "D");
    (58458, 0, "O");
    (58459, 0, ":");
    (58460, 0, " ");
    (58461, 0, "C");
    (58462, 0, "h");
    (58463, 0, "e");
    (58464, 0, "c");
    (58465, 0, "k");
    (58466, 0, " ");
    (58467, 0, "t");
    (58468, 0, "h");
    (58469, 0, "e");
    (58470, 0, " ");
    (58471, 0, "c");
    (58472, 0, "u");
    (58473, 0, "r");
    (58474, 0, "s");
    (58475, 0, "o");
    (58476, 0, "r");
    (58477, 0, " ");
    (58478, 0, "i");
    (58479, 0, "s");
    (58480, 0, " ");
    (58481, 0, "s");
    (58482, 0, "t");
    (58483, 0, "i");
    (58484, 0, "l");
    (58485, 0, "l");
    (58486, 0, " ");
    (58487, 0, "v");
    (58488, 0, "a");
    (58489, 0, "l");
    (58490, 0, "i");
    (58491, 0, "d");
    (58492, 0, "?");
    (56676, 0, "\n    ");
    (56681, 0, "\n    ");
    (56677, 4, "");
    (56682, 0, "pub fn del_at(&mut self, mut userpos: usize, num_items: usize)");
    (56744, 0, " ");
    (56745, 0, "{");
    (56746, 0, "\n        ");
    (56755, 0, "\n        ");
    (56747, 8, "");
    (56748, 8, "    }");
    (56747, 0, "        ");
    (56755, 0, "s");
    (56756, 0, "e");
    (56757, 0, "l");
    (56758, 0, "f");
    (56759, 0, ".");
    (56760, 0, "e");
    (56761, 0, "d");
    (56762, 0, "i");
    (56763, 0, "t");
    (56764, 0, "(");
    (56765, 0, "u");
    (56766, 0, "s");
    (56767, 0, "e");
    (56768, 0, "r");
    (56769, 0, "p");
    (56770, 0, "o");
    (56771, 0, "s");
    (56772, 0, ",");
    (56773, 0, " ");
    (56774, 0, "|");
    (56775, 0, "e");
    (56776, 0, "d");
    (56777, 0, "i");
    (56778, 0, "t");
    (56779, 0, "|");
    (56780, 0, " ");
    (56781, 0, "{");
    (56782, 0, "\n            ");
    (56795, 0, "\n            ");
    (56783, 12, "");
    (56784, 12, "        }");
    (56793, 0, ")");
    (56783, 0, "            ");
    (56795, 0, "e");
    (56796, 0, "d");
    (56797, 0, "i");
    (56798, 0, "t");
    (56799, 0, ".");
    (56800, 0, "d");
    (56801, 0, "e");
    (56802, 0, "l");
    (56803, 0, "_");
    (56804, 0, "a");
    (56805, 0, "t");
    (56806, 0, "(");
    (56807, 0, "n");
    (56808, 0, "u");
    (56809, 0, "m");
    (56810, 0, "_");
    (56811, 0, "i");
    (56812, 0, "t");
    (56813, 0, "e");
    (56814, 0, "m");
    (56815, 0, "s");
    (56816, 0, ")");
    (56817, 0, ";");
    (56707, 3, "");
    (56707, 1, "");
    (58598, 0, "\n        ");
    ( 58607,
      0,
      "\n\
      \    //     if cfg!(debug_assertions) {\n\
      \    //         let (c2, _) = self.iter_at_userpos(userpos);\n\
      \    //         if &cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \    //     }" );
    (58599, 8, "");
    (58779, 3, "");
    (58703, 3, "");
    (58643, 3, "");
    (58604, 3, "");
    (58683, 0, "s");
    (58684, 0, "e");
    (58685, 0, "l");
    (58686, 0, "f");
    (58687, 0, ".");
    (58688, 0, "c");
    (58689, 0, "u");
    (58690, 0, "r");
    (58691, 0, "s");
    (58692, 0, "o");
    (58693, 0, "r");
    (58694, 0, ".");
    (58666, 0, ".");
    (58667, 0, "l");
    (58668, 0, "i");
    (58669, 0, "s");
    (58670, 0, "t");
    (58671, 0, ".");
    (58671, 1, "");
    (58726, 0, "s");
    (58727, 0, "e");
    (58728, 0, "l");
    (58729, 0, "f");
    (58730, 0, ".");
    (58597, 1, "");
    (58797, 50, "");
    (55995, 682, "");
    (55813, 0, "// ");
    (55802, 0, "// ");
    (55788, 0, "// ");
    (55703, 0, "// ");
    (55622, 0, "// ");
    (55543, 0, "// ");
    (55503, 0, "// ");
    (55422, 0, "// ");
    (55353, 0, "// ");
    (55280, 0, "// ");
    (55211, 0, "// ");
    (55181, 0, "// ");
    (55110, 0, "// ");
    (55038, 0, "// ");
    (54980, 0, "// ");
    (54959, 0, "// ");
    (54879, 0, "// ");
    (54800, 0, "// ");
    (54771, 0, "// ");
    (54754, 0, "// ");
    (54687, 0, "// ");
    (54635, 0, "// ");
    (54577, 0, "// ");
    (54534, 0, "// ");
    (54445, 0, "// ");
    (54345, 0, "// ");
    (55888, 3, "");
    (55874, 3, "");
    (55857, 3, "");
    (55769, 3, "");
    (55685, 3, "");
    (55603, 3, "");
    (55560, 3, "");
    (55476, 3, "");
    (55404, 3, "");
    (55328, 3, "");
    (55256, 3, "");
    (55223, 3, "");
    (55149, 3, "");
    (55074, 3, "");
    (55013, 3, "");
    (54989, 3, "");
    (54906, 3, "");
    (54824, 3, "");
    (54792, 3, "");
    (54772, 3, "");
    (54702, 3, "");
    (54647, 3, "");
    (54586, 3, "");
    (54540, 3, "");
    (54448, 3, "");
    (54345, 3, "");
    ( 56251,
      0,
      "\n\
      \    pub fn edit<F, R>(&mut self, userpos: usize, f: F) -> R\n\
      \    where F: FnOnce(&mut Edit<C>) -> R {" );
    (56215, 0, "// ");
    (56155, 0, "// ");
    (56306, 0, " ");
    (56307, 0, "n");
    (56308, 0, "o");
    (56309, 0, "t");
    (56310, 0, "i");
    (56311, 0, "f");
    (56312, 0, "y");
    (56313, 0, ":");
    (56314, 0, " ");
    (56315, 0, "N");
    (56316, 0, "o");
    (56317, 0, "t");
    (56318, 0, "i");
    (56319, 0, "f");
    (56320, 0, "y");
    (56321, 0, ",");
    (56274, 0, "N");
    (56275, 0, "o");
    (56276, 0, "t");
    (56277, 0, "i");
    (56278, 0, "f");
    (56279, 0, "y");
    (56280, 0, ",");
    (56281, 0, " ");
    (56346, 0, "where Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (56392, 6, " ");
    (56392, 1, "");
    (56392, 0, ",");
    (56393, 0, " ");
    (56273, 0, ")");
    (56274, 0, "n");
    (56275, 0, "o");
    (56275, 1, "");
    (56274, 1, "");
    (56273, 1, "");
    (56273, 0, "_");
    (56274, 0, "n");
    (56275, 0, "o");
    (56276, 0, "t");
    (56277, 0, "i");
    (56278, 0, "f");
    (56279, 0, "y");
    (56218, 3, "");
    (56155, 3, "");
    (56251, 0, "\n        ");
    (56252, 8, "    }");
    (56251, 0, "\n        ");
    (56260, 0, "s");
    (56261, 0, "e");
    (56262, 0, "l");
    (56263, 0, "f");
    (56264, 0, ".");
    (56265, 0, "e");
    (56266, 0, "d");
    (56267, 0, "i");
    (56268, 0, "t");
    (56265, 4, "edit_notify(userpos: usize, notify: Notify, f: F)");
    (56277, 14, "u");
    (56278, 0, "s");
    (56279, 0, "e");
    (56280, 0, "r");
    (56281, 0, "p");
    (56282, 0, "o");
    (56283, 0, "s");
    (56286, 14, "S");
    (56287, 0, "e");
    (56288, 0, "l");
    (56289, 0, "f");
    (56290, 0, ":");
    (56291, 0, ":");
    (56292, 0, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56301, 50, "");
    (56301, 0, ",");
    (56302, 0, " ");
    (56303, 0, "f");
    (56311, 0, "\n    ");
    (57770, 0, "\n");
    (56312, 4, "");
    (57767, 0, "where Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (57773, 40, "");
    (57767, 6, "");
    (57766, 1, "");
    (57800, 0, ",");
    (57801, 0, " ");
    (57802, 0, "N");
    (57803, 0, "o");
    (57804, 0, "t");
    (57805, 0, "i");
    (57806, 0, "f");
    (57807, 0, "y");
    (57808, 0, ":");
    (57809, 0, " ");
    (57810, 0, "Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (57810, 40, "");
    (57802, 8, "Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (57956, 0, "\n    ");
    (57961, 0, "N");
    (57962, 0, "o");
    (57963, 0, "t");
    (57964, 0, "i");
    (57965, 0, "f");
    (57966, 0, "y");
    (57967, 0, ":");
    (57968, 0, " ");
    (57961, 0, "n");
    (57962, 0, "o");
    (57963, 0, "t");
    (57964, 0, "i");
    (57965, 0, "f");
    (57966, 0, "y");
    (57967, 0, ":");
    (57968, 0, " ");
    (57976, 1, "");
    (57975, 1, "");
    (58001, 0, ",");
    (58002, 0, " ");
    (58003, 0, "Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (58055, 0, ",");
    (58056, 0, " ");
    (58057, 0, "N");
    (58058, 0, "o");
    (58059, 0, "t");
    (58060, 0, "i");
    (58061, 0, "f");
    (58062, 0, "y");
    (56662, 0, ",");
    (56663, 0, "\n            ");
    (56676, 0, "n");
    (56677, 0, "o");
    (56678, 0, "t");
    (56679, 0, "i");
    (56680, 0, "f");
    (56681, 0, "y");
    (56621, 8, "");
    (56648, 0, "item_");
    (56508, 0, "item_");
    (56651, 13, "");
    (56584, 43, "            list: self, cursor,");
    (56584, 56, "            list: self, cursor, item_offset,");
    (56584, 63, "            list: self, cursor, item_offset, notify");
    ( 56554,
      81,
      "        let mut edit = Edit { list: self, cursor, item_offset, notify" );
    ( 56554,
      80,
      "        let mut edit = Edit { list: self, cursor, item_offset, notify };"
    );
    (56477, 0, ",");
    (56478, 0, " ");
    (56479, 0, "N");
    (56480, 0, "o");
    (56481, 0, "t");
    (56482, 0, "i");
    (56483, 0, "f");
    (56484, 0, "y");
    (56242, 0, ",");
    (56243, 0, " ");
    (56244, 0, "_");
    (56244, 1, "");
    (56244, 0, "S");
    (56245, 0, "e");
    (56246, 0, "l");
    (56247, 0, "f");
    (56248, 0, ":");
    (56249, 0, ":");
    (56250, 0, "no_notify(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56250, 53, "");
    (56250, 0, "n");
    (56251, 0, "o");
    (56252, 0, "_");
    (56253, 0, "n");
    (56254, 0, "o");
    (56255, 0, "t");
    (56256, 0, "i");
    (56257, 0, "f");
    (56258, 0, "y");
    (56244, 15, "");
    (56244, 0, "i");
    (56245, 0, "m");
    (56246, 0, "p");
    (56247, 0, "l");
    (56247, 1, "");
    (56246, 1, "");
    (56245, 1, "");
    (56244, 1, "");
    (56244, 0, "t");
    (56245, 0, "y");
    (56246, 0, "p");
    (56247, 0, "e");
    (56248, 0, "o");
    (56248, 1, "");
    (56248, 0, " ");
    (56248, 1, "");
    (56248, 0, "o");
    (56244, 5, "");
    (56244, 0, "impl");
    (56244, 4, "");
    (56244, 0, "Self::no_notify");
    (56244, 0, "t");
    (56245, 0, "y");
    (56246, 0, "p");
    (56247, 0, "e");
    (56248, 0, " ");
    (56171, 0, ",");
    (56172, 0, " ");
    (56173, 0, "N");
    (56174, 0, "o");
    (56175, 0, "t");
    (56176, 0, "i");
    (56177, 0, "f");
    (56178, 0, "y");
    (56171, 8, "");
    (56167, 0, "N");
    (56168, 0, "o");
    (56169, 0, "t");
    (56170, 0, "i");
    (56171, 0, "f");
    (56172, 0, "y");
    (56173, 0, ",");
    (56174, 0, " ");
    (56252, 20, "N");
    (56253, 0, "o");
    (56254, 0, "t");
    (56255, 0, "i");
    (56256, 0, "f");
    (56257, 0, "y");
    (56229, 0, "Notify: FnMut(&[C::Item], ItemMarker<C>), ");
    (56229, 42, "");
    (56252, 6, "type Self::no_notify");
    (56174, 1, "");
    (56167, 7, "");
    (56244, 5, "");
    (56244, 4, "");
    (56244, 0, "S");
    (56245, 0, "k");
    (56246, 0, "i");
    (56247, 0, "l");
    (56244, 4, "SkipList");
    (56252, 0, ":");
    (56253, 0, ":");
    (56254, 0, "<");
    (56255, 0, "C");
    (56256, 0, ">");
    (56253, 1, "");
    (56252, 1, "");
    (56251, 1, "");
    (56251, 0, "t");
    (56244, 0, "<");
    (56256, 0, ">");
    (56256, 0, " ");
    (56257, 0, "a");
    (56258, 0, "s");
    (56259, 0, " ");
    (56260, 0, "S");
    (56261, 0, "k");
    (56262, 0, "i");
    (56260, 3, "SkipList");
    (56268, 0, "<");
    (56269, 0, "C");
    (56270, 0, ">");
    (56268, 3, "");
    (56260, 8, "Ski");
    (56259, 4, "");
    (56256, 3, "");
    (56256, 1, "");
    (56244, 1, "");
    (20204, 0, "\n");
    ( 20205,
      0,
      "\n    pub fn no_notify(_items: &[C::Item], _marker: ItemMarker<C>) {}\n"
    );
    (20206, 4, "");
    (20222, 0, "<");
    (20223, 0, "C");
    (20224, 0, ":");
    (20225, 0, " ");
    (20226, 0, "L");
    (20227, 0, "i");
    (20228, 0, "s");
    (20229, 0, "t");
    (20226, 4, "ListConfig");
    (20236, 0, ">");
    (20222, 0, "_");
    (20223, 0, "x");
    (56327, 13, "");
    (56336, 0, "_");
    (56337, 0, "x");
    (56338, 0, "<");
    (56339, 0, "C");
    (56340, 0, ">");
    (56385, 15, "rustc --explain E0573");
    (56385, 21, "Self::no_notify");
    (56385, 15, "n");
    (56386, 0, "o");
    (56387, 0, "_");
    (56388, 0, "n");
    (56389, 0, "o");
    (56385, 5, "no_notify_x(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56415, 0, ">");
    (56397, 0, "<");
    (56398, 18, "C");
    (56399, 0, ">");
    (56398, 2, "_items: &[C::Item]");
    (56416, 1, "");
    (56397, 1, "");
    (56396, 44, "");
    (56396, 0, "<");
    (56397, 0, "C");
    (56398, 0, ">");
    (56396, 3, "");
    (56340, 1, "");
    (56339, 1, "");
    (56338, 1, "");
    (56238, 0, "// ");
    (56233, 0, "\n    ");
    ( 56238,
      0,
      "    pub fn edit_notify<Notify, F, R>(&mut self, userpos: usize, notify: \
       Notify, f: F) -> R\n\
      \    where Notify: FnMut(&[C::Item], ItemMarker<C>), F: FnOnce(&mut \
       Edit<C, Notify>) -> R {\n" );
    (56234, 8, "    ");
    (56484, 0, "// ");
    (56255, 1, "");
    (56254, 1, "");
    (56253, 1, "");
    (56252, 1, "");
    (56251, 1, "");
    (56250, 1, "");
    (56249, 1, "");
    (56289, 16, "");
    (56559, 0, "<");
    (56560, 0, "C");
    (56561, 0, ">");
    (56559, 0, ":");
    (56560, 0, ":");
    (56306, 0, "// ");
    (56238, 0, "// ");
    (56467, 3, "");
    (56404, 3, "");
    (56504, 0, ":");
    (56505, 0, ":");
    (56506, 0, "<");
    (56507, 0, "C");
    (56508, 0, ">");
    (56505, 1, "");
    (56504, 1, "");
    (56493, 15, "");
    (56493, 0, "_");
    (56494, 0, ">");
    (56493, 1, "");
    (56493, 0, "C");
    (56493, 1, "");
    (56493, 0, "u");
    (56494, 0, "2");
    (56495, 0, "3");
    (56495, 1, "");
    (56494, 1, "");
    (56494, 0, "3");
    (56495, 0, "2");
    (56514, 0, "// ");
    (56563, 0, "\n        ");
    ( 56572,
      0,
      "        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        let mut edit = Edit { list: self, cursor, item_offset, notify \
       };\n\n\
      \        // TODO: Or maybe I should pass ownership here?\n\
      \        f(&mut edit)\n" );
    (56564, 16, "        ");
    (56694, 6, "n");
    (56695, 0, "o");
    (56696, 0, "_");
    (56697, 0, "n");
    (56698, 0, "o");
    (56694, 5, "no_notify_x(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56724, 0, ">");
    (56706, 0, "<");
    (56725, 1, "");
    (56706, 1, "");
    (56705, 44, "");
    (56705, 0, "<");
    (56706, 0, "C");
    (56707, 0, ">");
    (56705, 0, ":");
    (56706, 0, ":");
    (56694, 0, "n");
    (56695, 0, "o");
    (56696, 0, "t");
    (56697, 0, "i");
    (56698, 0, "f");
    (56699, 0, "y");
    (56700, 0, ":");
    (56701, 0, " ");
    ( 56493,
      3,
      "for<'r> fn(&'r [<C as skiplist::ListConfig>::Item], \
       skiplist::ItemMarker<C>) {skiplist::no_notify_x::<C>}" );
    (56570, 28, "");
    (56569, 1, "");
    (56545, 10, "");
    (56515, 10, "");
    (56755, 0, "&");
    (56549, 0, " ");
    (56550, 0, "{no_notify_x::<C>}");
    (56493, 0, "&");
    (56420, 0, ",");
    (56421, 0, " ");
    (56422, 0, "N");
    (56423, 0, "N");
    (56497, 0, "N");
    (56498, 0, ")");
    (56498, 0, ">");
    (56500, 0, ",");
    (56501, 0, " ");
    (56502, 0, "N");
    (56503, 0, ":");
    (56504, 0, " ");
    (56587, 1, "");
    (56586, 1, "");
    (56585, 1, "");
    (56584, 1, "");
    (56583, 1, "");
    (56582, 1, "");
    (56500, 0, " ");
    (56501, 0, "-");
    (56502, 0, ">");
    (56503, 0, " ");
    (56504, 0, "R");
    (56506, 1, "");
    (56506, 0, "\n    ");
    (56590, 1, "");
    (56514, 1, "");
    (56498, 0, "N");
    (56512, 0, "N");
    (56516, 0, "&");
    (56516, 1, "");
    (56516, 58, "");
    (56532, 1, "");
    (56532, 0, "}");
    (56516, 0, "for<'r> fn(&'r [<C as ListConfig>::Item], ItemMarker<C>) {");
    (56524, 49, "");
    (56524, 1, "");
    (56540, 1, "");
    (56843, 0, "// ");
    (56821, 0, "// ");
    (56765, 0, "// ");
    (56672, 0, "// ");
    (56605, 0, "// ");
    (56547, 0, "// ");
    (56512, 0, "// ");
    (56468, 0, "// ");
    (56404, 0, "// ");
    (57191, 0, ":");
    (57192, 0, " ");
    (57193, 0, "n");
    (57194, 0, "o");
    (57193, 2, "no_notify_x(_items: &[C::Item], _marker: ItemMarker<C>)");
    (57193, 55, "no");
    (57195, 0, "n");
    (57195, 1, "");
    (57195, 0, "_");
    (57196, 0, "n");
    (57197, 0, "o");
    (57198, 0, "t");
    (57199, 0, "i");
    (57200, 0, "f");
    (57201, 0, "y");
    (57202, 0, "_");
    (57203, 0, "x");
    (57204, 0, "<");
    (57205, 0, "C");
    (57206, 0, ">");
    (57204, 0, ":");
    (57205, 0, ":");
    (57204, 2, "");
    (57195, 12, "");
    (57195, 0, "n");
    (57195, 1, "");
    (57192, 3, "");
    (57191, 1, "");
    (56867, 3, "");
    (56842, 3, "");
    (56783, 3, "");
    (56687, 3, "");
    (56617, 3, "");
    (56556, 3, "");
    (56518, 3, "");
    (56471, 3, "");
    (56404, 3, "");
    ( 56516,
      24,
      "for<'r> fn(&'r [<C as skiplist::ListConfig>::Item], \
       skiplist::ItemMarker<C>) {skiplist::no_notify_x::<C>}" );
    (56594, 10, "");
    (56568, 10, "");
    (56538, 10, "");
    (56516, 8, "");
    (56516, 67, "");
    (56516, 0, "i");
    (56517, 0, "m");
    (56518, 0, "p");
    (56519, 0, "l");
    (56520, 0, " ");
    (56521, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    ( 56464,
      91,
      "    where F: FnOnce(&mut Edit<C, NN>) -> R, NN: impl FnMut(&[C::Item], \
       ItemMarker<C>) {" );
    ( 56464,
      87,
      "    where F: FnOnce(&mut Edit<C, NN>) -> R,\n\
      \    NN: impl FnMut(&[C::Item], ItemMarker<C>) {" );
    (56516, 5, "");
    (56747, 1, "");
    (56423, 1, "");
    (56422, 1, "");
    (56421, 1, "");
    (56420, 1, "");
    (56502, 43, "");
    (56502, 0, " ");
    (56502, 1, "");
    (56502, 0, ",\n    NN: FnMut(&[C::Item], ItemMarker<C>) ");
    (56512, 32, "");
    (56508, 4, "");
    (56504, 4, "");
    (56503, 1, "");
    (56502, 1, "");
    (56493, 2, "i");
    (56494, 0, "m");
    (56495, 0, "p");
    (56496, 0, "l");
    (56497, 0, " ");
    (56498, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    (56493, 5, "");
    (56493, 0, "d");
    (56494, 0, "y");
    (56495, 0, "n");
    (56496, 0, " ");
    (56838, 0, "// ");
    (56816, 0, "// ");
    (56760, 0, "// ");
    (56668, 0, "// ");
    (56601, 0, "// ");
    (56543, 0, "// ");
    (56464, 0, "// ");
    (56404, 0, "// ");
    (58489, 0, "// ");
    (58470, 0, "// ");
    (58413, 0, "// ");
    (58390, 0, "// ");
    (58359, 0, "// ");
    (58280, 0, "// ");
    ( 58280,
      0,
      "// pub struct Edit<'a, C: ListConfig, Notify: FnMut(&[C::Item], \
       ItemMarker<C>)> {\n\
       //     list: &'a mut SkipList<C>,\n\
       //     cursor: Cursor<C>,\n\
       //     item_offset: usize, // Offset into the current item.\n\
       //     notify: Notify\n\
       // }\n" );
    (58733, 3, "");
    (58711, 3, "");
    (58651, 3, "");
    (58625, 3, "");
    (58591, 3, "");
    (58509, 3, "");
    (58542, 42, "");
    (58542, 0, ", Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (58542, 42, "");
    (58669, 6, ", Notify: FnMut(&[C::Item], ItemMarker<C>)");
    (58669, 15, "f");
    (58670, 0, "n");
    ( 58789,
      0,
      "\n\
       impl<'a, C: ListConfig, Notify: FnMut(&[C::Item], ItemMarker<C>)> \
       Edit<'a, C, Notify> {" );
    (58702, 0, "// ");
    (58869, 8, "");
    (57269, 0, "// ");
    (57248, 0, "// ");
    (57192, 0, "// ");
    (57118, 0, "// ");
    (57051, 0, "// ");
    (56960, 0, "// ");
    (56869, 0, "// ");
    (56859, 3, "");
    (56834, 3, "");
    (56775, 3, "");
    (56680, 3, "");
    (56610, 3, "");
    (56549, 3, "");
    (56467, 3, "");
    (56404, 3, "");
    (56493, 9, "f");
    (56494, 0, "n");
    (56491, 31, "");
    ( 58831,
      0,
      "\n\
       impl<'a, C: ListConfig, Notify: FnMut(&[C::Item], ItemMarker<C>)> \
       Edit<'a, C> {" );
    (58752, 0, "// ");
    (58752, 3, "");
    (58831, 80, "");
    (58774, 42, "");
    (56794, 1, "");
    ( 56802,
      0,
      "    // pub fn edit_notify<Notify, F, R>(&mut self, userpos: usize, \
       notify: Notify, f: F) -> R\n\
      \    // where Notify: FnMut(&[C::Item], ItemMarker<C>), F: FnOnce(&mut \
       Edit<C, Notify>) -> R {\n\
      \    //     let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \    //     let mut edit = Edit { list: self, cursor, item_offset, \
       notify };\n\n\
      \    //     // TODO: Or maybe I should pass ownership here?\n\
      \    //     f(&mut edit)\n\
      \    // }\n" );
    (57651, 3, "");
    (57627, 3, "");
    (57568, 3, "");
    (57491, 3, "");
    (57421, 3, "");
    (57327, 3, "");
    (57233, 3, "");
    (57393, 8, "");
    (57252, 8, "");
    (57322, 42, "");
    (57322, 0, "Notify: FnMut(&[C::Item], ItemMarker<C>), ");
    (57252, 0, "Notify, ");
    (57338, 5, "f");
    (57339, 0, "n");
    (57338, 29, "");
    (57330, 8, "");
    (57330, 1, "");
    (57330, 1, "");
    (57301, 6, "fn(&[C::Item], ItemMarker<C>)");
    (53196, 0, "// ");
    (53118, 0, "// ");
    (53008, 0, "// ");
    (52951, 0, "// ");
    (52882, 0, "// ");
    (52810, 0, "// ");
    (52745, 0, "// ");
    (52593, 0, "// ");
    (53217, 3, "");
    (53136, 3, "");
    (53023, 3, "");
    (52963, 3, "");
    (52891, 3, "");
    (52816, 3, "");
    (52748, 3, "");
    (52593, 3, "");
    (60918, 0, "\n    ");
    (60923, 0, "\n    ");
    (60919, 4, "");
    ( 60924,
      0,
      "\n\
      \    pub fn replace_at<I>(&mut self, mut start_userpos: usize, \
       removed_items: usize, mut inserted_content: I) where I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        let num_inserted_items = inserted_content.len();\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, &mut \
       inserted_content, Self::no_notify); }\n\n\
      \        self.dbg_check_cursor_at(&cursor, start_userpos, \
       num_inserted_items);\n\
      \    }" );
    (60920, 4, "");
    (60919, 1, "");
    (60918, 1, "");
    (60918, 0, "\n    ");
    (60918, 614, "");
    ( 59568,
      0,
      "\n\
      \    \n\
      \    pub fn replace_at<I>(&mut self, mut start_userpos: usize, \
       removed_items: usize, mut inserted_content: I) where I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        start_userpos = min(start_userpos, self.get_userlen());\n\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n\
      \        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n\
      \        let num_inserted_items = inserted_content.len();\n\
      \        unsafe { self.replace_at_iter(&mut cursor, removed_items, &mut \
       inserted_content, Self::no_notify); }\n\n\
      \        self.dbg_check_cursor_at(&cursor, start_userpos, \
       num_inserted_items);\n\
      \    }" );
    (59569, 4, "");
    (59606, 26, "");
    (59652, 1, "");
    (59652, 0, "\n    ");
    (59700, 65, "");
    (59700, 72, "");
    (59719, 0, "s");
    (59720, 0, "e");
    (59721, 0, "l");
    (59722, 0, "f");
    (59723, 0, ".");
    (59724, 0, "i");
    (59725, 0, "t");
    (59726, 0, "e");
    (59727, 0, "m");
    (59728, 0, "_");
    (59857, 0, ".");
    (59858, 0, "l");
    (59859, 0, "i");
    (59860, 0, "s");
    (59861, 0, "t");
    (59930, 15, "");
    (59930, 0, "s");
    (59931, 0, "e");
    (59932, 0, "l");
    (59933, 0, "f");
    (59934, 0, ".");
    (59935, 0, "n");
    (59936, 0, "o");
    (59937, 0, "t");
    (59938, 0, "i");
    (59939, 0, "f");
    (59940, 0, "y");
    (59884, 0, "s");
    (59885, 0, "e");
    (59886, 0, "l");
    (59887, 0, "f");
    (59888, 0, ".");
    (59960, 0, "// ");
    (59960, 3, "");
    (59964, 0, ".");
    (59965, 0, "l");
    (59966, 0, "i");
    (59967, 0, "s");
    (59968, 0, "t");
    (59991, 0, "s");
    (59992, 0, "e");
    (59993, 0, "l");
    (59994, 0, "f");
    (59995, 0, ".");
    (60004, 13, "s");
    (60005, 0, "e");
    (60006, 0, "l");
    (60007, 0, "f");
    (60008, 0, ".");
    (60004, 5, "start_userpos");
    (59835, 0, "\n        ");
    (59844, 0, "l");
    (59845, 0, "e");
    (59846, 0, "t");
    (59847, 0, " ");
    (59848, 0, "s");
    (59849, 0, "t");
    (59850, 0, "a");
    (59851, 0, "r");
    (59852, 0, "t");
    (59853, 0, "_");
    (59854, 0, "u");
    (59855, 0, "s");
    (59856, 0, "e");
    (59857, 0, "r");
    (59858, 0, "p");
    (59859, 0, "o");
    (59860, 0, "s");
    (59861, 0, " ");
    (59862, 0, "=");
    (59863, 0, " ");
    (59864, 0, "s");
    (59865, 0, "e");
    (59866, 0, "l");
    (59867, 0, "f");
    (59868, 0, ".");
    (59869, 0, "c");
    (59870, 0, "u");
    (59871, 0, "r");
    (59872, 0, "s");
    (59869, 4, "cursor");
    (59875, 0, ".");
    (59876, 0, "c");
    (59877, 0, "u");
    (59878, 0, "r");
    (59876, 3, "");
    (59876, 0, "u");
    (59877, 0, "s");
    (59878, 0, "e");
    (59879, 0, "r");
    (59876, 4, "userpos");
    (59883, 0, ";");
    (59884, 0, "\n        ");
    (59885, 8, "");
    (58994, 0, "    notify: fn(&[C::Item], ItemMarker<C>)\n");
    (59040, 0, "// ");
    (59040, 3, "");
    (59040, 0, "// ");
    (59040, 3, "");
    (59927, 0, "        ");
    (58994, 42, "");
    (59036, 0, "// ");
    (58994, 0, "// ");
    (58937, 0, "// ");
    (58914, 0, "// ");
    (58883, 0, "// ");
    (58846, 0, "// ");
    (58841, 3, "");
    (58819, 3, "");
    (58759, 3, "");
    (58733, 3, "");
    (58699, 3, "");
    (58617, 3, "");
    (59130, 0, "// ");
    (59039, 3, "");
    (57606, 0, "// ");
    (57585, 0, "// ");
    (57529, 0, "// ");
    (57455, 0, "// ");
    (57388, 0, "// ");
    (57347, 0, "// ");
    (57233, 0, "// ");
    (57228, 0, "\n    ");
    (57233, 0, "\n    ");
    (57229, 4, "");
    (57230, 4, "");
    (56491, 0, ",");
    (56492, 0, " ");
    (56493, 0, "n");
    (56494, 0, "o");
    (56495, 0, "t");
    (56493, 3, "no_notify_x(_items: &[C::Item], _marker: ItemMarker<C>)");
    (56493, 55, "not");
    (56495, 1, "");
    (56495, 0, "_");
    (56496, 0, "n");
    (56497, 0, "o");
    (56498, 0, "t");
    (56499, 0, "i");
    (56500, 0, "f");
    (56501, 0, "y");
    (56502, 0, "_");
    (56503, 0, "x");
    (56504, 0, ":");
    (56505, 0, ":");
    (56506, 0, "<");
    (56507, 0, "C");
    (56508, 0, ">");
    (56509, 0, " ");
    (56510, 0, "a");
    (56511, 0, "s");
    (56512, 0, " ");
    (56513, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    (56493, 0, "<");
    (56547, 0, ">");
    (56547, 1, "");
    (56493, 1, "");
    (56508, 1, "");
    (56507, 1, "");
    (56506, 1, "");
    (56505, 1, "");
    (56504, 1, "");
    (56504, 0, "::<C>");
    (56509, 36, "");
    (56509, 0, " as FnMut(&[C::Item], ItemMarker<C>)");
    (56509, 36, "");
    (56493, 0, "t");
    (56494, 0, "y");
    (56495, 0, "p");
    (56496, 0, "e");
    (56497, 0, "o");
    (56498, 0, "f");
    (56499, 0, "(");
    (56516, 0, ")");
    (56493, 7, "");
    (56493, 0, "{");
    (56510, 1, "");
    (56510, 0, "}");
    (58703, 5, "f");
    (58704, 0, "n");
    (58703, 2, "FnMut");
    (58869, 0, "// ");
    (58850, 0, "// ");
    (58793, 0, "// ");
    (58770, 0, "// ");
    (58739, 0, "// ");
    (58660, 0, "// ");
    (59094, 3, "");
    (59049, 3, "");
    (58989, 3, "");
    (58963, 3, "");
    (58929, 3, "");
    (58889, 3, "");
    (59082, 0, "// ");
    (59173, 3, "");
    (56493, 18, "expected type, found function");
    (56493, 29, "{no_notify_x::<C>}");
    (56493, 18, "");
    (56492, 1, "");
    (56491, 1, "");
    (57224, 3, "");
    (57200, 3, "");
    (57141, 3, "");
    (57064, 3, "");
    (56994, 3, "");
    (56900, 3, "");
    (56806, 3, "");
    (56966, 8, "");
    (56966, 0, ", Notify");
    (57206, 0, "// ");
    (57185, 0, "// ");
    (57129, 0, "// ");
    (57055, 0, "// ");
    (56988, 0, "// ");
    (56897, 0, "// ");
    (56806, 0, "// ");
    (57224, 3, "");
    (57200, 3, "");
    (57141, 3, "");
    (57064, 3, "");
    (56994, 3, "");
    (56900, 3, "");
    (56806, 3, "");
    (57206, 0, "// ");
    (57185, 0, "// ");
    (57129, 0, "// ");
    (57055, 0, "// ");
    (56988, 0, "// ");
    (56897, 0, "// ");
    (56806, 0, "// ");
    (57626, 3, "");
    (57602, 3, "");
    (57543, 3, "");
    (57466, 3, "");
    (57396, 3, "");
    (57352, 3, "");
    (57235, 3, "");
    (53122, 0, "// ");
    (53012, 0, "// ");
    (52955, 0, "// ");
    (52886, 0, "// ");
    (52814, 0, "// ");
    (52749, 0, "// ");
    (52740, 0, "\n        ");
    (52749, 0, "s");
    (52750, 0, "e");
    (52751, 0, "l");
    (52752, 0, "f");
    (52753, 0, ".");
    (52754, 0, "e");
    (52755, 0, "d");
    (52756, 0, "i");
    (52754, 3, "edit(userpos: usize, f: F)");
    (52759, 14, "s");
    (52760, 0, "t");
    (52761, 0, "a");
    (52762, 0, "r");
    (52763, 0, "t");
    (52764, 0, "_");
    (52765, 0, "u");
    (52766, 0, "s");
    (52767, 0, "e");
    (52768, 0, "r");
    (52769, 0, "p");
    (52770, 0, "o");
    (52771, 0, "s");
    (52774, 4, "|");
    (52775, 0, "e");
    (52776, 0, "i");
    (52777, 0, "d");
    (52778, 0, "t");
    (52778, 1, "");
    (52777, 1, "");
    (52776, 1, "");
    (52776, 0, "d");
    (52777, 0, "i");
    (52778, 0, "t");
    (52779, 0, "|");
    (52780, 0, " ");
    (52781, 0, "{");
    (52782, 0, "\n            ");
    (52783, 12, "        }");
    (52782, 0, "\n            ");
    (52795, 0, "e");
    (52796, 0, "d");
    (52797, 0, "i");
    (52798, 0, "t");
    (52799, 0, ".");
    (52800, 0, "r");
    (52801, 0, "e");
    (52802, 0, "p");
    (52803, 0, "l");
    (52804, 0, "a");
    (52800, 5, "replace_at");
    (52810, 0, "(");
    (52811, 0, "r");
    (52812, 0, "e");
    (52813, 0, "m");
    (52814, 0, "o");
    (52815, 0, "v");
    (52816, 0, "e");
    (52817, 0, "d");
    (52818, 0, "_");
    (52819, 0, "i");
    (52820, 0, "t");
    (52821, 0, "e");
    (52822, 0, "m");
    (52823, 0, "s");
    (52824, 0, ",");
    (52825, 0, " ");
    (52826, 0, "i");
    (52827, 0, "n");
    (52828, 0, "s");
    (52829, 0, "e");
    (52830, 0, "r");
    (52831, 0, "t");
    (52832, 0, "e");
    (52833, 0, "d");
    (52834, 0, "_");
    (52835, 0, "c");
    (52836, 0, "o");
    (52837, 0, "n");
    (52838, 0, "t");
    (52839, 0, "e");
    (52840, 0, "n");
    (52841, 0, "t");
    (52842, 0, ")");
    (52843, 0, ";");
    (52625, 4, "");
    (52669, 4, "");
    (52848, 469, "");
    (54077, 0, "// ");
    (53977, 0, "// ");
    (53964, 0, "// ");
    (53926, 0, "// ");
    (53906, 0, "// ");
    (53850, 0, "// ");
    (53839, 0, "// ");
    (53748, 0, "// ");
    (53670, 0, "// ");
    (53637, 0, "// ");
    (53560, 0, "// ");
    (53509, 0, "// ");
    (53476, 0, "// ");
    (53426, 0, "// ");
    (53369, 0, "// ");
    (53334, 0, "// ");
    (53268, 0, "// ");
    (53183, 0, "// ");
    (53090, 0, "// ");
    (54131, 3, "");
    (54028, 3, "");
    (54012, 3, "");
    (53971, 3, "");
    (53948, 3, "");
    (53889, 3, "");
    (53875, 3, "");
    (53781, 3, "");
    (53700, 3, "");
    (53664, 3, "");
    (53584, 3, "");
    (53530, 3, "");
    (53494, 3, "");
    (53441, 3, "");
    (53381, 3, "");
    (53343, 3, "");
    (53274, 3, "");
    (53186, 3, "");
    (53090, 3, "");
    (58840, 3, "");
    (55856, 3, "");
    (59240, 3, "");
    (52799, 3, "");
    (59749, 0, "\n    ");
    (59754, 0, "\n    ");
    (59750, 4, "");
    (59751, 4, "");
    (59216, 1, "");
    (59750, 0, "    ");
    (59754, 0, "p");
    (59755, 0, "u");
    (59756, 0, "b");
    (59757, 0, " ");
    (59758, 0, "f");
    (59759, 0, "n");
    (59760, 0, " ");
    (59761, 0, "c");
    (59762, 0, "u");
    (59763, 0, "r");
    (59764, 0, "r");
    (59765, 0, "e");
    (59766, 0, "n");
    (59767, 0, "t");
    (59768, 0, "_");
    (59769, 0, "i");
    (59770, 0, "t");
    (59771, 0, "e");
    (59772, 0, "m");
    (59773, 0, "(");
    (59774, 0, ")");
    (59774, 0, "&");
    (59775, 0, "s");
    (59776, 0, "e");
    (59777, 0, "l");
    (59778, 0, "f");
    (59779, 0, ",");
    (59780, 0, " ");
    (59780, 1, "");
    (59779, 1, "");
    (59780, 0, " ");
    (59781, 0, "-");
    (59782, 0, ">");
    (59783, 0, " ");
    (59784, 0, "C");
    (59785, 0, ":");
    (59786, 0, ":");
    (59787, 0, "I");
    (59788, 0, "t");
    (59789, 0, "e");
    (59790, 0, "m");
    (59787, 4, "Item");
    (59784, 0, "(");
    (59785, 0, "&");
    (59793, 0, ",");
    (59794, 0, " ");
    (59795, 0, "u");
    (59796, 0, "s");
    (59797, 0, "i");
    (59798, 0, "z");
    (59799, 0, "e");
    (59800, 0, ")");
    (59801, 0, " ");
    (59802, 0, "{");
    (59803, 0, "\n        ");
    (59812, 0, "\n        ");
    (59804, 8, "");
    (59805, 8, "    }");
    (59804, 0, "        ");
    (59812, 0, "s");
    (59813, 0, "e");
    (59814, 0, "l");
    (59815, 0, "f");
    (59816, 0, ".");
    (59817, 0, "c");
    (59818, 0, "u");
    (59819, 0, "r");
    (59820, 0, "s");
    (59821, 0, "o");
    (59822, 0, "r");
    (59823, 0, ".");
    (59812, 0, "// ");
    (59812, 3, "");
    (59824, 0, "unsafe { cursor.current_item_mut() };");
    (59812, 12, "");
    (59843, 1, "");
    (59842, 1, "");
    (59841, 1, "");
    (59840, 1, "");
    (59844, 1, "");
    (59821, 0, "s");
    (59822, 0, "e");
    (59823, 0, "l");
    (59824, 0, "f");
    (59825, 0, ".");
    (59812, 0, "(");
    (59850, 0, ",");
    (59851, 0, " ");
    (59852, 0, "s");
    (59853, 0, "e");
    (59854, 0, "l");
    (59855, 0, "f");
    (59856, 0, ".");
    (59857, 0, "i");
    (59858, 0, "t");
    (59859, 0, "e");
    (59860, 0, "m");
    (59861, 0, "_");
    (59862, 0, "o");
    (59863, 0, "f");
    (59864, 0, "f");
    (59857, 8, "item_offset");
    (59868, 0, ")");
    (16126, 4, "");
    (59871, 0, "\n    ");
    (59876, 0, "\n    ");
    (59872, 4, "");
    (59877, 0, "p");
    (59878, 0, "u");
    (59879, 0, "b");
    (59880, 0, " ");
    (59881, 0, "f");
    (59882, 0, "n");
    (59883, 0, " ");
    (59884, 0, "n");
    (59885, 0, "e");
    (59886, 0, "x");
    (59887, 0, "t");
    (59888, 0, "_");
    (59889, 0, "i");
    (59890, 0, "t");
    (59891, 0, "e");
    (59892, 0, "m");
    (59893, 0, "(");
    (59894, 0, ")");
    (59894, 0, "&");
    (59895, 0, "m");
    (59896, 0, "u");
    (59897, 0, "t");
    (59898, 0, " ");
    (59899, 0, "s");
    (59900, 0, "e");
    (59901, 0, "l");
    (59902, 0, "f");
    (59904, 0, " ");
    (59905, 0, "{");
    (59906, 0, "\n        ");
    (59915, 0, "\n        ");
    (59907, 8, "");
    (59908, 8, "    }");
    (59907, 0, "        ");
    (59915, 0, "s");
    (59916, 0, "e");
    (59917, 0, "l");
    (59918, 0, "f");
    (59919, 0, ".");
    (59920, 0, "c");
    (59921, 0, "u");
    (59922, 0, "r");
    (59923, 0, "s");
    (59924, 0, "o");
    (59925, 0, "r");
    (59926, 0, ".");
    (59927, 0, "a");
    (59928, 0, "d");
    (59929, 0, "v");
    (59930, 0, "a");
    (59931, 0, "n");
    (59927, 5, "advance_item(height: u8)");
    (59940, 10, "s");
    (59941, 0, "e");
    (59942, 0, "l");
    (59943, 0, "f");
    (59944, 0, ".");
    (59945, 0, "list");
    (59949, 0, ".");
    (59950, 0, "h");
    (59951, 0, "e");
    (59952, 0, "a");
    (59953, 0, "d");
    (59954, 0, ".");
    (59955, 0, "h");
    (59956, 0, "e");
    (59957, 0, "i");
    (59958, 0, "g");
    (59959, 0, "h");
    (59960, 0, "t");
    (59962, 0, ";");
    (59963, 0, "\n        ");
    (59972, 0, "s");
    (59973, 0, "e");
    (59974, 0, "l");
    (59975, 0, "f");
    (59976, 0, ".");
    (59977, 0, "i");
    (59978, 0, "t");
    (59979, 0, "e");
    (59980, 0, "m");
    (59981, 0, "_");
    (59982, 0, "o");
    (59983, 0, "f");
    (59984, 0, "f");
    (59977, 8, "item_offset");
    (59988, 0, " ");
    (59989, 0, "=");
    (59990, 0, " ");
    (59991, 0, "0");
    (59992, 0, ";");
    (59999, 0, "\n    ");
    (60004, 0, "\n    ");
    (60000, 4, "");
    (60005, 0, "unsafe { cursor.current_item_mut() };");
    (60005, 37, "");
    ( 60005,
      0,
      "\n\
      \    pub fn modify_at<Notify, F>(&mut self, userpos: usize, mut notify: \
       Notify, modify_fn: F)\n\
      \    where Notify: FnMut(&[C::Item], ItemMarker<C>), F: FnOnce(&mut \
       C::Item, usize) {\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\
      \        let e = cursor.here_ptr();\n\
      \        let item = unsafe { cursor.current_item_mut() };\n\
      \        let old_usersize = C::get_usersize(item);\n\
      \        modify_fn(item, offset);\n\
      \        let new_usersize = C::get_usersize(item);\n\n\
      \        let usersize_delta = new_usersize as isize - old_usersize as \
       isize;\n\n\
      \        if usersize_delta != 0 {\n\
      \            cursor.update_offsets(self.head.height as usize, \
       usersize_delta);\n\
      \            self.num_usercount = \
       self.num_usercount.wrapping_add(usersize_delta as usize);\n\
      \        }\n\n\
      \        notify(std::slice::from_ref(item), ItemMarker {\n\
      \            ptr: e,\n\
      \            // _phantom: PhantomData,\n\
      \        });\n\n\
      \        // cursor.update_offsets(self.head.height as usize, new_size as \
       isize - old_size as isize);\n\
      \    }" );
    (60025, 1, "");
    (60024, 1, "");
    (60024, 0, "i");
    (60025, 0, "t");
    (60026, 0, "e");
    (60027, 0, "m");
    (60027, 1, "");
    (60026, 1, "");
    (60025, 1, "");
    (60024, 1, "");
    (60024, 0, "i");
    (60025, 0, "n");
    (60026, 0, "_");
    (60026, 1, "");
    (60025, 1, "");
    (60024, 1, "");
    (60023, 1, "");
    (60024, 8, "");
    (60001, 4, "");
    (60000, 1, "");
    (60049, 20, "");
    (60073, 42, "");
    ( 60001,
      104,
      "    pub fn modify<F>(&mut self, userpos: usize, modify_fn: F) where F: \
       FnOnce(&mut C::Item, usize) {" );
    (60102, 66, "");
    (60118, 0, "s");
    (60119, 0, "e");
    (60120, 0, "l");
    (60121, 0, "f");
    (60122, 0, ".");
    (60170, 0, "s");
    (60171, 0, "e");
    (60172, 0, "l");
    (60173, 0, "f");
    (60174, 0, ".");
    (60278, 0, "s");
    (60279, 0, "e");
    (60280, 0, "l");
    (60281, 0, "f");
    (60282, 0, ".");
    (60283, 0, "item_offset");
    (60294, 6, "");
    (60470, 0, "s");
    (60471, 0, "e");
    (60472, 0, "l");
    (60473, 0, "f");
    (60474, 0, ".");
    (60502, 0, "l");
    (60503, 0, "i");
    (60504, 0, "s");
    (60505, 0, "t");
    (60506, 0, ".");
    (60563, 0, "l");
    (60564, 0, "i");
    (60565, 0, "s");
    (60566, 0, "t");
    (60567, 0, ".");
    (60589, 0, "l");
    (60590, 0, "i");
    (60591, 0, "s");
    (60592, 0, "t");
    (60593, 0, ".");
    (60666, 0, "s");
    (60667, 0, "e");
    (60668, 0, "l");
    (60669, 0, "f");
    (60670, 0, ".");
    (60677, 0, ")");
    (60666, 0, "(");
    (60033, 16, "");
    (60018, 0, "_");
    (60019, 0, "i");
    (60020, 0, "t");
    (60021, 0, "e");
    (60022, 0, "m");
    (60780, 101, "");
    (60335, 0, "\n        ");
    (60344, 0, "i");
    (60345, 0, "f");
    (60346, 0, " ");
    (60347, 0, "(");
    (60347, 1, "");
    (60347, 0, "n");
    (60348, 0, "e");
    (60349, 0, "w");
    (60350, 0, "_");
    (60347, 4, "new_usersize");
    (60359, 0, " ");
    (60360, 0, ">");
    (60361, 0, " ");
    (60362, 0, "s");
    (60363, 0, "e");
    (60364, 0, "l");
    (60365, 0, "f");
    (60366, 0, ".");
    (60367, 0, "i");
    (60368, 0, "t");
    (60369, 0, "e");
    (60367, 3, "item_offset");
    (60336, 42, "");
    (60335, 1, "");
    (60635, 0, "\n            ");
    (60648, 0, "\n            ");
    (60636, 12, "");
    (60649, 0, "        if new_usersize > self.item_offset");
    (60637, 20, "            ");
    (60683, 0, " ");
    (60684, 0, "{");
    (60685, 0, "\n                ");
    (60702, 0, "\n                ");
    (60686, 16, "");
    (60687, 16, "            }");
    (60686, 0, "                ");
    (60702, 0, "s");
    (60703, 0, "e");
    (60704, 0, "l");
    (60705, 0, "f");
    (60706, 0, ".");
    (60707, 0, "i");
    (60708, 0, "t");
    (60709, 0, "e");
    (60710, 0, "m");
    (60711, 0, "_");
    (60707, 5, "item_offset");
    (60718, 0, " ");
    (60719, 0, "=");
    (60720, 0, " ");
    (60721, 0, "n");
    (60722, 0, "e");
    (60723, 0, "w");
    (60724, 0, "_");
    (60725, 0, "u");
    (60721, 5, "new_usersize");
    (60733, 0, ";");
    (60636, 112, "");
    ( 60636,
      0,
      "\n\
      \            if new_usersize > self.item_offset {\n\
      \                self.item_offset = new_usersize;\n\
      \            }" );
    (60734, 0, " ");
    (60735, 0, "/");
    (60736, 0, "/");
    (60737, 0, " ");
    (60737, 1, "");
    (60736, 1, "");
    (60735, 1, "");
    (60734, 1, "");
    (60636, 0, "\n            ");
    (60649, 0, "s");
    (60650, 0, "e");
    (60651, 0, "l");
    (60652, 0, "f");
    (60653, 0, ".");
    (60654, 0, "i");
    (60655, 0, "t");
    (60656, 0, "e");
    (60657, 0, "m");
    (60654, 4, "item_offset");
    (60665, 0, " ");
    (60666, 0, "=");
    (60667, 0, " ");
    (60668, 0, "s");
    (60669, 0, "e");
    (60670, 0, "l");
    (60671, 0, "f");
    (60672, 0, ".");
    (60673, 0, "i");
    (60673, 1, "item_offset");
    (60684, 0, ".");
    (60685, 0, "m");
    (60686, 0, "a");
    (60685, 2, "");
    (60684, 1, "");
    (60667, 0, " ");
    (60668, 0, "u");
    (60669, 0, "s");
    (60670, 0, "i");
    (60671, 0, "z");
    (60672, 0, "e");
    (60673, 0, ":");
    (60674, 0, ":");
    (60675, 0, "m");
    (60676, 0, "a");
    (60677, 0, "x");
    (60678, 0, "(");
    (60679, 1, "");
    (60695, 0, ",");
    (60696, 0, " ");
    (60697, 0, "new_usersize");
    (60709, 0, ")");
    (60710, 0, ";");
    (60712, 112, "");
    (60635, 1, "");
    (53100, 8, "");
    (53130, 20, "");
    (53154, 42, "");
    ( 53079,
      107,
      "    pub fn modify_at<F>(&mut self, userpos: usize, modify_fn: F) where \
       F: FnOnce(&mut C::Item, usize) {" );
    (53183, 808, "");
    (53182, 1, "");
    (53182, 0, "\n        ");
    (53191, 0, "s");
    (53192, 0, "e");
    (53193, 0, "l");
    (53194, 0, "f");
    (53195, 0, ".");
    (53196, 0, "e");
    (53197, 0, "d");
    (53198, 0, "i");
    (53199, 0, "t");
    (53200, 0, "(");
    (53201, 0, "s");
    (53202, 0, "t");
    (53203, 0, "a");
    (53204, 0, "r");
    (53205, 0, "t");
    (53206, 0, "_");
    (53207, 0, "u");
    (53201, 7, "start_userpos");
    (53214, 0, ",");
    (53215, 0, " ");
    (53216, 0, "|");
    (53217, 0, "e");
    (53218, 0, "d");
    (53219, 0, "i");
    (53220, 0, "t");
    (53221, 0, "|");
    (53201, 1, "");
    (53201, 1, "");
    (53201, 1, "");
    (53201, 1, "");
    (53201, 1, "");
    (53201, 1, "");
    (53216, 0, " ");
    (53217, 0, "{");
    (53218, 0, "\n            ");
    (53231, 0, "s");
    (53232, 0, "e");
    (53232, 1, "");
    (53231, 1, "");
    (53231, 0, "e");
    (53232, 0, "d");
    (53233, 0, "i");
    (53234, 0, "t");
    (53235, 0, ".");
    (53236, 0, "m");
    (53237, 0, "o");
    (53238, 0, "d");
    (53239, 0, "i");
    (53236, 4, "modify_item");
    (53097, 0, "i");
    (53098, 0, "t");
    (53099, 0, "e");
    (53100, 0, "m");
    (53101, 0, "_");
    (53252, 0, "(");
    (53253, 0, "m");
    (53254, 0, "o");
    (53255, 0, "d");
    (53256, 0, "i");
    (53257, 0, "f");
    (53258, 0, "y");
    (53253, 6, "modify_fn");
    (53262, 0, ")");
    (53263, 0, ";");
    (53264, 0, "\n            ");
    (53265, 12, "        }");
    (53222, 1, "");
    (53188, 75, "        self.edit(userpos, |edit| edit.modify_item(modify_fn);");
    ( 53188,
      72,
      "        self.edit(userpos, |edit| edit.modify_item(modify_fn); }" );
    (53250, 1, "");
    (53249, 1, "");
    (53249, 1, "");
    (53249, 0, ")");
    (53250, 0, ";");
    (58398, 0, "\n    ");
    (58403, 0, "\n    ");
    (58399, 4, "");
    ( 58404,
      0,
      "    pub fn insert_at<Notify, I>(&mut self, mut userpos: usize, mut \
       contents: I, mut notify: Notify)\n\
      \    where Notify: FnMut(&[C::Item], ItemMarker<C>), I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        if contents.len() == 0 { return; }\n\
      \        let num_inserted_items = contents.len();\n\
      \        \n\
      \        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        unsafe {\n\
      \            if offset == 0 {\n\
      \                self.insert_at_iter(&mut cursor, &mut contents, &mut \
       notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       num_inserted_items);\n\
      \            } else {\n\
      \                let current_item = cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                cursor.move_to_item_start(self.head.height, offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.replace_item(&mut cursor, start, &mut notify);\n\n\
      \                // TODO: Consider concatenating end into contents then \
       just call\n\
      \                // insert_at_iter once.\n\
      \                self.insert_at_iter(&mut cursor, &mut contents, &mut \
       notify);\n\n\
      \                self.dbg_check_cursor_at(&cursor, userpos, \
       num_inserted_items);\n\n\
      \                self.insert_at_iter(&mut cursor, &mut iter::once(end), \
       &mut notify);\n\
      \            }\n\
      \        }\n\n\
      \    }" );
    (58400, 8, "    ");
    (58417, 3, "");
    (58418, 8, "");
    (58430, 21, "");
    (58430, 0, ",");
    (58447, 20, "");
    (58459, 42, "");
    ( 58400,
      95,
      "    pub fn insert<I>(&mut self, mut contents: I) where I: \
       ExactSizeIterator<Item=C::Item> {" );
    (58593, 118, "");
    (58592, 1, "");
    (58592, 0, "\n");
    ( 58593,
      0,
      "        userpos = min(userpos, self.get_userlen());\n\
      \        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n" );
    (58653, 0, "// ");
    (58601, 0, "// ");
    (58750, 6, "s");
    (58751, 0, "e");
    (58752, 0, "l");
    (58753, 0, "f");
    (58754, 0, ".");
    (58755, 0, "i");
    (58756, 0, "t");
    (58757, 0, "e");
    (58758, 0, "m");
    (58759, 0, "_");
    (58755, 5, "item_offset");
    (58795, 0, "l");
    (58796, 0, "i");
    (58797, 0, "s");
    (58798, 0, "t");
    (58799, 0, ".");
    (58820, 0, "s");
    (58821, 0, "e");
    (58822, 0, "l");
    (58823, 0, "f");
    (58824, 0, ".");
    (58853, 0, "s");
    (58854, 0, "e");
    (58855, 0, "l");
    (58856, 0, "f");
    (58857, 0, ".");
    (58849, 4, "");
    (58848, 1, "");
    (58848, 0, "&mut ");
    (58849, 4, "");
    (58849, 0, "mut ");
    (58888, 0, ".");
    (58889, 0, "l");
    (58890, 0, "i");
    (58891, 0, "s");
    (58892, 0, "t");
    (58915, 0, "s");
    (58916, 0, "e");
    (58917, 0, "l");
    (58918, 0, "f");
    (58919, 0, ".");
    (58716, 0, "\n        ");
    (58725, 0, "\n        ");
    (58717, 8, "");
    (58726, 0, "l");
    (58727, 0, "e");
    (58728, 0, "t");
    (58729, 0, " ");
    (58730, 0, "i");
    (58731, 0, "n");
    (58732, 0, "i");
    (58733, 0, "t");
    (58734, 0, "i");
    (58735, 0, "a");
    (58736, 0, "_");
    (58736, 1, "");
    (58736, 0, "l");
    (58737, 0, "_");
    (58738, 0, "u");
    (58739, 0, "s");
    (58740, 0, "e");
    (58741, 0, "r");
    (58742, 0, "p");
    (58743, 0, "o");
    (58744, 0, "s");
    (58745, 0, " ");
    (58746, 0, "=");
    (58747, 0, " ");
    (58748, 0, "s");
    (58749, 0, "e");
    (58750, 0, "l");
    (58751, 0, "f");
    (58752, 0, ".");
    (58753, 0, "c");
    (58754, 0, "u");
    (58755, 0, "r");
    (58756, 0, "s");
    (58757, 0, "o");
    (58758, 0, "r");
    (58759, 0, ".");
    (58760, 0, "u");
    (58761, 0, "s");
    (58762, 0, "e");
    (58763, 0, "r");
    (58764, 0, "p");
    (58765, 0, "o");
    (58766, 0, "s");
    (58767, 0, ";");
    (58730, 15, "s");
    (58731, 0, "t");
    (58732, 0, "a");
    (58733, 0, "r");
    (58734, 0, "t");
    (58735, 0, "_");
    (58736, 0, "u");
    (58737, 0, "s");
    (58738, 0, "e");
    (58739, 0, "r");
    (58740, 0, "p");
    (58741, 0, "o");
    (58742, 0, "s");
    (58978, 7, "start_userpos");
    (59070, 0, "s");
    (59071, 0, "e");
    (59072, 0, "l");
    (59073, 0, "f");
    (59074, 0, ".");
    (59161, 6, "s");
    (59162, 0, "e");
    (59163, 0, "l");
    (59164, 0, "f");
    (59165, 0, ".");
    (59166, 0, "l");
    (59167, 0, "o");
    (59168, 0, "c");
    (59169, 0, "a");
    (59166, 4, "local_offset");
    (59166, 12, "loca");
    (59161, 9, "offset");
    (59161, 6, "self.loca");
    (59166, 4, "local_offset");
    (59166, 1, "");
    (59166, 1, "");
    (59166, 1, "");
    (59166, 1, "");
    (59166, 1, "");
    (59166, 0, "i");
    (59167, 0, "t");
    (59168, 0, "e");
    (59169, 0, "m");
    (59297, 0, "s");
    (59298, 0, "e");
    (59299, 0, "l");
    (59300, 0, "f");
    (59301, 0, ".");
    (59332, 0, ".");
    (59333, 0, "l");
    (59334, 0, "i");
    (59335, 0, "s");
    (59336, 0, "t");
    (59351, 6, "self.item_offset");
    (59463, 0, ".");
    (59464, 0, "l");
    (59465, 0, "i");
    (59466, 0, "s");
    (59467, 0, "t");
    (59486, 0, "s");
    (59487, 0, "e");
    (59487, 1, "");
    (59486, 1, "");
    (59487, 0, "s");
    (59488, 0, "e");
    (59489, 0, "l");
    (59490, 0, "f");
    (59491, 0, ".");
    (59512, 0, "s");
    (59513, 0, "e");
    (59514, 0, "l");
    (59515, 0, "f");
    (59516, 0, ".");
    (59668, 0, ".");
    (59669, 0, "l");
    (59670, 0, "i");
    (59671, 0, "s");
    (59672, 0, "t");
    (59694, 0, "s");
    (59695, 0, "e");
    (59696, 0, "l");
    (59697, 0, "f");
    (59698, 0, ".");
    (59727, 0, "s");
    (59728, 0, "e");
    (59729, 0, "l");
    (59730, 0, "f");
    (59731, 0, ".");
    (59763, 0, "l");
    (59764, 0, "i");
    (59765, 0, "s");
    (59766, 0, "t");
    (59767, 0, ".");
    (59789, 0, "s");
    (59790, 0, "e");
    (59791, 0, "l");
    (59792, 0, "f");
    (59793, 0, ".");
    (59802, 7, "s");
    (59803, 0, "t");
    (59804, 0, "a");
    (59805, 0, "r");
    (59802, 4, "userpos");
    (59802, 7, "s");
    (59803, 0, "t");
    (59804, 0, "a");
    (59805, 0, "r");
    (59802, 4, "start_userpos");
    (59860, 0, "l");
    (59861, 0, "i");
    (59862, 0, "s");
    (59863, 0, "t");
    (59864, 0, ".");
    (59885, 0, "s");
    (59886, 0, "e");
    (59887, 0, "l");
    (59888, 0, "f");
    (59889, 0, ".");
    (59925, 0, "s");
    (59926, 0, "e");
    (59927, 0, "l");
    (59928, 0, "f");
    (59929, 0, ".");
    (54724, 0, "// ");
    (54710, 0, "// ");
    (54625, 0, "// ");
    (54544, 0, "// ");
    (54465, 0, "// ");
    (54425, 0, "// ");
    (54344, 0, "// ");
    (54275, 0, "// ");
    (54202, 0, "// ");
    (54133, 0, "// ");
    (54103, 0, "// ");
    (54032, 0, "// ");
    (53960, 0, "// ");
    (53902, 0, "// ");
    (53881, 0, "// ");
    (53801, 0, "// ");
    (53722, 0, "// ");
    (53693, 0, "// ");
    (53676, 0, "// ");
    (53609, 0, "// ");
    (53557, 0, "// ");
    (53499, 0, "// ");
    (53456, 0, "// ");
    (53447, 0, "\n        ");
    (53456, 0, "s");
    (53457, 0, "e");
    (53458, 0, "l");
    (53459, 0, "f");
    (53460, 0, ".");
    (53461, 0, "e");
    (53462, 0, "d");
    (53463, 0, "i");
    ( 53461,
      3,
      "edit_notify(userpos: usize, notify: fn(&[C::Item], ItemMarker<C>), f: F)"
    );
    (53473, 14, "u");
    (53474, 0, "s");
    (53475, 0, "e");
    (53476, 0, "r");
    (53477, 0, "p");
    (53478, 0, "o");
    (53479, 0, "s");
    (53482, 37, "");
    (53482, 0, "n");
    (53483, 0, "o");
    (53484, 0, "t");
    (53485, 0, "i");
    (53486, 0, "f");
    (53487, 0, "y");
    (53280, 8, "");
    (53329, 20, "");
    (53341, 42, "");
    (53401, 1, "");
    (53400, 1, "");
    (53399, 1, "");
    (53398, 1, "");
    (53397, 1, "");
    (53396, 1, "");
    (53395, 1, "");
    (53405, 8, "");
    (53405, 5, "");
    (53405, 0, "|");
    (53406, 0, "e");
    (53407, 0, "d");
    (53408, 0, "i");
    (53409, 0, "t");
    (53410, 0, "|");
    (53411, 0, " ");
    (53412, 0, "e");
    (53413, 0, "d");
    (53414, 0, "i");
    (53415, 0, "t");
    (53416, 0, ".");
    (53417, 0, "i");
    (53418, 0, "n");
    (53419, 0, "s");
    (53420, 0, "e");
    (53421, 0, "r");
    (53422, 0, "t");
    (53423, 0, "(");
    (53424, 0, "c");
    (53425, 0, "o");
    (53426, 0, "n");
    (53427, 0, "t");
    (53428, 0, "e");
    (53429, 0, "n");
    (53430, 0, "t");
    (53431, 0, "s");
    (53432, 0, ")");
    (53433, 0, ")");
    (54944, 17, "");
    (21484, 17, "");
    (1247, 2, "2");
    (1247, 1, "10");
    (53418, 1347, "");
    (53417, 1, "");
    (53297, 3, "");
    (53277, 3, "");
    (53294, 1, "");
    (53277, 1, "");
    (58628, 1, "");
    (58634, 0, "\n    ");
    (58639, 0, "\n    ");
    (58635, 4, "");
    (58640, 0, "p");
    (58641, 0, "u");
    (58642, 0, "b");
    (58643, 0, " ");
    (58644, 0, "f");
    (58645, 0, "n");
    (58646, 0, " ");
    (58647, 0, "i");
    (58648, 0, "n");
    (58649, 0, "s");
    (58650, 0, "e");
    (58651, 0, "r");
    (58652, 0, "t");
    (58653, 0, "_");
    (58654, 0, "s");
    (58655, 0, "l");
    (58656, 0, "i");
    (58657, 0, "c");
    (58658, 0, "e");
    (58659, 0, "(");
    (58660, 0, "&");
    (58661, 0, "m");
    (58662, 0, "u");
    (58663, 0, "t");
    (58664, 0, " ");
    (58665, 0, "s");
    (58666, 0, "e");
    (58667, 0, "l");
    (58668, 0, "f");
    (58669, 0, ",");
    (58670, 0, " ");
    (58671, 0, "&");
    (58672, 0, "[");
    (58673, 0, "C");
    (58674, 0, ":");
    (58675, 0, ":");
    (58676, 0, "I");
    (58677, 0, "t");
    (58678, 0, "e");
    (58679, 0, "m");
    (58680, 0, "]");
    (58671, 0, "i");
    (58672, 0, "t");
    (58673, 0, "e");
    (58674, 0, "m");
    (58675, 0, "s");
    (58676, 0, ":");
    (58677, 0, " ");
    (58688, 0, ")");
    (58689, 0, " ");
    (58690, 0, "w");
    (58691, 0, "h");
    (58692, 0, "e");
    (58693, 0, "r");
    (58694, 0, "e");
    (58695, 0, " ");
    (58696, 0, "C");
    (58697, 0, ":");
    (58698, 0, ":");
    (58699, 0, "I");
    (58700, 0, "m");
    (58700, 1, "");
    (58700, 0, "t");
    (58701, 0, "e");
    (58702, 0, "m");
    (58703, 0, ":");
    (58704, 0, " ");
    (58705, 0, "C");
    (58706, 0, "o");
    (58707, 0, "p");
    (58708, 0, "y");
    (58709, 0, " ");
    (58710, 0, "{");
    (58711, 0, "\n        ");
    (58720, 0, "\n        ");
    (58712, 8, "");
    (58713, 8, "    }");
    (58712, 0, "        ");
    (58720, 0, "s");
    (58721, 0, "e");
    (58722, 0, "l");
    (58723, 0, "f");
    (58724, 0, ".");
    (58725, 0, "i");
    (58726, 0, "n");
    (58727, 0, "s");
    (58728, 0, "e");
    (58729, 0, "r");
    (58730, 0, "t");
    (58731, 0, "(");
    (58732, 0, "i");
    (58733, 0, "t");
    (58734, 0, "e");
    (58735, 0, "m");
    (58736, 0, "s");
    (58737, 0, ".");
    (58738, 0, "i");
    (58739, 0, "t");
    (58740, 0, "e");
    (58741, 0, "r");
    (58742, 0, "(");
    (58743, 0, ")");
    (58744, 0, ".");
    (58745, 0, "c");
    (58746, 0, "l");
    (58746, 1, "");
    (58746, 0, "o");
    (58747, 0, "p");
    (58748, 0, "e");
    (58749, 0, "i");
    (58749, 1, "");
    (58748, 1, "");
    (58748, 0, "i");
    (58749, 0, "e");
    (58750, 0, "d");
    (58751, 0, "(");
    (58752, 0, ")");
    (58753, 0, ")");
    (58754, 0, ";");
    (58731, 0, "_iter");
    (57083, 0, "_iter");
    (53398, 0, "_iter");
    (57069, 0, "\n    ");
    (57074, 0, "\n    ");
    (57070, 4, "");
    (57075, 0, "p");
    (57076, 0, "u");
    (57077, 0, "b");
    (57078, 0, " ");
    (57079, 0, "f");
    (57080, 0, "n");
    (57081, 0, " ");
    (57082, 0, "i");
    (57083, 0, "n");
    (57084, 0, "s");
    (57085, 0, "e");
    (57086, 0, "r");
    (57087, 0, "t");
    (57088, 0, "(");
    (57088, 1, "");
    (57088, 0, "(");
    (57089, 0, "&");
    (57090, 0, "m");
    (57091, 0, "u");
    (57092, 0, "t");
    (57093, 0, " ");
    (57094, 0, "s");
    (57095, 0, "e");
    (57096, 0, "l");
    (57097, 0, "f");
    (57098, 0, ",");
    (57099, 0, " ");
    (57100, 0, "i");
    (57101, 0, "t");
    (57102, 0, "e");
    (57103, 0, "m");
    (57104, 0, ":");
    (57105, 0, " ");
    (57106, 0, "C");
    (57107, 0, ":");
    (57108, 0, ":");
    (57109, 0, "I");
    (57110, 0, "t");
    (57111, 0, "e");
    (57109, 3, "Item");
    (57113, 0, ")");
    (57114, 0, " ");
    (57115, 0, "{");
    (57116, 0, "\n        ");
    (57125, 0, "\n        ");
    (57117, 8, "");
    (57118, 8, "    }");
    (57117, 0, "        ");
    (57125, 0, "s");
    (57126, 0, "e");
    (57127, 0, "l");
    (57128, 0, "f");
    (57129, 0, ".");
    (57130, 0, "i");
    (57131, 0, "n");
    (57132, 0, "s");
    (57133, 0, "e");
    (57134, 0, "r");
    (57130, 5, "insert_iter(mut contents: I)");
    (57142, 15, "i");
    (57143, 0, "t");
    (57144, 0, "e");
    (57145, 0, "r");
    (57146, 0, ":");
    (57147, 0, ":");
    (57148, 0, "o");
    (57149, 0, "n");
    (57148, 2, "once(value: T)");
    (57153, 8, "i");
    (57154, 0, "t");
    (57155, 0, "e");
    (57156, 0, "m");
    (57159, 0, ";");
    (57069, 97, "");
    ( 58644,
      0,
      "\n\n\
      \    pub fn insert(&mut self, item: C::Item) {\n\
      \        self.insert_iter(iter::once(item));\n\
      \    }" );
    (51993, 193, "");
    (51992, 1, "");
    (51992, 0, "\n");
    ( 51993,
      0,
      "\n\
      \        // self.modify_at(start_userpos, Self::no_notify, |item, \
       offset| {\n\
      \        //     assert_eq!(offset, 0, \"replace_at must modify the \
       entire item\");\n\
      \        //     *item = \n\
      \        // })" );
    (60521, 0, "\n    ");
    (60526, 0, "\n    ");
    (60522, 4, "");
    (60527, 0, "p");
    (60528, 0, "u");
    (60529, 0, "b");
    (60530, 0, " ");
    (60531, 0, "f");
    (60532, 0, "n");
    (60533, 0, " ");
    (60534, 0, "r");
    (60535, 0, "e");
    (60536, 0, "p");
    (60537, 0, "l");
    (60538, 0, "a");
    (60539, 0, "c");
    (60540, 0, "e");
    (60541, 0, "_");
    (60542, 0, "i");
    (60543, 0, "t");
    (60544, 0, "e");
    (60545, 0, "m");
    (60546, 0, "(");
    (60547, 0, "&");
    (60548, 0, "s");
    (60549, 0, "e");
    (60550, 0, "l");
    (60551, 0, "f");
    (60552, 0, ",");
    (60553, 0, " ");
    (60554, 0, "r");
    (60555, 0, "e");
    (60556, 0, "p");
    (60557, 0, "l");
    (60558, 0, "a");
    (60559, 0, "c");
    (60560, 0, "e");
    (60561, 0, "m");
    (60562, 0, "e");
    (60563, 0, "n");
    (60564, 0, "t");
    (60565, 0, ":");
    (60566, 0, " ");
    (60567, 0, "C");
    (60568, 0, ":");
    (60569, 0, ":");
    (60570, 0, "I");
    (60571, 0, "t");
    (60572, 0, "e");
    (60573, 0, "m");
    (60574, 0, ")");
    (60575, 0, " ");
    (60576, 0, "{");
    (60577, 0, "\n        ");
    (60586, 0, "\n        ");
    (60578, 8, "");
    (60579, 8, "    }");
    (60578, 0, "        ");
    (60586, 0, "s");
    (60587, 0, "e");
    (60588, 0, "l");
    (60589, 0, "f");
    (60590, 0, ".");
    (60591, 0, "m");
    (60592, 0, "o");
    (60593, 0, "d");
    (60594, 0, "i");
    (60591, 4, "modify_item(modify_fn: F)");
    (60603, 12, "");
    (60603, 0, "|");
    (60604, 0, "e");
    (60604, 1, "");
    (60604, 0, "o");
    (60605, 0, "l");
    (60606, 0, "d");
    (60607, 0, "|");
    (60608, 0, " ");
    (60609, 0, "*");
    (60610, 0, "o");
    (60611, 0, "l");
    (60612, 0, "d");
    (60613, 0, " ");
    (60614, 0, "=");
    (60615, 0, " ");
    (60616, 0, "r");
    (60617, 0, "e");
    (60618, 0, "p");
    (60619, 0, "l");
    (60620, 0, "a");
    (60621, 0, "c");
    (60622, 0, "e");
    (60623, 0, "m");
    (60624, 0, "e");
    (60625, 0, "n");
    (60626, 0, "t");
    (60628, 0, ";");
    (60607, 0, ",");
    (60608, 0, " ");
    (60609, 0, "o");
    (60610, 0, "f");
    (60611, 0, "f");
    (60612, 0, "s");
    (60613, 0, "e");
    (60614, 0, "t");
    (60617, 0, "{");
    (60617, 1, "");
    (60609, 0, "_");
    (60577, 0, "\n        ");
    (60577, 9, "");
    (60548, 0, "m");
    (60549, 0, "u");
    (60550, 0, "t");
    (60551, 0, " ");
    (52193, 304, "");
    (52192, 1, "");
    (56367, 0, "\n    ");
    ( 56372,
      0,
      "\n\
      \    fn dbg_check_cursor_at(&self, cursor: &Cursor<C>, userpos: usize, \
       plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.head.height);\n\
      \            assert_eq!(cursor, &c2);\n\
      \        }\n\
      \    }" );
    (56368, 4, "");
    (56672, 0, "\n    ");
    (56673, 4, "");
    (56367, 1, "");
    (56400, 20, "");
    (56509, 0, ".");
    (56510, 0, "l");
    (56511, 0, "i");
    (56512, 0, "s");
    (56513, 0, "t");
    (56589, 0, ".");
    (56590, 0, "l");
    (56591, 0, "i");
    (56592, 0, "s");
    (56593, 0, "t");
    (56632, 0, "s");
    (56633, 0, "e");
    (56634, 0, "l");
    (56635, 0, "f");
    (56636, 0, ".");
    (59319, 5, "");
    (58433, 5, "");
    (57609, 5, "");
    (59309, 0, ".list");
    (58428, 0, ".list");
    (57609, 0, ".list");
    (59345, 14, "");
    (58459, 14, "");
    (57635, 14, "");
    (59292, 5, "");
    (58420, 5, "");
    (57610, 5, "");
    (56632, 0, "&");
    (53999, 428, "");
    (53998, 1, "");
    (53431, 166, "");
    (53430, 1, "");
    (53430, 0, "\n    ");
    (53431, 4, "");
    (53379, 1, "");
    (53345, 67, "        self.edit(userpos, |edit| edit.del(num_items);");
    (53345, 65, "        self.edit(userpos, |edit| edit.del(num_items); })");
    (53398, 1, "");
    (53399, 1, "");
    (53398, 1, "");
    (53832, 8, "");
    (58752, 0, "I");
    (58753, 0, "o");
    (58754, 0, "t");
    (58755, 0, "u");
    (58756, 0, "i");
    (58752, 5, "O");
    (58753, 0, "p");
    (58754, 0, "t");
    (58755, 0, "i");
    (58756, 0, "o");
    (58757, 0, "n");
    (58758, 0, "<");
    (58776, 0, ">");
    (58779, 0, "\n        ");
    (58788, 0, "i");
    (58789, 0, "f");
    (58790, 0, " ");
    (58791, 0, "s");
    (58792, 0, "e");
    (58793, 0, "l");
    (58794, 0, "f");
    (58795, 0, ".");
    (58796, 0, "c");
    (58797, 0, "u");
    (58798, 0, "r");
    (58799, 0, "s");
    (58800, 0, "o");
    (58801, 0, "r");
    (58802, 0, ".");
    (58803, 0, "u");
    (58804, 0, "s");
    (58805, 0, "e");
    (58806, 0, "r");
    (58807, 0, "p");
    (58808, 0, "o");
    (58809, 0, "s");
    (58810, 0, " ");
    (58811, 0, "=");
    (58812, 0, "=");
    (58813, 0, " ");
    (58814, 0, "0");
    (58815, 0, " ");
    (58816, 0, "7");
    (58816, 1, "");
    (58816, 0, "&");
    (58817, 0, "&");
    (58818, 0, " ");
    (58819, 0, "s");
    (58820, 0, "e");
    (58821, 0, "l");
    (58822, 0, "f");
    (58823, 0, ".");
    (58824, 0, "i");
    (58825, 0, "t");
    (58826, 0, "e");
    (58824, 3, "item_offset");
    (58835, 0, " ");
    (58836, 0, "=");
    (58837, 0, "=");
    (58838, 0, " ");
    (58839, 0, "0");
    (58840, 0, " ");
    (58841, 0, "{");
    (58842, 0, " ");
    (58843, 0, "N");
    (58844, 0, "o");
    (58845, 0, "n");
    (58846, 0, "e");
    (58847, 0, " ");
    (58848, 0, "}");
    (58849, 0, "\n        ");
    (58858, 0, "e");
    (58859, 0, "l");
    (58860, 0, "s");
    (58861, 0, "e");
    (58862, 0, " ");
    (58863, 0, "{");
    (58864, 0, " ");
    ( 58850,
      81,
      "        else { (unsafe { self.cursor.current_item() }, self.item_offset)"
    );
    (58865, 0, "S");
    (58866, 0, "o");
    (58867, 0, "m");
    (58868, 0, "e");
    (58869, 0, "(");
    (58927, 0, ")");
    (58928, 0, " ");
    (58929, 0, "}");
    (16234, 1, "");
    (16235, 16, "");
    (16234, 1, "");
    (16233, 1, "");
    (16232, 1, "");
    (16209, 0, "self.local_index");
    (16225, 0, " ");
    (16226, 0, "<");
    (16227, 0, " ");
    ( 29278,
      79,
      "            if usersize >= offset { break; } // We're in the middle of \
       an item.\n" );
    ( 29278,
      80,
      "            if usersize  offset { break; } // We're in the middle of an \
       item.\n" );
    ( 29278,
      78,
      "            if usersize > offset { break; } // We're in the middle of \
       an item.\n" );
    ( 58717,
      254,
      "    pub fn prev_item(&self) -> Option<(&C::Item, usize)> {\n\
      \        if self.item_offset == 0 {\n\
      \            assert!(self.cursor.userpos == 0, \"Invalid cursor\");\n\
      \            None\n\
      \        } else {\n\
      \            Some((unsafe { self.cursor.current_item() }, \
       self.item_offset))\n\
      \        }\n\
      \    }\n\n\
      \    pub fn advance_item(&mut self) {\n" );
    ( 16098,
      0,
      "    unsafe fn prev_item(&self) -> &'a C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        assert!(self.local_index > 0);\n\
      \        debug_assert!(self.local_index < node.num_items as usize);\n\
      \        &*(node.items[self.local_index - 1].as_ptr())\n\
      \    }\n\n" );
    ( 59163,
      76,
      "            Some((unsafe { self.cursor.prev_item() }, self.item_offset))\n"
    );
    (59235, 0, "\n        } else {");
    (59146, 17, "");
    (59063, 0, "\n            ");
    (59076, 0, "i");
    (59077, 0, "f");
    (59078, 0, " ");
    (59079, 0, "s");
    (59080, 0, "e");
    (59081, 0, "l");
    (59082, 0, "f");
    (59083, 0, ".");
    (59084, 0, "c");
    (59085, 0, "u");
    (59086, 0, "r");
    (59087, 0, "s");
    (59088, 0, "o");
    (59089, 0, "r");
    (59090, 0, ".");
    (59091, 0, "i");
    (59092, 0, "n");
    (59093, 0, "d");
    (59094, 0, "e");
    (59095, 0, "x");
    (59091, 5, "local_index");
    (59102, 0, " ");
    (59103, 0, "=");
    (59104, 0, "=");
    (59105, 0, " ");
    (59106, 0, "0");
    (59107, 0, " ");
    (59108, 0, "{");
    (59122, 0, "    ");
    (59191, 0, "    ");
    (59199, 0, "\n                ");
    (59200, 16, "            }");
    (59213, 0, " ");
    (59214, 0, "e");
    (59215, 0, "l");
    (59216, 0, "s");
    (59217, 0, "e");
    (59218, 0, " ");
    (59219, 0, "{");
    (59233, 0, "    ");
    (59297, 0, "\n                ");
    (59298, 16, "            }");
    (59298, 13, "                ");
    (59298, 16, "            }");
    (59328, 0, "\n            ");
    (59341, 0, "Some((unsafe { self.cursor.prev_item() }, self.item_offset))");
    (59368, 9, "n");
    (59369, 0, "e");
    (59369, 1, "");
    (59368, 1, "");
    (59368, 0, "c");
    (59369, 0, "u");
    (59370, 0, "r");
    (59371, 0, "r");
    (59368, 4, "current_item()");
    (59381, 1, "");
    (59380, 1, "");
    (16263, 0, "=");
    (20455, 80, "");
    (20454, 1, "");
    (20453, 1, "");
    (20452, 1, "");
    (53884, 1, "");
    (53883, 1, "");
    (53883, 5, "");
    (53874, 0, "S");
    (53875, 0, "e");
    (53876, 0, "l");
    (53877, 0, "f");
    (53878, 0, ":");
    (53879, 0, ":");
    (1897, 0, "\n");
    (1898, 0, "\n");
    (1899, 0, "\n");
    (1899, 1, "");
    (1899, 0, "i");
    (1900, 0, "m");
    (1901, 0, "p");
    (1902, 0, "l");
    (1903, 0, " ");
    (1904, 0, "I");
    (1905, 0, "t");
    (1906, 0, "e");
    (1907, 0, "m");
    (1904, 4, "ItemMarker");
    (1914, 0, " ");
    (1915, 0, "{");
    (1916, 0, "\n    ");
    (1921, 0, "\n    ");
    (1917, 4, "");
    (1918, 4, "}");
    (1917, 0, "    ");
    (1921, 0, "n");
    (1922, 0, "u");
    (1923, 0, "l");
    (1924, 0, "l");
    (1921, 0, "f");
    (1922, 0, "n");
    (1923, 0, " ");
    (1928, 0, ")");
    (1929, 0, "(");
    (1929, 1, "");
    (1928, 1, "");
    (1928, 0, "(");
    (1929, 0, ")");
    (1930, 0, " ");
    (1931, 0, "-");
    (1932, 0, ">");
    (1933, 0, " ");
    (1934, 0, "I");
    (1935, 0, "t");
    (1936, 0, "e");
    (1937, 0, "m");
    (1934, 4, "ItemMarker");
    (1944, 0, " ");
    (1945, 0, "{");
    (1946, 0, "\n        ");
    (1955, 0, "I");
    (1956, 0, "t");
    (1957, 0, "e");
    (1958, 0, "m");
    (1959, 0, "M");
    (1955, 5, "ItemMarker");
    (1965, 0, " ");
    (1966, 0, "{");
    (1967, 0, " ");
    (1968, 0, "p");
    (1969, 0, "t");
    (1970, 0, "r");
    (1971, 0, ":");
    (1972, 0, " ");
    (1973, 0, "P");
    (1974, 0, "t");
    (1975, 0, "r");
    (1975, 1, "");
    (1974, 1, "");
    (1973, 1, "");
    (1973, 0, "p");
    (1974, 0, "t");
    (1975, 0, "r");
    (1976, 0, ":");
    (1977, 0, ":");
    (1978, 0, "n");
    (1979, 0, "u");
    (1980, 0, "l");
    (1978, 3, "null()");
    (1984, 0, " ");
    (1985, 0, "}");
    (1986, 0, " ");
    (1986, 1, "");
    (1986, 0, "\n        ");
    (1987, 8, "    }");
    (1903, 0, "<");
    (1904, 0, "C");
    (1905, 0, ">");
    (1917, 0, "<");
    (1918, 0, "C");
    (1919, 0, ">");
    (1950, 0, "<");
    (1951, 0, "C");
    (1952, 0, ">");
    (1905, 0, ":");
    (1906, 0, " ");
    (1907, 0, "L");
    (1908, 0, "i");
    (1909, 0, "s");
    (1910, 0, "t");
    (1907, 4, "ListConfig");
    (2003, 0, "_");
    (2004, 0, "m");
    (2005, 0, "u");
    (2006, 0, "t");
    (1939, 0, "p");
    (1940, 0, "u");
    (1941, 0, "b");
    (1942, 0, " ");
    ( 1935,
      0,
      "    pub fn null() -> ItemMarker<C> {\n\
      \        ItemMarker { ptr: ptr::null_mut() }\n\
      \    }\n" );
    (2033, 0, "i");
    (2034, 0, "s");
    (2035, 0, "_");
    (2041, 0, "I");
    (2042, 0, "T");
    (2041, 2, "ItemMarker");
    (2051, 0, "<");
    (2052, 0, "C");
    (2053, 0, ">");
    (2041, 13, "&");
    (2042, 0, "s");
    (2043, 0, "e");
    (2044, 0, "l");
    (2045, 0, "f");
    (2051, 13, "b");
    (2052, 0, "o");
    (2053, 0, "o");
    (2054, 0, "l");
    (2066, 35, "");
    (2066, 0, "p");
    (2067, 0, "t");
    (2068, 0, "r");
    (2069, 0, ":");
    (2070, 0, ":");
    (2071, 0, "i");
    (2072, 0, "s");
    (2072, 1, "");
    (2071, 1, "");
    (2070, 1, "");
    (2070, 0, ":");
    (2066, 5, "");
    (2066, 0, "s");
    (2067, 0, "e");
    (2068, 0, "l");
    (2069, 0, ".");
    (2069, 1, "");
    (2069, 0, "f");
    (2070, 0, ".");
    (2071, 0, "p");
    (2072, 0, "t");
    (2073, 0, "r");
    (2074, 0, ".");
    (2075, 0, "i");
    (2076, 0, "s");
    (2077, 0, "_");
    (2078, 0, "n");
    (2079, 0, "u");
    (2080, 0, "l");
    (2081, 0, "l");
    (2082, 0, "(");
    (2083, 0, ")");
    (2041, 1, "");
    (2021, 0, "\n    ");
    (54174, 0, "// ");
    (54153, 0, "// ");
    (54097, 0, "// ");
    (54006, 0, "// ");
    (53939, 0, "// ");
    (53881, 0, "// ");
    (53840, 0, "// ");
    (53780, 0, "// ");
    (2022, 4, "");
    ( 53772,
      0,
      "    // pub fn edit<F, R>(&mut self, userpos: usize, f: F) -> R\n\
      \    // where F: FnOnce(&mut Edit<C>) -> R {\n\
      \    //     // self.edit_notify(userpos, no_notify_x::<C>, f)\n\
      \    //     let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \    //     let mut edit = Edit { list: self, cursor, item_offset, \
       notify: Self::no_notify };\n\n\
      \    //     // TODO: Or maybe I should pass ownership here?\n\
      \    //     f(&mut edit)\n\
      \    // }\n" );
    (54615, 3, "");
    (54591, 3, "");
    (54532, 3, "");
    (54438, 3, "");
    (54368, 3, "");
    (54307, 3, "");
    (54263, 3, "");
    (54200, 3, "");
    (54211, 6, "");
    (54237, 6, "");
    (54242, 1, "");
    (54242, 0, "E");
    (54243, 0, "d");
    (54244, 0, "i");
    (54245, 0, "t");
    (54246, 0, "<");
    (54247, 0, "C");
    (54248, 0, ">");
    (54249, 39, "");
    (54249, 0, " ");
    (54249, 1, "");
    (54532, 12, "");
    (54385, 15, "");
    (54452, 65, "");
    (54451, 1, "");
    (54450, 1, "");
    (53735, 14, "");
    (53438, 14, "");
    (53256, 14, "");
    (53707, 0, ")");
    (53424, 0, ")");
    (53256, 0, ")");
    (53710, 0, ".");
    (53426, 0, ".");
    (53257, 0, ".");
    (53727, 1, "");
    (53449, 1, "");
    (53281, 1, "");
    (53280, 1, "");
    (52803, 0, ")");
    (52804, 0, ".");
    (52805, 28, "");
    (52846, 11, "");
    (54403, 6, "");
    (53694, 424, "");
    (54005, 51, "");
    (54005, 0, ")");
    (54006, 0, " ");
    (54007, 0, "-");
    (54008, 0, ">");
    (54009, 0, " ");
    (54010, 0, "E");
    (54011, 0, "d");
    (54012, 0, "i");
    (54013, 0, "t");
    (54014, 0, "<");
    (54015, 0, "C");
    (54016, 0, ">");
    (54017, 40, "");
    (54017, 0, " ");
    (54160, 77, "");
    (54159, 1, "");
    (54158, 1, "");
    (54158, 0, ";\n");
    ( 54160,
      0,
      "\n\
      \        // TODO: Or maybe I should pass ownership here?\n\
      \        f(&mut edit)" );
    (54017, 1, "");
    (54017, 0, "\n    where F: FnOnce(&mut Edit<C>) -> R ");
    (54009, 8, "");
    (54006, 3, "");
    (54005, 1, "");
    (54005, 0, ", notify: fn(&[C::Item], ItemMarker<C>), f: F) -> R");
    ( 53694,
      0,
      "\n\
      \    // pub fn edit<F, R>(&mut self, userpos: usize, f: F) -> R\n\
      \    // where F: FnOnce(&mut Edit<C>) -> R {\n\
      \    //     // self.edit_notify(userpos, no_notify_x::<C>, f)\n\
      \    //     let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \    //     let mut edit = Edit { list: self, cursor, item_offset, \
       notify: Self::no_notify };\n\n\
      \    //     // TODO: Or maybe I should pass ownership here?\n\
      \    //     f(&mut edit)\n\
      \    // }" );
    (53694, 424, "");
    (54005, 51, "");
    (54005, 0, ", notify: fn(&[C::Item], ItemMarker<C>), f: F) -> R");
    (54049, 1, "");
    (54048, 1, "");
    (54047, 1, "");
    (54046, 1, "");
    (54045, 1, "");
    (54044, 1, "");
    (54049, 1, "");
    (54049, 26, "");
    (54056, 6, "");
    (54044, 1, "");
    (54044, 0, ")");
    (54199, 77, "");
    (54198, 1, "");
    (54197, 1, "");
    (54134, 15, "");
    (58866, 0, "\n                ");
    (58883, 0, "/");
    (58884, 0, "/");
    (58885, 0, " ");
    (58886, 0, "C");
    (58953, 0, " ");
    (58954, 0, "a");
    (58955, 0, "t");
    (58956, 0, " ");
    (58957, 0, "s");
    (58958, 0, "t");
    (58959, 0, "a");
    (58960, 0, "r");
    (58961, 0, "t");
    (58962, 0, " ");
    (58963, 0, "o");
    (58964, 0, "f");
    (58965, 0, " ");
    (58966, 0, "n");
    (58967, 0, "o");
    (58968, 0, "d");
    (58969, 0, "e");
    (58947, 0, "s");
    (58948, 0, "t");
    (58949, 0, "a");
    (58950, 0, "t");
    (58951, 0, "e");
    (58952, 0, ":");
    (58953, 0, " ");
    (58954, 1, "");
    (58954, 0, "C");
    (58867, 20, "");
    (58866, 1, "");
    (58866, 0, "\n                ");
    (58883, 0, "/");
    (58884, 0, "/");
    (58885, 0, " ");
    (58886, 0, "C");
    (58887, 0, "u");
    (58888, 0, "r");
    (58889, 0, "s");
    (58890, 0, "o");
    (58891, 0, "r");
    (58892, 0, "s");
    (58893, 0, " ");
    (58894, 0, "s");
    (58895, 0, "h");
    (58896, 0, "o");
    (58897, 0, "u");
    (58898, 0, "l");
    (58899, 0, "d");
    (58900, 0, " ");
    (58901, 0, "a");
    (58902, 0, "l");
    (58903, 0, "w");
    (58904, 0, "a");
    (58905, 0, "y");
    (58906, 0, "s");
    (58907, 0, " ");
    (58908, 0, "b");
    (58909, 0, "e");
    (58910, 0, " ");
    (58911, 0, "a");
    (58912, 0, "t");
    (58913, 0, " ");
    (58914, 0, "t");
    (58915, 0, "h");
    (58916, 0, "e");
    (58917, 0, " ");
    (58918, 0, "e");
    (58919, 0, "n");
    (58920, 0, "d");
    (58921, 0, " ");
    (58922, 0, "o");
    (58923, 0, "f");
    (58924, 0, " ");
    (58925, 0, "t");
    (58926, 0, "h");
    (58927, 0, "e");
    (58928, 0, " ");
    (58929, 0, "i");
    (58930, 0, "t");
    (58931, 0, "e");
    (58932, 0, "m");
    (58933, 0, " ");
    (58886, 48, "");
    (58886, 0, "C");
    (58887, 0, "u");
    (58888, 0, "r");
    (58889, 0, "s");
    (58890, 0, "o");
    (58891, 0, "r");
    (58892, 0, "s");
    (58893, 0, " ");
    (58894, 0, "s");
    (58895, 0, "h");
    (58896, 0, "o");
    (58897, 0, "u");
    (58898, 0, "l");
    (58899, 0, "d");
    (58900, 0, " ");
    (58894, 7, "s");
    (58895, 0, "t");
    (58896, 0, "i");
    (58897, 0, "c");
    (58898, 0, "k");
    (58899, 0, " ");
    (58900, 0, "t");
    (58901, 0, "o");
    (58902, 0, " ");
    (58903, 0, "t");
    (58904, 0, "h");
    (58905, 0, "e");
    (58906, 0, " ");
    (58907, 0, "e");
    (58908, 0, "n");
    (58909, 0, "e");
    (58909, 1, "");
    (58909, 0, "d");
    (58910, 0, " ");
    (58911, 0, "o");
    (58912, 0, "f");
    (58913, 0, " ");
    (58914, 0, "a");
    (58915, 0, " ");
    (58916, 0, "n");
    (58917, 0, "o");
    (58918, 0, "d");
    (58919, 0, "e");
    (58894, 0, "a");
    (58895, 0, "t");
    (58896, 0, " ");
    (58897, 0, "t");
    (58898, 0, "h");
    (58899, 0, "e");
    (58900, 0, " ");
    (58901, 0, "e");
    (58902, 0, "n");
    (58903, 0, "d");
    (58904, 0, " ");
    (58905, 0, "o");
    (58906, 0, "f");
    (58907, 0, " ");
    (58908, 0, "a");
    (58909, 0, " ");
    (58910, 0, "n");
    (58911, 0, "o");
    (58912, 0, "d");
    (58913, 0, "e");
    (58914, 0, " ");
    (58920, 21, "");
    (58915, 5, "d");
    (58916, 0, "o");
    (58917, 0, "n");
    (58918, 0, "'");
    (58919, 0, "t");
    (58920, 0, " ");
    (58921, 0, "m");
    (58922, 0, "o");
    (58923, 0, "v");
    (58924, 0, "e");
    (58925, 0, " ");
    (58926, 0, "t");
    (58927, 0, "o");
    (58928, 0, " ");
    (58929, 0, "t");
    (58930, 0, "h");
    (58931, 0, "e");
    (58932, 0, " ");
    (58933, 0, "n");
    (58934, 0, "e");
    (58935, 0, "x");
    (58936, 0, "t");
    (58937, 0, " ");
    (58938, 0, "n");
    (58939, 0, "o");
    (58940, 0, "d");
    (58941, 0, "e");
    (58886, 56, "");
    (58886, 0, "W");
    (58887, 0, "h");
    (58888, 0, "e");
    (58889, 0, "n");
    (58890, 0, " ");
    (58890, 1, "");
    (58890, 0, " ");
    (58886, 5, "T");
    (58887, 0, "h");
    (58888, 0, "e");
    (58889, 0, " ");
    (58890, 0, "o");
    (58891, 0, "n");
    (58892, 0, "l");
    (58893, 0, "y");
    (58894, 0, " ");
    (58895, 0, "t");
    (58896, 0, "i");
    (58897, 0, "m");
    (58898, 0, "e");
    (58899, 0, " ");
    (58900, 0, "a");
    (58901, 0, " ");
    (58902, 0, "c");
    (58903, 0, "u");
    (58904, 0, "r");
    (58905, 0, "s");
    (58906, 0, "o");
    (58907, 0, "r");
    (58908, 0, " ");
    (58909, 0, "i");
    (58910, 0, "s");
    (58911, 0, " ");
    (58912, 0, "r");
    (58913, 0, "i");
    (58914, 0, "g");
    (58915, 0, "h");
    (58916, 0, "t");
    (58917, 0, " ");
    (58918, 0, "a");
    (58919, 0, "t");
    (58920, 0, " ");
    (58921, 0, "t");
    (58922, 0, "h");
    (58923, 0, "e");
    (58924, 0, " ");
    (58925, 0, "s");
    (58926, 0, "t");
    (58927, 0, "a");
    (58928, 0, "r");
    (58929, 0, "t");
    (58930, 0, " ");
    (58931, 0, "o");
    (58932, 0, "f");
    (58933, 0, " ");
    (58934, 0, "n");
    (58935, 0, "o");
    (58935, 1, "");
    (58934, 1, "");
    (58934, 0, "t");
    (58935, 0, "h");
    (58936, 0, "e");
    (58937, 0, " ");
    (58938, 0, "n");
    (58939, 0, "o");
    (58940, 0, "d");
    (58941, 0, "e");
    (58942, 0, ",");
    (58943, 0, " ");
    (58943, 1, "");
    (58942, 1, "");
    (58942, 0, " ");
    (58943, 0, "i");
    (58944, 0, "s");
    (58945, 0, " ");
    (58946, 0, "w");
    (58947, 0, "h");
    (58948, 0, "e");
    (58949, 0, "n");
    (58950, 0, " ");
    (58951, 0, "t");
    (58952, 0, "h");
    (58953, 0, "e");
    (58954, 0, " ");
    (58955, 0, "c");
    (58956, 0, "u");
    (58957, 0, "r");
    (58958, 0, "s");
    (58959, 0, "o");
    (58960, 0, "r");
    (58961, 0, " ");
    (58962, 0, "s");
    (58962, 1, "");
    (58962, 0, "i");
    (58963, 0, "s");
    (58964, 0, " ");
    (58965, 0, "r");
    (58966, 0, "i");
    (58967, 0, "g");
    (58968, 0, "h");
    (58965, 4, "a");
    (58966, 0, "t");
    (58967, 0, " ");
    (58968, 0, "t");
    (58969, 0, "h");
    (58970, 0, "e");
    (58971, 0, " ");
    (58972, 0, "s");
    (58973, 0, "t");
    (58974, 0, "a");
    (58975, 0, "r");
    (58976, 0, "t");
    (58977, 0, " ");
    (58978, 0, "o");
    (58979, 0, "f");
    (58980, 0, " ");
    (58981, 0, "t");
    (58982, 0, "n");
    (58982, 1, "");
    (58982, 0, "h");
    (58983, 0, "e");
    (58984, 0, " ");
    (58985, 0, "e");
    (58986, 0, "n");
    (58987, 0, "t");
    (58988, 0, "i");
    (58989, 0, "r");
    (58990, 0, "e");
    (58991, 0, " ");
    (58992, 0, "l");
    (58993, 0, "i");
    (58994, 0, "s");
    (58995, 0, "t");
    (58996, 0, ".");
    ( 58867,
      130,
      "                // The only time a cursor is right at the start of the \
       node is\n\
      \                // when the cursor is at the start of the entire list."
    );
    (58909, 2, "s");
    (58910, 0, "h");
    (58911, 0, "o");
    (58912, 0, "u");
    (58913, 0, "l");
    (58914, 0, "d");
    (58915, 0, " ");
    (58916, 0, "b");
    (58917, 0, "e");
    (58919, 5, "");
    (58918, 1, "");
    (1897, 0, "\n");
    (1898, 0, "\n");
    (1899, 0, "i");
    (1900, 0, "m");
    (1901, 0, "p");
    (1902, 0, "l");
    (1903, 0, " ");
    (1904, 0, "C");
    (1905, 0, "o");
    (1906, 0, "p");
    (1907, 0, "y");
    (1908, 0, " ");
    (1909, 0, "f");
    (1910, 0, "o");
    (1911, 0, "r");
    (1912, 0, " ");
    (1913, 0, "I");
    (1914, 0, "t");
    (1915, 0, "e");
    (1916, 0, "m");
    (1917, 0, "M");
    (1913, 5, "ItemMarker");
    (1923, 0, " ");
    (1924, 0, "{");
    (1925, 0, "}");
    (1903, 0, "<");
    (1904, 0, "C");
    (1905, 0, ":");
    (1906, 0, " ");
    (1907, 0, "L");
    (1908, 0, "i");
    (1909, 0, "s");
    (1910, 0, "t");
    (1907, 4, "ListConfig");
    (1917, 0, ">");
    (1938, 0, "<");
    (1939, 0, "C");
    (1940, 0, ">");
    (1779, 6, "");
    (1892, 0, "\n");
    (1893, 0, "i");
    (1894, 0, "m");
    (1895, 0, "p");
    (1896, 0, "l");
    (1943, 0, "\nimpl<C: ListConfig> Copy for ItemMarker<C> {}");
    (1893, 4, "");
    (1892, 1, "");
    (1913, 4, "C");
    (1914, 0, "l");
    (1915, 0, "o");
    (1916, 0, "n");
    (1917, 0, "e");
    (1764, 17, "");
    (1921, 0, "\n    \n");
    (1926, 0, "f");
    (1927, 0, "n");
    (1928, 0, " ");
    (1929, 0, "c");
    (1930, 0, "l");
    (1931, 0, "o");
    (1929, 3, "clone()");
    (1926, 0, "// ");
    (1926, 13, "fn clone(&self) -> Self;");
    (1949, 1, "");
    (1949, 0, " ");
    (1950, 0, "{");
    (1951, 0, " ");
    (1952, 0, "*");
    (1953, 0, "s");
    (1954, 0, "e");
    (1955, 0, "l");
    (1956, 0, "f");
    (1957, 0, " ");
    (1958, 0, "}");
    (1875, 0, "\n");
    (1876, 0, "/");
    (1877, 0, "/");
    (1878, 0, " ");
    (1879, 0, "D");
    (1880, 0, "e");
    (1881, 0, "r");
    (1882, 0, "i");
    (1883, 0, "v");
    (1884, 0, "e");
    (1885, 0, " ");
    (1886, 0, "t");
    (1887, 0, "r");
    (1888, 0, "a");
    (1889, 0, "i");
    (1890, 0, "t");
    (1891, 0, "s");
    (1892, 0, " ");
    (1893, 0, "d");
    (1894, 0, "o");
    (1895, 0, "n");
    (1896, 0, "'");
    (1897, 0, "t");
    (1898, 0, " ");
    (1899, 0, "w");
    (1900, 0, "o");
    (1901, 0, "r");
    (1902, 0, "k");
    (1903, 0, " ");
    (1904, 0, "h");
    (1905, 0, "e");
    (1906, 0, "r");
    (1907, 0, "e");
    (1908, 0, ".");
    (54159, 2, "F");
    (54160, 0, "n");
    (54161, 0, "M");
    (54162, 0, "u");
    (54163, 0, "t");
    (54159, 0, "i");
    (54160, 0, "m");
    (54161, 0, "p");
    (54162, 0, "l");
    (54163, 0, " ");
    (55769, 0, "// ");
    (55727, 0, "// ");
    (55670, 0, "// ");
    (55647, 0, "// ");
    (55616, 0, "// ");
    (55579, 0, "// ");
    (55574, 3, "");
    (55552, 3, "");
    (55492, 3, "");
    (55466, 3, "");
    (55432, 3, "");
    (55350, 3, "");
    (55559, 0, "// ");
    (55540, 0, "// ");
    (55483, 0, "// ");
    (55460, 0, "// ");
    (55429, 0, "// ");
    (55350, 0, "// ");
    (55784, 3, "");
    (55739, 3, "");
    (55679, 3, "");
    (55653, 3, "");
    (55619, 3, "");
    (55579, 3, "");
    (55727, 0, "    notify: fn(&[C::Item], ItemMarker<C>)\n");
    (55773, 0, "// ");
    (55739, 2, "i");
    (55740, 0, "m");
    (55741, 0, "p");
    (55742, 0, "l");
    (55743, 0, " ");
    (55744, 0, "F");
    (55745, 0, "n");
    (55746, 0, "M");
    (55747, 0, "u");
    (55748, 0, "t");
    (55743, 6, "");
    (55739, 4, "fn");
    (55773, 3, "");
    (55727, 42, "");
    (55769, 0, "// ");
    (55727, 0, "// ");
    (55670, 0, "// ");
    (55647, 0, "// ");
    (55616, 0, "// ");
    (55579, 0, "// ");
    (55574, 3, "");
    (55552, 3, "");
    (55492, 3, "");
    (55466, 3, "");
    (55432, 3, "");
    (55350, 3, "");
    (54098, 0, "// ");
    (54024, 0, "// ");
    (53957, 0, "// ");
    (53899, 0, "// ");
    (53843, 0, "// ");
    (54138, 0, "<");
    (54139, 0, "N");
    (54140, 0, ":");
    (54141, 0, " ");
    (54142, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    (54174, 0, ">");
    (54259, 0, ",");
    (54260, 0, " ");
    (54261, 0, "N");
    (54211, 37, "N");
    (54110, 3, "");
    (54033, 3, "");
    (53963, 3, "");
    (53902, 3, "");
    (53843, 3, "");
    (53891, 0, ",");
    (53892, 0, " ");
    (53893, 0, "i");
    (53894, 0, "m");
    (53895, 0, "p");
    (53896, 0, "l");
    (53897, 0, " ");
    (53898, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    (55928, 0, ",");
    (55929, 0, " ");
    (55930, 0, "FnMut(&[C::Item], ItemMarker<C>)");
    (55930, 0, "N");
    (55931, 0, ":");
    (55932, 0, " ");
    (55977, 0, ",");
    (55978, 0, " ");
    (55979, 0, "N");
    (49409, 0, "&");
    (52104, 5, "");
    (49410, 0, "m");
    (49411, 0, "u");
    (49412, 0, "t");
    (49413, 0, " ");
    (49397, 4, "");
    (52318, 0, "&");
    (52319, 0, "m");
    (52320, 0, "u");
    (52321, 0, "t");
    (52322, 0, " ");
    (58870, 0, "&");
    (58871, 0, "m");
    (58872, 0, "u");
    (58873, 0, "t");
    (58874, 0, " ");
    (59452, 16, "");
    (59452, 0, "C");
    (59453, 0, ":");
    (59454, 0, ":");
    (59455, 0, "get_usersize(_item: &Self::Item)");
    (59393, 0, "\n                ");
    (59410, 0, "l");
    (59411, 0, "e");
    (59412, 0, "t");
    (59413, 0, " ");
    (59414, 0, "p");
    (59415, 0, "r");
    (59416, 0, "e");
    (59417, 0, "v");
    (59418, 0, "_");
    (59419, 0, "i");
    (59420, 0, "t");
    (59421, 0, "e");
    (59422, 0, "m");
    (59423, 0, " ");
    (59424, 0, "=");
    (59425, 0, " ");
    (59458, 23, "");
    (59458, 0, "self.cursor.prev_item()");
    (59449, 34, "");
    (59426, 0, "unsafe { self.cursor.prev_item() }");
    (59460, 0, ";");
    (59484, 0, "p");
    (59485, 0, "r");
    (59486, 0, "e");
    (59487, 0, "v");
    (59488, 0, "_");
    (59484, 5, "prev_item");
    (59511, 18, "p");
    (59512, 0, "r");
    (59513, 0, "e");
    (59514, 0, "v");
    (59511, 4, "prev_item");
    (55393, 5375, "");
    (56742, 0, "\n");
    (56743, 0, "\n");
    (56744, 0, "\n");
    (56745, 0, "\n");
    ( 56746,
      0,
      "\n\
       pub struct Edit<'a, C: ListConfig, Notify: FnMut(&[C::Item], \
       ItemMarker<C>)> {\n\
      \    list: &'a mut SkipList<C>,\n\
      \    cursor: Cursor<C>,\n\
      \    item_offset: usize, // Offset into the current item.\n\
      \    notify: Notify\n\
       }\n\
       // pub struct Edit<'a, C: ListConfig> {\n\
       //     list: &'a mut SkipList<C>,\n\
       //     cursor: Cursor<C>,\n\
       //     item_offset: usize, // Offset into the current item.\n\
       //     notify: fn(&[C::Item], ItemMarker<C>)\n\
       // }\n\n\
       // impl<'a, C: ListConfig, Notify: FnMut(&[C::Item], ItemMarker<C>)> \
       Edit<'a, C, Notify> {\n\
       impl<'a, C: ListConfig, N: FnMut(&[C::Item], ItemMarker<C>)> Edit<'a, \
       C, N> {\n\
      \    fn dbg_check_cursor_at(&self, userpos: usize, plus_items: usize) {\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (mut c2, _) = self.list.iter_at_userpos(userpos);\n\
      \            c2.advance_by_items(plus_items, self.list.head.height);\n\
      \            assert_eq!(&self.cursor, &c2);\n\
      \        }\n\
      \    }\n\n\
      \    pub fn del(&mut self, num_items: usize) {\n\
      \        assert_eq!(self.item_offset, 0, \"Splitting nodes not yet \
       supported\");\n\n\
      \        unsafe { self.list.del_at_iter(&self.cursor, num_items); }\n\n\
      \        if cfg!(debug_assertions) {\n\
      \            let (c2, _) = self.list.iter_at_userpos(self.cursor.userpos);\n\
      \            if &self.cursor != &c2 { panic!(\"Invalid cursor after \
       delete\"); }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn insert_iter<I>(&mut self, mut contents: I) where I: \
       ExactSizeIterator<Item=C::Item> {\n\
      \        if contents.len() == 0 { return; }\n\
      \        let num_inserted_items = contents.len();\n\
      \        \n\
      \        // userpos = min(userpos, self.get_userlen());\n\
      \        // let (mut cursor, offset) = self.iter_at_userpos(userpos);\n\n\
      \        let start_userpos = self.cursor.userpos;\n\n\
      \        unsafe {\n\
      \            if self.item_offset == 0 {\n\
      \                self.list.insert_at_iter(&mut self.cursor, &mut \
       contents, &mut self.notify);\n\n\
      \                self.dbg_check_cursor_at(start_userpos, \
       num_inserted_items);\n\
      \            } else {\n\
      \                let current_item = self.cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, \
       self.item_offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                self.cursor.move_to_item_start(self.list.head.height, \
       self.item_offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.list.replace_item(&mut self.cursor, start, &mut \
       self.notify);\n\n\
      \                // TODO: Consider concatenating end into contents then \
       just call\n\
      \                // insert_at_iter once.\n\
      \                self.list.insert_at_iter(&mut self.cursor, &mut \
       contents, &mut self.notify);\n\n\
      \                self.dbg_check_cursor_at(start_userpos, \
       num_inserted_items);\n\n\
      \                self.list.insert_at_iter(&mut self.cursor, &mut \
       iter::once(end), &mut self.notify);\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    pub fn insert(&mut self, item: C::Item) {\n\
      \        self.insert_iter(iter::once(item));\n\
      \    }\n\n\
      \    pub fn insert_slice(&mut self, items: &[C::Item]) where C::Item: \
       Copy {\n\
      \        self.insert_iter(items.iter().copied());\n\
      \    }\n\n\
      \    pub fn replace<I>(&mut self, removed_items: usize, mut \
       inserted_content: I)\n\
      \    where I: ExactSizeIterator<Item=C::Item> {\n\
      \        assert_eq!(self.item_offset, 0, \"Splitting nodes not yet \
       supported\");\n\n\
      \        let num_inserted_items = inserted_content.len();\n\
      \        let start_userpos = self.cursor.userpos;\n\
      \        \n\
      \        unsafe { self.list.replace_at_iter(&mut self.cursor, \
       removed_items, &mut inserted_content, &mut self.notify); }\n\n\
      \        self.dbg_check_cursor_at(start_userpos, num_inserted_items);\n\
      \    }\n\n\
      \    pub fn prev_item(&self) -> Option<(&C::Item, usize)> {\n\
      \        if self.item_offset == 0 {\n\
      \            if self.cursor.local_index == 0 {\n\
      \                // The only time a cursor should be at the start of the \
       node is\n\
      \                // when the cursor is at the start of the entire list.\n\
      \                assert!(self.cursor.userpos == 0, \"Invalid state: \
       Cursor at start of node\");\n\
      \                None\n\
      \            } else {\n\
      \                let prev_item = unsafe { self.cursor.prev_item() };\n\
      \                Some((prev_item, C::get_usersize(prev_item)))\n\
      \            }\n\
      \        } else {\n\
      \            Some((unsafe { self.cursor.current_item() }, \
       self.item_offset))\n\
      \        }\n\
      \    }\n\n\
      \    pub fn advance_item(&mut self) {\n\
      \        self.cursor.advance_item(self.list.head.height);\n\
      \        self.item_offset = 0;\n\
      \    }\n\n\
      \    pub fn modify_item<F>(&mut self, modify_fn: F) where F: FnOnce(&mut \
       C::Item, usize) {\n\
      \        let e = self.cursor.here_ptr();\n\
      \        let item = unsafe { self.cursor.current_item_mut() };\n\
      \        let old_usersize = C::get_usersize(item);\n\
      \        modify_fn(item, self.item_offset);\n\
      \        let new_usersize = C::get_usersize(item);\n\n\
      \        let usersize_delta = new_usersize as isize - old_usersize as \
       isize;\n\n\
      \        if usersize_delta != 0 {\n\
      \            self.cursor.update_offsets(self.list.head.height as usize, \
       usersize_delta);\n\
      \            self.list.num_usercount = \
       self.list.num_usercount.wrapping_add(usersize_delta as usize);\n\
      \            self.item_offset = usize::max(self.item_offset, \
       new_usersize);\n\
      \        }\n\n\
      \        (self.notify)(std::slice::from_ref(item), ItemMarker {\n\
      \            ptr: e,\n\
      \            // _phantom: PhantomData,\n\
      \        });\n\
      \    }\n\n\
      \    pub fn replace_item(&mut self, replacement: C::Item) {\n\
      \        self.modify_item(|old, _offset| *old = replacement);\n\
      \    }\n\
       }\n" );
    (56743, 0, "\n");
    (56744, 0, "i");
    (56745, 0, "m");
    (56746, 0, "p");
    (56747, 0, "l");
    (56748, 0, "<");
    (56749, 0, "C");
    (56750, 0, ":");
    (56751, 0, " ");
    (56752, 0, "L");
    (56753, 0, "i");
    (56754, 0, "s");
    (56755, 0, "t");
    (56752, 4, "ListConfig");
    (56762, 0, ">");
    (56763, 0, " ");
    (56764, 0, "D");
    (56765, 0, "e");
    (56766, 0, "b");
    (56767, 0, "u");
    (56768, 0, "g");
    (56764, 0, "f");
    (56765, 0, "m");
    (56766, 0, "t");
    (56767, 0, ":");
    (56768, 0, ":");
    (56769, 0, "Debug");
    (56769, 5, "");
    (56774, 0, " ");
    (56775, 0, "f");
    (56776, 0, "o");
    (56777, 0, "r");
    (56778, 0, " ");
    (56779, 0, "S");
    (56780, 0, "k");
    (56781, 0, "i");
    (56782, 0, "l");
    (56779, 4, "SkipList");
    (56787, 0, "<");
    (56788, 0, "C");
    (56789, 0, ">");
    (56790, 0, " ");
    (56791, 0, "{");
    (56792, 0, "\n    ");
    (56797, 0, "\n    ");
    (56793, 4, "");
    (56794, 4, "}");
    (56793, 0, "    ");
    (56797, 0, "n");
    (56797, 1, "");
    (56797, 0, "f");
    (56798, 0, "n");
    (56799, 0, " ");
    (56800, 0, "f");
    (56801, 0, "m");
    (56802, 0, "t");
    (56803, 0, "(");
    (56804, 0, "&");
    (56805, 0, "s");
    (56806, 0, "e");
    (56807, 0, "l");
    (56808, 0, "f");
    (56809, 0, ",");
    (56810, 0, " ");
    (56811, 0, "f");
    (56812, 0, ":");
    (56813, 0, " ");
    (56814, 0, "&");
    (56815, 0, "m");
    (56816, 0, "u");
    (56817, 0, "t");
    (56818, 0, " ");
    (56819, 0, "F");
    (56820, 0, "o");
    (56821, 0, "r");
    (56822, 0, "m");
    (56823, 0, "a");
    (56824, 0, "t");
    (56825, 0, "t");
    (56826, 0, "e");
    (56827, 0, "r");
    (56819, 9, "Formatter");
    (56828, 0, "<");
    (56829, 0, "'");
    (56830, 0, "_");
    (56831, 0, "'");
    (56831, 1, "");
    (56831, 0, ">");
    (56832, 0, ")");
    (56833, 0, " ");
    (56834, 0, "-");
    (56835, 0, ">");
    (56836, 0, " ");
    (56837, 0, "R");
    (56838, 0, "e");
    (56839, 0, "s");
    (56840, 0, "u");
    (56841, 0, "l");
    (56842, 0, "t");
    (56843, 0, " ");
    (56844, 0, "{");
    (56845, 0, "\n        ");
    (56854, 0, "\n        ");
    (56846, 8, "");
    (56847, 8, "    }");
    (56792, 0, "\n    ");
    (56797, 0, "u");
    (56798, 0, "s");
    (56799, 0, "e");
    (56800, 0, " ");
    (56801, 0, "s");
    (56802, 0, "t");
    (56803, 0, "d");
    (56804, 0, ":");
    (56805, 0, ":");
    (56806, 0, "f");
    (56807, 0, "m");
    (56808, 0, "t");
    (56809, 0, ":");
    (56810, 0, ":");
    (56811, 0, "F");
    (56812, 0, "o");
    (56813, 0, "r");
    (56811, 3, "");
    (56811, 0, "*");
    (56812, 0, ";");
    (56811, 1, "");
    (56811, 0, "F");
    (56812, 0, "o");
    (56813, 0, "r");
    (56814, 0, "m");
    (56811, 4, "Formatter");
    (56848, 0, "s");
    (56849, 0, "t");
    (56850, 0, "d");
    (56851, 0, ":");
    (56852, 0, ":");
    (56853, 0, "f");
    (56854, 0, "m");
    (56855, 0, "t");
    (56856, 0, ":");
    (56857, 0, ":");
    (56793, 28, "");
    (56792, 1, "");
    (56819, 5, "");
    (56851, 0, "        ");
    (56859, 0, "f");
    (56860, 0, ".");
    (56861, 0, "d");
    (56862, 0, "e");
    (56863, 0, "b");
    (56864, 0, "u");
    (56865, 0, "g");
    (56861, 5, "debug_list()");
    (56873, 0, ".");
    (56874, 0, "e");
    (56875, 0, "n");
    (56876, 0, "t");
    (56877, 0, "r");
    (56878, 0, "i");
    (56879, 0, "e");
    (56880, 0, "s");
    (56881, 0, "(");
    (56882, 0, "s");
    (56883, 0, "e");
    (56884, 0, "l");
    (56885, 0, "f");
    (56886, 0, ".");
    (56894, 0, "// ");
    (56888, 0, "// ");
    (56851, 0, "// ");
    (56793, 0, "// ");
    (56744, 0, "// ");
    (56743, 0, "\n");
    (56744, 0, "\n");
    (56744, 0, "i");
    (56745, 0, "m");
    (56746, 0, "p");
    (56747, 0, "l");
    (56748, 0, " ");
    (56744, 5, "");
    (56743, 1, "");
    (56796, 0, "\n// impl<C: ListConfig> fmt::Debug for SkipList<C> {");
    (56796, 0, "\n");
    (56744, 1, "");
    (56795, 0, "\n");
    (56743, 1, "");
    (56794, 1, "");
    (56743, 0, "\n");
    (56744, 3, "");
    (56764, 10, "I");
    (56765, 0, "t");
    (56766, 0, "e");
    (56767, 0, "r");
    (56768, 0, "a");
    (56769, 0, "t");
    (56770, 0, "o");
    (56771, 0, "r");
    (56790, 0, "\n    ");
    (56795, 0, "\n    ");
    (56791, 4, "");
    (56792, 4, "}");
    (56791, 0, "    ");
    (56795, 0, "t");
    (56796, 0, "y");
    (56797, 0, "p");
    (56798, 0, "e");
    (56799, 0, " ");
    (56800, 0, "I");
    (56801, 0, "t");
    (56802, 0, "e");
    (56803, 0, "m");
    (56804, 0, " ");
    (56805, 0, "=");
    (56806, 0, " ");
    (56807, 0, "C");
    (56808, 0, ":");
    (56809, 0, ":");
    (56810, 0, "I");
    (56811, 0, "t");
    (56812, 0, "e");
    (56813, 0, "m");
    (56810, 4, "Item");
    (56814, 0, ";");
    (56815, 0, "\n    ");
    (56820, 0, "\n    ");
    (56816, 4, "");
    (56821, 0, "f");
    (56822, 0, "n");
    (56823, 0, " ");
    (56824, 0, "n");
    (56825, 0, "e");
    (56826, 0, "x");
    (56827, 0, "t");
    (56828, 0, "(");
    (56817, 12, "");
    (56816, 1, "");
    (56744, 74, "/");
    ( 56744,
      1,
      "impl<C: ListConfig> Iterator for SkipList<C> {\n\
      \    type Item = C::Item;\n\n\
       }" );
    (56817, 0, "// ");
    (56791, 0, "// ");
    (56744, 0, "// ");
    (56743, 0, "\n");
    ( 56744,
      0,
      "\n\
       struct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\n\
       impl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n\
      \    type Item = &'a Node<C>;\n\n\
      \    fn next(&mut self) -> Option<&'a Node<C>> {\n\
      \        let prev = self.0;\n\
      \        if let Some(n) = self.0 {\n\
      \            *self = NodeIter(unsafe { \
       n.first_skip_entry().node.as_ref() });\n\
      \        }\n\
      \        prev\n\
      \    }\n\
       }\n" );
    (57104, 0, "\n");
    (56752, 4, "L");
    (56753, 0, "i");
    (56754, 0, "s");
    (56755, 0, "t");
    (56799, 0, ",");
    (56800, 0, " ");
    (56801, 0, "u");
    (56802, 0, "s");
    (56803, 0, "i");
    (56804, 0, "z");
    (56805, 0, "e");
    (56846, 8, "L");
    (56847, 0, "i");
    (56848, 0, "s");
    (56849, 0, "t");
    (56850, 0, "I");
    (56851, 0, "t");
    (56852, 0, "e");
    (56853, 0, "r");
    (56880, 11, "C");
    (56881, 0, ":");
    (56882, 0, ":");
    (56883, 0, "Item");
    (56927, 7, "C");
    (56928, 0, ":");
    (56929, 0, ":");
    (56930, 0, "I");
    (56927, 4, "S");
    (56928, 0, "e");
    (56929, 0, "l");
    (56930, 0, "f");
    (56931, 0, ":");
    (56932, 0, ":");
    (56933, 0, "I");
    (56934, 0, "t");
    (56935, 0, "e");
    (56936, 0, "m");
    (56927, 10, "C::I");
    (56927, 4, "Node<C>");
    (56927, 7, "C::I");
    (56927, 4, "Self::Item");
    (56926, 1, "");
    (56925, 1, "");
    (56924, 1, "");
    (56880, 0, "&");
    (56881, 0, "'");
    (56882, 0, "a");
    (56883, 0, " ");
    (56928, 0, "'");
    (56929, 0, "a");
    (56930, 0, " ");
    (57101, 0, "// ");
    (57091, 0, "// ");
    (57014, 0, "// ");
    (56980, 0, "// ");
    (56953, 0, "// ");
    (56944, 0, "\n        ");
    (56953, 0, "u");
    (56954, 0, "n");
    (56955, 0, "i");
    (56956, 0, "m");
    (56957, 0, "p");
    (56953, 5, "unimplemented");
    (56966, 0, "(");
    (56967, 0, ")");
    (56968, 0, ";");
    (56968, 1, "");
    (56966, 0, "!");
    (56927, 4, "");
    (56941, 24, "");
    (56940, 1, "");
    (56940, 0, "\n        ");
    (56949, 0, "i");
    (56950, 0, "f");
    (56951, 0, " ");
    (56941, 11, "");
    (56940, 1, "");
    (56779, 1, "");
    (56779, 0, " ");
    (56780, 0, "{");
    (56781, 0, "\n    ");
    (56786, 0, "n");
    (56787, 0, "o");
    (56788, 0, "d");
    (56789, 0, "e");
    (56790, 0, ":");
    (56791, 0, " ");
    (56812, 1, "");
    (56811, 1, "");
    (56811, 0, ",");
    (56812, 0, "\n    ");
    (56817, 0, "i");
    (56818, 0, "n");
    (56819, 0, "d");
    (56820, 0, "e");
    (56821, 0, "x");
    (56822, 0, ":");
    (56823, 0, " ");
    (56829, 1, "");
    (56829, 0, "\n    ");
    (56830, 4, "}");
    (56831, 1, "");
    (56963, 0, "\n        ");
    (56972, 0, "i");
    (56973, 0, "f");
    (56974, 0, " ");
    (56975, 0, "s");
    (56976, 0, "e");
    (56977, 0, "l");
    (56978, 0, "f");
    (56979, 0, ".");
    (56980, 0, "n");
    (56981, 0, "o");
    (56982, 0, "d");
    (56983, 0, "e");
    (56984, 0, " ");
    (56984, 1, "");
    (56984, 0, ".");
    (56985, 0, "i");
    (56986, 0, "s");
    (56987, 0, "_");
    (56972, 16, "");
    (56972, 0, "i");
    (56973, 0, "f");
    (56974, 0, " ");
    (56975, 0, "l");
    (56976, 0, "e");
    (56977, 0, "t");
    (56978, 0, " ");
    (56979, 0, "S");
    (56980, 0, "o");
    (56981, 0, "m");
    (56982, 0, "e");
    (56983, 0, "(");
    (56984, 0, "n");
    (56985, 0, "o");
    (56986, 0, "d");
    (56987, 0, "e");
    (56988, 0, ")");
    (56989, 0, " ");
    (56990, 0, "=");
    (56991, 0, " ");
    (56992, 0, "s");
    (56993, 0, "e");
    (56994, 0, "l");
    (56995, 0, "f");
    (56996, 0, ".");
    (56997, 0, "n");
    (56998, 0, "o");
    (56999, 0, "d");
    (57000, 0, "e");
    (57001, 0, " ");
    (57002, 0, "{");
    (57003, 0, "\n            ");
    (57016, 0, "\n            ");
    (57004, 12, "");
    (57005, 12, "        }");
    (57014, 0, " ");
    (57015, 0, "e");
    (57016, 0, "l");
    (57017, 0, "s");
    (57018, 0, "e");
    (57019, 0, " ");
    (57020, 0, "{");
    (57021, 0, " ");
    (57022, 0, "N");
    (57023, 0, "o");
    (57024, 0, "n");
    (57025, 0, "e");
    (57026, 0, " ");
    (57027, 0, "}");
    (57004, 0, "            ");
    (57016, 0, "l");
    (57017, 0, "e");
    (57018, 0, "t");
    (57019, 0, " ");
    (57020, 0, "i");
    (57021, 0, "t");
    (57022, 0, "e");
    (57020, 3, "c");
    (57021, 0, "u");
    (57022, 0, "r");
    (57023, 0, "r");
    (57024, 0, "e");
    (57025, 0, "n");
    (57026, 0, "t");
    (57027, 0, " ");
    (57028, 0, "=");
    (57029, 0, " ");
    (57030, 0, "n");
    (57031, 0, "o");
    (57032, 0, "d");
    (57033, 0, "e");
    (57034, 0, "[");
    (57034, 1, "");
    (57034, 0, ".");
    (57035, 0, "i");
    (57036, 0, "t");
    (57037, 0, "e");
    (57038, 0, "m");
    (57039, 0, "s");
    (57040, 0, "[");
    (57041, 0, "s");
    (57042, 0, "e");
    (57043, 0, "l");
    (57044, 0, "f");
    (57045, 0, ".");
    (57046, 0, "i");
    (57047, 0, "n");
    (57048, 0, "d");
    (57049, 0, "e");
    (57050, 0, "x");
    (57051, 0, "]");
    (57052, 0, ";");
    (57053, 0, "\n            ");
    (57066, 0, "\n            ");
    (57054, 12, "");
    (57067, 0, "c");
    (57068, 0, "u");
    (57069, 0, "r");
    (57070, 0, "r");
    (57071, 0, "e");
    (57072, 0, "n");
    (57073, 0, "t");
    (57074, 0, ".");
    (57067, 0, "u");
    (57068, 0, "n");
    (57069, 0, "s");
    (57070, 0, "a");
    (57071, 0, "f");
    (57072, 0, "e");
    (57073, 0, " ");
    (57074, 0, "{");
    (57075, 0, " ");
    (57084, 0, "g");
    (57085, 0, "e");
    (57086, 0, "t");
    (57087, 0, "_");
    (57088, 0, "r");
    (57089, 0, "e");
    (57090, 0, "f");
    (57091, 0, "(");
    (57092, 0, ")");
    (57093, 0, " ");
    (57094, 0, "}");
    (57067, 0, "S");
    (57068, 0, "o");
    (57069, 0, "m");
    (57070, 0, "e");
    (57071, 0, "(");
    (57100, 0, ")");
    (57089, 7, "a");
    (57090, 0, "s");
    (57091, 0, "_");
    (57092, 0, "p");
    (57093, 0, "t");
    (57094, 0, "r");
    (57081, 0, "*");
    (57081, 0, "&");
    (57030, 0, "&");
    (57054, 0, "\n            ");
    (57067, 0, "i");
    (57068, 0, "f");
    (57069, 0, " ");
    (57070, 0, "s");
    (57071, 0, "e");
    (57072, 0, "l");
    (57073, 0, "f");
    (57074, 0, ".");
    (57075, 0, "i");
    (57076, 0, "n");
    (57077, 0, "d");
    (57078, 0, "e");
    (57079, 0, "x");
    (57080, 0, " ");
    (57081, 0, "+");
    (57082, 0, " ");
    (57083, 0, "1");
    (57083, 1, "");
    (57082, 1, "");
    (57081, 1, "");
    (57067, 14, "s");
    (57068, 0, "e");
    (57069, 0, "l");
    (57070, 0, "f");
    (57071, 0, ".");
    (57072, 0, "i");
    (57073, 0, "n");
    (57074, 0, "d");
    (57075, 0, "e");
    (57076, 0, "x");
    (57077, 0, " ");
    (57078, 0, "+");
    (57079, 0, "=");
    (57080, 0, " ");
    (57081, 0, "1");
    (57082, 0, ";");
    (57083, 0, "\n            ");
    (57096, 0, "i");
    (57097, 0, "f");
    (57098, 0, " ");
    (57099, 0, "s");
    (57100, 0, "e");
    (57101, 0, "l");
    (57102, 0, "f");
    (57103, 0, ".");
    (57104, 0, "i");
    (57105, 0, "n");
    (57106, 0, "d");
    (57107, 0, "e");
    (57108, 0, "x");
    (57109, 0, " ");
    (57110, 0, "=");
    (57111, 0, "=");
    (57112, 0, " ");
    (57112, 1, "");
    (57111, 1, "");
    (57110, 1, "");
    (57110, 0, "=");
    (57111, 0, "=");
    (57112, 0, " ");
    (57113, 0, "n");
    (57114, 0, "o");
    (57115, 0, "d");
    (57116, 0, "e");
    (57117, 0, ".");
    (57118, 0, "l");
    (57119, 0, "e");
    (57120, 0, "n");
    (57120, 1, "");
    (57119, 1, "");
    (57118, 1, "");
    (57117, 1, "");
    (57117, 0, ".");
    (57118, 0, "n");
    (57119, 0, "u");
    (57120, 0, "m");
    (57118, 3, "num_items");
    (57127, 0, " ");
    (57128, 0, "{");
    (57129, 0, "\n                ");
    (57130, 16, "            }");
    (57129, 0, "\n                ");
    (57146, 0, "s");
    (57147, 0, "e");
    (57148, 0, "l");
    (57149, 0, "f");
    (57150, 0, ".");
    (57151, 0, "i");
    (57152, 0, "n");
    (57153, 0, "d");
    (57154, 0, "e");
    (57155, 0, "x");
    (57156, 0, " ");
    (57157, 0, "=");
    (57158, 0, " ");
    (57159, 0, "0");
    (57160, 0, ";");
    (57161, 0, "\n                ");
    (57178, 0, "s");
    (57179, 0, "e");
    (57180, 0, "l");
    (57181, 0, "f");
    (57182, 0, ".");
    (57183, 0, "n");
    (57184, 0, "o");
    (57185, 0, "d");
    (57186, 0, "e");
    (57187, 0, " ");
    (57188, 0, "=");
    (57189, 0, " ");
    (57190, 0, "s");
    (57191, 0, "e");
    (57192, 0, "l");
    (57193, 0, "f");
    (57194, 0, ".");
    (57195, 0, "n");
    (57196, 0, "o");
    (57197, 0, "d");
    (57198, 0, "e");
    (57199, 0, ".");
    (57200, 0, "n");
    (57200, 1, "");
    (57199, 1, "");
    (57199, 0, ".");
    (57200, 0, "n");
    (57201, 0, "e");
    (57202, 0, "x");
    (57203, 0, "t");
    (57204, 0, "_");
    (57205, 0, "n");
    (57206, 0, "o");
    (57207, 0, "d");
    (57208, 0, "e");
    (57209, 0, "(");
    (57210, 0, ")");
    (57211, 0, ";");
    (57190, 0, "unsafe { n.first_skip_entry().node.as_ref() }");
    (57235, 22, "");
    (57235, 0, ";");
    (57200, 0, "o");
    (57201, 0, "d");
    (57202, 0, "e");
    (57127, 0, " ");
    (57128, 0, "a");
    (57129, 0, "s");
    (57130, 0, " ");
    (57131, 0, "u");
    (57132, 0, "s");
    (57133, 0, "i");
    (57134, 0, "z");
    (57135, 0, "e");
    (11448, 0, "\n    ");
    (11453, 0, "\n    ");
    (11449, 4, "");
    (11454, 0, "self.node.next_node();");
    (11454, 22, "");
    (11449, 5, "");
    (11449, 0, "    ");
    (11448, 5, "");
    (57213, 23, "");
    (57213, 0, "g");
    (57214, 0, "e");
    (57215, 0, "t");
    (57216, 0, "_");
    (57217, 0, "n");
    (57213, 5, "get_next_ptr()");
    (12071, 23, "");
    (12071, 0, "g");
    (12072, 0, "e");
    (12073, 0, "t");
    (12074, 0, "n");
    (12071, 4, "get_next_ptr()");
    (57318, 176, "");
    (57575, 3, "");
    (57566, 3, "");
    (57526, 3, "");
    (57465, 3, "");
    (57413, 3, "");
    (57459, 0, " ");
    (57460, 0, "w");
    (57461, 0, "h");
    (57462, 0, "e");
    (57463, 0, "r");
    (57464, 0, "e");
    (57465, 0, " ");
    (57466, 0, "C");
    (57467, 0, ":");
    (57468, 0, ":");
    (57469, 0, "I");
    (57470, 0, "t");
    (57471, 0, "e");
    (57472, 0, "m");
    (57473, 0, ":");
    (57474, 0, " ");
    (57475, 0, "f");
    (57476, 0, "m");
    (57477, 0, "t");
    (57478, 0, ":");
    (57479, 0, " ");
    (57479, 1, "");
    (57479, 0, ":");
    (57480, 0, " ");
    (57480, 1, "");
    (57480, 0, "D");
    (57481, 0, "e");
    (57482, 0, "b");
    (57483, 0, "u");
    (57484, 0, "g");
    (57537, 0, "f");
    (57538, 0, "t");
    (57539, 0, ":");
    (57540, 0, ":");
    (57540, 1, "");
    (57539, 1, "");
    (57538, 1, "");
    (57538, 0, "m");
    (57539, 0, "t");
    (57540, 0, ":");
    (57541, 0, ":");
    (57594, 0, "// ");
    (57588, 0, "// ");
    (57551, 0, "// ");
    (57488, 0, "// ");
    (57413, 0, "// ");
    (55381, 0, "\n    ");
    (55386, 0, "\n    ");
    (55382, 4, "");
    (55387, 0, "p");
    (55388, 0, "u");
    (55389, 0, "b");
    (55390, 0, " ");
    (55391, 0, "f");
    (55392, 0, "n");
    (55393, 0, " ");
    (55394, 0, "i");
    (55395, 0, "t");
    (55396, 0, "e");
    (55397, 0, "m");
    (55398, 0, "_");
    (55399, 0, "i");
    (55400, 0, "t");
    (55401, 0, "e");
    (55402, 0, "r");
    (55403, 0, "(");
    (55404, 0, "&");
    (55405, 0, "s");
    (55406, 0, "e");
    (55407, 0, "l");
    (55408, 0, "f");
    (55409, 0, ")");
    (55410, 0, " ");
    (55411, 0, "-");
    (55412, 0, ">");
    (55413, 0, " ");
    (55414, 0, "L");
    (55415, 0, "i");
    (55416, 0, "s");
    (55417, 0, "t");
    (55418, 0, "I");
    (55414, 5, "ListIter");
    (55422, 0, "<");
    (55423, 0, "C");
    (55424, 0, ">");
    (55425, 0, " ");
    (55426, 0, "{");
    (55427, 0, "\n        ");
    (55436, 0, "\n        ");
    (55428, 8, "");
    (55429, 8, "    }");
    (55428, 0, "        ");
    (55436, 0, "L");
    (55437, 0, "i");
    (55438, 0, "s");
    (55439, 0, "t");
    (55440, 0, "I");
    (55436, 5, "ListIter");
    (55444, 0, " ");
    (55445, 0, "{");
    (55446, 0, "\n            ");
    (55459, 0, "n");
    (55460, 0, "o");
    (55461, 0, "d");
    (55462, 0, "e");
    (55463, 0, ":");
    (55464, 0, " ");
    (55465, 0, "S");
    (55466, 0, "o");
    (55467, 0, "m");
    (55468, 0, "e");
    (55469, 0, "(");
    (55470, 0, "s");
    (55471, 0, "e");
    (55472, 0, "l");
    (55473, 0, "f");
    (55474, 0, ".");
    (55475, 0, "h");
    (55476, 0, "e");
    (55477, 0, "a");
    (55475, 3, "head");
    (55479, 0, ")");
    (55470, 0, "&");
    (55481, 0, ",");
    (55482, 0, "\n            ");
    (55495, 0, "i");
    (55496, 0, "n");
    (55497, 0, "d");
    (55498, 0, "e");
    (55499, 0, "x");
    (55500, 0, ":");
    (55501, 0, " ");
    (55502, 0, "0");
    (55503, 0, "\n            ");
    (55504, 12, "        }");
    (56874, 0, "p");
    (56875, 0, "u");
    (56876, 0, "b");
    (56877, 0, " ");
    (55382, 137, "");
    (55381, 1, "");
    (22276, 0, "\n    ");
    (22277, 4, "");
    (22276, 0, "\n    ");
    ( 22281,
      0,
      "\n\
      \    pub fn item_iter(&self) -> ListIter<C> {\n\
      \        ListIter {\n\
      \            node: Some(&self.head),\n\
      \            index: 0\n\
      \        }\n\
      \    }" );
    (22277, 4, "");
    (22276, 1, "");
    (55028, 0, "node_");
    (23928, 0, "node_");
    (22214, 0, "node_");
    (22293, 5, "");
    (55737, 0, "n");
    (55738, 0, "o");
    (55739, 0, "d");
    (55740, 0, "e");
    (55741, 0, "_");
    (56786, 0, "n");
    (56787, 0, "o");
    (56788, 0, "d");
    (56789, 0, "e");
    (56790, 0, "_");
    (57029, 0, "mIte");
    (56912, 0, "mIte");
    (22337, 0, "mIte");
    (22315, 0, "mIte");
    (56996, 0, "\n");
    (57785, 3, "");
    (57776, 3, "");
    (57736, 3, "");
    (57670, 3, "");
    (57592, 3, "");
    (57766, 0, "i");
    (57767, 0, "t");
    (57768, 0, "e");
    (57769, 0, "r");
    (57770, 0, "(");
    (57771, 0, ")");
    (57772, 0, ")");
    (57773, 0, ".");
    (57774, 0, "f");
    (57775, 0, "i");
    (57776, 0, "n");
    (57777, 0, "i");
    (57778, 0, "s");
    (57779, 0, "h");
    (57780, 0, "(");
    (57781, 0, ")");
    (57505, 86, "");
    (57504, 1, "");
    (57504, 0, "\n");
    (57702, 0, "\n    ");
    (57707, 0, "\n    ");
    (57703, 4, "");
    (57708, 0, "f");
    (57709, 0, "n");
    (57710, 0, " ");
    (57711, 0, "s");
    (57711, 1, "");
    (57710, 1, "");
    (57709, 1, "");
    (57708, 1, "");
    (57704, 4, "");
    (57703, 1, "");
    (57702, 1, "");
    (57502, 0, "\n    ");
    (57507, 0, "\n    ");
    (57503, 4, "");
    (57508, 0, "f");
    (57509, 0, "n");
    (57510, 0, " ");
    (57511, 0, "s");
    (57512, 0, "i");
    (57513, 0, "z");
    (57511, 3, "size_hint()");
    (57522, 0, " ");
    (57523, 0, "-");
    (57524, 0, ">");
    (57525, 0, " ");
    (57526, 0, "(");
    (57527, 0, "u");
    (57528, 0, "s");
    (57529, 0, "i");
    (57530, 0, "z");
    (57531, 0, "e");
    (57532, 0, ",");
    (57533, 0, " ");
    (57534, 0, "O");
    (57535, 0, "p");
    (57536, 0, "t");
    (57537, 0, "i");
    (57538, 0, "o");
    (57539, 0, "n");
    (57540, 0, "(");
    (57541, 0, "u");
    (57542, 0, "s");
    (57543, 0, "i");
    (57544, 0, "z");
    (57545, 0, "e");
    (57546, 0, ")");
    (57547, 0, " ");
    (57547, 1, "");
    (57547, 0, ")");
    (57548, 0, " ");
    (57549, 0, "{");
    (57550, 0, "\n        ");
    (57551, 8, "    }");
    (57550, 0, "\n        ");
    (57559, 0, "u");
    (57560, 0, "n");
    (57561, 0, "i");
    (57562, 0, "m");
    (57563, 0, "p");
    (57564, 0, "l");
    (57559, 6, "unimplemented");
    (57572, 0, "!");
    (57573, 0, "(");
    (57574, 0, ")");
    (57521, 0, "&");
    (57522, 0, "s");
    (57523, 0, "e");
    (57524, 0, "l");
    (57525, 0, "f");
    (57545, 1, "");
    (57545, 0, "<");
    (57551, 1, "");
    (57551, 0, ">");
    (56994, 0, ",");
    (56995, 0, "\n    ");
    (57000, 0, "r");
    (57001, 0, "e");
    (57002, 0, "m");
    (57003, 0, "a");
    (57004, 0, "i");
    (57005, 0, "n");
    (57006, 0, "i");
    (57007, 0, "n");
    (57008, 0, "g");
    (57009, 0, "_");
    (57010, 0, "i");
    (57011, 0, "t");
    (57012, 0, "e");
    (57013, 0, "m");
    (57014, 0, "s");
    (57015, 0, ":");
    (57016, 0, " ");
    (57017, 0, "u");
    (57018, 0, "s");
    (57019, 0, "i");
    (57020, 0, "z");
    (57021, 0, "e");
    (57022, 0, " ");
    (57023, 0, "/");
    (57024, 0, "/");
    (57025, 0, " ");
    (57026, 0, "F");
    (57027, 0, "o");
    (57028, 0, "r");
    (57029, 0, "e");
    (57030, 0, " ");
    (57030, 1, "");
    (57029, 1, "");
    (57029, 0, " ");
    (57030, 0, "s");
    (57031, 0, "i");
    (57032, 0, "z");
    (57033, 0, "e");
    (57034, 0, "_");
    (57035, 0, "h");
    (57036, 0, "i");
    (57037, 0, "n");
    (57038, 0, "t");
    (57039, 0, ".");
    (57610, 16, "");
    (57610, 0, "(");
    (57611, 0, "r");
    (57612, 0, "e");
    (57613, 0, "m");
    (57614, 0, "a");
    (57615, 0, "i");
    (57616, 0, "n");
    (57611, 6, "remain");
    (57617, 0, "i");
    (57618, 0, "n");
    (57619, 0, "g");
    (57611, 9, "remaining_items");
    (57626, 0, ",");
    (57627, 0, " ");
    (57628, 0, "S");
    (57629, 0, "o");
    (57630, 0, "m");
    (57631, 0, "z");
    (57632, 0, "e");
    (57633, 0, "(");
    (57633, 1, "");
    (57632, 1, "");
    (57631, 1, "");
    (57631, 0, "m");
    (57631, 1, "");
    (57631, 0, "e");
    (57632, 0, "(");
    (57633, 0, "r");
    (57634, 0, "e");
    (57626, 0, "s");
    (57627, 0, "e");
    (57628, 0, "l");
    (57629, 0, "f");
    (57629, 1, "");
    (57628, 1, "");
    (57627, 1, "");
    (57626, 1, "");
    (57611, 0, "s");
    (57612, 0, "e");
    (57613, 0, "l");
    (57614, 0, "f");
    (57615, 0, ".");
    (57638, 0, "s");
    (57639, 0, "e");
    (57640, 0, "l");
    (57641, 0, "f");
    (57642, 0, ".");
    (57645, 0, "m");
    (57646, 0, "a");
    (57647, 0, "i");
    (57648, 0, "n");
    (57649, 0, "i");
    (57650, 0, "n");
    (57643, 8, "remaining_items");
    (57658, 0, ")");
    (57659, 0, ")");
    (22405, 0, ",");
    (22406, 0, "\n            ");
    (22419, 0, "r");
    (22420, 0, "e");
    (22421, 0, "m");
    (22422, 0, "a");
    (22423, 0, "i");
    (22424, 0, "n");
    (22419, 6, "remaining_items");
    (22434, 0, ":");
    (22435, 0, " ");
    (22436, 0, "s");
    (22437, 0, "e");
    (22438, 0, "l");
    (22439, 0, "f");
    (22440, 0, ".");
    (22441, 0, "l");
    (22442, 0, "e");
    (22443, 0, "n");
    (22441, 3, "len_items()");
    (54748, 3, "");
    (54742, 1, "n");
    (54740, 1, "l");
    (27931, 3, "");
    (27925, 1, "n");
    (27923, 1, "l");
    (26884, 3, "");
    (26878, 1, "n");
    (26876, 1, "l");
    (22151, 3, "");
    (22145, 1, "n");
    (22143, 1, "l");
    (22203, 262, "");
    (22202, 1, "");
    (22280, 0, "\n    ");
    ( 22285,
      0,
      "\n\
      \    fn node_iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n\
      \    \n\
      \    pub fn iter(&self) -> ListItemIter<C> {\n\
      \        ListItemIter {\n\
      \            node: Some(&self.head),\n\
      \            index: 0,\n\
      \            remaining_items: self.len_items()\n\
      \        }\n\
      \    }" );
    (22281, 4, "");
    (22544, 0, "\n    ");
    (22545, 4, "");
    (22544, 0, "\n    ");
    (22549, 0, "f");
    (22550, 0, "n");
    (22551, 0, " ");
    (22552, 0, "h");
    (22553, 0, "e");
    (22554, 0, "i");
    (22555, 0, "g");
    (22556, 0, "h");
    (22557, 0, "t");
    (22558, 0, "(");
    (22559, 0, ")");
    (22559, 0, "&");
    (22560, 0, "s");
    (22561, 0, "m");
    (22561, 1, "");
    (22560, 1, "");
    (22560, 0, "m");
    (22561, 0, "u");
    (22562, 0, "t");
    (22563, 0, " ");
    (22564, 0, "s");
    (22565, 0, "e");
    (22566, 0, "l");
    (22567, 0, "f");
    (22569, 0, " ");
    (22570, 0, "-");
    (22571, 0, ">");
    (22572, 0, " ");
    (22573, 0, "u");
    (22574, 0, "s");
    (22575, 0, "i");
    (22576, 0, "z");
    (22577, 0, "e");
    (22578, 0, " ");
    (22579, 0, "{");
    (22580, 0, "\n        ");
    (22589, 0, "\n        ");
    (22581, 8, "");
    (22582, 8, "    }");
    (22581, 0, "        ");
    (22589, 0, "s");
    (22590, 0, "e");
    (22591, 0, "l");
    (22592, 0, "f");
    (22593, 0, ".");
    (22594, 0, "h");
    (22595, 0, "e");
    (22596, 0, "a");
    (22597, 0, "d");
    (22598, 0, ".");
    (22599, 0, "h");
    (22600, 0, "e");
    (22601, 0, "i");
    (22599, 3, "height");
    (22605, 0, " ");
    (22606, 0, "a");
    (22607, 0, "s");
    (22608, 0, " ");
    (22609, 0, "u");
    (22610, 0, "s");
    (22611, 0, "i");
    (22612, 0, "z");
    (22613, 0, "e");
    (22544, 0, "\n    ");
    (22549, 0, "#");
    (22550, 0, "[");
    (22551, 0, "i");
    (22552, 0, "n");
    (22553, 0, "l");
    (22554, 0, "i");
    (22555, 0, "n");
    (22551, 5, "inline");
    (22557, 0, "=");
    (22558, 0, "a");
    (22559, 0, "l");
    (22560, 0, "w");
    (22561, 0, "a");
    (22558, 4, "always");
    (22564, 0, "]");
    (22557, 1, "");
    (22557, 0, "(");
    (22564, 0, ")");
    (66235, 21, ".");
    (62885, 21, ".");
    (51797, 21, ".");
    (51372, 21, ".");
    (49261, 21, ".");
    (42201, 21, ".");
    (40541, 21, ".");
    (40234, 21, ".");
    (34225, 21, ".");
    (28107, 21, ".");
    (26593, 21, ".");
    (22615, 21, ".");
    (66016, 0, "h");
    (62686, 0, "h");
    (51618, 0, "h");
    (51213, 0, "h");
    (49122, 0, "h");
    (42082, 0, "h");
    (40442, 0, "h");
    (40155, 0, "h");
    (34166, 0, "h");
    (28068, 0, "h");
    (26574, 0, "h");
    (22616, 0, "h");
    (66028, 0, "e");
    (62697, 0, "e");
    (51628, 0, "e");
    (51222, 0, "e");
    (49130, 0, "e");
    (42089, 0, "e");
    (40448, 0, "e");
    (40160, 0, "e");
    (34170, 0, "e");
    (28071, 0, "e");
    (26576, 0, "e");
    (22617, 0, "e");
    (66040, 0, "i");
    (62708, 0, "i");
    (51638, 0, "i");
    (51231, 0, "i");
    (49138, 0, "i");
    (42096, 0, "i");
    (40454, 0, "i");
    (40165, 0, "i");
    (34174, 0, "i");
    (28074, 0, "i");
    (26578, 0, "i");
    (22618, 0, "i");
    (66052, 0, "g");
    (62719, 0, "g");
    (51648, 0, "g");
    (51240, 0, "g");
    (49146, 0, "g");
    (42103, 0, "g");
    (40460, 0, "g");
    (40170, 0, "g");
    (34178, 0, "g");
    (28077, 0, "g");
    (26580, 0, "g");
    (22619, 0, "g");
    (66064, 0, "h");
    (62730, 0, "h");
    (51658, 0, "h");
    (51249, 0, "h");
    (49154, 0, "h");
    (42110, 0, "h");
    (40466, 0, "h");
    (40175, 0, "h");
    (34182, 0, "h");
    (28080, 0, "h");
    (26582, 0, "h");
    (22620, 0, "h");
    (66076, 0, "t");
    (62741, 0, "t");
    (51668, 0, "t");
    (51258, 0, "t");
    (49162, 0, "t");
    (42117, 0, "t");
    (40472, 0, "t");
    (40180, 0, "t");
    (34186, 0, "t");
    (28083, 0, "t");
    (26584, 0, "t");
    (22621, 0, "t");
    (66088, 0, "(");
    (62752, 0, "(");
    (51678, 0, "(");
    (51267, 0, "(");
    (49170, 0, "(");
    (42124, 0, "(");
    (40478, 0, "(");
    (40185, 0, "(");
    (34190, 0, "(");
    (28086, 0, "(");
    (26586, 0, "(");
    (22622, 0, "(");
    (66100, 0, ")");
    (62763, 0, ")");
    (51688, 0, ")");
    (51276, 0, ")");
    (49178, 0, ")");
    (42131, 0, ")");
    (40484, 0, ")");
    (40190, 0, ")");
    (34194, 0, ")");
    (28089, 0, ")");
    (26588, 0, ")");
    (22623, 0, ")");
    (22582, 4, "");
    (22612, 8, "");
    (22611, 1, "");
    (22611, 0, ".");
    (22612, 0, "h");
    (22613, 0, "e");
    (22614, 0, "a");
    (22615, 0, "d");
    (22616, 0, ".");
    (22617, 0, "h");
    (22618, 0, "e");
    (22619, 0, "i");
    (22620, 0, "g");
    (22621, 0, "h");
    (22622, 0, "t");
    (22623, 0, " ");
    (22624, 0, "a");
    (22625, 0, "s");
    (22626, 0, " ");
    (22627, 0, "u");
    (22628, 0, "s");
    (22629, 0, "i");
    (22630, 0, "z");
    (22631, 0, "e");
    (17047, 1, "");
    (57686, 0, "// ");
    (57627, 0, "// ");
    (57575, 0, "// ");
    (57692, 3, "");
    (57630, 3, "");
    (57575, 3, "");
    (62314, 0, " ");
    (62315, 0, "w");
    (62316, 0, "a");
    (62317, 0, "n");
    (62318, 0, "t");
    (62319, 0, "_");
    (62315, 5, "m");
    (62316, 0, "o");
    (62317, 0, "d");
    (62318, 0, "i");
    (62319, 0, "f");
    (62320, 0, "y");
    (62321, 0, "_");
    (62322, 0, "n");
    (62323, 0, "e");
    (62324, 0, "x");
    (62325, 0, "t");
    (62326, 0, ":");
    (62327, 0, " ");
    (62328, 0, "b");
    (62329, 0, "o");
    (62330, 0, "o");
    (62331, 0, "l");
    (62332, 0, ",");
    (62454, 0, " ");
    (62455, 0, "i");
    (62456, 0, "f");
    (62457, 0, " ");
    (62457, 1, "");
    (62456, 1, "");
    (62455, 1, "");
    (62454, 1, "");
    (62276, 0, "\n    ");
    (62281, 0, "\n    ");
    (62277, 4, "");
    (62282, 0, "f");
    (62283, 0, "n");
    (62284, 0, " ");
    (62285, 0, "i");
    (62286, 0, "s");
    (62286, 1, "");
    (62285, 1, "");
    (62285, 0, "a");
    (62286, 0, "t");
    (62287, 0, "_");
    (62288, 0, "e");
    (62289, 0, "n");
    (62290, 0, "_");
    (62291, 0, "o");
    (62292, 0, "f");
    (62292, 1, "");
    (62291, 1, "");
    (62290, 1, "");
    (62289, 1, "");
    (62289, 0, "d");
    (62289, 1, "");
    (62289, 0, "n");
    (62290, 0, "d");
    (62291, 0, "_");
    (62292, 0, "o");
    (62293, 0, "f");
    (62294, 0, "_");
    (62295, 0, "n");
    (62296, 0, "o");
    (62297, 0, "d");
    (62298, 0, "e");
    (62299, 0, "(");
    (62300, 0, "&");
    (62301, 0, "s");
    (62302, 0, "e");
    (62303, 0, "l");
    (62304, 0, "f");
    (62305, 0, ")");
    (62306, 0, " ");
    (62307, 0, "-");
    (62308, 0, ">");
    (62309, 0, " ");
    (62310, 0, "b");
    (62311, 0, "o");
    (62312, 0, "o");
    (62313, 0, "l");
    (62314, 0, " ");
    (62315, 0, "{");
    (62316, 0, "\n        ");
    (62325, 0, "\n        ");
    (62317, 8, "");
    (62318, 8, "    }");
    (62317, 0, "        ");
    (62325, 0, "s");
    (62326, 0, "e");
    (62327, 0, "l");
    (62328, 0, "f");
    (62329, 0, ".");
    (62330, 0, "l");
    (62331, 0, "o");
    (62332, 0, "c");
    (62333, 0, "a");
    (62334, 0, "l");
    (62335, 0, "_");
    (62330, 6, "local_index");
    (62330, 0, "c");
    (62331, 0, "u");
    (62332, 0, "r");
    (62333, 0, "s");
    (62334, 0, "o");
    (62335, 0, "r");
    (62336, 0, ".");
    (62348, 0, " ");
    (62349, 0, "=");
    (62350, 0, "=");
    (62351, 0, " ");
    (62352, 0, "s");
    (62353, 0, "e");
    (62354, 0, "l");
    (62355, 0, "f");
    (62356, 0, ".");
    (62325, 0, "// ");
    (62277, 90, "");
    (62386, 0, "\n        ");
    (62395, 0, "i");
    (62396, 0, "f");
    (62397, 0, " ");
    (62398, 0, "m");
    (62399, 0, "o");
    (62400, 0, "d");
    (62401, 0, "i");
    (62398, 4, "modify_next");
    (62409, 0, " ");
    (62410, 0, "&");
    (62411, 0, "&");
    (62412, 0, " ");
    (62413, 0, "s");
    (62414, 0, "e");
    (62415, 0, "l");
    (62416, 0, "f");
    (62417, 0, ".");
    (62418, 0, "c");
    (62419, 0, "u");
    (62420, 0, "r");
    (62421, 0, "s");
    (62422, 0, "o");
    (62423, 0, "r");
    (62424, 0, ".");
    (62425, 0, "i");
    (62426, 0, "s");
    (62425, 2, "is_at_node_end()");
    (62441, 0, " ");
    (62442, 0, "{");
    (62443, 0, "\n            ");
    (62444, 12, "        }");
    (62443, 0, "\n            ");
    (62444, 12, "");
    (62409, 32, "");
    (62398, 0, "!");
    (62410, 0, " ");
    (62411, 0, "&");
    (62412, 0, "&");
    (62413, 0, " ");
    (62413, 1, "");
    (62410, 3, "");
    (62398, 1, "");
    (62412, 0, "            ");
    (62409, 0, " && self.cursor.is_at_node_end()");
    (62387, 79, "");
    (62386, 1, "");
    (62296, 0, "p");
    (62296, 1, "");
    (63225, 0, "prev_");
    (62296, 0, "prev_");
    (53539, 0, "prev_");
    (62323, 19, "");
    (63135, 0, "\n    ");
    (63136, 4, "");
    (63136, 0, "\n    ");
    (63137, 4, "");
    ( 63137,
      0,
      "    pub fn modify_prev_item<F>(&mut self, modify_fn: F) where F: \
       FnOnce(&mut C::Item, usize) {\n" );
    (63141, 0, "// ");
    (62458, 16, "p");
    (62459, 0, "r");
    (62460, 0, "e");
    (62461, 0, "v");
    (62458, 4, "prev_item()");
    (62468, 1, "");
    (62467, 1, "");
    (62467, 0, "_");
    (62468, 0, "m");
    (62469, 0, "u");
    (62470, 0, "t");
    ( 16427,
      0,
      "\n\
      \    unsafe fn prev_item(&self) -> &'a C::Item {\n\
      \        let node = &*self.here_ptr();\n\
      \        assert!(self.local_index > 0);\n\
      \        debug_assert!(self.local_index <= node.num_items as usize);\n\
      \        &*(node.items[self.local_index - 1].as_ptr())\n\
      \    }\n" );
    (16705, 0, "_");
    (16706, 0, "m");
    (16707, 0, "u");
    (16708, 0, "t");
    (16711, 0, "m");
    (16712, 0, "u");
    (16713, 0, "t");
    (16714, 0, " ");
    (16728, 0, " ");
    (16728, 1, "");
    (16728, 0, "m");
    (16729, 0, "u");
    (16730, 0, "t");
    (16731, 0, " ");
    (16934, 0, "m");
    (16935, 0, "u");
    (16936, 0, "t");
    (16937, 0, "_");
    (16896, 0, "m");
    (16897, 0, "u");
    (16898, 0, "t");
    (16899, 0, " ");
    (16762, 0, ",");
    (16763, 0, "u");
    (16764, 0, "t");
    (16764, 1, "");
    (16763, 1, "");
    (16762, 1, "");
    (16762, 0, "m");
    (16763, 0, "u");
    (16764, 0, "t");
    (16765, 0, " ");
    (59838, 0, "-");
    (59838, 1, "");
    (62723, 0, " ");
    (62723, 1, "");
    (62723, 0, " ");
    (62723, 1, "");
    (62723, 1, "");
    (62723, 0, "\n            ");
    (62763, 1, "");
    (62763, 0, "\n        ");
    (62723, 0, "\n            ");
    (62736, 0, "i");
    (62737, 0, "f");
    (62738, 0, " ");
    (62739, 0, "s");
    (62740, 0, "e");
    (62741, 0, "l");
    (62742, 0, "f");
    (62743, 0, ".");
    (62744, 0, "item_offset");
    (62755, 0, " ");
    (62756, 0, ">");
    (62757, 0, " ");
    (62758, 0, "0");
    (62759, 0, " ");
    (62760, 0, "{");
    (62761, 0, " ");
    (62762, 0, "s");
    (62763, 0, "e");
    (62764, 0, "l");
    (62765, 0, "f");
    (62766, 0, ".");
    (62767, 0, "c");
    (62768, 0, "u");
    (62769, 0, "r");
    (62770, 0, "s");
    (62771, 0, "o");
    (62772, 0, "r");
    (62773, 0, ".");
    (62774, 0, "n");
    (62775, 0, "e");
    (62776, 0, "x");
    (62776, 1, "");
    (62775, 1, "");
    (62774, 1, "");
    (62773, 1, "");
    (62773, 0, ".");
    (62774, 0, "c");
    (62775, 0, "u");
    (62776, 0, "r");
    (62777, 0, "r");
    (62774, 4, "current_item_mut()");
    (62792, 0, " ");
    (62793, 0, "}");
    (62807, 0, "e");
    (62808, 0, "l");
    (62809, 0, "s");
    (62810, 0, "e");
    (62811, 0, " ");
    (62812, 0, "{");
    (62813, 0, " ");
    (62841, 0, " ");
    (62842, 0, "}");
    (63516, 3, "");
    (63606, 0, "\n        ");
    (63607, 8, "    }");
    (63530, 1, "");
    (63530, 1, "");
    (63530, 1, "");
    (63530, 1, "");
    (63530, 0, "n");
    (63531, 0, "e");
    (63532, 0, "x");
    (63533, 0, "t");
    (63606, 0, "\n        ");
    (63615, 0, "i");
    (63616, 0, "f");
    (63617, 0, " ");
    (63618, 0, "s");
    (63619, 0, "e");
    (63620, 0, "l");
    (63621, 0, "f");
    (63622, 0, ".");
    (63623, 0, "c");
    (63624, 0, "u");
    (63625, 0, "r");
    (63626, 0, "s");
    (63627, 0, "o");
    (63628, 0, "r");
    (63629, 0, ".");
    (63630, 0, "is_at_node_end()");
    (63646, 0, " ");
    (63647, 0, "{");
    (63648, 0, "\n            ");
    (63661, 0, "s");
    (63662, 0, "e");
    (63663, 0, "l");
    (63664, 0, "f");
    (63665, 0, ".");
    (63666, 0, "a");
    (63667, 0, "d");
    (63668, 0, "v");
    (63669, 0, "a");
    (63666, 4, "advance_item()");
    (63680, 0, ";");
    (63681, 0, "\n            ");
    (63682, 12, "        }");
    (63691, 0, "\n        ");
    (63700, 0, "m");
    (63701, 0, "o");
    (63702, 0, "d");
    (63703, 0, "i");
    (63704, 0, "f");
    (63705, 0, "y");
    (63706, 0, "_");
    (63707, 0, "p");
    (63708, 0, "r");
    (63709, 0, "e");
    (63710, 0, "v");
    (63700, 11, "modify_prev_item");
    (63700, 0, "s");
    (63701, 0, "e");
    (63702, 0, "l");
    (63703, 0, "f");
    (63704, 0, ".");
    (63721, 0, "(");
    (63722, 0, "s");
    (63723, 0, "e");
    (63724, 0, "l");
    (63725, 0, "f");
    (63726, 0, ",");
    (63727, 0, " ");
    (63728, 0, "m");
    (63729, 0, "o");
    (63730, 0, "d");
    (63731, 0, "i");
    (63732, 0, "f");
    (63733, 0, "y");
    (63734, 0, "_");
    (63735, 0, "f");
    (63736, 0, "n");
    (63737, 0, ")");
    (63738, 0, ";");
    (63746, 1, "");
    (63722, 6, "");
    (63630, 14, "");
    (63630, 0, "h");
    (63631, 0, "e");
    (63632, 0, "r");
    (63633, 0, "e");
    (63634, 0, "_");
    (63630, 5, "here_ptr()");
    (63639, 1, "");
    (63638, 1, "");
    (63638, 0, "()");
    (63630, 10, "here_");
    (63630, 5, "");
    (63630, 0, "is_at_node_end");
    (63646, 0, " ");
    (63647, 0, "|");
    (63647, 1, "");
    (63646, 1, "");
    (63646, 0, "\n        ");
    (63655, 0, "|");
    (63656, 0, "|");
    (63657, 0, " ");
    (63658, 0, "*");
    (63659, 0, "s");
    (63660, 0, "e");
    (63661, 0, "l");
    (63662, 0, "f");
    (63663, 0, ".");
    (63658, 1, "");
    (63658, 0, "*");
    (63658, 1, "");
    (63658, 0, "(");
    (63664, 0, "c");
    (63665, 0, "u");
    (63666, 0, "r");
    (63667, 0, "s");
    (63668, 0, "o");
    (63669, 0, "r");
    (63670, 0, ".");
    (63671, 0, "c");
    (63672, 0, "u");
    (63673, 0, "r");
    (63674, 0, "r");
    (63675, 0, "e");
    (63676, 0, "n");
    (63677, 0, "t");
    (63671, 7, "current_item");
    (63683, 0, "(");
    (63684, 0, ")");
    (63659, 0, "C");
    (63660, 0, ":");
    (63661, 0, ":");
    (63662, 0, "get_usersize(_item: &Self::Item)");
    (63675, 18, "");
    (63675, 1, "");
    (63701, 0, ")");
    (63702, 0, " ");
    (63703, 0, "<");
    (63704, 0, "=");
    (63705, 0, " ");
    (63706, 0, "s");
    (63707, 0, "e");
    (63708, 0, "l");
    (63709, 0, "f");
    (63710, 0, ".");
    (63711, 0, "l");
    (63712, 0, "o");
    (63713, 0, "c");
    (63714, 0, "a");
    (63711, 4, "local_index");
    (63711, 11, "i");
    (63712, 0, "t");
    (63713, 0, "e");
    (63714, 0, "m");
    (63715, 0, "_");
    (63716, 0, "o");
    (63717, 0, "f");
    (63718, 0, "f");
    (63719, 0, "s");
    (63720, 0, "e");
    (63721, 0, "t");
    (63722, 0, ")");
    (63675, 0, "u");
    (63676, 0, "n");
    (63677, 0, "s");
    (63678, 0, "a");
    (63679, 0, "f");
    (63680, 0, "e");
    (63681, 0, " ");
    (63682, 0, "{");
    (63683, 0, " ");
    (63710, 0, " ");
    (63711, 0, "}");
    (63511, 0, "\n    ");
    (63516, 0, "/");
    (63517, 0, "/");
    (63518, 0, " ");
    (63519, 0, "T");
    (63520, 0, "O");
    (63521, 0, "D");
    (63522, 0, "O");
    (63523, 0, ":");
    (63524, 0, " ");
    (63525, 0, "N");
    (63526, 0, "o");
    (63527, 0, "t");
    (63528, 0, " ");
    (63529, 0, "s");
    (63530, 0, "u");
    (63531, 0, "r");
    (63532, 0, "e");
    (63533, 0, " ");
    (63534, 0, "i");
    (63535, 0, "f");
    (63536, 0, " ");
    (63537, 0, "t");
    (63538, 0, "h");
    (63539, 0, "i");
    (63540, 0, "s");
    (63541, 0, " ");
    (63542, 0, "f");
    (63543, 0, "u");
    (63544, 0, "n");
    (63545, 0, "c");
    (63546, 0, "t");
    (63547, 0, "i");
    (63548, 0, "o");
    (63549, 0, "n");
    (63550, 0, " ");
    (63551, 0, "i");
    (63552, 0, "s");
    (63553, 0, " ");
    (63554, 0, "c");
    (63555, 0, "o");
    (63556, 0, "r");
    (63557, 0, "r");
    (63558, 0, "e");
    (63559, 0, "c");
    (63560, 0, "t");
    (63561, 0, ".");
    (63562, 0, " ");
    (63563, 0, "N");
    (63564, 0, "e");
    (63565, 0, "e");
    (63566, 0, "d");
    (63567, 0, "s");
    (63568, 0, " ");
    (63569, 0, "t");
    (63570, 0, "e");
    (63571, 0, "s");
    (63572, 0, "t");
    (63573, 0, "s");
    (63574, 0, "!");
    (53820, 1, "");
    (53819, 1, "");
    (53818, 1, "");
    (53817, 1, "");
    (53817, 0, "n");
    (53818, 0, "e");
    (53819, 0, "x");
    (53820, 0, "t");
    (62565, 4, "");
    (62579, 1, "");
    (62578, 1, "");
    (62577, 1, "");
    (62576, 1, "");
    (62575, 1, "");
    (62575, 0, "prev_");
    ( 62651,
      0,
      "\n\
      \    fn modify_prev_item<F>(&mut self, modify_fn: F) where F: \
       FnOnce(&mut C::Item, usize) {" );
    (62651, 0, "\n        ");
    (62660, 0, "\n        ");
    (62652, 8, "");
    (62653, 8, "    }");
    (62658, 0, "\n    ");
    (62659, 4, "");
    (62565, 0, "u");
    (62566, 0, "n");
    (62567, 0, "s");
    (62568, 0, "a");
    (62569, 0, "f");
    (62570, 0, "e");
    (62571, 0, " ");
    (62586, 1, "");
    (62585, 1, "");
    (62584, 1, "");
    (62583, 1, "");
    (62582, 1, "");
    (62600, 0, " ");
    (62601, 0, "*");
    (62601, 1, "");
    (62601, 0, "e");
    (62602, 0, ":");
    (62603, 0, " ");
    (62604, 0, "*");
    (62605, 0, "m");
    (62606, 0, "u");
    (62607, 0, "t");
    (62608, 0, " ");
    (62609, 0, "N");
    (62610, 0, "o");
    (62611, 0, "d");
    (62612, 0, "e");
    (62613, 0, "<");
    (62614, 0, "C");
    (62615, 0, ">");
    (62616, 0, ",");
    (62617, 0, " ");
    (62618, 0, "i");
    (62619, 0, "t");
    (62620, 0, "e");
    (62621, 0, "m");
    (62622, 0, ":");
    (62623, 0, " ");
    (62624, 0, "&");
    (62625, 0, "m");
    (62626, 0, "u");
    (62627, 0, "t");
    (62628, 0, " ");
    (62629, 0, "C");
    (62630, 0, ":");
    (62631, 0, ":");
    (62632, 0, "I");
    (62633, 0, "t");
    (62634, 0, "e");
    (62635, 0, "m");
    (62636, 0, ",");
    (62989, 650, "");
    ( 62691,
      0,
      "        let old_usersize = C::get_usersize(item);\n\
      \        modify_fn(item, self.item_offset);\n\
      \        let new_usersize = C::get_usersize(item);\n\n\
      \        let usersize_delta = new_usersize as isize - old_usersize as \
       isize;\n\n\
      \        if usersize_delta != 0 {\n\
      \            self.cursor.update_offsets(self.list.height(), \
       usersize_delta);\n\
      \            self.list.num_usercount = \
       self.list.num_usercount.wrapping_add(usersize_delta as usize);\n\
      \            self.item_offset = usize::max(self.item_offset, \
       new_usersize);\n\
      \        }\n\n\
      \        (self.notify)(std::slice::from_ref(item), ItemMarker {\n\
      \            ptr: e,\n\
      \            // _phantom: PhantomData,\n\
      \        });\n" );
    (63341, 1, "");
    (62601, 17, "");
    (63430, 31, "");
    (62673, 0, "\n        ");
    (62682, 0, "let e = self.cursor.here_ptr();");
    (62682, 0, "// ");
    (62693, 23, "");
    (63291, 1, "");
    (63291, 0, "self.cursor.here_ptr();");
    (63313, 1, "");
    (62674, 19, "");
    (62673, 1, "");
    (63887, 16, "");
    (63886, 1, "");
    (63885, 1, "");
    (63884, 1, "");
    (63883, 1, "");
    (63829, 0, "self.item_offset");
    (63845, 0, " ");
    (63846, 0, ">");
    (63847, 0, " ");
    (63847, 1, "");
    (63847, 0, "=");
    (63848, 0, " ");
    (63828, 1, "");
    (63902, 1, "");
    (63956, 0, "// ");
    (63992, 0, "\n        ");
    (64001, 0, "s");
    (64002, 0, "e");
    (64003, 0, "l");
    (64004, 0, "f");
    (64005, 0, ".");
    (64006, 0, "m");
    (64007, 0, "o");
    (64008, 0, "d");
    (64009, 0, "i");
    (64010, 0, "f");
    (64006, 5, "modify_item(item: &mut C::Item, modify_fn: F)");
    (64018, 18, "s");
    (64019, 0, "e");
    (64020, 0, "l");
    (64021, 0, "f");
    (64022, 0, ".");
    (64023, 0, "c");
    (64024, 0, "u");
    (64025, 0, "r");
    (64026, 0, "s");
    (64027, 0, "o");
    (64028, 0, "r");
    (64029, 0, ".");
    (64030, 0, "c");
    (64031, 0, "u");
    (64032, 0, "r");
    (64033, 0, "r");
    (64030, 4, "current_item_mut()");
    (64050, 12, "m");
    (64051, 0, "o");
    (64052, 0, "d");
    (64053, 0, "i");
    (64054, 0, "f");
    (64055, 0, "y");
    (64056, 0, "_");
    (64057, 0, "f");
    (64058, 0, "n");
    (64060, 0, ";");
    (64001, 0, "u");
    (64002, 0, "n");
    (64003, 0, "s");
    (64004, 0, "a");
    (64005, 0, "f");
    (64006, 0, "e");
    (64007, 0, " ");
    (64008, 0, "{");
    (64009, 0, " ");
    (64070, 0, " ");
    (64071, 0, "}");
    (63947, 45, "");
    (63947, 0, "\n        ");
    (63948, 8, "");
    (62601, 18, "");
    (63930, 0, "        ");
    (62601, 0, "item: &mut C::Item");
    (63948, 8, "");
    (62601, 18, "");
    (62601, 0, "m");
    (62602, 0, "o");
    (62603, 0, "d");
    (62604, 0, "i");
    (62605, 0, "f");
    (62606, 0, "y");
    (62607, 0, "_");
    (62608, 0, "c");
    (62609, 0, "u");
    (62610, 0, "r");
    (62611, 0, "r");
    (62612, 0, "e");
    (62613, 0, "n");
    (62613, 1, "");
    (62612, 1, "");
    (62611, 1, "");
    (62610, 1, "");
    (62609, 1, "");
    (62608, 1, "");
    (62608, 0, "p");
    (62609, 0, "r");
    (62610, 0, "e");
    (62611, 0, "v");
    (62612, 0, ":");
    (62613, 0, " ");
    (62614, 0, "b");
    (62615, 0, "o");
    (62616, 0, "o");
    (62617, 0, "l");
    (62672, 0, "\n        ");
    (63460, 158, "");
    (62673, 8, "");
    ( 62673,
      0,
      "        let item = unsafe {\n\
      \            if self.item_offset > 0 { self.cursor.current_item_mut() }\n\
      \            else { self.cursor.prev_item_mut() }\n\
      \        };" );
    (62831, 0, "\n        ");
    (62832, 8, "");
    (62716, 16, "m");
    (62717, 0, "o");
    (62718, 0, "d");
    (62719, 0, "i");
    (62720, 0, "f");
    (62721, 0, "y");
    (62716, 6, "modify_prev");
    (62734, 30, "");
    (62756, 0, "self.cursor.current_item_mut()");
    (62786, 27, "");
    (62734, 0, "self.cursor.prev_item_mut()");
    (62729, 1, "");
    (62729, 1, "");
    (62729, 1, "");
    (62728, 1, "");
    (63975, 30, "");
    (63975, 0, "f");
    (63976, 0, "a");
    (63977, 0, "l");
    (63978, 0, "s");
    (63979, 0, "e");
    (63820, 0, "(");
    (63821, 0, "s");
    (63822, 0, "e");
    (63823, 0, "l");
    (63824, 0, "f");
    (63825, 0, ".");
    (63826, 0, "i");
    (63827, 0, "t");
    (63828, 0, "e");
    (63829, 0, "m");
    (63830, 0, "_");
    (63831, 0, "o");
    (63832, 0, "f");
    (63833, 0, "f");
    (63834, 0, "s");
    (63835, 0, "e");
    (63836, 0, "t");
    (63837, 0, " ");
    (63838, 0, ">");
    (63839, 0, " ");
    (63840, 0, "0");
    (63841, 0, " ");
    (63842, 0, "&");
    (63843, 0, "&");
    (63844, 0, " ");
    (63919, 0, ")");
    (63601, 1, "");
    (63597, 4, "");
    (63593, 4, "");
    (63592, 1, "");
    (63592, 0, "\n        ");
    (63601, 0, "unsafe { self.modify_item(false, modify_fn); }");
    (63627, 5, "t");
    (63628, 0, "r");
    (63629, 0, "u");
    (63630, 0, "e");
    (62692, 8, "");
    ( 62673,
      78,
      "        let item = if modify_prev { self.cursor.prev_item_mut() }" );
    (62739, 12, "        ");
    (62787, 10, "");
    (62786, 1, "");
    (62786, 0, ";");
    (63471, 0, "p");
    (63472, 0, "u");
    (63473, 0, "b");
    (63474, 0, " ");
    (54288, 0, "");
    (54289, 0, "m");
    (54288, 2, "");
    (63314, 1, "");
    (63325, 1, "");
    (63325, 0, ")");
    (63314, 0, "(");
    (62962, 0, "0");
    (62963, 0, ";");
    (62964, 0, " ");
    (62965, 0, "/");
    (62966, 0, "/");
    (62964, 3, "");
    (62962, 2, "");
    (63232, 0, "// ");
    (63232, 3, "");
    (63456, 0, "// ");
    (63418, 0, "// ");
    (63377, 0, "// ");
    (63314, 0, "// ");
    (63465, 3, "");
    (63424, 3, "");
    (63380, 3, "");
    (63314, 3, "");
    (67039, 0, " ");
    (67030, 1, "");
    (64176, 0, "\n");
    (57202, 1, "");
    (57103, 0, "i");
    (57097, 1, "");
    (56878, 0, "\n");
    (56796, 1, "");
    (56795, 0, "{");
    (56753, 1, "");
    (56736, 0, ">");
    (56734, 1, "");
    (56728, 0, ">");
    (56724, 1, "");
    (56707, 0, "i");
    (56706, 1, "");
    (56054, 0, "i");
    (56048, 1, "");
    (55841, 0, "\n");
    (58313, 0, "// ");
    (54544, 13, "");
    (54517, 0, "(");
    (54517, 1, "");
    (54544, 0, "item_offset, ");
    (54806, 13, "");
    (54544, 13, "");
    (54766, 0, "(");
    (54517, 0, "(");
    (54803, 0, ",");
    (54570, 0, ",");
    (54805, 0, " ");
    (54571, 0, " ");
    (54807, 0, "item_offset, ");
    (54572, 0, "item_offset, ");
    (54832, 1, "");
    (54584, 1, "");
    (54830, 1, "");
    (54583, 1, "");
    (54829, 0, ")");
    (54583, 0, ")");
    (54335, 0, "(");
    (54382, 0, ",");
    (54383, 0, " ");
    (54384, 0, "u");
    (54385, 0, "s");
    (54386, 0, "i");
    (54387, 0, "z");
    (54388, 0, "e");
    (54389, 0, ")");
    (54702, 0, "(");
    (54713, 0, ",");
    (54714, 0, " ");
    (54715, 0, "u");
    (54716, 0, "s");
    (54717, 0, "i");
    (54718, 0, "z");
    (54719, 0, "e");
    (54720, 0, ")");
    (59138, 78, "");
    (59138, 1, "");
    (60947, 0, "\n    ");
    (60952, 0, "\n    ");
    (60948, 4, "");
    (60953, 0, "p");
    (60954, 0, "u");
    (60955, 0, "b");
    (60956, 0, " ");
    (60957, 0, "f");
    (60958, 0, "n");
    (60959, 0, " ");
    (60960, 0, "i");
    (60961, 0, "n");
    (60962, 0, "s");
    (60963, 0, "e");
    (60964, 0, "r");
    (60965, 0, "t");
    (60966, 0, "_");
    (60967, 0, "b");
    (60968, 0, "e");
    (60969, 0, "t");
    (60970, 0, "w");
    (60971, 0, "e");
    (60972, 0, "e");
    (60973, 0, "n");
    ( 60974,
      0,
      "<I>(&mut self, mut contents: I) where I: \
       ExactSizeIterator<Item=C::Item> {" );
    (60988, 0, " ");
    (60989, 0, "o");
    (60990, 0, "f");
    (60991, 0, "f");
    (60992, 0, "s");
    (60993, 0, "e");
    (60994, 0, "t");
    (60995, 0, ":");
    (60996, 0, " ");
    (60997, 0, "u");
    (60998, 0, "s");
    (60999, 0, "i");
    (61000, 0, "z");
    (61001, 0, "e");
    (61002, 0, ",");
    (61063, 0, "\n        ");
    (61072, 0, "\n        ");
    (61064, 8, "");
    (61065, 8, "    }");
    (59610, 124, "");
    (59609, 1, "");
    (60939, 0, "        ");
    (60947, 0, "i");
    (60948, 0, "f");
    (60949, 0, " ");
    (60950, 0, "o");
    (60951, 0, "f");
    (60952, 0, "f");
    (60953, 0, "s");
    (60954, 0, "e");
    (60955, 0, "t");
    (60956, 0, " ");
    (60957, 0, "=");
    (60958, 0, "=");
    (60959, 0, " ");
    (60960, 0, "0");
    (60961, 0, " ");
    (60962, 0, "{");
    (60963, 0, " ");
    (60964, 0, "r");
    (60965, 0, "e");
    (60966, 0, "t");
    (60967, 0, "u");
    (60968, 0, "r");
    (60969, 0, "n");
    (60970, 0, " ");
    (60971, 0, "i");
    (60972, 0, "n");
    (60972, 1, "");
    (60971, 1, "");
    (60971, 0, "t");
    (60972, 0, "h");
    (60973, 0, "i");
    (60974, 0, "s");
    (60975, 0, ".");
    (60976, 0, "i");
    (60977, 0, "n");
    (60978, 0, "s");
    (60979, 0, "e");
    (60980, 0, "r");
    (60981, 0, "t");
    (60982, 0, "_");
    (60983, 0, "i");
    (60976, 8, "insert_iter");
    (60987, 0, "(");
    (60988, 0, "c");
    (60989, 0, "o");
    (60990, 0, "n");
    (60991, 0, "t");
    (60992, 0, "e");
    (60993, 0, "n");
    (60994, 0, "t");
    (60995, 0, "s");
    (60996, 0, ")");
    (60997, 0, ";");
    (60998, 0, " ");
    (60999, 0, "}");
    (61000, 0, "\n        ");
    (61001, 8, "");
    (60971, 4, "s");
    (60972, 0, "e");
    (60973, 0, "l");
    (60974, 0, "f");
    (59660, 56, "");
    (59754, 16, "            ");
    (59660, 16, "            ");
    (59750, 12, "        ");
    (59660, 12, "        ");
    (59746, 8, "            ");
    (59660, 8, "            ");
    (59750, 12, "                ");
    (59660, 12, "                ");
    (59660, 0, "        unsafe {\n            if self.item_offset == 0 {\n");
    (59677, 39, "");
    (59771, 16, "            ");
    (59677, 16, "            ");
    (59840, 21, "");
    (59840, 884, "");
    (59840, 15, "");
    (60034, 0, "\n        ");
    ( 60043,
      0,
      "                let current_item = self.cursor.current_item();\n\
      \                let (start, end) = C::split_item(current_item, \
       self.item_offset);\n\
      \                // Move the cursor back to the start of the item we're\n\
      \                // splitting.\n\
      \                self.cursor.move_to_item_start(self.list.head.height, \
       self.item_offset);\n\
      \                // This feels pretty inefficient; but its probably fine.\n\
      \                self.list.replace_item(&mut self.cursor, start, &mut \
       self.notify);\n\n\
      \                // TODO: Consider concatenating end into contents then \
       just call\n\
      \                // insert_at_iter once.\n\
      \                self.list.insert_at_iter(&mut self.cursor, &mut \
       contents, &mut self.notify);\n\n\
      \                self.dbg_check_cursor_at(start_userpos, \
       num_inserted_items);\n\n\
      \                self.list.insert_at_iter(&mut self.cursor, &mut \
       iter::once(end), &mut self.notify);" );
    (60828, 16, "        ");
    (60750, 16, "        ");
    (60656, 16, "        ");
    (60616, 16, "        ");
    (60535, 16, "        ");
    (60451, 16, "        ");
    (60378, 16, "        ");
    (60289, 16, "        ");
    (60259, 16, "        ");
    (60188, 16, "        ");
    (60106, 16, "        ");
    (60035, 24, "        ");
    (60311, 16, "o");
    (60145, 16, "o");
    (60297, 0, "f");
    (60146, 0, "f");
    (60299, 0, "f");
    (60147, 0, "f");
    (60301, 0, "s");
    (60148, 0, "s");
    (60303, 0, "e");
    (60149, 0, "e");
    (60305, 0, "t");
    (60150, 0, "t");
    (59605, 4, "");
    (59601, 4, "");
    (59600, 1, "");
    (60025, 0, "\n        ");
    ( 60034,
      0,
      "        let num_inserted_items = contents.len();\n\
      \        let start_userpos = self.cursor.userpos;\n" );
    (60026, 16, "        ");
    (59873, 0, "_");
    (59874, 0, "i");
    (59875, 0, "t");
    (59876, 0, "e");
    (59877, 0, "r");
    (61002, 0, "\n    ");
    (61003, 4, "");
    (61002, 0, "\n    ");
    ( 61007,
      0,
      "    pub fn insert(&mut self, item: C::Item) {\n\
      \        self.insert_iter(iter::once(item));\n\
      \    }" );
    (61003, 8, "    ");
    (61020, 0, "_");
    (61021, 0, "b");
    (61022, 0, "e");
    (61023, 0, "t");
    (61024, 0, "w");
    (61025, 0, "e");
    (61026, 0, "e");
    (61027, 0, "n");
    (61039, 0, " ");
    (61040, 0, "o");
    (61041, 0, "f");
    (61042, 0, "f");
    (61043, 0, "s");
    (61044, 0, "e");
    (61045, 0, "t");
    (61046, 0, ":");
    (61047, 0, " ");
    (61048, 0, "u");
    (61049, 0, "s");
    (61050, 0, "i");
    (61051, 0, "z");
    (61052, 0, "e");
    (61053, 0, ",");
    (61092, 0, "b");
    (61093, 0, "e");
    (61094, 0, "t");
    (61095, 0, "w");
    (61096, 0, "e");
    (61097, 0, "e");
    (61098, 0, "n");
    (61099, 0, "_");
    (61105, 0, "o");
    (61106, 0, "f");
    (61107, 0, "f");
    (61108, 0, "s");
    (61109, 0, "e");
    (61110, 0, "t");
    (61111, 0, ",");
    (61112, 0, " ");
    (61398, 79, "");
    (61769, 35, "");
    (62231, 12, "        ");
    (62169, 16, "            ");
    (62101, 16, "            ");
    (62080, 12, "        ");
    (62059, 16, "            ");
    (61966, 16, "            ");
    (61895, 16, "            ");
    (61815, 16, "            ");
    (61769, 12, "        ");
    (62209, 103, "");
    (62310, 30, "");
    (62617, 18, "");
    (62418, 7, "");
    (62951, 74, "");
    (62950, 1, "");
    (63427, 7, "");
    (63207, 7, "");
    (63464, 112, "");
    (63463, 1, "");
    (63463, 0, " ");
    (63335, 0, "\n    ");
    (63336, 4, "");
    (63335, 1, "");
    (63271, 0, "\n    ");
    (63276, 0, "/");
    (63277, 0, "/");
    (63278, 0, "/");
    (63279, 0, " ");
    (63280, 0, "T");
    (63281, 0, "h");
    (63282, 0, "i");
    (63283, 0, "s");
    (63284, 0, " ");
    (63280, 5, "C");
    (63281, 0, "a");
    (63282, 0, "v");
    (63283, 0, "e");
    (63284, 0, "a");
    (63285, 0, "t");
    (63286, 0, ":");
    (63287, 0, " ");
    (63288, 0, "T");
    (63289, 0, "h");
    (63290, 0, "i");
    (63291, 0, "s");
    (63292, 0, " ");
    (63293, 0, "m");
    (63294, 0, "o");
    (63295, 0, "v");
    (63296, 0, "e");
    (63297, 0, "s");
    (63298, 0, " ");
    (63299, 0, "t");
    (63300, 0, "h");
    (63301, 0, "e");
    (63302, 0, " ");
    (63303, 0, "c");
    (63304, 0, "u");
    (63305, 0, "r");
    (63306, 0, "s");
    (63307, 0, "o");
    (63308, 0, "r");
    (63309, 0, " ");
    (63310, 0, "t");
    (63311, 0, "o");
    (63312, 0, " ");
    (63313, 0, "t");
    (63314, 0, "h");
    (63315, 0, "e");
    (63316, 0, " ");
    (63317, 0, "n");
    (63318, 0, "e");
    (63319, 0, "x");
    (63320, 0, "t");
    (63321, 0, " ");
    (63322, 0, "i");
    (63323, 0, "t");
    (63324, 0, "e");
    (63325, 0, "m");
    (17326, 16, "");
    (17325, 1, "");
    (17324, 1, "");
    (17323, 1, "");
    (17300, 0, ">");
    (17301, 0, " ");
    (17301, 1, "");
    (17300, 1, "");
    (17323, 0, " > ");
    (17323, 3, "");
    (17300, 0, ">");
    (17300, 1, "");
    (17300, 0, "<");
    (17301, 0, " ");
    (17300, 0, "self.local_index");
    (17316, 0, " ");
    (16462, 0, "O");
    (16463, 0, "p");
    (16464, 0, "t");
    (16465, 0, "i");
    (16466, 0, "o");
    (16467, 0, "n");
    (16479, 0, ">");
    (16468, 0, "<");
    (16521, 0, "\n        ");
    (16530, 0, "i");
    (16531, 0, "f");
    (16532, 0, " ");
    (16533, 0, "s");
    (16534, 0, "e");
    (16535, 0, "l");
    (16536, 0, "f");
    (16537, 0, ".");
    (16538, 0, "l");
    (16539, 0, "o");
    (16540, 0, "c");
    (16541, 0, "a");
    (16542, 0, "l");
    (16538, 5, "local_index");
    (16549, 0, " ");
    (16550, 0, "=");
    (16551, 0, "=");
    (16552, 0, " ");
    (16553, 0, "0");
    (16554, 0, " ");
    (16555, 0, "{");
    (16556, 0, "\n            ");
    (16569, 0, "\n            ");
    (16557, 12, "");
    (16558, 12, "        }");
    (16557, 0, "            ");
    (16569, 0, "a");
    (16570, 0, "s");
    (16571, 0, "s");
    (16572, 0, "e");
    (16573, 0, "r");
    (16569, 5, "assert_eq!");
    (16579, 0, "(");
    (16580, 0, "s");
    (16581, 0, "e");
    (16582, 0, "l");
    (16583, 0, "f");
    (16584, 0, ".");
    (16584, 1, "");
    (16584, 0, ".");
    (16585, 0, "u");
    (16586, 0, "s");
    (16587, 0, "e");
    (16588, 0, "r");
    (16589, 0, "p");
    (16590, 0, "o");
    (16591, 0, "s");
    (16592, 0, ",");
    (16593, 0, " ");
    (16594, 0, "0");
    (16595, 0, ")");
    (16596, 0, ";");
    ( 16522,
      75,
      "        if self.local_index == 0 { assert_eq!(self.userpos, 0);" );
    ( 16522,
      73,
      "        if self.local_index == 0 { assert_eq!(self.userpos, 0); }" );
    ( 16522,
      65,
      "        if self.local_index == 0 { assert_eq!(self.userpos, 0);\n\
      \        }" );
    ( 16522,
      63,
      "        if self.local_index == 0 {\n\
      \            assert_eq!(self.userpos, 0);" );
    (16597, 0, "\n            ");
    (16610, 0, "N");
    (16611, 0, "o");
    (16612, 0, "n");
    (16613, 0, "e");
    (16624, 0, " ");
    (16625, 0, "e");
    (16626, 0, "l");
    (16627, 0, "s");
    (16628, 0, "e");
    (16629, 0, " ");
    (16630, 0, "{");
    (16739, 8, "            ");
    (16671, 8, "            ");
    (16632, 8, "            ");
    (16632, 42, "");
    (16631, 1, "");
    (16761, 0, "\n            ");
    (16762, 12, "        }");
    (16715, 0, "S");
    (16715, 1, "");
    (16716, 0, "S");
    (16717, 0, "o");
    (16718, 0, "m");
    (16719, 0, "e");
    (16720, 0, "(");
    (16766, 0, ")");
    (16845, 8, "\n        ");
    (16846, 8, "\n        ");
    ( 16845,
      0,
      "        let node = &*self.here_ptr();\n\
      \        if self.local_index == 0 {\n\
      \            assert_eq!(self.userpos, 0);\n\
      \            None\n\
      \        } else {\n\
      \            debug_assert!(self.local_index <= node.num_items as usize);\n\
      \            Some(&*(node.items[self.local_index - 1].as_ptr()))\n\
      \        }\n" );
    (17083, 0, "m");
    (17084, 0, "u");
    (17085, 0, "t");
    (17086, 0, " ");
    (16865, 0, "m");
    (16866, 0, "u");
    (16867, 0, "t");
    (16868, 0, " ");
    (16827, 0, "O");
    (16828, 0, "t");
    (16828, 1, "");
    (16828, 0, "p");
    (16829, 0, "t");
    (16830, 0, "i");
    (16831, 0, "o");
    (16832, 0, "n");
    (16833, 0, "<");
    (16849, 0, ">");
    (17314, 0, "// ");
    (17246, 0, "// ");
    (17207, 0, "// ");
    (17165, 0, "// ");
    (17137, 0, "m");
    (17138, 0, "u");
    (17139, 0, "t");
    (17140, 0, " ");
    (17140, 1, "");
    (17140, 0, "_");
    (17159, 225, "");
    (17055, 0, ".");
    (17055, 1, "");
    (17424, 0, "O");
    (17203, 0, "O");
    (17426, 0, "p");
    (17204, 0, "p");
    (17428, 0, "t");
    (17205, 0, "t");
    (17430, 0, "i");
    (17206, 0, "i");
    (17432, 0, "o");
    (17207, 0, "o");
    (17434, 0, "n");
    (17208, 0, "n");
    (17436, 0, "<");
    (17209, 0, "<");
    (17453, 0, ">");
    (17221, 0, ">");
    (16929, 0, "\n            ");
    (16930, 12, "");
    (16929, 1, "");
    (17271, 0, "// ");
    (17262, 0, "\n        ");
    (17271, 0, "i");
    (17272, 0, "f");
    (17273, 0, " ");
    (17274, 0, "self.local_index < node.num_items");
    (17307, 0, " ");
    (17308, 0, "a");
    (17309, 0, "s");
    (17310, 0, " ");
    (17311, 0, "u");
    (17312, 0, "s");
    (17313, 0, "i");
    (17314, 0, "z");
    (17315, 0, "e");
    (17316, 0, " ");
    (17317, 0, "{");
    (17318, 0, "\n            ");
    (17331, 0, "\n            ");
    (17319, 12, "");
    (17320, 12, "        }");
    (17319, 0, "            ");
    (17331, 0, "/");
    (17332, 0, "/");
    (17333, 0, " ");
    (17334, 0, "O");
    (17335, 0, "k");
    (17336, 0, " ");
    (17337, 0, "-");
    (17338, 0, " ");
    (17339, 0, "w");
    (17340, 0, "e");
    (17341, 0, "'");
    (17342, 0, "r");
    (17343, 0, "e");
    (17344, 0, " ");
    (17339, 6, "j");
    (17340, 0, "u");
    (17341, 0, "s");
    (17342, 0, "t");
    (17343, 0, " ");
    (17344, 0, "r");
    (17345, 0, "e");
    (17346, 0, "t");
    (17347, 0, "u");
    (17348, 0, "r");
    (17349, 0, "n");
    (17350, 0, " ");
    (17351, 0, "t");
    (17352, 0, "h");
    (17353, 0, "e");
    (17354, 0, " ");
    (17355, 0, "c");
    (17356, 0, "u");
    (17357, 0, "r");
    (17358, 0, "r");
    (17359, 0, "e");
    (17360, 0, "n");
    (17361, 0, "t");
    (17362, 0, " ");
    (17363, 0, "i");
    (17364, 0, "t");
    (17365, 0, "e");
    (17366, 0, "m");
    (17367, 0, ".");
    (17379, 70, "");
    (17428, 0, "\n        }");
    (17379, 8, "            ");
    (17369, 10, "");
    (17381, 0, "S");
    (17382, 0, "o");
    (17383, 0, "m");
    (17384, 0, "e");
    (17385, 0, "(");
    (17427, 0, ")");
    (17438, 0, " ");
    (17439, 0, "e");
    (17440, 0, "l");
    (17441, 0, "s");
    (17442, 0, "e");
    (17443, 0, " ");
    (17444, 0, "{");
    (17445, 0, "\n            ");
    (17458, 0, "\n            ");
    (17446, 12, "");
    (17447, 12, "        }");
    (17446, 0, "            ");
    (17458, 0, "/");
    (17459, 0, "/");
    (17460, 0, " ");
    (17461, 0, "R");
    (17462, 0, "e");
    (17463, 0, "t");
    (17464, 0, "u");
    (17465, 0, "r");
    (17466, 0, "n");
    (17467, 0, " ");
    (17468, 0, "t");
    (17469, 0, "h");
    (17470, 0, "e");
    (17471, 0, " ");
    (17472, 0, "f");
    (17473, 0, "i");
    (17474, 0, "r");
    (17475, 0, "s");
    (17476, 0, "t");
    (17477, 0, " ");
    (17478, 0, "i");
    (17479, 0, "t");
    (17480, 0, "e");
    (17481, 0, "m");
    (17482, 0, " ");
    (17483, 0, "i");
    (17484, 0, "n");
    (17485, 0, " ");
    (17486, 0, "t");
    (17487, 0, "h");
    (17488, 0, "e");
    (17489, 0, " ");
    (17490, 0, "n");
    (17491, 0, "e");
    (17492, 0, "x");
    (17493, 0, "t");
    (17494, 0, " ");
    (17495, 0, "n");
    (17496, 0, "o");
    (17497, 0, "d");
    (17498, 0, "e");
    (17499, 0, ".");
    (17461, 10, "P");
    (17462, 0, "e");
    (17463, 0, "e");
    (17464, 0, "l");
    (17464, 1, "");
    (17464, 0, "k");
    (17465, 0, " ");
    (17466, 0, "t");
    (17467, 0, "h");
    (17468, 0, "e");
    (17498, 0, "\n            ");
    (17511, 0, "l");
    (17512, 0, "e");
    (17513, 0, "t");
    (17514, 0, " ");
    (17515, 0, "n");
    (17516, 0, "e");
    (17517, 0, "x");
    (17518, 0, "t");
    (17519, 0, " ");
    (17520, 0, "=");
    (17521, 0, " ");
    (17522, 0, "s");
    (17523, 0, "e");
    (17524, 0, "l");
    (17525, 0, "f");
    (17526, 0, ".");
    (17527, 0, "h");
    (17528, 0, "e");
    (17529, 0, "r");
    (17530, 0, "e");
    (17527, 4, "here_ptr()");
    (17537, 0, ".");
    (17538, 0, "n");
    (17539, 0, "o");
    (17540, 0, "d");
    (17541, 0, "e");
    (17527, 15, "");
    (17527, 0, "e");
    (17528, 0, "n");
    (17529, 0, "t");
    (17530, 0, "r");
    (17531, 0, "i");
    (17532, 0, "e");
    (17533, 0, "s");
    (17527, 7, "");
    (17527, 0, "here_ptr().node");
    (17538, 4, "");
    (17538, 0, "g");
    (17539, 0, "e");
    (17540, 0, "t");
    (17541, 0, "_");
    (17542, 0, "n");
    (17543, 0, "e");
    (17544, 0, "x");
    (17538, 7, "get_next_ptr");
    (17550, 0, "(");
    (17551, 0, ")");
    (17522, 0, "(");
    (17523, 0, "*");
    (17539, 0, ")");
    (17498, 0, "\n            ");
    (17511, 0, "u");
    (17512, 0, "n");
    (17513, 0, "s");
    (17514, 0, "a");
    (17515, 0, "f");
    (17516, 0, "e");
    (17517, 0, " ");
    (17518, 0, "{");
    (17576, 0, "\n            ");
    (17577, 12, "            }");
    (17576, 14, "");
    (17517, 2, "");
    (17498, 19, "");
    (17555, 0, ";");
    (17556, 0, "\n            ");
    (17569, 0, "i");
    (17570, 0, "f");
    (17571, 0, " ");
    (17572, 0, "n");
    (17573, 0, "e");
    (17574, 0, "x");
    (17575, 0, "t");
    (17576, 0, ".");
    (17577, 0, "i");
    (17578, 0, "s");
    (17579, 0, "_");
    (17580, 0, "n");
    (17581, 0, "u");
    (17577, 5, "is_null");
    (17584, 0, "(");
    (17585, 0, ")");
    (17586, 0, " ");
    (17587, 0, "{");
    (17588, 0, " ");
    (17589, 0, "r");
    (17590, 0, "e");
    (17591, 0, "t");
    (17592, 0, "u");
    (17593, 0, "r");
    (17594, 0, "n");
    (17595, 0, " ");
    (17596, 0, "N");
    (17597, 0, "o");
    (17598, 0, "n");
    (17599, 0, "e");
    (17600, 0, ";");
    (17601, 0, " ");
    (17602, 0, "}");
    (17603, 0, "\n            ");
    (17616, 0, "e");
    (17617, 0, "l");
    (17618, 0, "s");
    (17619, 0, "e");
    (17620, 0, " ");
    (17589, 7, "");
    (17593, 1, "");
    (17613, 0, "{");
    (17614, 0, "\n                ");
    (17631, 0, "\n                ");
    (17615, 16, "");
    (17616, 16, "            }");
    (17615, 0, "                ");
    (17631, 0, "S");
    (17632, 0, "o");
    (17633, 0, "m");
    (17634, 0, "e");
    (17635, 0, "(");
    (17636, 0, "(");
    (17636, 1, "");
    (17636, 0, "(");
    (17637, 0, "*");
    (17638, 0, "n");
    (17639, 0, "e");
    (17640, 0, "x");
    (17641, 0, "t");
    (17642, 0, ")");
    (17643, 0, ".");
    (17644, 0, "c");
    (17645, 0, "o");
    (17646, 0, "n");
    (17647, 0, "t");
    (17648, 0, "e");
    (17649, 0, "n");
    (17650, 0, "t");
    (17644, 7, "content");
    (17651, 0, "_");
    (17652, 0, "s");
    (17653, 0, "l");
    (17654, 0, "i");
    (17655, 0, "c");
    (17656, 0, "e");
    (17657, 0, "[");
    (17658, 0, "0");
    (17658, 1, "");
    (17658, 0, "]");
    (17658, 1, "");
    (17658, 0, "0");
    (17659, 0, "]");
    (17657, 0, "(");
    (17658, 0, ")");
    (17662, 0, ")");
    (17636, 0, "&");
    (17192, 0, "<");
    (17193, 0, "'");
    (17194, 0, "a");
    (17195, 0, ">");
    (13966, 1, "");
    (13965, 1, "");
    (13964, 1, "");
    (13963, 1, "");
    (16808, 0, "<");
    (16809, 0, "'");
    (16810, 0, "a");
    (16811, 0, ".");
    (16811, 1, "");
    (16811, 0, ">");
    (16447, 0, "<'a>");
    (17622, 0, "\n                ");
    (17639, 0, "d");
    (17640, 0, "e");
    (17641, 0, "b");
    (17642, 0, "u");
    (17643, 0, "g");
    (17639, 5, "debug_assert!");
    (17652, 0, "(");
    (17653, 0, "*");
    (17654, 0, "n");
    (17655, 0, "e");
    (17656, 0, "x");
    (17657, 0, "t");
    (17653, 0, "(");
    (17659, 0, ")");
    (17660, 0, ".");
    (17661, 0, "n");
    (17662, 0, "u");
    (17663, 0, "m");
    (17664, 0, "_");
    (17665, 0, "i");
    (17666, 0, "t");
    (17667, 0, "e");
    (17668, 0, "m");
    (17669, 0, "s");
    (17670, 0, " ");
    (17671, 0, ">");
    (17672, 0, " ");
    (17673, 0, "0");
    (17674, 0, ")");
    (17675, 0, ";");
    (17698, 1, "");
    (17698, 0, "&");
    (17707, 13, "");
    (17707, 1, "");
    (17707, 1, "");
    (17707, 0, "i");
    (17708, 0, "t");
    (17709, 0, "e");
    (17710, 0, "m");
    (17711, 0, "s");
    (17715, 0, ".");
    (17716, 0, "a");
    (17717, 0, "s");
    (17718, 0, "_");
    (17719, 0, "r");
    (17720, 0, "e");
    (17721, 0, "f");
    (17722, 0, "(");
    (17723, 0, ")");
    (17716, 6, "a");
    (17717, 0, "s");
    (17718, 0, "_");
    (17719, 0, "p");
    (17720, 0, "t");
    (17721, 0, "r");
    (17699, 0, "*");
    (17168, 0, "\n    ");
    (17173, 0, "\n    ");
    (17169, 4, "");
    (17174, 0, "f");
    (17175, 0, "n");
    (17176, 0, " ");
    (17177, 0, "p");
    (17178, 0, "e");
    (17179, 0, "e");
    (17180, 0, "k");
    (17181, 0, "_");
    (17182, 0, "n");
    (17183, 0, "e");
    (17184, 0, "x");
    (17185, 0, "t");
    (17186, 0, "_");
    (17187, 0, "i");
    (17188, 0, "t");
    (17189, 0, "e");
    (17190, 0, "m");
    (17191, 0, "(");
    (17192, 0, "&");
    (17193, 0, "s");
    (17194, 0, "e");
    (17195, 0, "l");
    (17196, 0, "f");
    (17197, 0, ")");
    (17198, 0, " ");
    (17199, 0, "-");
    (17200, 0, ">");
    (17201, 0, " ");
    (17202, 0, "O");
    (17202, 1, "");
    (17202, 0, "O");
    (17202, 1, "");
    (17202, 0, "*");
    (17203, 0, "C");
    (17204, 0, ":");
    (17205, 0, ":");
    (17206, 0, "I");
    (17206, 1, "Item");
    (17203, 0, "m");
    (17204, 0, "u");
    (17205, 0, "t");
    (17206, 0, " ");
    (17214, 0, " ");
    (17215, 0, "{");
    (17216, 0, "\n        ");
    (17225, 0, "\n        ");
    (17217, 8, "");
    (17218, 8, "    }");
    ( 17217,
      0,
      "            let next = (*self.here_ptr()).get_next_ptr();\n\
      \            if next.is_null() { None }\n\
      \            else {\n\
      \                debug_assert!((*next).num_items > 0);\n\
      \                Some(&*(*next).items[0].as_ptr())\n\
      \            }\n" );
    (17437, 12, "        ");
    (17387, 16, "            ");
    (17333, 16, "            ");
    (17314, 12, "        ");
    (17275, 12, "        ");
    (17217, 12, "        ");
    (17426, 1, "");
    (17299, 4, "");
    (17299, 0, "p");
    (17300, 0, "t");
    (17301, 0, "r");
    (17302, 0, ":");
    (17303, 0, ":");
    (17304, 0, "n");
    (17305, 0, "u");
    (17306, 0, "l");
    (17304, 3, "null()");
    (17422, 1, "");
    (17390, 7, "");
    (17308, 0, "_");
    (17309, 0, "m");
    (17310, 0, "u");
    (17311, 0, "t");
    (17414, 0, "m");
    (17415, 0, "u");
    (17416, 0, "t");
    (17417, 0, "_");
    (17174, 0, "u");
    (17175, 0, "n");
    (17176, 0, "s");
    (17177, 0, "a");
    (17178, 0, "f");
    (17179, 0, "e");
    (17180, 0, " ");
    (17209, 0, "O");
    (17210, 0, "p");
    (17211, 0, "t");
    (17212, 0, "i");
    (17213, 0, "o");
    (17214, 0, "n");
    (17215, 0, "<");
    (17228, 0, ">");
    (17314, 15, "N");
    (17315, 0, "u");
    (17315, 1, "");
    (17314, 1, "");
    (17314, 0, "N");
    (17315, 0, "o");
    (17316, 0, "n");
    (17317, 0, "e");
    (17398, 0, "S");
    (17399, 0, "o");
    (17400, 0, "m");
    (17401, 0, "e");
    (17402, 0, "(");
    (17432, 0, ")");
    (17787, 0, "\n            ");
    (17800, 0, "s");
    (17801, 0, "e");
    (17802, 0, "l");
    (17803, 0, "f");
    (17804, 0, ".");
    (17805, 0, ".");
    (17806, 0, "p");
    (17807, 0, "e");
    (17808, 0, "e");
    (17809, 0, "k");
    (17809, 1, "");
    (17808, 1, "");
    (17807, 1, "");
    (17806, 1, "");
    (17805, 1, "");
    (17805, 0, "p");
    (17806, 0, "e");
    (17807, 0, "e");
    (17808, 0, "k");
    (17805, 4, "peek_next_item()");
    (17821, 0, ".");
    (17822, 0, "a");
    (17823, 0, "n");
    (17824, 0, "d");
    (17822, 3, "and_then(f: F)");
    (17831, 4, "|");
    (17832, 0, "p");
    (17833, 0, "t");
    (17834, 0, "r");
    (17835, 0, "|");
    (17836, 0, " ");
    (17837, 0, "&");
    (17838, 0, "*");
    (17839, 0, "p");
    (17840, 0, "t");
    (17841, 0, "r");
    (18076, 0, "// ");
    (18026, 0, "// ");
    (17972, 0, "// ");
    (17953, 0, "// ");
    (17914, 0, "// ");
    (17856, 0, "// ");
    (17822, 8, "m");
    (17823, 0, "a");
    (17824, 0, "p");
    (17839, 252, "");
    (17927, 8, "\n        ");
    (17928, 8, "\n        ");
    ( 17927,
      0,
      "        let node = &*self.here_ptr();\n\
      \        if self.local_index < node.num_items as usize {\n\
      \            // Ok - just return the current item.\n\
      \            Some(&*(node.items[self.local_index].as_ptr()))\n\
      \        } else {\n\
      \            // Peek the first item in the next node.\n\
      \            self.peek_next_item().map(|ptr| &*ptr)\n\
      \        }\n" );
    (17947, 0, "m");
    (17948, 0, "u");
    (17949, 0, "t");
    (17950, 0, " ");
    (18127, 0, "m");
    (18128, 0, "u");
    (18129, 0, "t");
    (18130, 0, "_");
    (18270, 160, "");
    (18270, 9, "");
    (18270, 0, "t_ptr())\n");
    ( 18270,
      0,
      "\n\n\
      \        let node = &mut *self.here_ptr();\n\
      \        debug_assert!(self.local_index < node.num_items as usize);\n\
      \        &mut *(node.items[self.local_index].as_mu" );
    (18270, 160, "");
    (18270, 9, "");
    (18093, 0, "m");
    (18094, 0, "u");
    (18095, 0, "t");
    (18096, 0, " ");
    (18258, 0, "m");
    (18259, 0, "u");
    (18260, 0, "t");
    (18261, 0, " ");
    (17169, 0, "\n    ");
    (17174, 0, "/");
    (17175, 0, "/");
    (17176, 0, " ");
    (17177, 0, "C");
    (17178, 0, "o");
    (17179, 0, "u");
    (17180, 0, "l");
    (17181, 0, "d");
    (17182, 0, " ");
    (17183, 0, "b");
    (17184, 0, "e");
    (17185, 0, " ");
    (17186, 0, "O");
    (17187, 0, "p");
    (17188, 0, "t");
    (17189, 0, "i");
    (17190, 0, "o");
    (17191, 0, "n");
    (17192, 0, "<");
    (17193, 0, "N");
    (17194, 0, "o");
    (17195, 0, "n");
    (17196, 0, "N");
    (17197, 0, "u");
    (17198, 0, "l");
    (17199, 0, "l");
    (17200, 0, "<");
    (17201, 0, ">");
    (17201, 1, "");
    (17201, 0, ".");
    (17202, 0, ".");
    (17202, 1, "");
    (17201, 1, "");
    (17201, 0, "_");
    (17202, 0, ">");
    (17203, 0, ">");
    (17204, 0, ".");
    (17205, 0, ".");
    (17206, 0, ".");
    (15888, 0, ".");
    (15889, 0, "u");
    (15890, 0, "n");
    (15891, 0, "w");
    (15892, 0, "r");
    (15893, 0, "a");
    (15894, 0, "p");
    (15895, 0, "(");
    (15896, 0, ")");
    (17933, 0, "<");
    (17934, 0, "'");
    (17935, 0, "a");
    (17936, 0, ">");
    (55525, 0, "\n    ");
    (55530, 0, "\n    ");
    (55526, 4, "");
    (55531, 0, "p");
    (55532, 0, "u");
    (55533, 0, "b");
    (55534, 0, " ");
    (55535, 0, "f");
    (55536, 0, "n");
    (55537, 0, " ");
    (55538, 0, "e");
    (55539, 0, "d");
    (55540, 0, "i");
    (55541, 0, "t");
    (55542, 0, "_");
    (55543, 0, "b");
    (55544, 0, "e");
    (55545, 0, "t");
    (55546, 0, "w");
    (55547, 0, "e");
    (55548, 0, "e");
    (55549, 0, "(");
    (55549, 1, "");
    (55549, 0, "n");
    (55550, 0, "_");
    (55550, 1, "");
    ( 55550,
      0,
      "(&mut self, userpos: usize) -> (Edit<C, impl FnMut(&[C::Item], \
       ItemMarker<C>)>, usize) {\n\
      \        // self.edit_notify(userpos, no_notify_x::<C>, f)\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify: Self::no_notify }, \
       item_offset)\n\
      \    }" );
    (55763, 0, "\n        ");
    (55772, 0, "a");
    (55773, 0, "s");
    (55772, 2, "assert_eq!");
    (55782, 0, "(");
    (55783, 0, "i");
    (55784, 0, "t");
    (55785, 0, "e");
    (55786, 0, "m");
    (55787, 0, "_");
    (55788, 0, "o");
    (55783, 6, "item_offset");
    (55794, 0, ",");
    (55795, 0, " ");
    (55796, 0, "0");
    (55797, 0, ",");
    (55798, 0, " ");
    (55799, 0, "\"");
    (55800, 0, "C");
    (55801, 0, "a");
    (55802, 0, "n");
    (55803, 0, "n");
    (55804, 0, "o");
    (55805, 0, "t");
    (55806, 0, " ");
    (55800, 7, "e");
    (55801, 0, "d");
    (55802, 0, "i");
    (55803, 0, "t");
    (55804, 0, "_");
    (55805, 0, "b");
    (55806, 0, "e");
    (55807, 0, "t");
    (55808, 0, "w");
    (55809, 0, "e");
    (55810, 0, "e");
    (55811, 0, "n");
    (55812, 0, " ");
    (55813, 0, "f");
    (55814, 0, "o");
    (55815, 0, "u");
    (55816, 0, "n");
    (55817, 0, "d");
    (55818, 0, " ");
    (55813, 6, "l");
    (55814, 0, "a");
    (55815, 0, "n");
    (55816, 0, "d");
    (55817, 0, "e");
    (55818, 0, "d");
    (55819, 0, " ");
    (55820, 0, "b");
    (55820, 1, "");
    (55820, 0, "i");
    (55821, 0, "n");
    (55822, 0, "s");
    (55823, 0, "i");
    (55824, 0, "d");
    (55825, 0, "e");
    (55826, 0, " ");
    (55827, 0, "a");
    (55828, 0, "n");
    (55829, 0, " ");
    (55830, 0, "i");
    (55831, 0, "t");
    (55832, 0, "e");
    (55833, 0, "m");
    (55834, 0, "\"");
    (55835, 0, ")");
    (55836, 0, ";");
    (55846, 1, "");
    (55898, 14, "");
    (55581, 1, "");
    (55627, 8, "");
    (55183, 0, "_");
    (54899, 0, "_");
    (54726, 0, "_");
    (54304, 0, "_");
    (55187, 0, "b");
    (54902, 0, "b");
    (54728, 0, "b");
    (54305, 0, "b");
    (55191, 0, "e");
    (54905, 0, "e");
    (54730, 0, "e");
    (54306, 0, "e");
    (55195, 0, "t");
    (54908, 0, "t");
    (54732, 0, "t");
    (54307, 0, "t");
    (55199, 0, "w");
    (54911, 0, "w");
    (54734, 0, "w");
    (54308, 0, "w");
    (55194, 9, "edit_between(userpos: usize)");
    (54905, 9, "edit_between(userpos: usize)");
    (54727, 9, "edit_between(userpos: usize)");
    (54300, 9, "edit_between(userpos: usize)");
    (55264, 14, "");
    (54956, 14, "");
    (54759, 14, "");
    (54313, 14, "");
    (55222, 1, "");
    (54928, 1, "");
    (54745, 1, "");
    (54313, 1, "");
    (55218, 1, "");
    (54925, 1, "");
    (54743, 1, "");
    (54312, 1, "");
    (54706, 7, "");
    (54685, 22, "");
    (54684, 1, "");
    (54683, 1, "");
    (54682, 1, "");
    (54681, 1, "");
    (54680, 1, "");
    (54679, 1, "");
    (54678, 1, "");
    (54677, 1, "");
    (54676, 0, ": FnOnce(&mut C::Item)");
    (54677, 1, "");
    (54676, 1, "");
    (54675, 1, "");
    (54675, 0, "F: ");
    (54676, 22, "");
    (54635, 0, ": FnOnce(&mut C::Item)");
    (54847, 34, "");
    (54794, 0, ": ExactSizeIterator<Item=C::Item> ");
    (54827, 1, "");
    (54873, 7, "");
    (54869, 4, "");
    (54868, 1, "");
    (54867, 1, "");
    (54867, 0, " ");
    (54867, 1, "");
    (54867, 0, ")");
    (54868, 0, " ");
    (54250, 34, "");
    (54249, 1, "");
    (54248, 1, "");
    (54247, 1, "");
    (54246, 1, "");
    (54245, 1, "");
    (54244, 1, "");
    (54243, 1, "");
    (54165, 1, "");
    (54165, 0, "I: ExactSizeIterator<Item=C::Item>");
    (54863, 0, "        self.edit_between(userpos).insert_iter(contents)\n");
    (54871, 0, "// ");
    (54922, 0, "\n        ");
    (54931, 0, "l");
    (54932, 0, "e");
    (54933, 0, "t");
    (54934, 0, " ");
    (54935, 0, "(");
    (54936, 0, "e");
    (54937, 0, "d");
    (54938, 0, "i");
    (54939, 0, "t");
    (54940, 0, ",");
    (54941, 0, " ");
    (54942, 0, "o");
    (54943, 0, "f");
    (54944, 0, "f");
    (54945, 0, "s");
    (54946, 0, "e");
    (54947, 0, "t");
    (54948, 0, ")");
    (54949, 0, " ");
    (54950, 0, "=");
    (54951, 0, " ");
    (54952, 0, "s");
    (54953, 0, "e");
    (54954, 0, "l");
    (54955, 0, "f");
    (54956, 0, ".");
    (54957, 0, "e");
    (54958, 0, "d");
    (54959, 0, "i");
    (54960, 0, "t");
    (54961, 0, "(");
    (54962, 0, "u");
    (54963, 0, "s");
    (54964, 0, "e");
    (54965, 0, "r");
    (54966, 0, "p");
    (54967, 0, "o");
    (54968, 0, "s");
    (54969, 0, ")");
    (54970, 0, ";");
    (54971, 0, "\n        ");
    (54980, 0, "e");
    (54981, 0, "d");
    (54982, 0, "i");
    (54983, 0, "t");
    (54984, 0, ".");
    (54985, 0, "i");
    (54986, 0, "n");
    (54987, 0, "s");
    (54988, 0, "e");
    (54989, 0, "r");
    (54985, 5, "insert_between_iter(offset: usize, mut contents: I)");
    (55005, 13, "o");
    (55006, 0, "f");
    (55007, 0, "f");
    (55008, 0, "s");
    (55009, 0, "e");
    (55010, 0, "t");
    (55013, 15, "c");
    (55014, 0, "o");
    (55015, 0, "n");
    (55016, 0, "t");
    (55017, 0, "e");
    (55018, 0, "n");
    (55019, 0, "t");
    (55020, 0, "s");
    (55022, 0, ";");
    (55024, 57, "");
    (54863, 59, "");
    (54862, 1, "");
    (61575, 0, ".");
    (61576, 0, "u");
    (61577, 0, "n");
    (61578, 0, "w");
    (61579, 0, "r");
    (61580, 0, "a");
    (61581, 0, "p");
    (61582, 0, "(");
    (61583, 0, ")");
    (61576, 6, "e");
    (61577, 0, "x");
    (61578, 0, "p");
    (61579, 0, "e");
    (61580, 0, "c");
    (61581, 0, "t");
    (61583, 0, "\"");
    (61583, 1, "");
    (61576, 6, "unwrap");
    (63103, 8, "");
    (63094, 1, "");
    (63426, 16, "");
    (63460, 1, "");
    (63459, 1, "");
    (63458, 1, "");
    (63458, 0, " ");
    (63459, 0, "}");
    (63461, 58, "");
    (16604, 0, ",");
    (16605, 0, " ");
    (16606, 0, "\"Invalid state: Cursor at start of node\"");
    (63503, 9, "");
    (63502, 1, "");
    (63148, 307, "");
    (63147, 1, "");
    (63148, 12, "        ");
    ( 63097,
      0,
      "\n\
      \    pub fn prev_item(&self) -> Option<&C::Item> {\n\
      \        unsafe { self.cursor.prev_item() }\n\
      \    }\n" );
    (63209, 1, "");
    (63209, 1, "");
    (63209, 1, "");
    (63209, 1, "");
    (63209, 0, "n");
    (63210, 0, "e");
    (63211, 0, "x");
    (63212, 0, "t");
    (63277, 9, "n");
    (63278, 0, "e");
    (63279, 0, "x");
    (63280, 0, "T");
    (63281, 0, "_");
    (63282, 0, "t");
    (63283, 0, "i");
    (63283, 1, "");
    (63282, 1, "");
    (63281, 1, "");
    (63280, 1, "");
    (63280, 0, "t");
    (63281, 0, "_");
    (63282, 0, "i");
    (63283, 0, "t");
    (63284, 0, "e");
    (63285, 0, "m");
    (63277, 4, "c");
    (63278, 0, "u");
    (63279, 0, "r");
    (63280, 0, "r");
    (63281, 0, "e");
    (63282, 0, "n");
    (63283, 0, "t");
    (63449, 4, "n");
    (63450, 0, "e");
    (63451, 0, "x");
    (63452, 0, "t");
    (63539, 1, "");
    (63538, 1, "");
    (63537, 1, "");
    (63536, 1, "");
    (63536, 0, "n");
    (63537, 0, "e");
    (63538, 0, "x");
    (63539, 0, "t");
    (63543, 27, "");
    (63561, 0, "self.cursor.prev_item_mut()");
    (63588, 30, "");
    (63543, 0, "self.cursor.current_item_mut()");
    (64330, 4, "f");
    (64331, 0, "a");
    (64332, 0, "l");
    (64333, 0, "s");
    (64334, 0, "e");
    (64685, 5, "t");
    (64686, 0, "r");
    (64687, 0, "e");
    (64687, 1, "");
    (64687, 0, "u");
    (64688, 0, "e");
    (63442, 19, "");
    (63423, 0, "p");
    (63424, 0, "r");
    (63425, 0, "e");
    (63426, 0, "v");
    (63427, 0, "_");
    (63512, 64, "");
    (63511, 1, "");
    (63540, 1, "");
    (63539, 1, "");
    (63539, 0, ".");
    (63540, 0, "u");
    (63541, 0, "n");
    (63540, 2, "unwrap()");
    (63540, 6, "e");
    (63541, 0, "x");
    (63542, 0, "p");
    (63543, 0, "e");
    (63544, 0, "c");
    (63545, 0, "t");
    (63547, 0, "\"");
    (63548, 0, "C");
    (63549, 0, "a");
    (63549, 1, "");
    (63548, 1, "");
    (63548, 0, "C");
    (63549, 0, "u");
    (63550, 0, "r");
    (63551, 0, "s");
    (63552, 0, "p");
    (63552, 1, "");
    (63552, 0, "o");
    (63553, 0, "r");
    (63548, 6, "c");
    (63549, 0, "a");
    (63550, 0, "n");
    (63551, 0, "n");
    (63552, 0, "o");
    (63553, 0, "t");
    (63554, 0, " ");
    (63555, 0, "m");
    (63556, 0, "o");
    (63548, 9, "C");
    (63549, 0, "a");
    (63550, 0, "n");
    (63551, 0, "n");
    (63552, 0, "o");
    (63553, 0, "t");
    (63554, 0, " ");
    (63555, 0, "m");
    (63556, 0, "o");
    (63557, 0, "d");
    (63558, 0, "i");
    (63559, 0, "f");
    (63560, 0, "y");
    (63548, 13, "C");
    (63549, 0, "u");
    (63550, 0, "r");
    (63551, 0, "s");
    (63552, 0, "o");
    (63553, 0, "r");
    (63554, 0, " ");
    (63555, 0, "a");
    (63556, 0, "t");
    (63557, 0, " ");
    (63558, 0, "s");
    (63559, 0, "t");
    (63560, 0, "a");
    (63561, 0, "r");
    (63562, 0, "t");
    (63563, 0, " ");
    (63564, 0, "o");
    (63565, 0, "f");
    (63566, 0, " ");
    (63567, 0, "d");
    (63568, 0, "o");
    (63569, 0, "c");
    (63570, 0, "u");
    (63571, 0, "m");
    (63572, 0, "e");
    (63573, 0, "n");
    (63574, 0, "t");
    (63575, 0, ".");
    (63576, 0, " ");
    (63577, 0, "C");
    (63578, 0, "a");
    (63579, 0, "n");
    (63580, 0, "n");
    (63581, 0, "o");
    (63582, 0, "t");
    (63583, 0, " ");
    (63584, 0, "m");
    (63585, 0, "o");
    (63586, 0, "d");
    (63587, 0, "i");
    (63588, 0, "f");
    (63589, 0, "y");
    (63590, 0, " ");
    (63591, 0, "p");
    (63592, 0, "r");
    (63593, 0, "e");
    (63594, 0, "v");
    (63595, 0, ".");
    (63596, 0, "\"");
    (63595, 1, "");
    (64183, 150, "");
    (63406, 6, "p");
    (63407, 0, "u");
    (63408, 0, "b");
    (64389, 42, "");
    (64389, 12, "        ");
    (64418, 10, "");
    (64417, 1, "");
    (64426, 9, "");
    (64438, 0, "p");
    (64439, 0, "r");
    (64440, 0, "e");
    (64441, 0, "v");
    (64442, 0, "_");
    (64448, 4, "");
    (64448, 1, "");
    (64448, 1, "");
    (64460, 1, "");
    (64459, 1, "");
    (64486, 0, "p");
    (64487, 0, "r");
    (64488, 0, "e");
    (64489, 0, "v");
    (64490, 0, "_");
    (64565, 9, "");
    (63508, 0, " ");
    (63509, 0, "u");
    (63510, 0, "n");
    (63511, 0, "s");
    (63512, 0, "a");
    (63513, 0, "f");
    (63514, 0, "e");
    (63515, 0, " ");
    (63516, 0, "{");
    (63545, 0, " ");
    (63546, 0, "}");
    (61508, 0, "\n        ");
    (61517, 0, "u");
    (61518, 0, "n");
    (61519, 0, "s");
    (61520, 0, "a");
    (61521, 0, "f");
    (61522, 0, "e");
    (61523, 0, " ");
    (61524, 0, "{");
    (62212, 8, "            ");
    (62142, 8, "            ");
    (62056, 8, "            ");
    (62024, 8, "            ");
    (61951, 8, "            ");
    (61875, 8, "            ");
    (61810, 8, "            ");
    (61739, 8, "            ");
    (61717, 8, "            ");
    (61654, 8, "            ");
    (61581, 8, "            ");
    (61526, 8, "            ");
    (62351, 0, "\n            ");
    (62352, 12, "        }");
    (54918, 0, "m");
    (54919, 0, "u");
    (54920, 0, "t");
    (54921, 0, " ");
    (54666, 1, "");
    (54665, 1, "");
    (54665, 0, "a");
    (54666, 0, "f");
    (54667, 0, "t");
    (54668, 0, "e");
    (54669, 0, "r");
    (54669, 1, "");
    (54668, 1, "");
    (54667, 1, "");
    (54666, 1, "");
    (54665, 1, "");
    (54665, 0, "a");
    (54666, 0, "t");
    (54690, 0, ",");
    (54691, 0, " ");
    (54692, 0, "u");
    (54693, 0, "s");
    (54694, 0, "i");
    (54695, 0, "z");
    (54696, 0, "e");
    (54743, 0, "        let (mut edit, offset) = self.edit(userpos);\n");
    (54665, 2, "a");
    (54666, 0, "f");
    (54667, 0, "t");
    (54668, 0, "e");
    (54669, 0, "r");
    (54798, 0, "\n        ");
    (54807, 0, "i");
    (54808, 0, "f");
    (54809, 0, " ");
    (54810, 0, "o");
    (54811, 0, "f");
    (54812, 0, "f");
    (54813, 0, "s");
    (54814, 0, "e");
    (54815, 0, "t");
    (54816, 0, " ");
    (54817, 0, "=");
    (54818, 0, "=");
    (54819, 0, " ");
    (54820, 0, "0");
    (54821, 0, " ");
    (54822, 0, "{");
    (54823, 0, " ");
    (54833, 0, "// ");
    (54824, 0, "e");
    (54825, 0, "d");
    (54826, 0, "i");
    (54827, 0, "t");
    (54828, 0, ".");
    (54829, 0, "m");
    (54830, 0, "o");
    (54831, 0, "d");
    (54832, 0, "i");
    (54829, 4, "modify_next_item");
    (54845, 0, "(");
    (54846, 0, "|");
    (54847, 0, "i");
    (54848, 0, "t");
    (54849, 0, "e");
    (54850, 0, "m");
    (54851, 0, "|");
    (54852, 0, " ");
    (54853, 0, "m");
    (54854, 0, "o");
    (54855, 0, "d");
    (54856, 0, "i");
    (54853, 4, "modify_fn");
    (54862, 0, "(");
    (54863, 0, "i");
    (54864, 0, "t");
    (54865, 0, "e");
    (54866, 0, "m");
    (54867, 0, ",");
    (54868, 0, " ");
    (54869, 0, "o");
    (54870, 0, "f");
    (54871, 0, "f");
    (54872, 0, "s");
    (54873, 0, "e");
    (54874, 0, "t");
    (54875, 0, ")");
    (54876, 0, ")");
    (54877, 0, " ");
    (54878, 0, "}");
    (54879, 0, "\n        ");
    (54888, 0, "e");
    (54889, 0, "l");
    (54890, 0, "s");
    (54891, 0, "e");
    (54892, 0, " ");
    (54893, 0, "{");
    (54894, 0, "\n            ");
    (54907, 0, "\n            ");
    (54895, 12, "");
    (54896, 12, "        }");
    (54895, 0, "            ");
    (64594, 1, "");
    (54895, 12, "");
    (64582, 1, "");
    (64582, 1, "");
    (64582, 1, "");
    (64582, 0, "c");
    (64583, 0, "u");
    (64584, 0, "r");
    (64585, 0, "r");
    (64586, 0, "e");
    (64587, 0, "n");
    (64588, 0, "t");
    (64582, 7, "");
    (64582, 0, "next");
    (54895, 0, "            ");
    (64594, 4, "");
    (54895, 12, "");
    (64582, 0, "current");
    (54836, 4, "c");
    (54837, 0, "u");
    (54838, 0, "r");
    (54839, 0, "r");
    (54840, 0, "e");
    (54841, 0, "n");
    (54842, 0, "t");
    (54883, 25, "");
    (54882, 1, "");
    (54881, 1, "");
    (54880, 1, "");
    (54807, 17, "");
    (54864, 66, "");
    (63253, 4, "c");
    (63254, 0, "u");
    (63255, 0, "r");
    (63256, 0, "r");
    (63257, 0, "e");
    (63258, 0, "n");
    (63259, 0, "t");
    (63324, 1, "");
    (63324, 1, "");
    (63324, 1, "");
    (63324, 1, "");
    (63324, 0, "c");
    (63325, 0, "u");
    (63326, 0, "r");
    (63327, 0, "r");
    (63328, 0, "e");
    (63329, 0, "n");
    (63330, 0, "t");
    (63324, 7, "");
    (63324, 0, "prev");
    (63253, 7, "prev");
    ( 54864,
      0,
      "        // self.edit_between(userpos).modify_next_item(modify_fn)\n" );
    (54864, 66, "");
    (63253, 4, "current");
    (63253, 7, "prev");
    (63353, 4, "c");
    (63354, 0, "u");
    (63355, 0, "r");
    (63356, 0, "r");
    (63357, 0, "e");
    (63358, 0, "n");
    (63359, 0, "t");
    (2236, 0, "\n");
    (2237, 0, "\n");
    (2237, 1, "");
    (2236, 1, "");
    (3161, 0, "\n");
    (3162, 0, "\n");
    (3163, 0, "p");
    (3164, 0, "u");
    (3165, 0, "b");
    (3166, 0, " ");
    (3167, 0, "t");
    (3168, 0, "r");
    (3169, 0, "a");
    (3170, 0, "i");
    (3171, 0, "t");
    (3172, 0, " ");
    (3173, 0, "N");
    (3174, 0, "o");
    (3175, 0, "t");
    (3176, 0, "i");
    (3177, 0, "f");
    (3178, 0, "y");
    (3178, 1, "");
    (3178, 0, "i");
    (3179, 0, "e");
    (3180, 0, "d");
    (3180, 1, "");
    (3179, 1, "");
    (3178, 1, "");
    (3178, 0, "y");
    (3179, 0, " ");
    (3180, 0, "{");
    (3181, 0, "\n    ");
    (3182, 4, "}");
    (3181, 0, "\n    ");
    (3186, 0, "f");
    (3187, 0, "n");
    (3188, 0, " ");
    (3189, 0, "u");
    (3190, 0, "s");
    (3191, 0, "e");
    (3192, 0, "d");
    (3189, 0, "i");
    (3190, 0, "s");
    (3191, 0, "_");
    (3189, 0, "n");
    (3190, 0, "o");
    (3191, 0, "f");
    (3192, 0, "i");
    (3192, 1, "");
    (3191, 1, "");
    (3191, 0, "t");
    (3192, 0, "i");
    (3193, 0, "f");
    (3194, 0, "i");
    (3195, 0, "c");
    (3196, 0, "a");
    (3197, 0, "t");
    (3198, 0, "i");
    (3199, 0, "o");
    (3200, 0, "n");
    (3201, 0, "_");
    (3178, 1, "");
    (3177, 1, "");
    (3177, 0, "f");
    (3178, 0, "i");
    (3179, 0, "c");
    (3180, 0, "a");
    (3181, 0, "t");
    (3182, 0, "i");
    (3183, 0, "o");
    (3184, 0, "n");
    (3185, 0, "T");
    (3186, 0, "a");
    (3187, 0, "r");
    (3188, 0, "g");
    (3189, 0, "e");
    (3190, 0, "t");
    (3213, 0, "s");
    (3214, 1, "");
    (3214, 1, "");
    (3214, 1, "");
    (3219, 0, " ");
    (3220, 0, "-");
    (3220, 1, "");
    (3219, 1, "");
    (3219, 0, "(");
    (3220, 0, ")");
    (3221, 0, " ");
    (3222, 0, "-");
    (3223, 0, ">");
    (3224, 0, " ");
    (3225, 0, "b");
    (3226, 0, "o");
    (3227, 0, "o");
    (3228, 0, "l");
    (3229, 0, " ");
    (3230, 0, "{");
    (3231, 0, " ");
    (3232, 0, "t");
    (3233, 0, "r");
    (3234, 0, "u");
    (3235, 0, "e");
    (3236, 0, " ");
    (3237, 0, "}");
    (3238, 0, "\n    ");
    (3243, 0, "\n    ");
    (3239, 4, "");
    (3240, 4, "");
    (3193, 0, "\n    ");
    (3198, 0, "/");
    (3199, 0, "/");
    (3200, 0, " ");
    (3201, 0, "F");
    (3202, 0, "o");
    (3203, 0, "r");
    (3204, 0, " ");
    (3201, 4, "T");
    (3202, 0, "u");
    (3203, 0, " ");
    (3203, 1, "");
    (3202, 1, "");
    (3202, 0, "o");
    (3203, 0, " ");
    (3204, 0, "t");
    (3205, 0, "u");
    (3206, 0, "r");
    (3207, 0, "n");
    (3208, 0, " ");
    (3209, 0, "o");
    (3210, 0, "f");
    (3211, 0, "f");
    (3212, 0, " ");
    (3213, 0, "s");
    (3214, 0, "o");
    (3215, 0, "m");
    (3216, 0, "e");
    (3217, 0, " ");
    (3218, 0, "c");
    (3219, 0, "o");
    (3220, 0, "m");
    (3221, 0, "p");
    (3222, 0, "l");
    (3223, 0, "i");
    (3224, 0, "e");
    (3225, 0, "r");
    (3226, 0, " ");
    (3227, 0, "i");
    (3228, 0, "n");
    (3218, 11, "i");
    (3219, 0, "n");
    (3220, 0, "f");
    (3221, 0, "r");
    (3222, 0, "a");
    (3223, 0, "s");
    (3218, 6, "b");
    (3219, 0, "o");
    (3220, 0, "o");
    (3221, 0, "k");
    (3222, 0, "k");
    (3223, 0, "e");
    (3224, 0, "e");
    (3225, 0, "p");
    (3226, 0, "i");
    (3227, 0, "n");
    (3228, 0, "g");
    (3229, 0, ".");
    (3230, 0, " ");
    (3231, 0, "T");
    (3232, 0, "h");
    (3233, 0, "e");
    (3234, 0, " ");
    (3235, 0, "o");
    (3236, 0, "p");
    (3237, 0, "t");
    (3238, 0, "i");
    (3239, 0, "m");
    (3240, 0, "i");
    (3241, 0, "e");
    (3242, 0, "r");
    (3242, 1, "");
    (3241, 1, "");
    (3241, 0, "z");
    (3242, 0, "e");
    (3243, 0, "r");
    (3244, 0, " ");
    (3245, 0, "w");
    (3246, 0, "i");
    (3247, 0, "l");
    (3248, 0, "l");
    (3249, 0, " ");
    (3250, 0, "i");
    (3251, 0, "n");
    (3252, 0, "l");
    (3253, 0, "i");
    (3254, 0, "n");
    (3255, 0, "e");
    (3256, 0, " ");
    (3257, 0, "t");
    (3258, 0, "h");
    (3259, 0, "i");
    (3260, 0, "s");
    (3212, 5, " ");
    (3212, 1, "");
    (3224, 0, " ");
    (3225, 0, "r");
    (3226, 0, "e");
    (3227, 0, "l");
    (3228, 0, "a");
    (3229, 0, "t");
    (3230, 0, "e");
    (3231, 0, "d");
    (3232, 0, " ");
    (3233, 0, "t");
    (3234, 0, "o");
    (3235, 0, " ");
    (3236, 0, "l");
    (3236, 1, "");
    (3236, 0, "q");
    (3237, 0, "u");
    (3238, 0, "e");
    (3239, 0, "r");
    (3240, 0, "y");
    (3241, 0, " ");
    (3242, 0, "l");
    (3243, 0, "o");
    (3244, 0, "o");
    (3245, 0, "k");
    (3246, 0, "u");
    (3247, 0, "p");
    (3248, 0, "s");
    (3198, 0, "/");
    (3236, 0, " ");
    (3237, 0, "I");
    (3238, 0, "t");
    (3239, 0, "e");
    (3240, 0, "m");
    (3241, 0, "M");
    (3242, 0, "a");
    (3243, 0, "r");
    (3244, 0, "k");
    (3245, 0, "e");
    (3246, 0, "r");
    ( 3194,
      99,
      "    /// To turn off bookkeeping related to ItemMarker query lookups. The\n\
      \    /// optimizer will inline this" );
    (3306, 0, "c");
    (3307, 0, "o");
    (3308, 0, "n");
    (3309, 0, "s");
    (3310, 0, "t");
    (3311, 0, " ");
    (3311, 1, "");
    (3311, 0, " ");
    (3306, 6, "");
    (3348, 0, "    ");
    (3348, 4, "");
    (3045, 110, "");
    ( 3238,
      0,
      "    // fn notify(&mut self, _items: &[Self::Item], _at_marker: \
       ItemMarker<Self>) where Self: Sized {\n\
      \    // }\n" );
    (3347, 1, "");
    (3343, 3, "");
    (3242, 3, "");
    (3263, 1, "");
    (3081, 0, "<");
    (3082, 0, "I");
    (3083, 0, "t");
    (3084, 0, "e");
    (3085, 0, "m");
    (3086, 0, ">");
    (3278, 6, "");
    (3082, 4, "C");
    (3083, 0, ":");
    (3084, 0, " ");
    (3085, 0, "L");
    (3086, 0, "i");
    (3087, 0, "s");
    (3088, 0, "t");
    (3089, 0, "o");
    (3085, 5, "ListConfig");
    (3287, 0, "C");
    (3288, 0, ":");
    (3289, 0, ":");
    (3297, 1, "");
    (3319, 4, "C");
    (3323, 25, "");
    (3323, 0, ";");
    (3323, 1, "");
    (3322, 1, "");
    (3322, 0, ";");
    (22222, 0, "N");
    (22223, 0, "o");
    (22224, 0, "f");
    (22225, 0, "i");
    (22225, 1, "");
    (22224, 1, "");
    (22224, 0, "t");
    (22225, 0, "i");
    (22226, 0, "f");
    (22227, 0, "y");
    (22230, 0, ",");
    (22231, 0, " ");
    (22232, 0, "N");
    (22233, 0, ":");
    (22234, 0, " ");
    (22235, 0, "N");
    (22236, 0, "o");
    (22237, 0, "t");
    (22238, 0, "i");
    (22235, 4, "NotificationTarget");
    (22233, 20, "");
    (22212, 0, ",");
    (22213, 0, " ");
    (22214, 0, ": NotificationTarget");
    (22214, 0, "N");
    (22235, 0, "<");
    (22236, 0, "C");
    (22237, 0, ">");
    (22248, 6, "");
    (7554, 0, ",");
    (7555, 0, " ");
    (7556, 0, "N");
    (7557, 0, ":");
    (7558, 0, " ");
    (7559, 0, "N");
    (7560, 0, "o");
    (7561, 0, "t");
    (7562, 0, "i");
    (7559, 4, "NotificationTarget");
    (7540, 0, "N");
    (7541, 0, "o");
    (7542, 0, "f");
    (7543, 0, "i");
    (7544, 0, "y");
    (7544, 1, "");
    (7543, 1, "");
    (7542, 1, "");
    (7542, 0, "t");
    (7543, 0, "i");
    (7544, 0, "f");
    (7545, 0, "y");
    (7583, 0, "<");
    (7584, 0, "C");
    (7585, 0, ">");
    (7560, 26, "");
    (7545, 1, "");
    (7544, 1, "");
    (7543, 1, "");
    (7542, 1, "");
    (7541, 1, "");
    (7540, 1, "");
    (22252, 1, "");
    (22251, 1, "");
    (22250, 1, "");
    (22250, 0, ", N");
    (7540, 0, "Notify");
    (7560, 0, ", N: NotificationTarget<C>");
    (9373, 0, "\n    ");
    (9378, 0, "\n    ");
    (9374, 4, "");
    (9379, 0, "_");
    (9380, 0, "p");
    (9381, 0, "h");
    (9382, 0, "a");
    (9383, 0, "n");
    (9384, 0, "t");
    (9385, 0, "o");
    (9386, 0, "m");
    (9387, 0, ":");
    (9388, 0, " ");
    (9389, 0, "P");
    (9390, 0, "h");
    (9391, 0, "a");
    (9392, 0, "n");
    (9389, 4, "PhantomData");
    (9400, 0, "<");
    (9401, 0, "N");
    (9402, 0, ">");
    (22302, 8, "SkipListNotify");
    (22368, 0, "N");
    (22369, 0, "o");
    (22370, 0, "f");
    (22371, 0, "i");
    (22372, 0, "y");
    (22372, 1, "");
    (22371, 1, "");
    (22370, 1, "");
    (22370, 0, "t");
    (22371, 0, "i");
    (22372, 0, "f");
    (22373, 0, "y");
    (22378, 0, ",");
    (22379, 0, " ");
    (22380, 0, "N");
    (22773, 0, "\n            ");
    (22786, 0, "_");
    (22787, 0, "m");
    (22788, 0, "a");
    (22789, 0, "r");
    (22790, 0, "k");
    (22791, 0, "e");
    (22792, 0, "r");
    (22793, 0, ":");
    (22794, 0, " ");
    (22795, 0, "P");
    (22796, 0, "h");
    (22797, 0, "a");
    (22798, 0, "n");
    (22795, 4, "PhantomData");
    (22787, 6, "p");
    (22788, 0, "h");
    (22789, 0, "a");
    (22790, 0, "n");
    (22791, 0, "t");
    (22792, 0, "o");
    (22793, 0, "m");
    (56606, 0, "// ");
    (56547, 0, "// ");
    (56480, 0, "// ");
    (56357, 0, "// ");
    (56017, 0, " ");
    (56018, 0, "n");
    (56019, 0, "o");
    (56020, 0, "t");
    (56021, 0, "i");
    (56022, 0, "f");
    (56023, 0, "y");
    (56024, 0, "_");
    (56025, 0, "t");
    (56026, 0, "a");
    (56027, 0, "r");
    (56028, 0, "g");
    (56029, 0, "e");
    (56030, 0, "t");
    (56017, 14, "");
    (55981, 0, "\n    ");
    (55986, 0, "\n    ");
    (55982, 4, "");
    (55987, 0, "p");
    (55988, 0, "u");
    (55989, 0, " ");
    (55990, 0, "b");
    (55990, 1, "");
    (55989, 1, "");
    (55989, 0, "b");
    (55990, 0, " ");
    (55991, 0, "f");
    (55992, 0, "n");
    (55993, 0, " ");
    (55983, 11, "");
    (55982, 1, "");
    (55981, 1, "");
    (56352, 0, "\n    ");
    (56357, 0, "p");
    (56358, 0, "u");
    (56359, 0, "b");
    (56360, 0, " ");
    (56361, 0, "f");
    (56362, 0, "n");
    (56363, 0, " ");
    (56364, 0, "e");
    (56365, 0, "d");
    (56366, 0, "i");
    (56367, 0, "t");
    (56368, 0, "_");
    (56369, 0, "n");
    (56370, 0, "o");
    (56371, 0, "t");
    (56372, 0, "i");
    (56373, 0, "f");
    (56374, 0, "y");
    (56375, 0, "(");
    (56375, 1, "");
    (56375, 0, "<");
    (56375, 1, "");
    (56375, 0, "(");
    (56376, 0, "&");
    (56377, 0, "m");
    (56378, 0, "u");
    (56379, 0, "t");
    (56380, 0, " ");
    (56381, 0, "s");
    (56382, 0, "e");
    (56383, 0, "l");
    (56384, 0, "f");
    (56385, 0, ",");
    (56386, 0, " ");
    (56387, 0, "u");
    (56388, 0, "s");
    (56389, 0, "e");
    (56390, 0, "r");
    (56391, 0, "p");
    (56392, 0, "o");
    (56393, 0, "s");
    (56394, 0, ":");
    (56395, 0, " ");
    (56396, 0, "u");
    (56397, 0, "s");
    (56398, 0, "i");
    (56399, 0, "z");
    (56400, 0, "e");
    (56401, 0, ",");
    (56402, 0, " ");
    (56402, 1, "");
    (56401, 1, "");
    (56401, 0, ")");
    (56402, 0, " ");
    (56403, 0, "{");
    (56404, 0, "\n        ");
    (56413, 0, "\n        ");
    (56405, 8, "");
    (56406, 8, "    }");
    (56405, 0, "        ");
    (56405, 8, "");
    (56401, 0, ",");
    (56402, 0, " ");
    (56403, 0, "n");
    (56404, 0, "o");
    (56405, 0, "t");
    (56406, 0, "i");
    (56407, 0, "f");
    (56408, 0, "y");
    (56409, 0, "_");
    (56410, 0, "t");
    (56411, 0, "a");
    (56412, 0, "r");
    (56413, 0, "g");
    (56414, 0, "e");
    (56415, 0, "t");
    (56416, 0, ":");
    (56417, 0, " ");
    (56418, 0, "N");
    (56419, 0, ":");
    (56420, 0, ":");
    (56420, 1, "");
    (56419, 1, "");
    (56418, 0, "&");
    (56419, 0, "m");
    (56420, 0, "u");
    (56421, 0, "t");
    (56422, 0, " ");
    (56428, 0, "        ");
    (56436, 0, "a");
    (56437, 0, "s");
    (56438, 0, "s");
    (56439, 0, "e");
    (56440, 0, "r");
    (56441, 0, "t");
    (56442, 0, "!");
    (56443, 0, "(");
    (56444, 0, "N");
    (56445, 0, ":");
    (56446, 0, ":");
    (56447, 0, "notifications_used()");
    (56467, 0, ")");
    (56468, 0, ";");
    (55899, 0, "\n        ");
    (55908, 0, "assert!(N::notifications_used());");
    (55916, 0, "!");
    (56513, 4, "\n    ");
    ( 56513,
      0,
      "    //     let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \    //     (Edit { list: self, cursor, notify }, item_offset)\n" );
    (56644, 1, "");
    (56587, 3, "");
    (56517, 3, "");
    (56622, 0, "_");
    (56623, 0, "t");
    (56624, 0, "a");
    (56625, 0, "r");
    (56626, 0, "g");
    (56627, 0, "e");
    (56628, 0, "t");
    (60297, 5, "");
    (60299, 32, "");
    (60299, 0, "N");
    (60300, 0, "o");
    (60301, 0, "t");
    (60302, 0, "i");
    (60299, 4, "NotificationTarget");
    (60317, 0, "<");
    (60318, 0, "C");
    (60319, 0, ">");
    (60352, 0, ",");
    (60353, 0, " ");
    (60354, 0, "N");
    (60342, 8, "SkipListNotify");
    (60459, 6, "&");
    (60460, 0, "m");
    (60461, 0, "u");
    (60462, 0, "t");
    (60463, 0, " ");
    (60464, 0, "N");
    (60280, 0, " ");
    (60281, 0, "'");
    (60282, 0, "b");
    (60283, 0, ":");
    (60284, 0, " ");
    (60285, 0, "'");
    (60286, 0, "a");
    (60467, 0, "'");
    (60468, 0, "b");
    (60469, 0, " ");
    (60287, 0, ",");
    (60286, 1, "");
    (60285, 1, "");
    (60284, 1, "");
    (60283, 1, "");
    (60283, 0, ": 'a");
    (60344, 1, "");
    (60344, 0, "b");
    (60469, 1, "");
    (60469, 0, "a");
    (60286, 1, "");
    (60285, 1, "");
    (60284, 1, "");
    (60283, 1, "");
    (60282, 1, "");
    (60281, 1, "");
    (60280, 1, "");
    (60279, 1, "");
    (60336, 1, "");
    (60336, 0, "a");
    (60468, 0, ",");
    (60778, 56, "<'a, C: ListConfig, N: NotificationTarget<C>>");
    (64788, 1, "");
    (64799, 1, "");
    (64799, 0, ".");
    (64800, 0, "n");
    (64801, 0, "o");
    (64802, 0, "t");
    (64803, 0, "i");
    (64800, 4, "notify(items: &[C::Item], at_marker: ItemMarker<C>)");
    (64807, 44, "");
    (64806, 1, "");
    (38784, 6, "N");
    (42261, 0, ".");
    (42262, 0, "n");
    (42263, 0, "o");
    (42264, 0, "t");
    (42265, 0, "i");
    (42266, 0, "f");
    (42267, 0, "y");
    (34835, 6, "M");
    (34835, 1, "");
    (34835, 0, "N");
    (38455, 0, ".");
    (38456, 0, "n");
    (38457, 0, "o");
    (38458, 0, "t");
    (38459, 0, "i");
    (38460, 0, "f");
    (38461, 0, "y");
    (34856, 42, "");
    (38765, 42, "");
    (38667, 8, "");
    (34721, 8, "");
    (51080, 42, "");
    (51054, 6, "N");
    (53256, 1, ".");
    (53256, 1, "");
    (53256, 0, "y");
    (53257, 0, ".");
    (53258, 0, "n");
    (53259, 0, "o");
    (53260, 0, "t");
    (53261, 0, "i");
    (53262, 0, "f");
    (53263, 0, "y");
    (53911, 50, "");
    (53910, 1, "");
    (53903, 6, "N");
    (53828, 6, "");
    (53828, 1, "");
    (53827, 1, "");
    (50943, 8, "");
    (56260, 0, " -> (Edit<C, N>, usize)");
    (56431, 0, "n");
    (56432, 0, "o");
    (56433, 0, "t");
    (56434, 0, "i");
    (56435, 0, "f");
    (56436, 0, "y");
    (56437, 0, ":");
    (56438, 0, " ");
    (56210, 0, "<");
    (56211, 0, "'");
    (56212, 0, "a");
    (56213, 0, ",");
    (56214, 0, " ");
    (56215, 0, "'");
    (56216, 0, "b");
    (56217, 0, ":");
    (56218, 0, " ");
    (56219, 0, "'");
    (56220, 0, "a");
    (56221, 0, ">");
    (56224, 0, "'");
    (56225, 0, "b");
    (56226, 0, " ");
    (56269, 0, "'");
    (56270, 0, "a");
    (56271, 0, " ");
    (56213, 8, "");
    (56217, 1, "");
    (56217, 0, "a");
    (3325, 0, "\n");
    (3326, 0, "\n");
    (3327, 0, "p");
    (3328, 0, "u");
    (3329, 0, "b");
    (3330, 0, " ");
    (3331, 0, "t");
    (3332, 0, "r");
    (3333, 0, "a");
    (3334, 0, "i");
    (3335, 0, "t");
    (3336, 0, " ");
    (3337, 0, "N");
    (3338, 0, "o");
    (3339, 0, "N");
    (3340, 0, "o");
    (3327, 4, "");
    (3326, 0, "\n");
    (3327, 0, "s");
    (3328, 0, "t");
    (3329, 0, "r");
    (3330, 0, "u");
    (3331, 0, "c");
    (3332, 0, "t");
    (3333, 0, " ");
    (3334, 0, "N");
    (3335, 0, "o");
    (3335, 1, "");
    (3335, 0, "u");
    (3336, 0, "l");
    (3337, 0, "l");
    (3338, 0, "N");
    (3339, 0, "o");
    (3340, 0, "t");
    (3341, 0, "i");
    (3342, 0, "f");
    (3343, 0, "i");
    (3344, 0, "c");
    (3345, 0, "a");
    (3346, 0, "t");
    (3347, 0, "i");
    (3348, 0, "o");
    (3349, 0, "n");
    (3335, 1, "");
    (3335, 1, "");
    (3335, 1, "");
    (3335, 0, "o");
    (3334, 14, "N");
    (3335, 0, "o");
    (3336, 0, "N");
    (3337, 0, "o");
    (3338, 0, "t");
    (3339, 0, "i");
    (3340, 0, "f");
    (3341, 0, "y");
    (3343, 10, "i");
    (3344, 0, "m");
    (3345, 0, "p");
    (3346, 0, "l");
    (3347, 0, " ");
    (3348, 0, "N");
    (3349, 0, "o");
    (3350, 0, "t");
    (3351, 0, "i");
    (3352, 0, "f");
    (3348, 5, "NotificationTarget");
    (3347, 0, "<");
    (3348, 0, "C");
    (3349, 0, ">");
    (3349, 0, ":");
    (3350, 0, " ");
    (3351, 0, "L");
    (3352, 0, "i");
    (3353, 0, "s");
    (3354, 0, "t");
    (3351, 4, "ListConfig");
    (3381, 0, "<");
    (3382, 0, "C");
    (3383, 0, ">");
    (3384, 0, " ");
    (3385, 0, "f");
    (3386, 0, "o");
    (3387, 0, "r");
    (3388, 0, " ");
    (3389, 0, "N");
    (3390, 0, "o");
    (3391, 0, "N");
    (3392, 0, "o");
    (3389, 4, "NoNotify");
    (3397, 0, " ");
    (3398, 0, "{");
    (3399, 0, "\n    ");
    (3404, 0, "\n    ");
    (3400, 4, "");
    (3401, 4, "}");
    (3400, 0, "    ");
    (3404, 0, "f");
    (3405, 0, "n");
    (3406, 0, " ");
    (3407, 0, "n");
    (3408, 0, "o");
    (3409, 0, "t");
    (3410, 0, "i");
    (3411, 0, "f");
    (3412, 0, "i");
    (3407, 6, "notifications_used");
    (3425, 0, "(");
    (3426, 0, ")");
    (3427, 0, " ");
    (3428, 0, "-");
    (3429, 0, ">");
    (3430, 0, " ");
    (3431, 0, "b");
    (3432, 0, "o");
    (3433, 0, "o");
    (3434, 0, "l");
    (3435, 0, " ");
    (3436, 0, "{");
    (3437, 0, " ");
    (3438, 0, "f");
    (3439, 0, "a");
    (3440, 0, "l");
    (3441, 0, "s");
    (3442, 0, "e");
    (3443, 0, " ");
    (3444, 0, "}");
    (3445, 0, "\n    ");
    ( 3450,
      0,
      "fn notify(&mut self, items: &[C::Item], at_marker: ItemMarker<C>);" );
    (3342, 0, ";");
    (3516, 1, "");
    (3516, 0, " ");
    (3517, 0, "{");
    (3518, 0, "}");
    (20130, 0, ",");
    (20131, 0, " ");
    (20132, 0, "N");
    (20133, 0, ":");
    (20134, 0, " ");
    (20135, 0, "N");
    (20136, 0, "o");
    (20137, 0, "t");
    (20138, 0, "i");
    (20139, 0, "f");
    (20135, 5, "NotificationTarget");
    (20153, 0, "<");
    (20154, 0, "C");
    (20155, 0, ">");
    (20304, 0, ",");
    (20305, 0, " ");
    (20306, 0, "C");
    (20306, 1, "");
    (20306, 0, "N");
    (20294, 8, "SkipListNotify");
    (20312, 1, "");
    (20312, 0, "_");
    (20312, 1, "");
    (20312, 0, "N");
    (20341, 0, ", N: NotificationTarget<C>");
    (20390, 0, ",");
    (20391, 0, " ");
    (20392, 0, "N");
    (21131, 0, ",");
    (21132, 0, " ");
    (21133, 0, ", N: NotificationTarget<C>");
    (21133, 26, "");
    (21132, 1, "");
    (21131, 1, "");
    (21131, 0, ", N: NotificationTarget<C>");
    (21193, 0, ",");
    (21194, 0, " ");
    (21195, 0, "N");
    (45357, 0, ",");
    (45358, 0, " ");
    (45359, 0, "N");
    (3327, 0, "// ");
    (3393, 8, "");
    (3393, 0, "(");
    (3394, 0, ")");
    (3326, 20, "");
    (22587, 0, " ");
    (22588, 0, "=");
    (22589, 0, " ");
    (22590, 0, "(");
    (22591, 0, ")");
    (22589, 3, "");
    (22587, 2, "");
    (22566, 0, " ");
    (22567, 0, "=");
    (22568, 0, " ");
    (22569, 0, "(");
    (22570, 0, ")");
    (22568, 3, "");
    (22566, 2, "");
    (7759, 0, " ");
    (7760, 0, "=");
    (7761, 0, " ");
    (7762, 0, "(");
    (7763, 0, ")");
    (60462, 1, "");
    (22644, 1, "");
    (22586, 1, "");
    (20289, 1, "");
    (7718, 1, "");
    (60457, 1, "");
    (22640, 1, "");
    (22583, 1, "");
    (20287, 1, "");
    (7717, 1, "");
    (60452, 1, "");
    (22636, 1, "");
    (22580, 1, "");
    (20285, 1, "");
    (7716, 1, "");
    (60447, 1, "");
    (22632, 1, "");
    (22577, 1, "");
    (20283, 1, "");
    (7715, 1, "");
    (60442, 1, "");
    (22628, 1, "");
    (22574, 1, "");
    (20281, 1, "");
    (7714, 1, "");
    (60437, 1, "");
    (22624, 1, "");
    (22571, 1, "");
    (20279, 1, "");
    (7713, 1, "");
    (60432, 1, "");
    (22620, 1, "");
    (22568, 1, "");
    (20277, 1, "");
    (7712, 1, "");
    (60428, 0, "t");
    (22617, 0, "t");
    (22566, 0, "t");
    (20276, 0, "t");
    (7712, 0, "t");
    (54461, 69, "");
    (54461, 1906, "");
    (56037, 0, "\n");
    (56038, 0, "i");
    (56039, 0, "m");
    (56040, 0, "p");
    (56041, 0, "l");
    (56042, 0, " ");
    (56042, 1, "");
    (56042, 0, "<");
    (56043, 0, "C");
    (56044, 0, ":");
    (56045, 0, " ");
    (56046, 0, "L");
    (56047, 0, "i");
    (56048, 0, "s");
    (56049, 0, "t");
    (56046, 4, "ListConfig");
    (56056, 0, ">");
    (56057, 0, " ");
    (56058, 0, "S");
    (56059, 0, "k");
    (56060, 0, "i");
    (56058, 3, "SkipList");
    (56066, 0, "<");
    (56067, 0, "C");
    (56068, 0, ",");
    (56069, 0, " ");
    (56070, 0, "(");
    (56071, 0, ")");
    (56071, 1, "");
    (56070, 1, "");
    (56069, 1, "");
    (56068, 1, "");
    (56068, 0, ">");
    (56069, 0, " ");
    (56070, 0, "{");
    (56071, 0, "\n    ");
    (56076, 0, "\n    ");
    (56072, 4, "");
    (56073, 4, "}");
    ( 56072,
      0,
      "\n\
      \    pub fn replace_at<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       start_userpos: usize, removed_items: usize, inserted_content: I) {\n\
      \        self.edit_between(start_userpos).replace(removed_items, \
       inserted_content);\n\
      \    }\n\n\
      \    pub fn replace_at_slice(&mut self, start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \        self.replace_at(start_userpos, removed_items, \
       inserted_content.iter().copied());\n\
      \    }\n\n\
      \    pub fn modify_item_after<F: FnOnce(&mut C::Item, usize)>(&mut self, \
       userpos: usize, modify_fn: F) {\n\
      \        let (mut edit, offset) = self.edit(userpos);\n\
      \        edit.modify_current_item(|item| modify_fn(item, offset))\n\
      \    }\n\n\
      \    pub fn insert_at<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       userpos: usize, contents: I) {\n\
      \        let (mut edit, offset) = self.edit(userpos);\n\
      \        edit.insert_between_iter(offset, contents);\n\
      \    }\n\n\
      \    pub fn insert_at_slice(&mut self, userpos: usize, contents: \
       &[C::Item]) where C::Item: Copy {\n\
      \        self.insert_at(userpos, contents.iter().copied())\n\
      \    }\n\n\
      \    pub fn del_at(&mut self, userpos: usize, num_items: usize) {\n\
      \        self.edit_between(userpos).del(num_items)\n\
      \    }\n\n\
      \    pub fn edit(&mut self, userpos: usize) -> (Edit<C, impl \
       FnMut(&[C::Item], ItemMarker<C>)>, usize) {\n\
      \        // self.edit_notify(userpos, no_notify_x::<C>, f)\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert!(!N::notifications_used());\n\
      \        (Edit { list: self, cursor, notify: Self::no_notify }, \
       item_offset)\n\
      \    }\n\n\
      \    pub fn edit_between(&mut self, userpos: usize) -> Edit<C, impl \
       FnMut(&[C::Item], ItemMarker<C>)> {\n\
      \        // self.edit_notify(userpos, no_notify_x::<C>, f)\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \        Edit { list: self, cursor, notify: Self::no_notify }\n\
      \    }" );
    (56071, 1, "");
    (57483, 42, "");
    (57482, 1, "");
    (57628, 37, "");
    (57309, 37, "");
    (57591, 0, "(");
    (57309, 0, "(");
    (57593, 0, ")");
    (57310, 0, ")");
    (60257, 0, "=");
    (60258, 0, " ");
    (60258, 1, "");
    (60257, 1, "");
    (60257, 0, " ");
    (60258, 0, "=");
    (60259, 0, " ");
    (60260, 0, "(");
    (60261, 0, ")");
    (57591, 4, "");
    (57307, 4, "");
    (57848, 0, ")");
    (57833, 0, "(");
    (57503, 0, ")");
    (57488, 0, "(");
    (57836, 15, ")");
    (57489, 15, ")");
    (57823, 1, "");
    (57490, 1, "");
    (57820, 0, "&");
    (57488, 0, "&");
    (57822, 0, "m");
    (57489, 0, "m");
    (57824, 0, "u");
    (57490, 0, "u");
    (57826, 0, "t");
    (57491, 0, "t");
    (57828, 0, " ");
    (57492, 0, " ");
    (58387, 0, ",");
    (58388, 0, " ");
    (58389, 0, "N");
    (58390, 0, ":");
    (58391, 0, " ");
    (58392, 0, "N");
    (58393, 0, "o");
    (58394, 0, "t");
    (58395, 0, "i");
    (58396, 0, "f");
    (58392, 5, "NotificationTarget");
    (58410, 0, "<");
    (58411, 0, "C");
    (58412, 0, ">");
    (58434, 0, ",");
    (58435, 0, " ");
    (58436, 0, "C");
    (58436, 1, "");
    (58436, 0, "N");
    (57845, 32, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (57845, 46, "impl<C: ListConfig> SkipList<C> ");
    (57845, 20, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (57901, 0, ",");
    (57902, 0, " ");
    (57903, 0, "N");
    (57849, 41, "");
    (57862, 1, "");
    (57861, 1, "");
    (57860, 1, "");
    (57859, 1, "");
    (57859, 0, "C, N");
    (57849, 0, "<C: ListConfig, N: NotificationTarget<C>>");
    (57863, 26, "");
    (57877, 1, "");
    (57877, 0, "_");
    (57863, 0, ",");
    (57864, 0, " ");
    (57865, 0, "N");
    (57866, 0, ":");
    (57867, 0, " ");
    (57868, 0, "_");
    (57883, 1, "");
    (57883, 0, "N");
    (57883, 1, "");
    (57883, 0, "_");
    (57867, 2, "");
    (57864, 3, "");
    (57863, 1, "");
    (57877, 1, "");
    (57877, 0, "N");
    (57863, 0, ", N: NotificationTarget<C>");
    (58763, 23, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (58961, 20, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (58831, 0, ",");
    (58832, 0, " ");
    (58833, 0, "N");
    (59044, 0, ",");
    (59045, 0, " ");
    (59046, 0, "N");
    (59045, 2, "");
    (59044, 1, "");
    (58832, 2, "");
    (58831, 1, "");
    (58961, 46, "impl<C: ListConfig> ");
    (58763, 46, "impl<C: ListConfig, I> ");
    (58763, 23, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (58961, 20, "impl<C: ListConfig, N: NotificationTarget<C>> ");
    (58831, 0, ",");
    (58832, 0, " N");
    (59044, 0, ",");
    (59045, 0, " N");
    (58768, 0, "I");
    (58769, 0, ",");
    (58770, 0, " ");
    (58916, 0, ",");
    (58917, 0, " ");
    (58918, 0, "N");
    (60109, 0, ", N: NotificationTarget<C>");
    (60162, 0, ",");
    (60163, 0, " ");
    (60164, 0, "N");
    (56037, 0, "\n");
    (56038, 0, "/");
    (56039, 0, "/");
    (56040, 0, " ");
    (56041, 0, "T");
    (56042, 0, "h");
    (56043, 0, "e");
    (56044, 0, "s");
    (56045, 0, "e");
    (56046, 0, " ");
    (56047, 0, "m");
    (56048, 0, "e");
    (56049, 0, "t");
    (56050, 0, "h");
    (56051, 0, "o");
    (56052, 0, "d");
    (56053, 0, "s");
    (56054, 0, " ");
    (56055, 0, "a");
    (56056, 0, "r");
    (56057, 0, "e");
    (56058, 0, " ");
    (56059, 0, "o");
    (56060, 0, "n");
    (56061, 0, "l");
    (56062, 0, "y");
    (56063, 0, " ");
    (56064, 0, "a");
    (56065, 0, "v");
    (56066, 0, "a");
    (56067, 0, "i");
    (56068, 0, "l");
    (56069, 0, "a");
    (56070, 0, "b");
    (56071, 0, "l");
    (56072, 0, "e");
    (56073, 0, " ");
    (56074, 0, "i");
    (56075, 0, "f");
    (56076, 0, " ");
    (56077, 0, "t");
    (56078, 0, "h");
    (56079, 0, "e");
    (56080, 0, "r");
    (56081, 0, "e");
    (56082, 0, "'");
    (56083, 0, "s");
    (56084, 0, " ");
    (56085, 0, "n");
    (56086, 0, "o");
    (56087, 0, " ");
    (56088, 0, "n");
    (56089, 0, "o");
    (56090, 0, "t");
    (56091, 0, "i");
    (56092, 0, "f");
    (56093, 0, "i");
    (56094, 0, "c");
    (56095, 0, "a");
    (56096, 0, "t");
    (56097, 0, "i");
    (56098, 0, "o");
    (56099, 0, "n");
    (56100, 0, " ");
    (56101, 0, "t");
    (56102, 0, "a");
    (56103, 0, "r");
    (56104, 0, "g");
    (56105, 0, "e");
    (56106, 0, "t");
    (56107, 0, ".");
    (57654, 57, "");
    (57390, 57, "");
    (57596, 1, "");
    (57389, 1, "");
    (23633, 294, "");
    ( 23633,
      0,
      "\n\
      \    pub fn new_from_iter<I: ExactSizeIterator<Item=C::Item>>(iter: I) \
       -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, iter);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        Self::new_from_iter(s.iter().copied())\n\
      \    }\n" );
    (23712, 0, "w");
    (23713, 0, "h");
    (23714, 0, "e");
    (23715, 0, "r");
    (23716, 0, "e");
    (23717, 0, " ");
    (23718, 0, "N");
    (23719, 0, ":");
    (23720, 0, " ");
    (23721, 0, "(");
    (23722, 0, ")");
    (23723, 0, " ");
    (23719, 1, "");
    (23719, 0, " ");
    (23720, 0, "=");
    (23721, 0, "=");
    (23711, 14, "");
    (23634, 293, "");
    (55849, 0, "\n    ");
    ( 55854,
      0,
      "    pub fn new_from_iter<I: ExactSizeIterator<Item=C::Item>>(iter: I) \
       -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, iter);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        Self::new_from_iter(s.iter().copied())\n\
      \    }\n" );
    (55850, 8, "    ");
    (56143, 0, "\n    ");
    (56144, 4, "");
    (56143, 1, "");
    (58740, 26, "");
    (58766, 1, "");
    (58765, 1, "");
    (58764, 1, "");
    (58845, 1, "");
    (58844, 1, "");
    (58843, 1, "");
    (58718, 0, "\n");
    (58719, 0, "/");
    (58720, 0, "/");
    (58721, 0, " ");
    (58722, 0, "O");
    (58723, 0, "n");
    (58724, 0, "l");
    (58725, 0, "y");
    (58726, 0, " ");
    (58727, 0, "w");
    (58727, 1, "");
    (58727, 0, "i");
    (58728, 0, "f");
    (58729, 0, " ");
    (58730, 0, "t");
    (58731, 0, "h");
    (58732, 0, "e");
    (58733, 0, "r");
    (58734, 0, "e");
    (58735, 0, "'");
    (58736, 0, "s");
    (58737, 0, " ");
    (58738, 0, "n");
    (58739, 0, "o");
    (58740, 0, " ");
    (58741, 0, "n");
    (58742, 0, "o");
    (58743, 0, "t");
    (58744, 0, "i");
    (58745, 0, "f");
    (58746, 0, "i");
    (58747, 0, "c");
    (58748, 0, "a");
    (58749, 0, "t");
    (58750, 0, "i");
    (58751, 0, "o");
    (58752, 0, "n");
    (58753, 0, " ");
    (58754, 0, "t");
    (58755, 0, "a");
    (58756, 0, "r");
    (58757, 0, "g");
    (58758, 0, "e");
    (58759, 0, "t");
    (58760, 0, ".");
    (55743, 0, "\n");
    (55744, 0, "\n");
    (55745, 0, "s");
    (55746, 0, "t");
    (55747, 0, "a");
    (55748, 0, "t");
    (55749, 0, "i");
    (55750, 0, "c");
    (55751, 0, " ");
    (55752, 0, "m");
    (55753, 0, "u");
    (55754, 0, "t");
    (55755, 0, " ");
    (55756, 0, "T");
    (55757, 0, "A");
    (55758, 0, "R");
    (55759, 0, "G");
    (55760, 0, "E");
    (55761, 0, "T");
    (55762, 0, ":");
    (55763, 0, " ");
    (55764, 0, "(");
    (55765, 0, ")");
    (55765, 1, "");
    (55764, 1, "");
    (55763, 1, "");
    (55762, 1, "");
    (55762, 0, " ");
    (55763, 0, "=");
    (55764, 0, " ");
    (55765, 0, "(");
    (55766, 0, ")");
    (55767, 0, ";");
    (55756, 0, "N");
    (55757, 0, "_");
    (55764, 0, ":");
    (55765, 0, " ");
    (55766, 0, "(");
    (55767, 0, ")");
    (57539, 1, "");
    (57538, 1, "");
    (57538, 0, "N");
    (57539, 0, "_");
    (57540, 0, "T");
    (57541, 0, "A");
    (57542, 0, "R");
    (57543, 0, "G");
    (57544, 0, "E");
    (57545, 0, "T");
    (57533, 0, "u");
    (57534, 0, "n");
    (57535, 0, "s");
    (57536, 0, "a");
    (57537, 0, "f");
    (57538, 0, "e");
    (57539, 0, " ");
    (57540, 0, "{");
    (57541, 0, " ");
    (57555, 0, " ");
    (57556, 0, "}");
    (57829, 7, "unsafe { &mut N_TARGET }");
    (57844, 0, "ULL_NOTIFY");
    (57548, 0, "ULL_NOTIFY");
    (55757, 0, "ULL_NOTIFY");
    (2236, 0, "\n");
    (2237, 0, "\n");
    (2238, 0, "i");
    (2239, 0, "m");
    (2240, 0, "p");
    (2241, 0, "l");
    (2242, 0, " ");
    (2243, 0, "D");
    (2244, 0, "e");
    (2245, 0, "f");
    (2246, 0, "a");
    (2247, 0, "u");
    (2248, 0, "l");
    (2249, 0, "t");
    (2250, 0, " ");
    (2251, 0, "f");
    (2252, 0, "o");
    (2253, 0, "r");
    (2254, 0, " ");
    (2255, 0, "I");
    (2256, 0, "t");
    (2257, 0, "e");
    (2258, 0, "m");
    (2259, 0, "M");
    (2255, 5, "ItemMarker");
    (2242, 0, "<");
    (2243, 0, "C");
    (2244, 0, ">");
    (2268, 0, "<");
    (2269, 0, "C");
    (2270, 0, ">");
    (2271, 0, " ");
    (2272, 0, "{");
    (2273, 0, "\n    ");
    (2274, 4, "}");
    (2273, 0, "\n    ");
    (2278, 0, "f");
    (2279, 0, "n");
    (2280, 0, " ");
    (2281, 0, "d");
    (2282, 0, "e");
    (2283, 0, "f");
    (2281, 3, "default()");
    (2290, 0, " ");
    (2291, 0, "{");
    (2292, 0, " ");
    (2293, 0, "S");
    (2294, 0, "e");
    (2295, 0, "l");
    (2296, 0, "f");
    (2297, 0, ":");
    (2298, 0, ":");
    (2299, 0, "n");
    (2300, 0, "u");
    (2301, 0, "l");
    (2302, 0, "l");
    (2303, 0, "(");
    (2304, 0, ")");
    (2305, 0, " ");
    (2306, 0, "}");
    (2290, 0, " ");
    (2291, 0, "-");
    (2292, 0, ">");
    (2293, 0, " ");
    (2294, 0, "S");
    (2295, 0, "E");
    (2296, 0, "l");
    (2297, 0, "f");
    (2294, 4, "S");
    (2295, 0, "e");
    (2296, 0, "l");
    (2297, 0, "f");
    (2244, 0, ":");
    (2245, 0, " ");
    (2246, 0, "L");
    (2247, 0, "i");
    (2248, 0, "s");
    (2249, 0, "t");
    (2246, 4, "ListConfig");
    ( 55950,
      0,
      "impl<C: ListConfig> SkipList<C> {\n\
      \    pub fn new_from_iter<I: ExactSizeIterator<Item=C::Item>>(iter: I) \
       -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, iter);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn new_from_slice(s: &[C::Item]) -> Self where C::Item: Copy {\n\
      \        Self::new_from_iter(s.iter().copied())\n\
      \    }\n\n\
      \    pub fn replace_at<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       start_userpos: usize, removed_items: usize, inserted_content: I) {\n\
      \        self.edit_between(start_userpos).replace(removed_items, \
       inserted_content);\n\
      \    }\n\n\
      \    pub fn replace_at_slice(&mut self, start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \        self.replace_at(start_userpos, removed_items, \
       inserted_content.iter().copied());\n\
      \    }\n\n\
      \    pub fn modify_item_after<F: FnOnce(&mut C::Item, usize)>(&mut self, \
       userpos: usize, modify_fn: F) {\n\
      \        let (mut edit, offset) = self.edit(userpos);\n\
      \        edit.modify_current_item(|item| modify_fn(item, offset))\n\
      \    }\n\n\
      \    pub fn insert_at<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       userpos: usize, contents: I) {\n\
      \        let (mut edit, offset) = self.edit(userpos);\n\
      \        edit.insert_between_iter(offset, contents);\n\
      \    }\n\n\
      \    pub fn insert_at_slice(&mut self, userpos: usize, contents: \
       &[C::Item]) where C::Item: Copy {\n\
      \        self.insert_at(userpos, contents.iter().copied())\n\
      \    }\n\n\
      \    pub fn del_at(&mut self, userpos: usize, num_items: usize) {\n\
      \        self.edit_between(userpos).del(num_items)\n\
      \    }\n\n\
      \    pub fn edit(&mut self, userpos: usize) -> (Edit<C>, usize) {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify: unsafe { &mut \
       NULL_NOTIFY_TARGET } }, item_offset)\n\
      \    }\n\n\
      \    pub fn edit_between(&mut self, userpos: usize) -> Edit<C> {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \        Edit { list: self, cursor, notify: unsafe { &mut \
       NULL_NOTIFY_TARGET } }\n\
      \    }\n\
       }\n" );
    (58005, 0, ",");
    (58006, 0, " ");
    (58007, 0, "N");
    (58008, 0, ":");
    (58009, 0, " ");
    (58010, 0, "L");
    (58011, 0, "i");
    (58010, 2, "N");
    (58011, 0, "o");
    (58012, 0, "t");
    (58013, 0, "i");
    (58014, 0, "f");
    (58010, 5, "NotificationTarget");
    (58028, 0, "<");
    (58029, 0, "C");
    (58030, 0, ">");
    (58043, 0, ",");
    (58044, 0, " ");
    (58045, 0, "N");
    (58047, 0, " ");
    (58047, 1, "");
    (58074, 0, "_");
    (58075, 0, "n");
    (58246, 0, "_");
    (58247, 0, "n");
    (58120, 0, ",");
    (58121, 0, " ");
    (58122, 0, "&");
    (58123, 0, "m");
    (58124, 0, "u");
    (58125, 0, "t");
    (58126, 0, " ");
    (58127, 0, "n");
    (58127, 1, "");
    (58127, 0, "N");
    (58122, 0, "n");
    (58123, 0, "o");
    (58124, 0, "t");
    (58125, 0, "i");
    (58126, 0, "f");
    (58127, 0, "y");
    (58128, 0, ":");
    (58129, 0, " ");
    (58278, 0, ",");
    (58279, 0, " ");
    (58280, 0, "n");
    (58281, 0, "o");
    (58282, 0, "t");
    (58283, 0, "i");
    (58284, 0, "f");
    (58285, 0, "y");
    (58286, 0, ":");
    (58287, 0, " ");
    (58288, 0, "&");
    (58289, 0, "m");
    (58290, 0, "u");
    (58291, 0, "t");
    (58292, 0, " ");
    (58293, 0, "n");
    (58293, 1, "");
    (58293, 0, "N");
    (58353, 0, "_");
    (58354, 0, "n");
    (58373, 0, ",");
    (58374, 0, " ");
    (58375, 0, "n");
    (58376, 0, "o");
    (58377, 0, "t");
    (58378, 0, "i");
    (58379, 0, "f");
    (58380, 0, "y");
    (59467, 0, "_");
    (59313, 0, "_");
    (59096, 0, "_");
    (58875, 0, "_");
    (58643, 0, "_");
    (58411, 0, "_");
    (59473, 0, "n");
    (59318, 0, "n");
    (59100, 0, "n");
    (58878, 0, "n");
    (58645, 0, "n");
    (58412, 0, "n");
    (60107, 0, "// ");
    (60027, 0, "// ");
    (59953, 0, "// ");
    (59886, 0, "// ");
    (59822, 0, "// ");
    (59815, 0, "// ");
    (59720, 0, "// ");
    (59653, 0, "// ");
    (59588, 0, "// ");
    (59581, 0, "// ");
    (59531, 0, "// ");
    (59464, 0, "// ");
    (59457, 0, "// ");
    (59399, 0, "// ");
    (59299, 0, "// ");
    (59292, 0, "// ");
    (59240, 0, "// ");
    (59187, 0, "// ");
    (59086, 0, "// ");
    (59079, 0, "// ");
    (59014, 0, "// ");
    (58961, 0, "// ");
    (58855, 0, "// ");
    (58848, 0, "// ");
    (58759, 0, "// ");
    (58622, 0, "// ");
    (59322, 3, "");
    (59267, 3, "");
    (59211, 3, "");
    (59107, 3, "");
    (59200, 0, ",");
    (59201, 0, " ");
    (59202, 0, "N");
    (59202, 1, "");
    (59202, 0, "n");
    (59203, 0, "o");
    (59204, 0, "t");
    (59205, 0, "i");
    (59206, 0, "f");
    (59207, 0, "y");
    (59208, 0, ":");
    (59209, 0, " ");
    (59210, 0, "&");
    (59211, 0, "m");
    (59212, 0, "u");
    (59213, 0, "t");
    (59214, 0, " ");
    (59215, 0, "N");
    (54280, 5, "");
    (54262, 292, "");
    (54263, 267, "");
    (54262, 1, "");
    (57421, 0, "\n");
    (59626, 0, "\n    ");
    ( 59631,
      0,
      "\n\
      \    pub fn edit_n<'a>(&'a mut self, userpos: usize, notify_target: &'a \
       mut N) -> (Edit<C, N>, usize) {\n\
      \        assert!(N::notifications_used());\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify: notify_target }, item_offset)\n\
      \    }" );
    (59627, 4, "");
    (58698, 0, "_");
    (58699, 0, "n");
    (58708, 0, ",");
    (58709, 0, " ");
    (58710, 0, "n");
    (58711, 0, "o");
    (58712, 0, "t");
    (58713, 0, "i");
    (58714, 0, "f");
    (58715, 0, "y");
    (59084, 245, "");
    (59083, 1, "");
    (59391, 292, "");
    (57824, 0, "\n    ");
    ( 57829,
      0,
      "\n\
      \    pub fn edit_n<'a>(&'a mut self, userpos: usize, notify_target: &'a \
       mut N) -> (Edit<C, N>, usize) {\n\
      \        assert!(N::notifications_used());\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify: notify_target }, item_offset)\n\
      \    }" );
    (57825, 4, "");
    (56893, 526, "");
    ( 55711,
      0,
      "\n\n\
      \    pub fn edit(&mut self, userpos: usize) -> (Edit<C>, usize) {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify: unsafe { &mut \
       NULL_NOTIFY_TARGET } }, item_offset)\n\
      \    }\n\n\
      \    pub fn edit_between(&mut self, userpos: usize) -> Edit<C> {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \        Edit { list: self, cursor, notify: unsafe { &mut \
       NULL_NOTIFY_TARGET } }\n\
      \    }" );
    (59376, 307, "");
    ( 58117,
      0,
      "\n\n\
      \    // pub fn edit_between(&mut self, userpos: usize) -> Edit<C> {\n\
      \    //     let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \    //     assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \    //     Edit { list: self, cursor, notify: unsafe { &mut \
       NULL_NOTIFY_TARGET } }\n\
      \    // }" );
    (58420, 3, "");
    (58337, 3, "");
    (58260, 3, "");
    (58190, 3, "");
    (58123, 3, "");
    (58142, 0, "_");
    (58143, 0, "n");
    (58170, 0, ",");
    (58171, 0, " ");
    (58172, 0, "n");
    (58173, 0, "o");
    (58174, 0, "t");
    (58175, 0, "i");
    (58176, 0, "f");
    (58177, 0, "y");
    (58178, 0, ":");
    (58179, 0, " ");
    (58180, 0, "&");
    (58181, 0, "m");
    (58182, 0, "u");
    (58183, 0, "t");
    (58184, 0, " ");
    (58185, 0, "N");
    (58383, 36, "");
    (58080, 15, "");
    (57890, 1, "");
    (57889, 1, "");
    (57888, 1, "");
    (57887, 1, "");
    (57886, 1, "");
    (57885, 1, "");
    (57884, 1, "");
    (57884, 0, "_target");
    (57884, 7, "");
    (58175, 0, ",");
    (58176, 0, " ");
    (58177, 0, "N");
    (58159, 0, "'");
    (58160, 0, " ");
    (58160, 1, "");
    (58160, 0, "a");
    (58161, 0, " ");
    (58122, 0, "<");
    (58123, 0, "'");
    (58124, 0, "a");
    (58125, 0, ">");
    (58128, 0, "'");
    (58129, 0, "a");
    (58130, 0, " ");
    (58547, 0, "_");
    (58548, 0, "n");
    (58563, 0, ",");
    (58564, 0, " ");
    (58565, 0, "n");
    (58566, 0, "o");
    (58567, 0, "t");
    (58568, 0, "i");
    (58569, 0, "f");
    (58570, 0, "y");
    (58518, 0, ",");
    (58519, 0, " ");
    (58520, 0, "n");
    (58521, 0, "o");
    (58522, 0, "t");
    (58523, 0, "i");
    (58524, 0, "f");
    (58525, 0, "y");
    (58526, 0, ":");
    (58527, 0, " ");
    (58528, 0, "&");
    (58529, 0, "m");
    (58530, 0, "u");
    (58531, 0, "t");
    (58532, 0, " ");
    (58533, 0, "N");
    (59530, 3, "");
    (59469, 3, "");
    (59366, 3, "");
    (59438, 0, ",");
    (59439, 0, " ");
    (59440, 0, "n");
    (59441, 0, "o");
    (59442, 0, "t");
    (59443, 0, "i");
    (59444, 0, "f");
    (59445, 0, "y");
    (59446, 0, "&");
    (59446, 1, "");
    (59446, 0, ":");
    (59447, 0, " ");
    (59448, 0, "&");
    (59449, 0, "n");
    (59449, 1, "");
    (59449, 0, "m");
    (59450, 0, "u");
    (59451, 0, "t");
    (59452, 0, " ");
    (59453, 0, "N");
    (59500, 0, "_");
    (59501, 0, "n");
    (59536, 0, ",");
    (59537, 0, " ");
    (59538, 0, "n");
    (59539, 0, "o");
    (59540, 0, "t");
    (59541, 0, "i");
    (59542, 0, "f");
    (59543, 0, "y");
    (57486, 2199, "");
    (55269, 0, "\n    ");
    (55274, 0, "\n    ");
    (55270, 4, "");
    (55275, 0, "\n    ");
    (55271, 4, "");
    (55276, 0, "\n    ");
    (55272, 4, "");
    ( 55277,
      0,
      "    pub fn new_from_iter_n<I: ExactSizeIterator<Item=C::Item>>(iter: I, \
       notify: &mut N) -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at(0, iter);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn new_from_slice_n(s: &[C::Item], notify: &mut N) -> Self \
       where C::Item: Copy {\n\
      \        Self::new_from_iter_n(s.iter().copied(), notify)\n\
      \    }\n\n\
      \    pub fn edit_n<'a>(&'a mut self, userpos: usize, notify: &'a mut N) \
       -> (Edit<C, N>, usize) {\n\
      \        assert!(N::notifications_used());\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify }, item_offset)\n\
      \    }\n\n\
      \    pub fn edit_between_n<'a>(&'a mut self, userpos: usize, notify: &'a \
       mut N) -> Edit<C, N> {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \        Edit { list: self, cursor, notify }\n\
      \    }\n\n\
      \    pub fn replace_at_n<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       start_userpos: usize, removed_items: usize, inserted_content: I, \
       notify: &mut N) {\n\
      \        self.edit_between_n(start_userpos, \
       notify).replace(removed_items, inserted_content);\n\
      \    }\n\n\
      \    // pub fn replace_at_slice_n(&mut self, start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \    //     self.replace_at(start_userpos, removed_items, \
       inserted_content.iter().copied());\n\
      \    // }\n\n\
      \    // pub fn modify_item_after_n<F: FnOnce(&mut C::Item, usize)>(&mut \
       self, userpos: usize, modify_fn: F) {\n\
      \    //     let (mut edit, offset) = self.edit(userpos);\n\
      \    //     edit.modify_current_item(|item| modify_fn(item, offset))\n\
      \    // }\n\n\
      \    pub fn insert_at_n<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       userpos: usize, contents: I, notify: &mut N) {\n\
      \        let (mut edit, offset) = self.edit_n(userpos, notify);\n\
      \        edit.insert_between_iter(offset, contents);\n\
      \    }\n\n\
      \    pub fn insert_at_slice_n(&mut self, userpos: usize, contents: \
       &[C::Item], notify: &mut N) where C::Item: Copy {\n\
      \        self.insert_at_n(userpos, contents.iter().copied(), notify)\n\
      \    }\n\n\
      \    // pub fn del_at_n(&mut self, userpos: usize, num_items: usize) {\n\
      \    //     self.edit_between(userpos).del(num_items)\n\
      \    // }\n" );
    (55273, 8, "    ");
    (55429, 0, "_");
    (55430, 0, "n");
    (55439, 0, ",");
    (55440, 0, " ");
    (55441, 0, "n");
    (55442, 0, "o");
    (55443, 0, "t");
    (55444, 0, "i");
    (55445, 0, "f");
    (55446, 0, "y");
    (55272, 2210, "");
    (55271, 1, "");
    (55270, 1, "");
    (55269, 1, "");
    ( 57486,
      0,
      "\n\
      \    pub fn new_from_iter_n<I: ExactSizeIterator<Item=C::Item>>(iter: I, \
       notify: &mut N) -> Self {\n\
      \        let mut rope = Self::new();\n\
      \        rope.insert_at_n(0, iter, notify);\n\
      \        rope\n\
      \    }\n\n\
      \    pub fn new_from_slice_n(s: &[C::Item], notify: &mut N) -> Self \
       where C::Item: Copy {\n\
      \        Self::new_from_iter_n(s.iter().copied(), notify)\n\
      \    }\n\n\
      \    pub fn edit_n<'a>(&'a mut self, userpos: usize, notify: &'a mut N) \
       -> (Edit<C, N>, usize) {\n\
      \        assert!(N::notifications_used());\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        (Edit { list: self, cursor, notify }, item_offset)\n\
      \    }\n\n\
      \    pub fn edit_between_n<'a>(&'a mut self, userpos: usize, notify: &'a \
       mut N) -> Edit<C, N> {\n\
      \        let (cursor, item_offset) = self.iter_at_userpos(userpos);\n\
      \        assert_eq!(item_offset, 0, \"edit_between landed inside an \
       item\");\n\
      \        Edit { list: self, cursor, notify }\n\
      \    }\n\n\
      \    pub fn replace_at_n<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       start_userpos: usize, removed_items: usize, inserted_content: I, \
       notify: &mut N) {\n\
      \        self.edit_between_n(start_userpos, \
       notify).replace(removed_items, inserted_content);\n\
      \    }\n\n\
      \    // pub fn replace_at_slice_n(&mut self, start_userpos: usize, \
       removed_items: usize, inserted_content: &[C::Item]) where C::Item: Copy \
       {\n\
      \    //     self.replace_at(start_userpos, removed_items, \
       inserted_content.iter().copied());\n\
      \    // }\n\n\
      \    // pub fn modify_item_after_n<F: FnOnce(&mut C::Item, usize)>(&mut \
       self, userpos: usize, modify_fn: F) {\n\
      \    //     let (mut edit, offset) = self.edit(userpos);\n\
      \    //     edit.modify_current_item(|item| modify_fn(item, offset))\n\
      \    // }\n\n\
      \    pub fn insert_at_n<I: ExactSizeIterator<Item=C::Item>>(&mut self, \
       userpos: usize, contents: I, notify: &mut N) {\n\
      \        let (mut edit, offset) = self.edit_n(userpos, notify);\n\
      \        edit.insert_between_iter(offset, contents);\n\
      \    }\n\n\
      \    pub fn insert_at_slice_n(&mut self, userpos: usize, contents: \
       &[C::Item], notify: &mut N) where C::Item: Copy {\n\
      \        self.insert_at_n(userpos, contents.iter().copied(), notify)\n\
      \    }\n\n\
      \    // pub fn del_at_n(&mut self, userpos: usize, num_items: usize) {\n\
      \    //     self.edit_between(userpos).del(num_items)\n\
      \    // }\n" );
    (1764, 0, "\n");
    (1765, 0, "#");
    (1766, 0, "[");
    (1767, 0, "d");
    (1768, 0, "e");
    (1769, 0, "r");
    (1770, 0, "i");
    (1771, 0, "v");
    (1772, 0, "e");
    (1773, 0, "(");
    (1774, 0, "P");
    (1775, 0, "a");
    (1776, 0, "r");
    (1777, 0, "t");
    (1778, 0, "i");
    (1774, 5, "PartialEq");
    (1783, 0, ")");
    (1783, 0, ",");
    (1784, 0, " ");
    (1785, 0, "E");
    (1786, 0, "q");
    (1788, 0, "]");
    (1765, 24, "");
    (1764, 1, "");
    (2041, 0, "\n");
    (2042, 0, "i");
    (2043, 0, "m");
    (2044, 0, "p");
    (2045, 0, "l");
    (2046, 0, " ");
    (2042, 5, "");
    (2041, 1, "");
    (1996, 0, "impl<C: ListConfig> Copy for ItemMarker<C> {}\n");
    (2062, 4, "P");
    (2063, 0, "a");
    (2064, 0, "r");
    (2065, 0, "t");
    (2066, 0, "i");
    (2067, 0, "a");
    (2062, 6, "PartialEq");
    (2091, 0, "\n    \n");
    (2096, 0, "fn eq(&self, other: &Rhs) -> bool;");
    (2117, 3, "S");
    (2118, 0, "e");
    (2119, 0, "l");
    (2120, 0, "f");
    (2126, 4, "");
    (2126, 0, "{");
    (2127, 0, "}");
    (2127, 0, " ");
    (2128, 0, "s");
    (2129, 0, "e");
    (2130, 0, "l");
    (2131, 0, "f");
    (2132, 0, ".");
    (2133, 0, "p");
    (2134, 0, "t");
    (2135, 0, "r");
    (2136, 0, " ");
    (2137, 0, "=");
    (2138, 0, "=");
    (2139, 0, " ");
    (2140, 0, "o");
    (2141, 0, "t");
    (2142, 0, "h");
    (2143, 0, "e");
    (2144, 0, "r");
    (2145, 0, ".");
    (2146, 0, "p");
    (2147, 0, "t");
    (2148, 0, "r");
    (2149, 0, " ");
    (2151, 1, "");
    (2125, 0, " ");
    (2126, 0, "b");
    (2127, 0, "o");
    (2128, 0, "o");
    (2129, 0, "l");
    (2042, 0, "impl<C: ListConfig> PartialEq for ItemMarker<C> {\n");
    (2141, 65, "");
    (2092, 0, "    ");
    ( 2092,
      0,
      "    fn eq(&self, other: &Self) -> bool { self.ptr == other.ptr }\n" );
    (2210, 2, "");
    (2157, 4, "        ");
    (2157, 0, "}\n");
    (2159, 8, "    ");
    (2159, 4, "");
    (2179, 9, "E");
    (2180, 0, "q");
    (2201, 0, "}");
    (62348, 5104, "");
    (55474, 4385, "");
    (55433, 41, "");
    (51128, 0, "[");
    (51129, 0, "i");
    (51130, 0, "b");
    (51130, 1, "");
    (51129, 1, "");
    (51128, 1, "");
    (51128, 0, "[");
    (51129, 0, "u");
    (51130, 0, "b");
    (51130, 1, "");
    (51129, 1, "");
    (51128, 1, "");
    (51128, 0, "p");
    (51129, 0, "u");
    (51130, 0, "b");
    (51131, 0, ")");
    (51132, 0, "c");
    (51133, 0, "r");
    (51133, 1, "");
    (51132, 1, "");
    (51131, 1, "");
    (51131, 0, "(");
    (51132, 0, "c");
    (51133, 0, "r");
    (51134, 0, "a");
    (51135, 0, "t");
    (51136, 0, "e");
    (51137, 0, ")");
    (51138, 0, " ");
    (45930, 0, "pub(crate) ");
    (38842, 0, "pub(crate) ");
    (38838, 4, "        ");
    (38838, 8, "    ");
    (29645, 0, "pub(crate) ");
    (16747, 0, "pub(crate) ");
    (16751, 5, "s");
    (16752, 0, "e");
    (16753, 0, "l");
    (16754, 0, "f");
    (16751, 4, "crate");
    (16751, 5, "s");
    (16752, 0, "u");
    (16753, 0, "p");
    (16754, 0, "e");
    (16755, 0, "r");
    (16881, 0, "pub(super) ");
    (16374, 0, "pub(super) ");
    (16251, 0, "pub(super) ");
    (51213, 1, "");
    (46004, 1, "");
    (38905, 1, "");
    (29697, 1, "");
    (51209, 1, "");
    (46001, 1, "");
    (38903, 1, "");
    (29696, 1, "");
    (51205, 1, "");
    (45998, 1, "");
    (38901, 1, "");
    (29695, 1, "");
    (51201, 1, "");
    (45995, 1, "");
    (38899, 1, "");
    (29694, 1, "");
    (51197, 1, "");
    (45992, 1, "");
    (38897, 1, "");
    (29693, 1, "");
    (51194, 0, "s");
    (45990, 0, "s");
    (38896, 0, "s");
    (29693, 0, "s");
    (51198, 0, "u");
    (45993, 0, "u");
    (38898, 0, "u");
    (29694, 0, "u");
    (51202, 0, "p");
    (45996, 0, "p");
    (38900, 0, "p");
    (29695, 0, "p");
    (51206, 0, "e");
    (45999, 0, "e");
    (38902, 0, "e");
    (29696, 0, "e");
    (51210, 0, "r");
    (46002, 0, "r");
    (38904, 0, "r");
    (29697, 0, "r");
    (16832, 1, "");
    (16832, 0, "s");
    (16833, 0, "i");
    (16834, 0, "z");
    (16835, 0, "e");
    (24375, 0, "p");
    (24376, 0, "u");
    (24377, 0, "b");
    (24378, 0, "(");
    (24379, 0, "s");
    (24380, 0, "u");
    (24381, 0, "p");
    (24382, 0, "e");
    (24383, 0, "r");
    (24384, 0, ")");
    (24385, 0, " ");
    (16431, 2, "u");
    (16432, 0, "s");
    (16433, 0, "z");
    (16434, 0, "i");
    (16434, 1, "");
    (16433, 1, "");
    (16433, 0, "i");
    (16434, 0, "z");
    (16435, 0, "e");
    (16628, 9, "");
    (13593, 0, "pub(super) ");
    (13593, 11, "");
    (13590, 3, "pub(super) ");
    (13600, 1, "");
    (13594, 5, "c");
    (13595, 0, "r");
    (13596, 0, "e");
    (13597, 0, "a");
    (13598, 0, "t");
    (13599, 0, "e");
    (13599, 1, "");
    (13598, 1, "");
    (13597, 1, "");
    (13596, 1, "");
    (13596, 0, "a");
    (13597, 0, "t");
    (13598, 0, "e");
    (14034, 0, "pub(super) ");
    (14283, 0, "pub(super) ");
    (14319, 0, "pub(super) ");
    (18277, 0, "pub(super) ");
    (18693, 0, "pub(super) ");
    (19190, 0, "pub(super) ");
    (17996, 0, "pub(super) ");
    (17573, 0, "pub(super) ");
    (17170, 0, "pub(super) ");
    (16992, 2, "u");
    (16993, 0, "s");
    (16994, 0, "i");
    (16995, 0, "z");
    (16996, 0, "e");
    (17064, 9, "");
    (54204, 0, "pub(super) ");
    (14686, 0, "pub(super) ");
    (8662, 0, "pub(super) ");
    (8745, 0, "pub(super) ");
    (5888, 0, "pub(super) ");
    (3703, 0, "_");
    (3723, 0, "_");
    (33936, 4, "");
    (33936, 0, "pub(super) ");
    (4065, 0, "pub(super) ");
    (1808, 0, "pub(super) ");
    (31206, 4, "");
    (31205, 1, "");
    (31205, 0, " ");
    (31206, 0, "l");
    (31207, 0, "i");
    (31208, 0, "s");
    (31209, 0, "t");
    (31206, 0, "s");
    (31207, 0, "k");
    (31208, 0, "i");
    (31206, 3, "");
    (31206, 5, "");
    (59430, 4, "l");
    (58657, 4, "l");
    (58649, 4, "l");
    (59425, 0, "i");
    (58655, 0, "i");
    (58650, 0, "i");
    (59428, 0, "s");
    (58657, 0, "s");
    (58651, 0, "s");
    (59431, 0, "t");
    (58659, 0, "t");
    (58652, 0, "t");
    (582, 178, "");
    (1144, 4, "L");
    (1145, 0, "i");
    (1146, 0, "s");
    (1147, 0, "t");
    (54562, 0, "(");
    (54563, 0, "c");
    (54564, 0, "r");
    (54565, 0, "a");
    (54566, 0, "t");
    (54567, 0, "e");
    (54568, 0, ")");
    (54523, 32, "");
    (54522, 1, "");
    (54530, 5, "s");
    (54531, 0, "u");
    (54532, 0, "p");
    (54533, 0, "e");
    (54534, 0, "r");
    (54530, 5, "d");
    (54531, 0, "i");
    (54531, 1, "");
    (54530, 1, "");
    (54530, 0, "p");
    (54531, 0, "a");
    (54532, 0, "t");
    (54533, 0, "h");
    (54530, 4, "");
    (54530, 0, "\"");
    (54531, 0, ".");
    (54532, 0, ".");
    (54533, 0, "\"");
    (54526, 10, "");
    (54526, 0, "p");
    (54527, 0, "u");
    (54528, 0, "b");
    (54529, 0, "(");
    (54530, 0, "s");
    (54531, 0, "u");
    (54532, 0, "p");
    (54533, 0, "e");
    (54534, 0, "r");
    (54535, 0, ")");
    (54536, 0, " ");
    (54530, 5, "i");
    (54531, 0, "n");
    (54532, 0, " ");
    (54533, 0, "\"");
    (54534, 0, ".");
    (54535, 0, ".");
    (54536, 0, "\"");
    (54533, 4, "s");
    (54534, 0, "u");
    (54535, 0, "p");
    (54536, 0, "e");
    (54537, 0, "r");
    (54533, 5, "s");
    (54534, 0, "e");
    (54535, 0, "l");
    (54536, 0, "f");
    (54529, 9, "");
    (54529, 0, "(");
    (54529, 1, "");
    (54521, 0, "\n    ");
    (54526, 0, "/");
    (54527, 0, "/");
    (54528, 0, " ");
    (54529, 0, "T");
    (54530, 0, "O");
    (54531, 0, "D");
    (54532, 0, "O");
    (54533, 0, ":");
    (54534, 0, " ");
    (54535, 0, "D");
    (54536, 0, "o");
    (54537, 0, " ");
    (54538, 0, "n");
    (54539, 0, "o");
    (54540, 0, "t");
    (54541, 0, " ");
    (54542, 0, "e");
    (54543, 0, "x");
    (54544, 0, "p");
    (54545, 0, "o");
    (54546, 0, "e");
    (54547, 0, "t");
    (54548, 0, " ");
    (54548, 1, "");
    (54547, 1, "");
    (54546, 1, "");
    (54546, 0, "r");
    (54547, 0, "t");
    (54548, 0, " ");
    (54549, 0, "t");
    (54550, 0, "h");
    (54551, 0, "i");
    (54552, 0, "s");
    (54553, 0, ".");
    (54554, 0, " ");
    (54554, 1, "");
    (54535, 0, "T");
    (54536, 0, "h");
    (54537, 0, "i");
    (54538, 0, "s");
    (54539, 0, " ");
    (54540, 0, "i");
    (54541, 0, "s");
    (54542, 0, " ");
    (54543, 0, "j");
    (54544, 0, "s");
    (54545, 0, "u");
    (54546, 0, "t");
    (54547, 0, " ");
    (54548, 0, "f");
    (54549, 0, "o");
    (54550, 0, "r");
    (54551, 0, " ");
    (54552, 0, "d");
    (54553, 0, "e");
    (54543, 11, "j");
    (54544, 0, "u");
    (54545, 0, "s");
    (54546, 0, "t");
    (54547, 0, " ");
    (54548, 0, "f");
    (54549, 0, "o");
    (54550, 0, "r");
    (54551, 0, " ");
    (54552, 0, "d");
    (54553, 0, "e");
    (54554, 0, "b");
    (54555, 0, "u");
    (54556, 0, "g");
    (54557, 0, "g");
    (54558, 0, "i");
    (54559, 0, "n");
    (54560, 0, "g");
    (54561, 0, ".");
    (54562, 0, " ");
    (32164, 0, "\n        ");
    (32173, 0, "a");
    (32174, 0, "s");
    (32175, 0, "s");
    (32176, 0, "e");
    (32177, 0, "r");
    (32178, 0, "t");
    (32179, 0, "!");
    (32180, 0, "(");
    (32181, 0, "N");
    (32182, 0, ":");
    (32183, 0, ":");
    (32184, 0, "notifications_used()");
    (32204, 0, ",");
    (32205, 0, " ");
    (32206, 0, "\"");
    (32207, 0, "C");
    (32208, 0, "a");
    (32209, 0, "n");
    (32210, 0, "n");
    (32211, 0, "o");
    (32212, 0, "t");
    (32207, 6, "i");
    (32208, 0, "t");
    (32209, 0, "e");
    (32210, 0, "r");
    (32211, 0, "_");
    (32212, 0, "a");
    (32213, 0, "t");
    (32214, 0, "_");
    (32215, 0, "n");
    (32216, 0, "o");
    (32217, 0, "d");
    (32218, 0, "e");
    (32219, 0, " ");
    (32220, 0, "n");
    (32221, 0, "o");
    (32222, 0, "t");
    (32223, 0, " ");
    (32224, 0, "a");
    (32225, 0, "v");
    (32226, 0, "a");
    (32227, 0, "i");
    (32228, 0, "l");
    (32229, 0, "a");
    (32230, 0, "b");
    (32231, 0, "l");
    (32232, 0, "e");
    (32233, 0, " ");
    (32234, 0, "i");
    (32235, 0, "f");
    (32236, 0, " ");
    (32237, 0, "n");
    (32238, 0, "o");
    (32239, 0, "t");
    (32240, 0, "i");
    (32241, 0, "f");
    (32242, 0, "i");
    (32243, 0, "c");
    (32244, 0, "a");
    (32245, 0, "t");
    (32246, 0, "i");
    (32247, 0, "o");
    (32248, 0, "n");
    (32249, 0, "s");
    (32250, 0, " ");
    (32251, 0, "a");
    (32252, 0, "r");
    (32253, 0, "e");
    (32254, 0, " ");
    (32255, 0, "d");
    (32256, 0, "i");
    (32257, 0, "s");
    (32258, 0, "a");
    (32259, 0, "b");
    (32260, 0, "l");
    (32261, 0, "e");
    (32262, 0, "d");
    (32263, 0, "\"");
    (32264, 0, ")");
    (32265, 0, ";");
    (32266, 0, "\n        ");
    (38129, 0, "\n        ");
    (32267, 8, "");
    (38130, 0, "i");
    (38131, 0, "f");
    (38132, 0, " ");
    (38133, 0, "N");
    (38134, 0, ":");
    (38135, 0, ":");
    (38136, 0, "notifications_used()");
    (38156, 0, " ");
    (38157, 0, "{");
    (38572, 8, "            ");
    (38558, 12, "                ");
    (38477, 16, "                    ");
    (38433, 16, "                    ");
    (38416, 16, "                    ");
    (38345, 16, "                    ");
    (38289, 16, "                    ");
    (38270, 12, "                ");
    (38232, 12, "                ");
    (38194, 12, "                ");
    (38159, 8, "            ");
    (38625, 0, "\n            ");
    (38626, 12, "        }");
    (49367, 0, "\n                ");
    (49367, 17, "");
    (38626, 9, "            ");
    (38625, 13, "");
    (38612, 12, "        ");
    (38594, 16, "            ");
    (38509, 20, "                ");
    (38461, 20, "                ");
    (38440, 20, "                ");
    (38365, 20, "                ");
    (38305, 20, "                ");
    (38282, 16, "            ");
    (38240, 16, "            ");
    (38198, 16, "            ");
    (38159, 12, "        ");
    (38133, 23, "");
    (38122, 13, "");
    (38121, 1, "");
    (38132, 0, " ");
    (38133, 0, "N::notifications_used()");
    (38156, 0, " ");
    (38157, 0, "&");
    (38158, 0, "&");
    (49322, 0, " ");
    (49323, 0, "N::notifications_used()");
    (49346, 0, " ");
    (49347, 0, "&");
    (49348, 0, "&");
    (33899, 4, "c");
    (33900, 0, "u");
    (33901, 0, "r");
    (33902, 0, "s");
    (33903, 0, "o");
    (33904, 0, "r");
    (32075, 1, "");
    (32074, 1, "");
    (32073, 1, "");
    (32072, 1, "");
    (32072, 0, "c");
    (32073, 0, "u");
    (32074, 0, "r");
    (32075, 0, "s");
    (32076, 0, "o");
    (32077, 0, "r");
    (28226, 4, "c");
    (28227, 0, "u");
    (28228, 0, "r");
    (28229, 0, "s");
    (28230, 0, "o");
    (28231, 0, "r");
    (34637, 1, "");
    (34636, 1, "");
    (34635, 1, "");
    (34634, 1, "");
    (34634, 0, "c");
    (34635, 0, "u");
    (34636, 0, "r");
    (34637, 0, "s");
    (34638, 0, "o");
    (34639, 0, "r");
    (29703, 3, "curso");
    (27769, 3, "curso");
    (27847, 0, "\n                ");
    (27864, 0, "a");
    (27865, 0, "s");
    (27866, 0, "s");
    (27867, 0, "e");
    (27868, 0, "r");
    (27864, 5, "assert_eq!");
    (27874, 0, "(");
    (27875, 0, "n");
    (27876, 0, "o");
    (27877, 0, "r");
    (27878, 0, "m");
    (27879, 0, "a");
    (27875, 5, "normal_iter");
    (27886, 0, ".");
    (27887, 0, "u");
    (27888, 0, "s");
    (27889, 0, "e");
    (27890, 0, "p");
    (27891, 0, "o");
    (27891, 1, "");
    (27890, 1, "");
    (27890, 0, "r");
    (27891, 0, "p");
    (27892, 0, "o");
    (27893, 0, "s");
    (27894, 0, ",");
    (27895, 0, " ");
    (27896, 0, "n");
    (27897, 0, "u");
    (27898, 0, "m");
    (27899, 0, "_");
    (27900, 0, "u");
    (27896, 5, "num_usercount");
    (27909, 0, ")");
    (27910, 0, ";");
    ( 27911,
      0,
      "\n                assert_eq!(normal_iter.userpos, num_usercount);" );
    (27911, 64, "");
    (28041, 0, "\n                ");
    (28058, 0, "i");
    (28059, 0, "f");
    (28060, 0, " ");
    (28061, 0, "p");
    (28061, 1, "");
    (28061, 0, "N");
    (28062, 0, ":");
    (28063, 0, ":");
    (28064, 0, "notifications_used()");
    (28084, 0, " ");
    (28085, 0, "{");
    (28397, 16, "                    ");
    (28291, 16, "                    ");
    (28227, 16, "                    ");
    (28209, 16, "                    ");
    (28161, 20, "                        ");
    (28087, 16, "                    ");
    (28472, 0, "\n                    ");
    (28473, 20, "                }");
    (26687, 247, "");
    (26341, 0, "\n                ");
    (26358, 0, "i");
    (26359, 0, "f");
    (26360, 0, " ");
    (26361, 0, "N");
    (26362, 0, ":");
    (26363, 0, ":");
    (26364, 0, "notifications_used()");
    (26384, 0, " ");
    (26385, 0, "{");
    (26733, 16, "                    ");
    (26713, 16, "                    ");
    (26669, 20, "                        ");
    (26644, 16, "                    ");
    (26562, 20, "                        ");
    (26505, 16, "                    ");
    (26444, 20, "                        ");
    (26387, 16, "                    ");
    (26847, 0, "\n                    ");
    (26848, 20, "                }");
    (38144, 0, "            if cfg!(debug_assertions) {\n");
    (38184, 0, "            ");
    (38182, 1, "");
    (38181, 1, "");
    (38159, 22, "");
    (38158, 1, "");
    (38157, 1, "");
    (38144, 13, "");
    (38144, 0, "cfg!(debug_assertions)");
    ( 38133,
      95,
      "        if cfg!(debug_assertions) N::notifications_used() && \
       new_height_usize > 1 {" );
    (38166, 0, " ");
    (38167, 0, "|");
    (38168, 0, "|");
    (38144, 0, "(");
    (38194, 0, ")");
    (38221, 1, "");
    (38144, 51, "");
    (38144, 0, "s");
    (38145, 0, "e");
    (38146, 0, "l");
    (38147, 0, "f");
    (38148, 0, ".");
    (38149, 0, "s");
    (38150, 0, "t");
    (38151, 0, "o");
    (38152, 0, "r");
    (38153, 0, "e");
    (38153, 1, "");
    (38152, 1, "");
    (38151, 1, "");
    (38150, 1, "");
    (38149, 1, "");
    (38149, 0, "u");
    (38150, 0, "s");
    (38151, 0, "e");
    (38152, 0, "_");
    (38153, 0, "p");
    (38154, 0, "a");
    (38155, 0, "r");
    (38156, 0, "e");
    (38157, 0, "n");
    (38158, 0, "t");
    (38159, 0, "s");
    (38160, 0, "(");
    (38161, 0, ")");
    (24736, 0, "\n    ");
    (24741, 0, "\n    ");
    (24737, 4, "");
    (24742, 0, "#");
    (24743, 0, "[");
    (24744, 0, "i");
    (24745, 0, "n");
    (24746, 0, "l");
    (24747, 0, "i");
    (24748, 0, "n");
    (24749, 0, "e");
    (24750, 0, "(");
    (24751, 0, "a");
    (24752, 0, "l");
    (24753, 0, "w");
    (24754, 0, "a");
    (24755, 0, "y");
    (24756, 0, "s");
    (24757, 0, ")");
    (24758, 0, "]");
    (24759, 0, "\n    ");
    (24764, 0, "f");
    (24765, 0, "n");
    (24766, 0, " ");
    (24767, 0, "u");
    (24768, 0, "s");
    (24769, 0, "e");
    (24770, 0, "_");
    (24771, 0, "p");
    (24772, 0, "a");
    (24773, 0, "r");
    (24774, 0, "e");
    (24775, 0, "n");
    (24776, 0, "t");
    (24777, 0, "s");
    (24778, 0, "(");
    (24779, 0, "&");
    (24780, 0, "s");
    (24781, 0, "e");
    (24781, 1, "");
    (24780, 1, "");
    (24779, 1, "");
    (24779, 0, ")");
    (24780, 0, " ");
    (24781, 0, "-");
    (24782, 0, ">");
    (24783, 0, " ");
    (24784, 0, "b");
    (24785, 0, "o");
    (24786, 0, "o");
    (24787, 0, "l");
    (24788, 0, " ");
    (24789, 0, "{");
    (24790, 0, "\n        ");
    (24799, 0, "\n        ");
    (24791, 8, "");
    (24792, 8, "    }");
    (24791, 0, "(cfg!(debug_assertions) || N::notifications_used())");
    (24791, 0, "        ");
    (24799, 1, "");
    (24848, 1, "");
    (38262, 5, "");
    (38262, 0, "S");
    (38263, 0, "e");
    (38264, 0, "l");
    (38265, 0, "f");
    (38266, 0, ":");
    (38267, 0, ":");
    (49447, 23, "Self::use_parents()");
    (26479, 23, "Self::use_parents()");
    (28023, 23, "Self::use_parents()");
    (28023, 19, "N::notifications_used()");
    (28023, 23, "Self::use_parents()");
    (32324, 1, "");
    (32324, 1, "");
    (32324, 1, "");
    (32324, 1, "");
    (32324, 0, "c");
    (32325, 0, "u");
    (32326, 0, "r");
    (32327, 0, "s");
    (32328, 0, "o");
    (32329, 0, "r");
    (32298, 23, "Self::use_parents()");
    (3771, 0, "// ");
    (3704, 0, "// ");
    (3628, 0, "// ");
    (3611, 0, "// ");
    (3589, 0, "// ");
    ( 34004,
      0,
      "    pub(super) unsafe fn cursor_at_marker(&mut self, marker: \
       ItemMarker<C>, query: &<C::Item as Queryable>::Query) -> Cursor<C> \
       where C::Item: Queryable {\n" );
    (34163, 0, "// ");
    ( 34316,
      0,
      "\n\
      \    pub(super) unsafe fn cursor_at_marker(&mut self, marker: \
       ItemMarker<C>, query: &<C::Item as Queryable>::Query) -> Cursor<C> \
       where C::Item: Queryable {" );
    (34004, 155, "");
    (34246, 29, "");
    (34245, 1, "");
    (34245, 0, "i");
    (34246, 0, "m");
    (34247, 0, "p");
    (34248, 0, "l");
    (34249, 0, " ");
    (34250, 0, "F");
    (34251, 0, "n");
    (34252, 0, "M");
    (34253, 0, "u");
    (34253, 1, "");
    (34252, 1, "");
    (34252, 0, "(");
    (34203, 0, "<");
    (34204, 0, "F");
    (34205, 0, ">");
    (34205, 1, "");
    (34204, 1, "");
    (34204, 0, "Q");
    (34205, 0, ">");
    (34248, 8, "Q");
    (34264, 24, "");
    (34263, 1, "");
    (34263, 1, "");
    (34263, 0, "\n    ");
    (34268, 0, "w");
    (34269, 0, "h");
    (34270, 0, "e");
    (34271, 0, "r");
    (34272, 0, "e");
    (34273, 0, " ");
    (34274, 0, "fn contains_item(&self, query: &Self::Query) -> Option<usize>;");
    (34274, 0, "W");
    (34275, 0, ":");
    (34276, 0, " ");
    (34276, 1, "");
    (34275, 1, "");
    (34274, 1, "");
    (34274, 0, "Q");
    (34275, 0, ":");
    (34276, 0, " ");
    (34277, 16, "F");
    (34278, 0, "n");
    (34280, 5, "");
    (34280, 0, "C");
    (34281, 0, ":");
    (34282, 0, ":");
    (34283, 0, "I");
    (34284, 0, "t");
    (34285, 0, "e");
    (34286, 0, "m");
    (34287, 21, "");
    (34280, 0, "&");
    (34280, 0, "i");
    (34281, 0, "t");
    (34282, 0, "e");
    (34283, 0, "m");
    (34284, 0, ":");
    (34285, 0, " ");
    (34312, 1, "");
    (34312, 0, " ");
    (34280, 6, "");
    (34603, 5, "p");
    (34241, 5, "p");
    (34600, 0, "r");
    (34242, 0, "r");
    (34602, 0, "e");
    (34243, 0, "e");
    (34604, 0, "d");
    (34244, 0, "d");
    (34606, 0, "i");
    (34245, 0, "i");
    (34608, 0, "c");
    (34246, 0, "c");
    (34610, 0, "a");
    (34247, 0, "a");
    (34612, 0, "t");
    (34248, 0, "t");
    (34614, 0, "e");
    (34249, 0, "e");
    (34252, 1, "");
    (34252, 0, "P");
    (34204, 1, "");
    (34204, 0, "P");
    (34278, 1, "");
    (34278, 0, "P");
    (34588, 0, "p");
    (34589, 0, "r");
    (34590, 0, "e");
    (34591, 0, "d");
    (34592, 0, "i");
    (34593, 0, "c");
    (34594, 0, "a");
    (34595, 0, "t");
    (34596, 0, "e");
    (34597, 0, "(");
    (34602, 0, ")");
    (34603, 25, "");
    (3588, 200, "\n");
    (3588, 1, "");
    (33804, 158, "");
    (32094, 0, ")");
    (32085, 0, "(");
    (32095, 0, ",");
    (32096, 0, " ");
    (32097, 0, "u");
    (32098, 0, "s");
    (32099, 0, "i");
    (32100, 0, "z");
    (32101, 0, "e");
    (33663, 0, "(");
    (33670, 0, ",");
    (33671, 0, " ");
    (33672, 0, "9");
    (33672, 1, "");
    (33672, 0, "0");
    (33673, 0, ")");
    (33672, 2, "");
    (33672, 0, "9");
    (33671, 2, "");
    (33670, 1, "");
    (33663, 1, "");
    (32096, 6, "");
    (32095, 1, "");
    (32095, 1, "");
    (32085, 1, "");
    ( 33804,
      0,
      "    // pub(super) unsafe fn cursor_at_marker(&mut self, marker: \
       ItemMarker<C>, query: &<C::Item as Queryable>::Query) -> Cursor<C> \
       where C::Item: Queryable {\n" );
    (33804, 158, "");
    (32094, 0, ")");
    (32085, 0, "(");
    (32095, 1, "");
    (32085, 1, "");
    (31987, 0, "\n    ");
    (31992, 0, "/");
    (31993, 0, "/");
    (31994, 0, " ");
    (31994, 1, "");
    (31994, 0, "/");
    (31995, 0, " ");
    (31996, 0, "G");
    (31997, 0, "e");
    (31997, 1, "");
    (31996, 1, "");
    (31996, 0, "C");
    (31997, 0, "r");
    (31998, 0, "e");
    (31999, 0, "a");
    (32000, 0, "t");
    (32001, 0, "e");
    (32002, 0, " ");
    (32003, 0, "a");
    (32004, 0, " ");
    (32005, 0, "c");
    (32006, 0, "u");
    (32007, 0, "r");
    (32008, 0, "s");
    (32009, 0, "o");
    (32010, 0, "r");
    (32011, 0, " ");
    (32012, 0, "a");
    (32013, 0, "t");
    (32014, 0, " ");
    (32015, 0, "t");
    (32016, 0, "h");
    (32017, 0, "e");
    (32018, 0, " ");
    (32019, 0, "s");
    (32020, 0, "p");
    (32021, 0, "e");
    (32022, 0, "c");
    (32023, 0, "i");
    (32024, 0, "f");
    (32025, 0, "i");
    (32026, 0, "e");
    (32027, 0, "d");
    (32028, 0, " ");
    (32029, 0, "n");
    (32030, 0, "o");
    (32031, 0, "d");
    (32032, 0, "e");
    (32033, 0, ",");
    (32034, 0, " ");
    (32035, 0, "u");
    (32036, 0, "s");
    (32037, 0, "i");
    (32038, 0, "n");
    (32039, 0, "g");
    (32040, 0, " ");
    (32041, 0, "t");
    (32042, 0, "h");
    (32043, 0, "e");
    (32044, 0, " ");
    (32045, 0, "p");
    (32046, 0, "a");
    (32047, 0, "r");
    (32048, 0, "e");
    (32049, 0, "n");
    (32050, 0, "t");
    (32051, 0, "s");
    (32052, 0, " ");
    (32053, 0, "i");
    (32054, 0, "n");
    (32055, 0, "f");
    (32056, 0, "r");
    (32057, 0, "a");
    (32058, 0, "s");
    (32059, 0, "t");
    (32060, 0, "r");
    (32061, 0, "u");
    (32062, 0, "c");
    (32063, 0, "t");
    (32064, 0, "u");
    (32065, 0, "r");
    (32066, 0, "e");
    (32067, 0, " ");
    (32068, 0, "t");
    (32069, 0, "o");
    (32070, 0, " ");
    (32071, 0, "c");
    (32072, 0, "a");
    (32073, 0, "l");
    (32074, 0, "c");
    (32075, 0, "u");
    (32076, 0, "l");
    (32077, 0, "a");
    (32078, 0, "t");
    (32079, 0, "e");
    (32080, 0, " ");
    (32081, 0, "o");
    (32082, 0, "f");
    (32083, 0, "f");
    (32084, 0, "s");
    (32085, 0, "e");
    (32086, 0, "t");
    (32087, 0, "s");
    (32088, 0, ".");
    (32089, 0, "q");
    (32089, 1, "");
    ( 31988,
      101,
      "    /// Create a cursor at the specified node, using the parents \
       infrastructure\n\
      \    /// to calculate offsets." );
    (32097, 0, " ");
    (32098, 0, "N");
    (32099, 0, "o");
    (32100, 0, "t");
    (32101, 0, "e");
    (32102, 0, " ");
    (32103, 0, "t");
    (32104, 0, "h");
    (32105, 0, "i");
    (32106, 0, "s");
    (32107, 0, " ");
    (32108, 0, "i");
    (32098, 11, "");
    (32097, 1, "");
    (32097, 0, " ");
    (32098, 0, "T");
    (32099, 0, "e");
    (32100, 0, "h");
    (32101, 0, " ");
    (32102, 0, "o");
    (32102, 1, "");
    (32101, 1, "");
    (32100, 1, "");
    (32099, 1, "");
    (32099, 0, "h");
    (32100, 0, "e");
    (32101, 0, " ");
    (32102, 0, "o");
    (32103, 0, "f");
    (32104, 0, "f");
    (32105, 0, "s");
    (32106, 0, "e");
    (32107, 0, "t");
    (32108, 0, " ");
    (32109, 0, "a");
    (32110, 0, "n");
    (32111, 0, "d");
    (32112, 0, " ");
    (32113, 0, "l");
    (32114, 0, "o");
    (32115, 0, "c");
    (32116, 0, "a");
    (32117, 0, "l");
    (32118, 0, "_");
    (32119, 0, "i");
    (32120, 0, "n");
    (32121, 0, "d");
    (32122, 0, "e");
    (32123, 0, "x");
    (32124, 0, " ");
    (32125, 0, "p");
    (32126, 0, "a");
    (32127, 0, "r");
    (32128, 0, "a");
    (32129, 0, "m");
    (32130, 0, "e");
    (32131, 0, "t");
    (32132, 0, "e");
    (32133, 0, "r");
    (32134, 0, "s");
    (32135, 0, " ");
    (32136, 0, "a");
    (32137, 0, "r");
    (32138, 0, "e");
    (32139, 0, " ");
    (32140, 0, "n");
    (32141, 0, "o");
    (32141, 1, "");
    (32140, 1, "");
    (32140, 0, "u");
    (32141, 0, "n");
    (32142, 0, "c");
    (32143, 0, "k");
    (32144, 0, "e");
    (32145, 0, "d");
    (32145, 1, "");
    (32145, 0, "c");
    (32146, 0, "k");
    (32140, 7, "u");
    (32141, 0, "n");
    (32142, 0, "c");
    (32143, 0, "k");
    (32144, 0, "e");
    (32136, 9, "m");
    (32137, 0, "u");
    (32138, 0, "s");
    (32139, 0, "t");
    (32140, 0, " ");
    (32141, 0, "s");
    (32142, 0, "p");
    (32143, 0, "e");
    (32144, 0, "c");
    (32136, 9, "s");
    (32137, 0, "h");
    (32138, 0, "o");
    (32139, 0, "u");
    (32140, 0, "l");
    (32141, 0, "d");
    (32142, 0, " ");
    (32143, 0, "s");
    (32144, 0, "p");
    (32145, 0, "e");
    (32146, 0, "c");
    (32147, 0, "i");
    (32148, 0, "f");
    (32149, 0, "y");
    (32150, 0, " ");
    (32151, 0, "t");
    (32152, 0, "h");
    (32153, 0, "e");
    (32154, 0, " ");
    (32155, 0, "o");
    (32156, 0, "f");
    (32157, 0, "f");
    (32158, 0, "s");
    (32159, 0, "e");
    (32160, 0, "t");
    (32161, 0, " ");
    (32162, 0, "i");
    (32163, 0, "n");
    (32164, 0, "t");
    (32165, 0, "o");
    (32166, 0, " ");
    (32167, 0, "t");
    (32168, 0, "h");
    (32169, 0, "e");
    (32170, 0, " ");
    (32171, 0, "c");
    (32172, 0, "u");
    (32173, 0, "r");
    (32174, 0, "r");
    (32175, 0, "e");
    (32176, 0, "n");
    (32177, 0, "t");
    (32178, 0, " ");
    (32179, 0, "n");
    (32180, 0, "o");
    (32181, 0, "d");
    (32182, 0, "e");
    (32183, 0, ".");
    (32184, 0, " ");
    (32185, 0, "T");
    (32186, 0, "h");
    (32187, 0, "e");
    (32188, 0, " ");
    (32185, 4, "");
    (32185, 0, "O");
    (32186, 0, "f");
    (32187, 0, "f");
    (32188, 0, "s");
    (32189, 0, "e");
    (32190, 0, "t");
    (32191, 0, " ");
    (32192, 0, "m");
    (32193, 0, "u");
    (32193, 1, "");
    (32192, 1, "");
    (32192, 0, "*");
    (32193, 0, "m");
    (32194, 0, "u");
    (32195, 0, "s");
    (32196, 0, "t");
    (32197, 0, "*");
    (32198, 0, " ");
    (32199, 0, "b");
    (32200, 0, "e");
    (32201, 0, " ");
    (32202, 0, "s");
    (32203, 0, "p");
    (32204, 0, "e");
    (32205, 0, "c");
    (32206, 0, "i");
    (32207, 0, "f");
    (32208, 0, "i");
    (32209, 0, "e");
    (32210, 0, "d");
    (32202, 9, "a");
    (32203, 0, "t");
    (32204, 0, " ");
    (32205, 0, "a");
    (32206, 0, " ");
    (32206, 1, "");
    (32206, 0, "n");
    (32207, 0, " ");
    (32208, 0, "i");
    (32209, 0, "t");
    (32210, 0, "e");
    (32211, 0, "m");
    (32212, 0, " ");
    (32213, 0, "b");
    (32214, 0, "o");
    (32215, 0, "u");
    (32216, 0, "n");
    (32217, 0, "d");
    (32218, 0, "a");
    (32219, 0, "r");
    (32220, 0, "y");
    (32184, 0, " ");
    (32185, 0, "T");
    (32186, 0, "h");
    (32187, 0, "e");
    (32188, 0, "y");
    (32189, 0, " ");
    (32190, 0, "a");
    (32191, 0, "r");
    (32192, 0, "e");
    (32193, 0, " ");
    (32194, 0, "a");
    (32195, 0, "c");
    (32196, 0, "c");
    (32197, 0, "e");
    (32198, 0, "p");
    (32199, 0, "t");
    (32200, 0, "e");
    (32201, 0, "d");
    (32202, 0, " ");
    (32203, 0, "a");
    (32204, 0, "s");
    (32205, 0, "-");
    (32206, 0, "i");
    (32207, 0, "s");
    (32208, 0, ".");
    ( 32068,
      178,
      "    /// to calculate offsets. The offset and local_index parameters \
       should\n\
      \    /// specify the offset into the current node. They are accepted \
       as-is.\n\
      \    /// Offset *must* be at an item boundary" );
    (34398, 0, "\n        ");
    (34407, 0, "l");
    (34408, 0, "e");
    (34409, 0, "t");
    (34410, 0, " ");
    (34411, 0, "m");
    (34412, 0, "u");
    (34413, 0, "t");
    (34414, 0, " ");
    (34415, 0, "i");
    (34416, 0, "t");
    (34417, 0, "e");
    (34418, 0, "m");
    (34419, 0, "_");
    (34420, 0, "o");
    (34421, 0, "f");
    (34422, 0, "f");
    (34423, 0, "s");
    (34424, 0, "e");
    (34425, 0, "t");
    (34426, 0, " ");
    (34427, 0, "=");
    (34428, 0, " ");
    (34429, 0, "0");
    (34430, 0, ";");
    (34429, 1, "");
    (34428, 1, "");
    (34427, 1, "");
    (34426, 1, "");
    (34426, 0, " = 0");
    (34534, 0, "_");
    (34573, 0, "// ");
    (34598, 0, "\n                ");
    (34615, 0, "i");
    (34616, 0, "t");
    (34617, 0, "e");
    (34618, 0, "m");
    (34619, 0, "_");
    (34620, 0, "o");
    (34615, 6, "item_offset");
    (34626, 0, " ");
    (34627, 0, "=");
    (34628, 0, " ");
    (34629, 0, "i");
    (34630, 0, "t");
    (34631, 0, "e");
    (34632, 0, "m");
    (34629, 4, "item_offset_");
    (34641, 0, ";");
    (34897, 0, "(");
    (34941, 0, ",");
    (34942, 0, " ");
    (34943, 0, "i");
    (34944, 0, "t");
    (34945, 0, "e");
    (34946, 0, "m");
    (34947, 0, "_");
    (34943, 5, "item_offset");
    (34954, 0, ")");
    (34175, 0, "(");
    (34185, 0, ",");
    (34186, 0, " ");
    (34187, 0, "u");
    (34188, 0, "s");
    (34189, 0, "i");
    (34190, 0, "z");
    (34191, 0, "e");
    (34192, 0, ")");
    (34175, 0, "O");
    (34176, 0, "p");
    (34177, 0, "t");
    (34178, 0, "i");
    (34179, 0, "o");
    (34180, 0, "n");
    (34181, 0, "<");
    (34200, 0, ">");
    (34816, 0, "\n        ");
    (34825, 0, "i");
    (34826, 0, "f");
    (34827, 0, " ");
    (34817, 11, "");
    (34816, 1, "");
    (34825, 0, "// ");
    (34816, 0, "\n        ");
    (34825, 0, "m");
    (34825, 1, "");
    (34825, 0, "i");
    (34826, 0, "f");
    (34827, 0, " ");
    (34828, 0, "l");
    (34829, 0, "e");
    (34830, 0, "t");
    (34831, 0, " ");
    (34832, 0, "l");
    (34833, 0, "o");
    (34834, 0, "c");
    (34835, 0, "a");
    (34832, 4, "local_index");
    (34843, 0, " ");
    (34844, 0, " ");
    (34844, 1, "");
    (34844, 0, "=");
    (34845, 0, " ");
    (34846, 0, "l");
    (34847, 0, "o");
    (34848, 0, "c");
    (34849, 0, "a");
    (34850, 0, "l");
    (34846, 5, "local_index");
    (34857, 0, " ");
    (34858, 0, "{");
    ( 35018,
      0,
      "\n\
      \        // let local_index = local_index.expect(\"Invalid marker - item \
       not found in node\");" );
    (34952, 8, "            ");
    (34860, 92, "");
    (34930, 0, "\n            ");
    (34931, 12, "        }");
    (34940, 0, " ");
    (34941, 0, "e");
    (34942, 0, "l");
    (34943, 0, "s");
    (34944, 0, "e");
    (34945, 0, " ");
    (34946, 0, "{");
    (34947, 0, " ");
    (34948, 0, "N");
    (34949, 0, "o");
    (34950, 0, "n");
    (34951, 0, "e");
    (34952, 0, " ");
    (34953, 0, "}");
    (34832, 0, "S");
    (34833, 0, "o");
    (34834, 0, "m");
    (34835, 0, "e");
    (34836, 0, "(");
    (34848, 0, ")");
    (34878, 0, "C");
    (34879, 0, "o");
    (34880, 0, "m");
    (34881, 0, "e");
    (34881, 1, "");
    (34880, 1, "");
    (34879, 1, "");
    (34878, 1, "");
    (34878, 0, "S");
    (34879, 0, "o");
    (34880, 0, "m");
    (34881, 0, "e");
    (34882, 0, "(");
    (34941, 0, ")");
    (34816, 0, "\n        ");
    (34825, 0, "l");
    (34826, 0, "o");
    (34827, 0, "c");
    (34828, 0, "a");
    (34825, 4, "local_index");
    (34836, 0, ".");
    (34837, 0, "m");
    (34838, 0, "a");
    (34837, 2, "map(f: F)");
    (34841, 5, "");
    (34841, 0, "l");
    (34841, 1, "");
    (34841, 0, "\\");
    (34841, 1, "");
    (34841, 0, "|");
    (34842, 0, "l");
    (34843, 0, "o");
    (34844, 0, "c");
    (34845, 0, "a");
    (34846, 0, "l");
    (34842, 5, "local_index");
    (34853, 0, "|");
    (34855, 66, "");
    (34854, 1, "");
    (34854, 0, "\n            ");
    (34854, 0, "{");
    (34854, 1, "");
    (34854, 0, " ");
    (34855, 0, "{");
    (34928, 0, "\n            ");
    (34929, 12, "        }");
    (34938, 0, ")");
    (34927, 1, "");
    (34939, 116, "");
    ( 34939,
      0,
      "        } else { None }\n\
      \        // let local_index = local_index.expect(\"Invalid marker - item \
       not found in node\");\n" );
    (34939, 24, "");
    (34939, 92, "");
    (55306, 1, "");
    (55305, 1, "");
    (10576, 8, "");
    (32654, 13, "");
    (58218, 229, "");
    ( 57449,
      0,
      "\n\
       impl<C: ListConfig, N: NotificationTarget<C>> fmt::Debug for \
       SkipList<C, N> where C::Item: fmt::Debug {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_list().entries(self.iter()).finish()\n\
      \    }\n\
       }\n" );
    ( 57450,
      0,
      "impl<C: ListConfig, N: NotificationTarget<C>> fmt::Debug for \
       SkipList<C, N> where C::Item: fmt::Debug {\n\
      \    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \        f.debug_list().entries(self.iter()).finish()\n\
      \    }\n\
       }\n" );
    (57678, 0, "\n");
    (57725, 10, "D");
    (57726, 0, "e");
    (57727, 0, "f");
    (57728, 0, "a");
    (57729, 0, "u");
    (57730, 0, "l");
    (57731, 0, "t");
    (57751, 26, "");
    (57761, 3, "d");
    (57762, 0, "e");
    (57763, 0, "f");
    (57764, 0, "a");
    (57765, 0, "u");
    (57766, 0, "l");
    (57767, 0, "t");
    (57807, 11, "S");
    (57808, 0, "e");
    (57809, 0, "l");
    (57810, 0, "f");
    (57769, 33, "");
    (57789, 44, "");
    (57789, 0, "S");
    (57790, 0, "k");
    (57789, 2, "SkipList");
    (57797, 0, ":");
    (57798, 0, ":");
    (57799, 0, "n");
    (57800, 0, "e");
    (57801, 0, "w");
    (57802, 0, "(");
    (57803, 0, ")");
    (56481, 7, "");
    (56497, 1, "");
    (18854, 0, "// ");
    (18844, 0, "// ");
    (18789, 0, "// ");
    (18736, 0, "// ");
    (18719, 0, "// ");
    (18651, 0, "// ");
    (18601, 0, "// ");
    (18545, 0, "// ");
    (18503, 0, "// ");
    (18417, 0, "// ");
    (57729, 7, "y");
    (57500, 7, "y");
    (57148, 7, "y");
    (56565, 7, "y");
    (56020, 7, "y");
    (22665, 7, "y");
    (21233, 7, "y");
    (20443, 7, "y");
    (20238, 7, "y");
    (7663, 7, "y");
    (3439, 7, "y");
    (3155, 7, "y");
    (2409, 10, "");
    (2409, 0, "ListConfig");
    (2409, 10, "L");
    (2410, 0, "i");
    (2411, 0, "s");
    (2412, 0, "t");
    (2413, 0, "I");
    (2414, 0, "t");
    (2415, 0, "e");
    (2416, 0, "m");
    (2420, 14, "");
    (2419, 1, "");
    (2325, 73, "");
    (2324, 1, "");
    (2346, 36, "");
    (2618, 7, "");
    (2623, 6, "");
    (2619, 4, "s");
    (2620, 0, "e");
    (2621, 0, "l");
    (2622, 0, "f");
    (2678, 6, "");
    (2826, 6, "");
    (2814, 7, "");
    (2249, 1, "");
    (2054, 1, "");
    (2009, 1, "");
    (1892, 1, "");
    (1846, 1, "");
    (1760, 1, "");
    (1621, 1, "");
    (2242, 1, "");
    (2048, 1, "");
    (2004, 1, "");
    (1888, 1, "");
    (1843, 1, "");
    (1758, 1, "");
    (1620, 1, "");
    (2235, 1, "");
    (2042, 1, "");
    (1999, 1, "");
    (1884, 1, "");
    (1840, 1, "");
    (1756, 1, "");
    (1619, 1, "");
    (2228, 1, "");
    (2036, 1, "");
    (1994, 1, "");
    (1880, 1, "");
    (1837, 1, "");
    (1754, 1, "");
    (1618, 1, "");
    (2221, 1, "");
    (2030, 1, "");
    (1989, 1, "");
    (1876, 1, "");
    (1834, 1, "");
    (1752, 1, "");
    (1617, 1, "");
    (2214, 1, "");
    (2024, 1, "");
    (1984, 1, "");
    (1872, 1, "");
    (1831, 1, "");
    (1750, 1, "");
    (1616, 1, "");
    (2208, 0, "I");
    (2019, 0, "I");
    (1980, 0, "I");
    (1869, 0, "I");
    (1829, 0, "I");
    (1749, 0, "I");
    (1616, 0, "I");
    (2215, 0, "t");
    (2025, 0, "t");
    (1985, 0, "t");
    (1873, 0, "t");
    (1832, 0, "t");
    (1751, 0, "t");
    (1617, 0, "t");
    (2222, 0, "e");
    (2031, 0, "e");
    (1990, 0, "e");
    (1877, 0, "e");
    (1835, 0, "e");
    (1753, 0, "e");
    (1618, 0, "e");
    (2229, 0, "m");
    (2037, 0, "m");
    (1995, 0, "m");
    (1881, 0, "m");
    (1838, 0, "m");
    (1755, 0, "m");
    (1619, 0, "m");
    (2225, 1, "");
    (2032, 1, "");
    (1989, 1, "");
    (1874, 1, "");
    (1830, 1, "");
    (1746, 1, "");
    (1609, 1, "");
    (2219, 0, "I");
    (2027, 0, "I");
    (1985, 0, "I");
    (1871, 0, "I");
    (1828, 0, "I");
    (1745, 0, "I");
    (1609, 0, "I");
    (1654, 1, "");
    (1654, 0, "I");
    (1780, 1, "");
    (1780, 0, "I");
    (1863, 1, "");
    (1863, 0, "I");
    (1913, 1, "");
    (1912, 1, "");
    (1912, 0, "I");
    (1913, 0, ">");
    (2020, 1, "");
    (2020, 0, "I");
    (2261, 1, "");
    (2093, 1, "");
    (2056, 1, "");
    (2259, 0, "I");
    (2092, 0, "I");
    (2056, 0, "I");
    (4117, 13, "I");
    (4031, 13, "I");
    (3986, 13, "I");
    (3556, 13, "I");
    (3240, 13, "I");
    (2990, 13, "I");
    (4058, 0, ":");
    (3984, 0, ":");
    (3951, 0, ":");
    (3533, 0, ":");
    (3229, 0, ":");
    (2991, 0, ":");
    (4064, 0, " ");
    (3989, 0, " ");
    (3955, 0, " ");
    (3536, 0, " ");
    (3231, 0, " ");
    (2992, 0, " ");
    (4070, 0, "L");
    (3994, 0, "L");
    (3959, 0, "L");
    (3539, 0, "L");
    (3233, 0, "L");
    (2993, 0, "L");
    (4076, 0, "i");
    (3999, 0, "i");
    (3963, 0, "i");
    (3542, 0, "i");
    (3235, 0, "i");
    (2994, 0, "i");
    (4082, 0, "s");
    (4004, 0, "s");
    (3967, 0, "s");
    (3545, 0, "s");
    (3237, 0, "s");
    (2995, 0, "s");
    (4088, 0, "t");
    (4009, 0, "t");
    (3971, 0, "t");
    (3548, 0, "t");
    (3239, 0, "t");
    (2996, 0, "t");
    (4094, 0, "I");
    (4014, 0, "I");
    (3975, 0, "I");
    (3551, 0, "I");
    (3241, 0, "I");
    (2997, 0, "I");
    (4100, 0, "t");
    (4019, 0, "t");
    (3979, 0, "t");
    (3554, 0, "t");
    (3243, 0, "t");
    (2998, 0, "t");
    (4106, 0, "e");
    (4024, 0, "e");
    (3983, 0, "e");
    (3557, 0, "e");
    (3245, 0, "e");
    (2999, 0, "e");
    (4112, 0, "m");
    (4029, 0, "m");
    (3987, 0, "m");
    (3560, 0, "m");
    (3247, 0, "m");
    (3000, 0, "m");
    (3357, 7, "L");
    (3193, 7, "L");
    (3352, 0, "i");
    (3194, 0, "i");
    (3354, 0, "s");
    (3195, 0, "s");
    (3356, 0, "t");
    (3196, 0, "t");
    (3358, 0, "I");
    (3197, 0, "I");
    (3360, 0, "t");
    (3198, 0, "t");
    (3362, 0, "e");
    (3199, 0, "e");
    (3364, 0, "m");
    (3200, 0, "m");
    (3226, 1, "");
    (3226, 0, "I");
    (3392, 1, "");
    (3392, 0, "I");
    (3358, 8, "I");
    (3193, 8, "I");
    (3258, 1, "");
    (3258, 0, "I");
    (3610, 1, "");
    (3610, 0, "I");
    (4118, 1, "");
    (4044, 1, "");
    (4000, 1, "");
    (4116, 0, "I");
    (4043, 0, "I");
    (4000, 0, "I");
    (5363, 13, "I");
    (5364, 0, "L");
    (5364, 1, "");
    (5364, 0, ":");
    (5365, 0, " ");
    (5366, 0, "L");
    (5367, 0, "i");
    (5368, 0, "s");
    (5369, 0, "t");
    (5370, 0, "I");
    (5366, 5, "ListItem");
    (5815, 7, "I");
    (6363, 1, "");
    (6363, 0, "I");
    (6651, 1, "");
    (6651, 0, "I");
    (7032, 0, "// ");
    (6975, 0, "// ");
    (6969, 0, "// ");
    (6910, 0, "// ");
    (6886, 0, "// ");
    (6849, 0, "// ");
    (6826, 0, "// ");
    (6821, 0, "\n    ");
    (6826, 0, "s");
    (6827, 0, "t");
    (6828, 0, "r");
    (6829, 0, "u");
    (6830, 0, "c");
    (6831, 0, "t");
    (6832, 0, " ");
    (6833, 0, "I");
    (6834, 0, "t");
    (6835, 0, "e");
    (6836, 0, "m");
    (6837, 0, "(");
    (6838, 0, "u");
    (6839, 0, "8");
    (6840, 0, ")");
    (6841, 0, ";");
    (7002, 3, "");
    (6940, 3, "");
    (6913, 3, "");
    (6873, 3, "");
    (6843, 25, "");
    (6842, 1, "");
    (6852, 10, "L");
    (6853, 0, "i");
    (6854, 0, "s");
    (6855, 0, "t");
    (6856, 0, "I");
    (6857, 0, "t");
    (6858, 0, "e");
    (6859, 0, "m");
    (6865, 10, "I");
    (6866, 0, "t");
    (6867, 0, "e");
    (6868, 0, "m");
    (6872, 23, "");
    (6871, 1, "");
    (7087, 3, "");
    (7001, 3, "");
    (6941, 3, "");
    (6976, 10, "I");
    (6977, 0, "t");
    (6978, 0, "e");
    (6979, 0, "m");
    (7054, 10, "I");
    (7055, 0, "t");
    (7056, 0, "e");
    (7057, 0, "m");
    (7069, 0, "// ");
    (7380, 10, "L");
    (7381, 0, "i");
    (7382, 0, "s");
    (7383, 0, "t");
    (7380, 4, "ListItem");
    (7377, 1, "");
    (7377, 0, "I");
    (8693, 1, "");
    (8693, 0, "I");
    (9206, 1, "");
    (9206, 0, "I");
    (9262, 13, "I");
    (9263, 0, ":");
    (9264, 0, " ");
    (9264, 1, "");
    (9264, 0, " ");
    (9265, 0, "I");
    (9265, 1, "");
    (9265, 0, "L");
    (9266, 0, "i");
    (9267, 0, "s");
    (9268, 0, "t");
    (9269, 0, "I");
    (9265, 5, "ListItem");
    (9280, 1, "");
    (9280, 0, "I");
    (9436, 1, "");
    (9436, 0, "I");
    (11466, 1, "");
    (11240, 1, "");
    (11123, 1, "");
    (10679, 1, "");
    (10583, 1, "");
    (10172, 1, "");
    (10016, 1, "");
    (9943, 1, "");
    (9883, 1, "");
    (9850, 1, "");
    (9605, 1, "");
    (11456, 0, "I");
    (11231, 0, "I");
    (11115, 0, "I");
    (10672, 0, "I");
    (10577, 0, "I");
    (10167, 0, "I");
    (10012, 0, "I");
    (9940, 0, "I");
    (9881, 0, "I");
    (9849, 0, "I");
    (9605, 0, "I");
    (7406, 1, "");
    (7406, 0, "I");
    (10885, 7, "I");
    (11905, 13, "I");
    (11859, 13, "I");
    (11516, 13, "I");
    (11882, 0, ":");
    (11848, 0, ":");
    (11517, 0, ":");
    (11885, 0, " ");
    (11850, 0, " ");
    (11518, 0, " ");
    (11888, 0, "L");
    (11852, 0, "L");
    (11519, 0, "L");
    (11891, 0, "i");
    (11854, 0, "i");
    (11520, 0, "i");
    (11894, 0, "s");
    (11856, 0, "s");
    (11521, 0, "s");
    (11897, 0, "t");
    (11858, 0, "t");
    (11522, 0, "t");
    (11900, 0, "I");
    (11860, 0, "I");
    (11523, 0, "I");
    (11898, 5, "ListItem");
    (11857, 5, "ListItem");
    (11519, 5, "ListItem");
    (11543, 1, "");
    (11543, 0, "I");
    (12017, 1, "");
    (11970, 1, "");
    (11886, 1, "");
    (12015, 0, "I");
    (11969, 0, "I");
    (11886, 0, "I");
    (11940, 1, "");
    (11940, 0, "I");
    (13016, 2, "I");
    (13017, 11, ":");
    (13018, 0, " ");
    (13019, 0, "L");
    (13020, 0, "i");
    (13021, 0, "s");
    (13022, 0, "t");
    (13023, 0, "I");
    (13019, 5, "ListItem");
    (13749, 1, "I");
    (14054, 13, "I");
    (14055, 0, "L");
    (14055, 1, "");
    (14055, 0, ":");
    (14056, 0, " ");
    (14057, 0, "L");
    (14058, 0, "i");
    (14059, 0, "s");
    (14060, 0, "t");
    (14057, 4, "ListItem");
    (14074, 1, "");
    (14074, 0, "I");
    (14804, 1, "I");
    (15969, 15, "");
    (15969, 1, "");
    (16008, 1, "");
    (16007, 1, "");
    (16006, 1, "");
    (15997, 0, " ");
    (15998, 0, "}");
    (16008, 0, ".");
    (16009, 0, "g");
    (16010, 0, "e");
    (16011, 0, "t");
    (16012, 0, "_");
    (16013, 0, "u");
    (16014, 0, "s");
    (16015, 0, "e");
    (16016, 0, "r");
    (16009, 8, "get_usersize");
    (16021, 0, "(");
    (16022, 0, ")");
    (17769, 7, "I");
    (17476, 7, "I");
    (17052, 7, "I");
    (16626, 7, "I");
    (18672, 1, "I");
    (19448, 13, "I");
    (19407, 13, "I");
    (18720, 13, "I");
    (19425, 0, ":");
    (19396, 0, ":");
    (18721, 0, ":");
    (19428, 0, "L");
    (19398, 0, "L");
    (18722, 0, "L");
    (19431, 0, "i");
    (19400, 0, "i");
    (18723, 0, "i");
    (19434, 0, "s");
    (19402, 0, "s");
    (18724, 0, "s");
    (19437, 0, "t");
    (19404, 0, "t");
    (18725, 0, "t");
    (19440, 0, "I");
    (19406, 0, "I");
    (18726, 0, "I");
    (19438, 5, "ListItem");
    (19403, 5, "ListItem");
    (18722, 5, "ListItem");
    (19444, 0, " ");
    (19406, 0, " ");
    (18722, 0, " ");
    (20124, 1, "");
    (19925, 1, "");
    (19479, 1, "");
    (19432, 1, "");
    (18754, 1, "");
    (20120, 0, "I");
    (19922, 0, "I");
    (19477, 0, "I");
    (19431, 0, "I");
    (18754, 0, "I");
    (20877, 13, "I");
    (20093, 13, "I");
    (19894, 13, "I");
    (20854, 0, "L");
    (20082, 0, "L");
    (19895, 0, "L");
    (20856, 1, "");
    (20083, 1, "");
    (19895, 1, "");
    (20854, 0, ":");
    (20082, 0, ":");
    (19895, 0, ":");
    (20857, 0, " ");
    (20084, 0, " ");
    (19896, 0, " ");
    (20860, 0, "L");
    (20086, 0, "L");
    (19897, 0, "L");
    (20863, 0, "i");
    (20088, 0, "i");
    (19898, 0, "i");
    (20866, 0, "s");
    (20090, 0, "s");
    (19899, 0, "s");
    (20869, 0, "t");
    (20092, 0, "t");
    (19900, 0, "t");
    (20872, 0, "I");
    (20094, 0, "I");
    (19901, 0, "I");
    (20870, 5, "ListItem");
    (20091, 5, "ListItem");
    (19897, 5, "ListItem");
    (20963, 7, "I");
    (20664, 7, "I");
    (20602, 7, "I");
    (20025, 7, "I");
    (20001, 7, "I");
    (20060, 1, "");
    (20060, 0, "I");
    (20132, 1, "");
    (20132, 0, "I");
    (20878, 1, "I");
    (20915, 1, "");
    (20915, 0, "I");
    (21389, 7, "I");
    (22261, 13, "I: ListItem");
    (22290, 1, "");
    (22290, 0, "I");
    (22303, 1, "");
    (22303, 0, "I");
    (22357, 1, "");
    (22357, 0, "I");
    (24917, 1, "");
    (24114, 1, "");
    (23934, 1, "");
    (23632, 1, "");
    (23554, 1, "");
    (24913, 0, "I");
    (24111, 0, "I");
    (23932, 0, "I");
    (23631, 0, "I");
    (23554, 0, "I");
    (25809, 1, "");
    (25809, 0, "I");
    (29321, 1, "I");
    (30812, 1, "");
    (29418, 1, "");
    (30811, 0, "I");
    (29418, 0, "I");
    (31351, 1, "I");
    (31351, 16, "");
    (31388, 1, "");
    (31388, 0, ".");
    (31389, 0, "g");
    (31390, 0, "e");
    (31391, 0, "t");
    (31392, 0, "_");
    (31393, 0, "u");
    (31394, 0, "s");
    (31389, 6, "get_usersize");
    (31401, 0, "(");
    (31402, 0, ")");
    (31360, 1, "");
    (31997, 1, "");
    (31944, 1, "");
    (31996, 0, "I");
    (31944, 0, "I");
    (31997, 1, "");
    (31944, 1, "");
    (31996, 0, "C");
    (31944, 0, "C");
    (35012, 1, "");
    (34882, 1, "");
    (33807, 1, "");
    (33771, 1, "");
    (32138, 1, "");
    (31997, 1, "");
    (31944, 1, "");
    (35006, 0, "I");
    (34877, 0, "I");
    (33803, 0, "I");
    (33768, 0, "I");
    (32136, 0, "I");
    (31996, 0, "I");
    (31944, 0, "I");
    (33836, 7, "I");
    (34380, 16, "");
    (34384, 1, "");
    (34384, 0, ".");
    (34385, 0, "g");
    (34386, 0, "e");
    (34387, 0, "t");
    (34388, 0, "_");
    (34389, 0, "u");
    (34390, 0, "s");
    (34391, 0, "e");
    (34392, 0, "r");
    (34385, 8, "get_usersize");
    (34397, 0, "(");
    (34398, 0, ")");
    (34971, 0, "t");
    (34972, 0, "e");
    (34973, 0, "r");
    (35101, 0, "t");
    (35102, 0, "e");
    (35103, 0, "r");
    (35120, 7, "I");
    (35655, 7, "I");
    (35757, 1, "");
    (35757, 0, "I");
    (38936, 0, "t");
    (38937, 0, "e");
    (38938, 0, "r");
    (38972, 1, "");
    (38972, 0, "I");
    (39029, 0, "t");
    (39030, 0, "e");
    (39031, 0, "r");
    (39057, 7, "I");
    (41720, 1, "");
    (41720, 0, "I");
    (45343, 1, "");
    (45343, 0, "I");
    (46058, 1, "I");
    (47505, 7, "I");
    (47726, 1, "I");
    (51262, 0, "t");
    (51263, 0, "e");
    (51264, 0, "r");
    (51352, 0, "t");
    (51353, 0, "e");
    (51354, 0, "r");
    (51392, 0, "t");
    (51393, 0, "e");
    (51394, 0, "r");
    (51420, 7, "I");
    (51298, 1, "");
    (51298, 0, "I");
    (52387, 1, "I");
    (52816, 1, "I");
    (54183, 1, "I");
    (54197, 7, "I");
    (54629, 7, "I");
    (55576, 13, "I::get_usersize(");
    (55576, 16, "C: ListConfig");
    (55576, 13, "I");
    (55577, 0, ":");
    (55578, 0, " ");
    (55579, 0, "L");
    (55580, 0, "i");
    (55581, 0, "s");
    (55582, 0, "t");
    (55583, 0, "I");
    (55579, 5, "ListItem");
    (56554, 1, "");
    (56144, 1, "");
    (55605, 1, "");
    (56552, 0, "I");
    (56143, 0, "I");
    (55605, 0, "I");
    (55618, 1, "");
    (55618, 0, "I");
    (55630, 7, "I");
    (56845, 7, "I");
    (56805, 7, "I");
    (56764, 7, "I");
    (56728, 7, "I");
    (56583, 7, "I");
    (55680, 7, "I");
    (56101, 13, "I: ListItem");
    (56152, 1, "");
    (56152, 0, "I");
    (56504, 13, "I: ListItem");
    (56611, 1, "");
    (56611, 0, "I");
    (56611, 1, "");
    (56611, 0, "C");
    (56504, 11, "C: ListConfig");
    (56152, 1, "");
    (56152, 0, "I");
    (56504, 13, "I: ListItem");
    (56611, 1, "");
    (56611, 0, "I");
    (56502, 0, "t");
    (56503, 0, "e");
    (56504, 0, "r");
    (56551, 0, "t");
    (56552, 0, "e");
    (56553, 0, "r");
    (56603, 0, "t");
    (56604, 0, "e");
    (56605, 0, "r");
    (56677, 13, "I: ListItem");
    (56737, 1, "");
    (56737, 0, "I");
    (56706, 1, "");
    (56706, 0, "I");
    (57496, 13, "I: ListItem");
    (57373, 13, "I: ListItem");
    (57220, 13, "I: ListItem");
    (56997, 13, "I: ListItem");
    (57410, 1, "");
    (57247, 1, "");
    (57026, 1, "");
    (57408, 0, "I");
    (57246, 0, "I");
    (57026, 0, "I");
    (57272, 1, "");
    (57054, 1, "");
    (57271, 0, "I");
    (57054, 0, "I");
    (57558, 7, "I");
    (57066, 7, "I");
    (57527, 1, "I");
    (2839, 6, "");
    (2827, 6, "");
    (6884, 18, "&");
    (6885, 0, "s");
    (6886, 0, "e");
    (6887, 0, "l");
    (6888, 0, "f");
    (57459, 1, "");
    (57338, 1, "");
    (57187, 1, "");
    (56972, 1, "");
    (56652, 1, "");
    (56482, 1, "");
    (56076, 1, "");
    (55551, 1, "");
    (22236, 1, "");
    (20824, 1, "");
    (20054, 1, "");
    (19869, 1, "");
    (19419, 1, "");
    (19380, 1, "");
    (18695, 1, "");
    (14029, 1, "");
    (12991, 1, "");
    (11876, 1, "");
    (11832, 1, "");
    (11491, 1, "");
    (9237, 1, "");
    (7352, 1, "");
    (5351, 1, "");
    (4083, 1, "");
    (3999, 1, "");
    (3956, 1, "");
    (3528, 1, "");
    (3220, 1, "");
    (2978, 1, "");
    (2225, 1, "");
    (2032, 1, "");
    (1989, 1, "");
    (1874, 1, "");
    (1830, 1, "");
    (1746, 1, "");
    (1609, 1, "");
    (57424, 0, "I");
    (57304, 0, "I");
    (57154, 0, "I");
    (56940, 0, "I");
    (56621, 0, "I");
    (56452, 0, "I");
    (56047, 0, "I");
    (55523, 0, "I");
    (22209, 0, "I");
    (20798, 0, "I");
    (20029, 0, "I");
    (19845, 0, "I");
    (19396, 0, "I");
    (19358, 0, "I");
    (18674, 0, "I");
    (14009, 0, "I");
    (12972, 0, "I");
    (11858, 0, "I");
    (11815, 0, "I");
    (11475, 0, "I");
    (9222, 0, "I");
    (7338, 0, "I");
    (5338, 0, "I");
    (4071, 0, "I");
    (3988, 0, "I");
    (3946, 0, "I");
    (3519, 0, "I");
    (3212, 0, "I");
    (2971, 0, "I");
    (2219, 0, "I");
    (2027, 0, "I");
    (1985, 0, "I");
    (1871, 0, "I");
    (1828, 0, "I");
    (1745, 0, "I");
    (1609, 0, "I");
    (57459, 1, "");
    (57338, 1, "");
    (57187, 1, "");
    (56972, 1, "");
    (56652, 1, "");
    (56482, 1, "");
    (56076, 1, "");
    (55551, 1, "");
    (22236, 1, "");
    (20824, 1, "");
    (20054, 1, "");
    (19869, 1, "");
    (19419, 1, "");
    (19380, 1, "");
    (18695, 1, "");
    (14029, 1, "");
    (12991, 1, "");
    (11876, 1, "");
    (11832, 1, "");
    (11491, 1, "");
    (9237, 1, "");
    (7352, 1, "");
    (5351, 1, "");
    (4083, 1, "");
    (3999, 1, "");
    (3956, 1, "");
    (3528, 1, "");
    (3220, 1, "");
    (2978, 1, "");
    (2225, 1, "");
    (2032, 1, "");
    (1989, 1, "");
    (1874, 1, "");
    (1830, 1, "");
    (1746, 1, "");
    (1609, 1, "");
    (57424, 0, "T");
    (57304, 0, "T");
    (57154, 0, "T");
    (56940, 0, "T");
    (56621, 0, "T");
    (56452, 0, "T");
    (56047, 0, "T");
    (55523, 0, "T");
    (22209, 0, "T");
    (20798, 0, "T");
    (20029, 0, "T");
    (19845, 0, "T");
    (19396, 0, "T");
    (19358, 0, "T");
    (18674, 0, "T");
    (14009, 0, "T");
    (12972, 0, "T");
    (11858, 0, "T");
    (11815, 0, "T");
    (11475, 0, "T");
    (9222, 0, "T");
    (7338, 0, "T");
    (5338, 0, "T");
    (4071, 0, "T");
    (3988, 0, "T");
    (3946, 0, "T");
    (3519, 0, "T");
    (3212, 0, "T");
    (2971, 0, "T");
    (2219, 0, "T");
    (2027, 0, "T");
    (1985, 0, "T");
    (1871, 0, "T");
    (1828, 0, "T");
    (1745, 0, "T");
    (1609, 0, "T");
    (57459, 1, "");
    (57338, 1, "");
    (57187, 1, "");
    (56972, 1, "");
    (56652, 1, "");
    (56482, 1, "");
    (56076, 1, "");
    (55551, 1, "");
    (22236, 1, "");
    (20824, 1, "");
    (20054, 1, "");
    (19869, 1, "");
    (19419, 1, "");
    (19380, 1, "");
    (18695, 1, "");
    (14029, 1, "");
    (12991, 1, "");
    (11876, 1, "");
    (11832, 1, "");
    (11491, 1, "");
    (9237, 1, "");
    (7352, 1, "");
    (5351, 1, "");
    (4083, 1, "");
    (3999, 1, "");
    (3956, 1, "");
    (3528, 1, "");
    (3220, 1, "");
    (2978, 1, "");
    (2225, 1, "");
    (2032, 1, "");
    (1989, 1, "");
    (1874, 1, "");
    (1830, 1, "");
    (1746, 1, "");
    (1609, 1, "");
    (57424, 0, "V");
    (57304, 0, "V");
    (57154, 0, "V");
    (56940, 0, "V");
    (56621, 0, "V");
    (56452, 0, "V");
    (56047, 0, "V");
    (55523, 0, "V");
    (22209, 0, "V");
    (20798, 0, "V");
    (20029, 0, "V");
    (19845, 0, "V");
    (19396, 0, "V");
    (19358, 0, "V");
    (18674, 0, "V");
    (14009, 0, "V");
    (12972, 0, "V");
    (11858, 0, "V");
    (11815, 0, "V");
    (11475, 0, "V");
    (9222, 0, "V");
    (7338, 0, "V");
    (5338, 0, "V");
    (4071, 0, "V");
    (3988, 0, "V");
    (3946, 0, "V");
    (3519, 0, "V");
    (3212, 0, "V");
    (2971, 0, "V");
    (2219, 0, "V");
    (2027, 0, "V");
    (1985, 0, "V");
    (1871, 0, "V");
    (1828, 0, "V");
    (1745, 0, "V");
    (1609, 0, "V");
    (57459, 1, "");
    (57338, 1, "");
    (57187, 1, "");
    (56972, 1, "");
    (56652, 1, "");
    (56482, 1, "");
    (56076, 1, "");
    (55551, 1, "");
    (22236, 1, "");
    (20824, 1, "");
    (20054, 1, "");
    (19869, 1, "");
    (19419, 1, "");
    (19380, 1, "");
    (18695, 1, "");
    (14029, 1, "");
    (12991, 1, "");
    (11876, 1, "");
    (11832, 1, "");
    (11491, 1, "");
    (9237, 1, "");
    (7352, 1, "");
    (5351, 1, "");
    (4083, 1, "");
    (3999, 1, "");
    (3956, 1, "");
    (3528, 1, "");
    (3220, 1, "");
    (2978, 1, "");
    (2225, 1, "");
    (2032, 1, "");
    (1989, 1, "");
    (1874, 1, "");
    (1830, 1, "");
    (1746, 1, "");
    (1609, 1, "");
    (57424, 0, "I");
    (57304, 0, "I");
    (57154, 0, "I");
    (56940, 0, "I");
    (56621, 0, "I");
    (56452, 0, "I");
    (56047, 0, "I");
    (55523, 0, "I");
    (22209, 0, "I");
    (20798, 0, "I");
    (20029, 0, "I");
    (19845, 0, "I");
    (19396, 0, "I");
    (19358, 0, "I");
    (18674, 0, "I");
    (14009, 0, "I");
    (12972, 0, "I");
    (11858, 0, "I");
    (11815, 0, "I");
    (11475, 0, "I");
    (9222, 0, "I");
    (7338, 0, "I");
    (5338, 0, "I");
    (4071, 0, "I");
    (3988, 0, "I");
    (3946, 0, "I");
    (3519, 0, "I");
    (3212, 0, "I");
    (2971, 0, "I");
    (2219, 0, "I");
    (2027, 0, "I");
    (1985, 0, "I");
    (1871, 0, "I");
    (1828, 0, "I");
    (1745, 0, "I");
    (1609, 0, "I");
    (57460, 0, "t");
    (57339, 0, "t");
    (57188, 0, "t");
    (56973, 0, "t");
    (56653, 0, "t");
    (56483, 0, "t");
    (56077, 0, "t");
    (55552, 0, "t");
    (22237, 0, "t");
    (20825, 0, "t");
    (20055, 0, "t");
    (19870, 0, "t");
    (19420, 0, "t");
    (19381, 0, "t");
    (18696, 0, "t");
    (14030, 0, "t");
    (12992, 0, "t");
    (11877, 0, "t");
    (11833, 0, "t");
    (11492, 0, "t");
    (9238, 0, "t");
    (7353, 0, "t");
    (5352, 0, "t");
    (4084, 0, "t");
    (4000, 0, "t");
    (3957, 0, "t");
    (3529, 0, "t");
    (3221, 0, "t");
    (2979, 0, "t");
    (2226, 0, "t");
    (2033, 0, "t");
    (1990, 0, "t");
    (1875, 0, "t");
    (1831, 0, "t");
    (1747, 0, "t");
    (1610, 0, "t");
    (57496, 0, "e");
    (57374, 0, "e");
    (57222, 0, "e");
    (57006, 0, "e");
    (56685, 0, "e");
    (56514, 0, "e");
    (56107, 0, "e");
    (55581, 0, "e");
    (22265, 0, "e");
    (20852, 0, "e");
    (20081, 0, "e");
    (19895, 0, "e");
    (19444, 0, "e");
    (19404, 0, "e");
    (18718, 0, "e");
    (14051, 0, "e");
    (13012, 0, "e");
    (11896, 0, "e");
    (11851, 0, "e");
    (11509, 0, "e");
    (9254, 0, "e");
    (7368, 0, "e");
    (5366, 0, "e");
    (4097, 0, "e");
    (4012, 0, "e");
    (3968, 0, "e");
    (3539, 0, "e");
    (3230, 0, "e");
    (2987, 0, "e");
    (2233, 0, "e");
    (2039, 0, "e");
    (1995, 0, "e");
    (1879, 0, "e");
    (1834, 0, "e");
    (1749, 0, "e");
    (1611, 0, "e");
    (57532, 0, "m");
    (57409, 0, "m");
    (57256, 0, "m");
    (57039, 0, "m");
    (56717, 0, "m");
    (56545, 0, "m");
    (56137, 0, "m");
    (55610, 0, "m");
    (22293, 0, "m");
    (20879, 0, "m");
    (20107, 0, "m");
    (19920, 0, "m");
    (19468, 0, "m");
    (19427, 0, "m");
    (18740, 0, "m");
    (14072, 0, "m");
    (13032, 0, "m");
    (11915, 0, "m");
    (11869, 0, "m");
    (11526, 0, "m");
    (9270, 0, "m");
    (7383, 0, "m");
    (5380, 0, "m");
    (4110, 0, "m");
    (4024, 0, "m");
    (3979, 0, "m");
    (3549, 0, "m");
    (3239, 0, "m");
    (2995, 0, "m");
    (2240, 0, "m");
    (2045, 0, "m");
    (2000, 0, "m");
    (1883, 0, "m");
    (1837, 0, "m");
    (1751, 0, "m");
    (1612, 0, "m");
    (57485, 0, "t");
    (57319, 0, "t");
    (57101, 0, "t");
    (56890, 0, "t");
    (56856, 0, "t");
    (56791, 0, "t");
    (56778, 0, "t");
    (56689, 0, "t");
    (56610, 0, "t");
    (56594, 0, "t");
    (56196, 0, "t");
    (55668, 0, "t");
    (54243, 0, "t");
    (51358, 0, "t");
    (47565, 0, "t");
    (46118, 0, "t");
    (39032, 0, "t");
    (35067, 0, "t");
    (34934, 0, "t");
    (33867, 0, "t");
    (33831, 0, "t");
    (32198, 0, "t");
    (32057, 0, "t");
    (32004, 0, "t");
    (30872, 0, "t");
    (29478, 0, "t");
    (29381, 0, "t");
    (24977, 0, "t");
    (24174, 0, "t");
    (23994, 0, "t");
    (23692, 0, "t");
    (23614, 0, "t");
    (22350, 0, "t");
    (21446, 0, "t");
    (20935, 0, "t");
    (20644, 0, "t");
    (20162, 0, "t");
    (20052, 0, "t");
    (19974, 0, "t");
    (19527, 0, "t");
    (19477, 0, "t");
    (18796, 0, "t");
    (18711, 0, "t");
    (14843, 0, "t");
    (14113, 0, "t");
    (13785, 0, "t");
    (12050, 0, "t");
    (12003, 0, "t");
    (11916, 0, "t");
    (11570, 0, "t");
    (11484, 0, "t");
    (11258, 0, "t");
    (11141, 0, "t");
    (10703, 0, "t");
    (10607, 0, "t");
    (10196, 0, "t");
    (10040, 0, "t");
    (9967, 0, "t");
    (9907, 0, "t");
    (9874, 0, "t");
    (9629, 0, "t");
    (9460, 0, "t");
    (9304, 0, "t");
    (9227, 0, "t");
    (8714, 0, "t");
    (7427, 0, "t");
    (6682, 0, "t");
    (6394, 0, "t");
    (5846, 0, "t");
    (4146, 0, "t");
    (4069, 0, "t");
    (4022, 0, "t");
    (3629, 0, "t");
    (3394, 0, "t");
    (3274, 0, "t");
    (3232, 0, "t");
    (2283, 0, "t");
    (2112, 0, "t");
    (2075, 0, "t");
    (2036, 0, "t");
    (1925, 0, "t");
    (1873, 0, "t");
    (1787, 0, "t");
    (1658, 0, "t");
    (57569, 0, "e");
    (57402, 0, "e");
    (57183, 0, "e");
    (56971, 0, "e");
    (56936, 0, "e");
    (56870, 0, "e");
    (56856, 0, "e");
    (56766, 0, "e");
    (56686, 0, "e");
    (56669, 0, "e");
    (56270, 0, "e");
    (55741, 0, "e");
    (54315, 0, "e");
    (51429, 0, "e");
    (47635, 0, "e");
    (46187, 0, "e");
    (39100, 0, "e");
    (35134, 0, "e");
    (35000, 0, "e");
    (33932, 0, "e");
    (33895, 0, "e");
    (32261, 0, "e");
    (32119, 0, "e");
    (32065, 0, "e");
    (30932, 0, "e");
    (29537, 0, "e");
    (29439, 0, "e");
    (25034, 0, "e");
    (24230, 0, "e");
    (24049, 0, "e");
    (23746, 0, "e");
    (23667, 0, "e");
    (22402, 0, "e");
    (21497, 0, "e");
    (20985, 0, "e");
    (20693, 0, "e");
    (20210, 0, "e");
    (20099, 0, "e");
    (20020, 0, "e");
    (19572, 0, "e");
    (19521, 0, "e");
    (18839, 0, "e");
    (18753, 0, "e");
    (14884, 0, "e");
    (14153, 0, "e");
    (13824, 0, "e");
    (12088, 0, "e");
    (12040, 0, "e");
    (11952, 0, "e");
    (11605, 0, "e");
    (11518, 0, "e");
    (11291, 0, "e");
    (11173, 0, "e");
    (10734, 0, "e");
    (10637, 0, "e");
    (10225, 0, "e");
    (10068, 0, "e");
    (9994, 0, "e");
    (9933, 0, "e");
    (9899, 0, "e");
    (9653, 0, "e");
    (9483, 0, "e");
    (9326, 0, "e");
    (9248, 0, "e");
    (8734, 0, "e");
    (7446, 0, "e");
    (6700, 0, "e");
    (6411, 0, "e");
    (5862, 0, "e");
    (4161, 0, "e");
    (4083, 0, "e");
    (4035, 0, "e");
    (3641, 0, "e");
    (3405, 0, "e");
    (3284, 0, "e");
    (3241, 0, "e");
    (2291, 0, "e");
    (2119, 0, "e");
    (2081, 0, "e");
    (2041, 0, "e");
    (1929, 0, "e");
    (1876, 0, "e");
    (1789, 0, "e");
    (1659, 0, "e");
    (57653, 0, "m");
    (57485, 0, "m");
    (57265, 0, "m");
    (57052, 0, "m");
    (57016, 0, "m");
    (56949, 0, "m");
    (56934, 0, "m");
    (56843, 0, "m");
    (56762, 0, "m");
    (56744, 0, "m");
    (56344, 0, "m");
    (55814, 0, "m");
    (54387, 0, "m");
    (51500, 0, "m");
    (47705, 0, "m");
    (46256, 0, "m");
    (39168, 0, "m");
    (35201, 0, "m");
    (35066, 0, "m");
    (33997, 0, "m");
    (33959, 0, "m");
    (32324, 0, "m");
    (32181, 0, "m");
    (32126, 0, "m");
    (30992, 0, "m");
    (29596, 0, "m");
    (29497, 0, "m");
    (25091, 0, "m");
    (24286, 0, "m");
    (24104, 0, "m");
    (23800, 0, "m");
    (23720, 0, "m");
    (22454, 0, "m");
    (21548, 0, "m");
    (21035, 0, "m");
    (20742, 0, "m");
    (20258, 0, "m");
    (20146, 0, "m");
    (20066, 0, "m");
    (19617, 0, "m");
    (19565, 0, "m");
    (18882, 0, "m");
    (18795, 0, "m");
    (14925, 0, "m");
    (14193, 0, "m");
    (13863, 0, "m");
    (12126, 0, "m");
    (12077, 0, "m");
    (11988, 0, "m");
    (11640, 0, "m");
    (11552, 0, "m");
    (11324, 0, "m");
    (11205, 0, "m");
    (10765, 0, "m");
    (10667, 0, "m");
    (10254, 0, "m");
    (10096, 0, "m");
    (10021, 0, "m");
    (9959, 0, "m");
    (9924, 0, "m");
    (9677, 0, "m");
    (9506, 0, "m");
    (9348, 0, "m");
    (9269, 0, "m");
    (8754, 0, "m");
    (7465, 0, "m");
    (6718, 0, "m");
    (6428, 0, "m");
    (5878, 0, "m");
    (4176, 0, "m");
    (4097, 0, "m");
    (4048, 0, "m");
    (3653, 0, "m");
    (3416, 0, "m");
    (3294, 0, "m");
    (3250, 0, "m");
    (2299, 0, "m");
    (2126, 0, "m");
    (2087, 0, "m");
    (2046, 0, "m");
    (1933, 0, "m");
    (1879, 0, "m");
    (1791, 0, "m");
    (1660, 0, "m");
    (3230, 0, "t");
    (3231, 0, "e");
    (3232, 0, "m");
    (3400, 0, "t");
    (3401, 0, "e");
    (3402, 0, "m");
    (55968, 0, "t");
    (11008, 0, "t");
    (55970, 0, "e");
    (11009, 0, "e");
    (55972, 0, "m");
    (11010, 0, "m");
    (57875, 0, "t");
    (12090, 0, "t");
    (57877, 0, "e");
    (12091, 0, "e");
    (57879, 0, "m");
    (12092, 0, "m");
    (17925, 0, "t");
    (16800, 0, "t");
    (17927, 0, "e");
    (16801, 0, "e");
    (17929, 0, "m");
    (16802, 0, "m");
    (17223, 0, "t");
    (17224, 0, "e");
    (17225, 0, "m");
    (17644, 0, "t");
    (17645, 0, "e");
    (17646, 0, "m");
    (17647, 0, "8");
    (17647, 1, "");
    (20235, 0, "tem");
    (20279, 0, "tem");
    (20360, 0, "tem");
    (20880, 0, "tem");
    (21158, 0, "tem");
    (21185, 0, "tem");
    (22561, 0, "tem");
    (22618, 0, "tem");
    (26088, 0, "tem");
    (34142, 0, "tem");
    (35341, 0, "tem");
    (35438, 0, "tem");
    (35976, 0, "tem");
    (36081, 0, "tem");
    (39321, 0, "tem");
    (39390, 0, "tem");
    (42056, 0, "tem");
    (45682, 0, "tem");
    (48074, 0, "tem");
    (51774, 0, "tem");
    (52744, 0, "tem");
    (53176, 0, "tem");
    (54563, 0, "tem");
    (54998, 0, "tem");
    (55996, 0, "tem");
    (55996, 3, "");
    (57692, 0, "tem");
    (57474, 0, "tem");
    (57145, 0, "tem");
    (56539, 0, "tem");
    (55996, 0, "tem");
    (57498, 0, "tem");
    (57166, 0, "tem");
    (56011, 0, "tem");
    (56984, 0, "tem");
    (58017, 0, "tem");
    (39320, 4, "I");
    (39321, 0, "t");
    (39322, 0, "e");
    (39323, 0, "r");
    (2720, 0, " ");
    (2721, 0, "w");
    (2722, 0, "h");
    (2723, 0, "e");
    (2724, 0, "r");
    (2725, 0, "e");
    (2726, 0, " ");
    (2727, 0, "S");
    (2728, 0, "e");
    (2729, 0, "l");
    (2730, 0, "f");
    (2731, 0, ":");
    (2732, 0, " ");
    (2733, 0, "L");
    (2734, 0, "S");
    (2734, 1, "");
    (2733, 1, "");
    (2733, 0, "S");
    (2734, 0, "i");
    (2735, 0, "z");
    (2736, 0, "e");
    (2737, 0, "d");
    (2720, 18, "");
    (2374, 0, " where Self: Sized");
    (2374, 18, ":");
    (2375, 0, " ");
    (2376, 0, "S");
    (2377, 0, "i");
    (2378, 0, "z");
    (2379, 0, "e");
    (2380, 0, "d");
    (35350, 1, "");
    (35349, 1, "");
    (35348, 1, "");
    (35348, 0, "t");
    (35349, 0, "e");
    (35350, 0, "r");
    (56965, 30, "");
    (56954, 11, "");
    (56907, 0, ": ExactSizeIterator<Item=Item>");
    (56907, 30, "");
    (56954, 0, " where Iter");
    (56965, 0, ": ExactSizeIterator<Item=Item>");
    (56913, 0, "x");
    (56995, 0, "x");
    (56935, 0, "x");
    (56955, 0, "x");
    (57042, 0, "x");
    (57042, 1, "");
    (56955, 1, "");
    (56935, 1, "");
    (56995, 1, "");
    (56913, 1, "");
    (35348, 3, "");
    (35348, 0, "ter");
    (56961, 4, "I");
    (56903, 4, "I");
    (57010, 4, "I");
    (56927, 4, "I");
    (51751, 4, "I");
    (51711, 4, "I");
    (51618, 4, "I");
    (39367, 4, "I");
    (39327, 4, "I");
    (39268, 4, "I");
    (35424, 4, "I");
    (35347, 4, "I");
    (35288, 4, "I");
    (31657, 0, "&");
    (2999, 4, "");
    (2998, 1, "");
    (2997, 1, "");
    (3000, 0, "\n");
    (3001, 0, "\n");
    (3001, 0, "i");
    (3002, 0, "m");
    (3003, 0, "p");
    (3004, 0, "l");
    (3005, 0, " ");
    (3006, 0, "L");
    (3007, 0, "i");
    (3008, 0, "s");
    (3009, 0, "t");
    (3010, 0, "I");
    (3011, 0, "t");
    (3012, 0, "e");
    (3013, 0, "m");
    (3014, 0, " ");
    (3015, 0, "f");
    (3016, 0, "o");
    (3017, 0, "r");
    (3018, 0, " ");
    (3005, 0, "<");
    (3006, 0, "T");
    (3007, 0, ">");
    (3021, 1, "");
    (3017, 0, "<");
    (3018, 0, "T");
    (3019, 0, ">");
    (3024, 0, " ");
    (3025, 0, "T");
    (3026, 0, ":");
    (3027, 0, " ");
    (3028, 0, "S");
    (3029, 0, "i");
    (3030, 0, "z");
    (3031, 0, "e");
    (3032, 0, "d");
    (3033, 0, " ");
    (3034, 0, "{");
    (3035, 0, "}");
    (3021, 3, "w");
    (3022, 0, "h");
    (3023, 0, "e");
    (3024, 0, "r");
    (3025, 0, "e");
    (3020, 0, " ");
    (3021, 0, "f");
    (3022, 0, "o");
    (3023, 0, "r");
    (3024, 0, " ");
    (3025, 0, "T");
    (3019, 1, "");
    (3018, 1, "");
    (3017, 1, "");
    (3000, 42, "");
    (2853, 1, "");
    (2853, 0, "s");
    (55959, 0, ",");
    (55960, 0, " ");
    (55961, 0, "R");
    (55962, 0, "h");
    (55963, 0, "s");
    (55964, 0, ":");
    (55965, 0, " ");
    (55966, 0, "?");
    (55967, 0, "S");
    (55968, 0, "i");
    (55969, 0, "z");
    (55970, 0, "e");
    (55971, 0, "d");
    (55972, 0, " ");
    (55973, 0, "+");
    (55974, 0, " ");
    (55974, 1, "");
    (55973, 1, "");
    (55972, 0, " ");
    (55973, 0, "=");
    (55974, 0, " ");
    (55975, 0, "I");
    (55976, 0, "t");
    (55977, 0, "e");
    (55978, 0, "m");
    (55979, 1, "");
    (56020, 0, "<");
    (56021, 0, "R");
    (56022, 0, "h");
    (56023, 0, "s");
    (56024, 0, ">");
    (56063, 4, "R");
    (56064, 0, "h");
    (56065, 0, "s");
    (55972, 7, "");
    (55959, 13, "");
    (56026, 0, "<");
    (56027, 0, ", Rhs: ?Sized");
    (56040, 0, ">");
    (56028, 1, "");
    (56027, 1, "");
    (55978, 27, "");
    (56042, 0, " ");
    (56043, 0, " where Item: PartialEq<Rhs>");
    (56043, 1, "");
    (56003, 8, "");
    (6963, 45, "");
    (6962, 1, "");
    (6934, 34, "    impl ListItem for Item { }");
    (6962, 1, "");
    (2999, 0, "\n");
    (3000, 0, "\n");
    (3001, 0, "/");
    (3002, 0, "/");
    (3003, 0, " ");
    (3004, 0, "B");
    (3005, 0, "l");
    (3006, 0, "a");
    (3007, 0, "n");
    (3008, 0, "k");
    (3009, 0, "e");
    (3010, 0, "t");
    (3011, 0, " ");
    (3012, 0, "i");
    (3013, 0, "m");
    (3014, 0, "p");
    (3015, 0, "l");
    (3016, 0, "e");
    (3017, 0, "m");
    (3018, 0, "e");
    (3019, 0, "n");
    (3020, 0, "t");
    (3021, 0, "a");
    (3022, 0, "t");
    (3023, 0, "i");
    (3024, 0, "o");
    (3025, 0, "n");
    (3026, 0, "s");
    (3027, 0, " ");
    (3028, 0, "f");
    (3029, 0, "o");
    (3030, 0, "r");
    (3031, 0, " ");
    (3032, 0, "b");
    (3033, 0, "u");
    (3034, 0, "i");
    (3035, 0, "l");
    (3036, 0, "t");
    (3037, 0, "i");
    (3038, 0, "n");
    (3032, 0, "s");
    (3033, 0, "o");
    (3034, 0, "m");
    (3035, 0, "e");
    (3036, 0, " ");
    (3037, 0, "c");
    (3038, 0, "o");
    (3039, 0, "m");
    (3040, 0, "m");
    (3041, 0, "o");
    (3042, 0, "n");
    (3043, 0, " ");
    (3051, 0, " ");
    (3052, 0, "t");
    (3053, 0, "y");
    (3054, 0, "p");
    (3055, 0, "e");
    (3056, 0, "s");
    (3057, 0, ";");
    (3058, 0, " ");
    (3058, 1, "");
    (3057, 1, "");
    (3057, 0, ",");
    (3058, 0, " ");
    (3059, 0, "b");
    (3060, 0, "e");
    (3061, 0, "c");
    (3062, 0, "a");
    (3063, 0, "u");
    (3064, 0, "s");
    (3065, 0, "e");
    (3066, 0, " ");
    (3067, 0, "i");
    (3068, 0, "t");
    (3069, 0, "s");
    (3070, 0, " ");
    (3071, 0, "i");
    (3072, 0, "m");
    (3073, 0, "p");
    (3074, 0, "o");
    (3075, 0, "s");
    (3076, 0, "s");
    (3077, 0, "i");
    (3078, 0, "b");
    (3079, 0, "l");
    (3080, 0, "e");
    (3081, 0, " ");
    (3082, 0, "t");
    (3083, 0, "o");
    (3084, 0, " ");
    (3085, 0, "a");
    (3086, 0, "d");
    (3087, 0, "d");
    (3088, 0, " ");
    (3089, 0, "t");
    (3090, 0, "h");
    (3091, 0, "e");
    (3092, 0, "s");
    (3093, 0, "e");
    (3094, 0, " ");
    (3095, 0, "l");
    (3096, 0, "a");
    (3097, 0, "t");
    (3098, 0, "e");
    (3099, 0, "r");
    (3100, 0, ".");
    (3101, 0, " ");
    (3102, 0, "T");
    (3103, 0, "h");
    (3104, 0, "e");
    (3105, 0, "s");
    (3106, 0, "e");
    (3107, 0, " ");
    (3108, 0, "a");
    (3109, 0, "l");
    (3110, 0, "l");
    (3111, 0, " ");
    (3112, 0, "u");
    (3113, 0, "s");
    (3114, 0, "e");
    (3115, 0, " ");
    (3101, 15, "");
    ( 3001,
      100,
      "// Blanket implementations for some common builtin types, because its \
       impossible\n\
       // to add these later." );
    (3104, 0, "\n");
    (3105, 0, "i");
    (3106, 0, "m");
    (3107, 0, "p");
    (3108, 0, "l");
    (3109, 0, " ");
    (3110, 0, "L");
    (3111, 0, "i");
    (3112, 0, "s");
    (3113, 0, "t");
    (3114, 0, "I");
    (3115, 0, "t");
    (3116, 0, "e");
    (3117, 0, "m");
    (3118, 0, " ");
    (3119, 0, "f");
    (3120, 0, "o");
    (3121, 0, "r");
    (3122, 0, " ");
    (3123, 0, "u");
    (3124, 0, "8");
    (3125, 0, " ");
    (3126, 0, "{");
    (3127, 0, "}");
    (3105, 0, "impl ListItem for u8 {}\n");
    (3129, 0, "impl ListItem for u8 {}\n");
    (3153, 0, "impl ListItem for u8 {}\n");
    (3177, 0, "impl ListItem for u8 {}\n");
    (3147, 1, "");
    (3147, 0, "s");
    (3172, 1, "");
    (3172, 0, "1");
    (3173, 0, "6");
    (3197, 1, "");
    (3197, 0, "3");
    (3198, 0, "2");
    (3222, 1, "");
    (3221, 1, "");
    (3221, 0, "f");
    (3222, 0, "3");
    (3223, 0, "2");
    (3203, 0, "impl ListItem for f32 {}\n");
    (3248, 1, "");
    (3247, 1, "");
    (3247, 0, "6");
    (3248, 0, "4");
    (3128, 24, "");
    (3129, 0, "impl ListItem for u16 {}\n");
    (3172, 1, "");
    (3172, 0, "s");
    (3179, 0, "impl ListItem for u32 {}\n");
    (3222, 1, "");
    (3222, 0, "s");
    (3172, 1, "");
    (3172, 0, "i");
    (3222, 1, "");
    (3222, 0, "i");
    (3105, 0, "impl ListItem for u8 {}\n");
    (3147, 1, "");
    (3147, 0, "i");
    (3128, 0, "\nimpl ListItem for u8 {}");
    (3124, 1, "");
    (3123, 1, "");
    (3123, 0, "(");
    (3124, 0, ")");
    (3128, 0, "\n");
    (3128, 1, "");
    (3105, 0, "impl ListItem for () {}\n");
    (3133, 0, "<");
    (3134, 0, "X");
    (3135, 0, ",");
    (3136, 0, " ");
    (3137, 0, "Y");
    (3138, 0, ">");
    (3154, 0, "X");
    (3155, 0, ",");
    (3156, 0, " ");
    (3157, 0, "Y");
    (3129, 0, "impl<X, Y> ListItem for (X, Y) {}\n");
    (3172, 0, ",");
    (3173, 0, " ");
    (3174, 0, "Z");
    (3195, 0, ",");
    (3196, 0, " ");
    (3197, 0, "Z");
    (3163, 0, "impl<X, Y, Z> ListItem for (X, Y, Z) {}\n");
    (3207, 9, "");
    (3207, 0, "<");
    (3208, 0, "V");
    (3209, 0, ">");
    (3224, 9, "");
    (3224, 0, "O");
    (3225, 0, "p");
    (3226, 0, "t");
    (3227, 0, "i");
    (3228, 0, "o");
    (3229, 0, "n");
    (3230, 0, "<");
    (3231, 0, "V");
    (3232, 0, ">");
    (3236, 0, "\n");
    (3203, 0, "impl<V> ListItem for Option<V> {}\n");
    (3242, 1, "");
    (3242, 0, "E");
    (3243, 0, ",");
    (3244, 0, " ");
    (3245, 0, "R");
    (3261, 6, "R");
    (3262, 0, "e");
    (3263, 0, "s");
    (3264, 0, "u");
    (3265, 0, "l");
    (3266, 0, "t");
    (3268, 1, "");
    (3268, 0, "E");
    (3269, 0, ",");
    (3270, 0, " ");
    (3271, 0, "R");
    (3268, 4, "T");
    (3242, 4, "T");
    (3266, 0, ",");
    (3243, 0, ",");
    (3268, 0, " ");
    (3244, 0, " ");
    (3270, 0, "E");
    (3245, 0, "E");
    (3104, 0, " ");
    (3105, 0, "T");
    (3106, 0, "h");
    (3107, 0, "e");
    (3108, 0, "s");
    (3109, 0, "e");
    (3110, 0, " ");
    (3111, 0, "a");
    (3112, 0, "l");
    (3113, 0, "l");
    (3114, 0, " ");
    (3115, 0, "m");
    (3116, 0, "a");
    (3117, 0, "k");
    (3118, 0, "e");
    (3119, 0, " ");
    (3120, 0, "e");
    (3121, 0, "a");
    (3122, 0, "c");
    (3123, 0, "h");
    (3124, 0, " ");
    (3115, 10, "s");
    (3116, 0, "e");
    (3116, 1, "");
    (3115, 1, "");
    (3115, 0, "u");
    (3116, 0, "s");
    (3117, 0, "e");
    (3118, 0, " ");
    (3115, 4, "m");
    (3116, 0, "a");
    (3117, 0, "k");
    (3118, 0, "e");
    (3119, 0, " ");
    (3120, 0, "e");
    (3121, 0, "v");
    (3122, 0, "e");
    (3123, 0, "r");
    (3124, 0, "y");
    (3125, 0, "t");
    (3126, 0, "h");
    (3127, 0, "i");
    (3128, 0, "n");
    (3129, 0, "g");
    (3130, 0, " ");
    (3131, 0, "a");
    (3131, 1, "");
    (3131, 0, "h");
    (3132, 0, "a");
    (3133, 0, "v");
    (3134, 0, "e");
    (3135, 0, " ");
    (3136, 0, "a");
    (3137, 0, " ");
    (3138, 0, "s");
    (3139, 0, "i");
    (3140, 0, "z");
    (3141, 0, "e");
    (3142, 0, " ");
    (3143, 0, "o");
    (3144, 0, "f");
    (3145, 0, " ");
    (3146, 0, "1");
    (3147, 0, ".");
    (3111, 8, "m");
    (3112, 0, "a");
    (3113, 0, "k");
    (3114, 0, "e");
    (3115, 0, " ");
    (3116, 0, "e");
    (3117, 0, "v");
    (3118, 0, "e");
    (3119, 0, "r");
    (3120, 0, "y");
    (3121, 0, " ");
    (3122, 0, "i");
    (3123, 0, "t");
    (3124, 0, "e");
    (3125, 0, "m");
    (3126, 11, "");
    ( 3318,
      0,
      "impl ListItem for u8 {}\n\
       impl ListItem for i8 {}\n\
       impl ListItem for u16 {}\n\
       impl ListItem for i16 {}\n\
       impl ListItem for u32 {}\n\
       impl ListItem for i32 {}\n\
       impl ListItem for f32 {}\n\
       impl ListItem for f64 {}\n" );
    (3516, 0, "\n");
    (3535, 0, "&");
    (3560, 0, "&");
    (3710, 0, "&");
    (3685, 0, "&");
    (3660, 0, "&");
    (3635, 0, "&");
    (3610, 0, "&");
    (3585, 0, "&");
    ( 3169,
      0,
      "impl<X, Y> ListItem for (X, Y) {}\n\
       impl<X, Y, Z> ListItem for (X, Y, Z) {}\n\
       impl<V> ListItem for Option<V> {}\n\
       impl<T, E> ListItem for Result<T, E> {}\n" );
    (3449, 0, "&");
    (3412, 0, "&");
    (3378, 0, "&");
    (3341, 0, "&");
    (3316, 0, "\n");
    (4315, 0, "\n    ");
    (4320, 0, "f");
    (4321, 0, "n");
    (4322, 0, " ");
    (4323, 0, "n");
    (4324, 0, "o");
    (4325, 0, "t");
    (4326, 0, "i");
    (4327, 0, "f");
    (4328, 0, "y");
    (4329, 0, "_");
    (4330, 0, "r");
    (4331, 0, "e");
    (4332, 0, "m");
    (4333, 0, "o");
    (4334, 0, "v");
    (4335, 0, "e");
    (4336, 0, "d");
    (4254, 0, "_");
    (4255, 0, "c");
    (4256, 0, "h");
    (4257, 0, "a");
    (4258, 0, "n");
    (4259, 0, "g");
    (4260, 0, "e");
    (4261, 0, "d");
    (4345, 0, "(");
    (4346, 0, "*");
    (4346, 1, "");
    (4346, 0, "&");
    (4347, 0, "m");
    (4348, 0, "u");
    (4349, 0, "t");
    (4350, 0, " ");
    (4351, 0, "s");
    (4352, 0, "e");
    (4353, 0, "l");
    (4354, 0, "f");
    (4355, 0, " ");
    (4355, 1, "");
    (4355, 0, ",");
    (4356, 0, " ");
    (4357, 0, "_");
    (4328, 30, "");
    (4142, 0, "\n    ");
    (4147, 0, "fn notify_removed(&mut self, _");
    (4176, 1, "");
    (4176, 0, "k");
    (4177, 0, "t");
    (4178, 0, "e");
    (4179, 0, "m");
    (4179, 1, "");
    (4178, 1, "");
    (4177, 1, "");
    (4176, 1, "");
    (4176, 0, "i");
    (4177, 0, "t");
    (4178, 0, "e");
    (4179, 0, "m");
    (4180, 0, "s");
    (4181, 0, ":");
    (4182, 0, " ");
    (4183, 0, "*");
    (4183, 1, "");
    (4183, 0, "&");
    (4184, 0, "[");
    (4185, 0, "I");
    (4186, 0, "t");
    (4187, 0, "e");
    (4188, 0, "m");
    (4189, 0, "]");
    (4190, 0, ")");
    (4191, 0, ";");
    (4304, 8, "");
    (4370, 0, "fn notify_removed(&mut self, items: &[Item]);");
    (4415, 0, " ");
    (4416, 0, "{");
    (4417, 0, "}");
    (4414, 1, "");
    (4399, 0, "_");
    (47346, 0, ", notify: &mut N");
    (48739, 0, "\n                ");
    (48756, 0, "n");
    (48757, 0, "o");
    (48758, 0, "t");
    (48759, 0, "i");
    (48760, 0, "f");
    (48761, 0, "y");
    (48762, 0, ".");
    (48763, 0, "notify_removed(items: &[Item])");
    (48778, 14, "c");
    (48779, 0, "[");
    (48778, 2, "item_idx..item_idx + removed_here");
    (48812, 0, ";");
    (48778, 0, "c");
    (48779, 0, "[");
    (48813, 0, "]");
    (48778, 0, " ");
    (48778, 0, "m");
    (48779, 0, "a");
    (48780, 0, "y");
    (48781, 0, "b");
    (48778, 4, "maybeinit_slice_get_ref(slice: &[MaybeUninit<T>])");
    (48802, 24, "");
    (48802, 1, "");
    (48802, 1, "");
    (48839, 0, "\n                ");
    (48856, 0, "0");
    (48856, 1, "");
    (48852, 4, "");
    (48848, 4, "");
    (48844, 4, "");
    (48840, 4, "");
    (48839, 1, "");
    (48839, 0, ")");
    (48802, 0, "&");
    (48739, 0, "\n                ");
    (48756, 0, "i");
    (48757, 0, "f");
    (48758, 0, " ");
    (48759, 0, "(");
    (48760, 0, "n");
    (48761, 0, "o");
    (48762, 0, "t");
    (48763, 0, "i");
    (48763, 1, "");
    (48762, 1, "");
    (48761, 1, "");
    (48760, 1, "");
    (48759, 1, "");
    (48759, 0, "n");
    (48760, 0, "o");
    (48761, 0, "t");
    (48762, 0, "i");
    (48763, 0, "f");
    (48764, 0, "y");
    (48765, 0, ".");
    (48766, 0, "n");
    (48767, 0, "o");
    (48768, 0, "t");
    (48769, 0, "i");
    (48770, 0, "f");
    (48771, 0, "i");
    (48766, 6, "");
    (48765, 1, "");
    (48765, 0, ".");
    (48759, 7, "N");
    (48760, 0, ":");
    (48761, 0, ":");
    (48762, 0, "notifications_used()");
    (48782, 0, " ");
    (48783, 0, "{");
    (48887, 0, "\n                ");
    (48888, 16, "                }");
    (48801, 0, "    ");
    (48784, 0, "\n                    ");
    (48784, 21, "");
    (48739, 0, "\n                ");
    (48756, 0, "/");
    (48757, 0, "/");
    (48758, 0, " ");
    (48759, 0, "G");
    (48760, 0, "u");
    (48761, 0, "a");
    (48762, 0, "r");
    (48763, 0, "d");
    (48764, 0, " ");
    (48765, 0, "m");
    (48766, 0, "a");
    (48767, 0, "y");
    (48768, 0, " ");
    (48769, 0, "h");
    (48770, 0, "a");
    (48771, 0, "v");
    (48772, 0, "e");
    (48773, 0, " ");
    (48774, 0, "n");
    (48775, 0, "o");
    (48776, 0, " ");
    (48777, 0, "e");
    (48778, 0, "f");
    (48779, 0, "f");
    (48780, 0, "e");
    (48781, 0, "c");
    (48782, 0, "c");
    (48783, 0, "t");
    (48783, 1, "");
    (48782, 1, "");
    (48782, 0, "t");
    (48783, 0, ".");
    (48784, 0, " ");
    (48785, 0, "N");
    (48786, 0, "o");
    (48787, 0, "t");
    (48788, 0, " ");
    (48789, 0, "s");
    (48790, 0, "u");
    (48791, 0, "r");
    (48792, 0, "e");
    (48793, 0, " ");
    (48794, 0, "h");
    (48795, 0, "o");
    (48796, 0, "w");
    (48797, 0, " ");
    (4244, 0, "\n    ");
    (4249, 0, "c");
    (4250, 0, "o");
    (4251, 0, "n");
    (4252, 0, "s");
    (4253, 0, "t");
    (4254, 0, " ");
    (4255, 0, "f");
    (4256, 0, "o");
    (4257, 0, "o");
    (4258, 0, ":");
    (4259, 0, " ");
    (4260, 0, "b");
    (4261, 0, "o");
    (4262, 0, "o");
    (4263, 0, "l");
    (4264, 0, ",");
    (4264, 1, "");
    (4264, 0, ";");
    (4245, 20, "");
    (3917, 0, "\n    ");
    (3922, 0, "    const foo: bool;");
    (3918, 8, "    ");
    (3938, 0, "\n    ");
    (3939, 4, "");
    (3928, 3, "n");
    (3929, 0, "o");
    (3930, 0, "t");
    (3931, 0, "i");
    (3932, 0, "f");
    (3933, 0, "i");
    (3928, 6, "notifications_used()");
    (3947, 1, "");
    (3946, 1, "");
    (3954, 154, "");
    (4133, 2, "c");
    (4134, 0, "n");
    (4134, 1, "");
    (4134, 0, "o");
    (4135, 0, "n");
    (4136, 0, "s");
    (4137, 0, "t");
    (4127, 1, "");
    (3952, 0, " ");
    (3953, 0, "=");
    (3954, 0, " ");
    (3955, 0, "t");
    (3956, 0, "r");
    (3957, 0, "u");
    (3958, 0, "e");
    (4139, 44, "const notifications_used: bool = true;");
    (4172, 5, "f");
    (4173, 0, "a");
    (4174, 0, "l");
    (4175, 0, "s");
    (4176, 0, "e");
    (4177, 0, ";");
    (4163, 6, "");
    (4139, 6, "");
    (4139, 0, "const ");
    (4163, 0, ": bool");
    (3928, 18, "u");
    (3929, 0, "s");
    (3930, 0, "e");
    (3931, 0, "d");
    (4131, 18, "u");
    (4132, 0, "s");
    (4133, 0, "e");
    (4134, 0, "d");
    (25340, 20, "u");
    (25341, 0, "s");
    (25342, 0, "e");
    (25343, 0, "d");
    (48665, 20, "u");
    (48666, 0, "s");
    (48667, 0, "e");
    (48668, 0, "d");
    (55432, 0, "&");
    (55432, 1, "");
    (55432, 0, ",");
    (55433, 0, " ");
    (55434, 0, "n");
    (55435, 0, "o");
    (55436, 0, "t");
    (55437, 0, "i");
    (55438, 0, "f");
    (55439, 0, "y");
    (48584, 59, "");
    (48737, 0, "\n                ");
    (49821, 0, "\n                ");
    (48738, 16, "");
    (49822, 0, "\n                ");
    (49806, 16, "");
    ( 49823,
      0,
      "                if N::used {\n\
      \                    \
       notify.notify_removed(maybeinit_slice_get_ref(&c[item_idx..item_idx + \
       removed_here]));\n\
      \                }\n" );
    (49807, 32, "                ");
    (49960, 1, "");
    (49878, 62, "");
    (49878, 0, "*");
    (49879, 0, "(");
    (49880, 0, "e");
    (49881, 0, ")");
    (49881, 1, "");
    (49880, 1, "");
    (49879, 1, "");
    (49878, 1, "");
    (49878, 0, "*");
    (49878, 1, "");
    (49878, 0, "(");
    (49879, 0, "E");
    (49879, 1, "");
    (49879, 0, "*");
    (49880, 0, "e");
    (49881, 0, ")");
    (49882, 0, ".");
    (49883, 0, "g");
    (49884, 0, "e");
    (49885, 0, "t");
    (49886, 0, "_");
    (49887, 0, "c");
    (49888, 0, "o");
    (49889, 0, "n");
    (49890, 0, "t");
    (49891, 0, "e");
    (49892, 0, "n");
    (49893, 0, "t");
    (49894, 0, "(");
    (49895, 0, ")");
    (49883, 11, "c");
    (49884, 0, "o");
    (49885, 0, "n");
    (49886, 0, "t");
    (49887, 0, "e");
    (49888, 0, "n");
    (49889, 0, "t");
    (49883, 7, "content_slice");
    (49829, 4, "USED");
    (48606, 4, "USED");
    (25340, 4, "USED");
    (3928, 4, "USED");
    (4131, 4, "U");
    (4132, 0, "S");
    (4133, 0, "E");
    (4134, 0, "D");
    (58117, 0, "\n");
    (58117, 0, "\n");
    (58118, 0, "i");
    (58119, 0, "m");
    (58120, 0, "p");
    (58121, 0, "l");
    (58122, 0, "<");
    (58123, 0, "I");
    (58123, 1, "");
    (58122, 1, "");
    (58121, 1, "");
    (58120, 1, "");
    (58119, 1, "");
    (58118, 1, "");
    (58118, 0, "i");
    (58119, 0, "m");
    (58120, 0, "p");
    (58121, 0, "l");
    (58122, 0, "<");
    (58123, 0, "I");
    (58124, 0, "t");
    (58125, 0, "e");
    (58126, 0, "m");
    (58127, 0, ":");
    (58128, 0, " ");
    (58129, 0, "L");
    (58130, 0, "i");
    (58131, 0, "s");
    (58132, 0, "t");
    (58129, 4, "ListItem");
    (58137, 0, ">");
    (58138, 0, " ");
    (58139, 0, "F");
    (58140, 0, "r");
    (58141, 0, "o");
    (58142, 0, "m");
    (58143, 0, "I");
    (58144, 0, "t");
    (58145, 0, "e");
    (58146, 0, "r");
    (58147, 0, "a");
    (58148, 0, "t");
    (58149, 0, "o");
    (58150, 0, "r");
    (58139, 0, "i");
    (58140, 0, "t");
    (58141, 0, "e");
    (58142, 0, "r");
    (58143, 0, ":");
    (58144, 0, ":");
    (58139, 0, "s");
    (58140, 0, "t");
    (58141, 0, "d");
    (58142, 0, ":");
    (58143, 0, ":");
    (58162, 0, " ");
    (58163, 0, "f");
    (58164, 0, "o");
    (58165, 0, "r");
    (58166, 0, " ");
    (58167, 0, "S");
    (58168, 0, "k");
    (58169, 0, "i");
    (58170, 0, "p");
    (58167, 4, "SkipList");
    (58175, 0, "<");
    (58176, 0, "I");
    (58177, 0, "t");
    (58178, 0, "e");
    (58179, 0, "m");
    (58180, 0, ">");
    (58181, 0, " ");
    (58182, 0, "{");
    (58183, 0, "\n    ");
    (58188, 0, "\n    ");
    (58184, 4, "");
    (58185, 4, "}");
    (58139, 5, "");
    (58179, 0, "fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;");
    (58179, 0, "    ");
    (58239, 1, "");
    (58239, 0, " ");
    (58240, 0, "{");
    (58241, 0, "\n        ");
    (58250, 0, "\n        ");
    (58242, 8, "");
    (58243, 8, "    }");
    (58242, 0, "        ");
    (58242, 8, "");
    (58219, 1, "");
    (58219, 0, "I");
    (58220, 0, "t");
    (58221, 0, "e");
    (58222, 0, "m");
    (58218, 1, "");
    (58216, 1, "");
    (58216, 0, " ");
    (58218, 0, " ");
    (58245, 0, "        ");
    (58253, 0, "S");
    (58254, 0, "k");
    (58255, 0, "i");
    (58256, 0, "p");
    (58253, 4, "SkipList");
    (58261, 0, "<");
    (58261, 1, "");
    (58261, 0, ":");
    (58262, 0, ":");
    (58263, 0, "n");
    (58264, 0, "e");
    (58265, 0, "w");
    (58265, 1, "");
    (58264, 1, "");
    (58263, 1, "");
    (58263, 0, "from(iter: I)");
    (58268, 7, "i");
    (58269, 0, "t");
    (58270, 0, "e");
    (58271, 0, "r");
    (58267, 0, "_");
    (58268, 0, "i");
    (58269, 0, "t");
    (58270, 0, "e");
    (58271, 0, "r");
    (58157, 0, "<");
    (58158, 0, "I");
    (58159, 0, "t");
    (58160, 0, "e");
    (58161, 0, "m");
    (58162, 0, ">");
    (58269, 9, "n");
    (58270, 0, "e");
    (58271, 0, "w");
    (58272, 0, "_");
    (58273, 0, "f");
    (58274, 0, "r");
    (58275, 0, "o");
    (58276, 0, "m");
    (58269, 8, "new_from_iter");
    (58182, 0, " ");
    (58183, 0, "w");
    (58184, 0, "h");
    (58185, 0, "e");
    (58186, 0, "r");
    (58187, 0, "e");
    (58188, 0, " ");
    (58182, 7, "");
    (58295, 0, "// ");
    (58289, 0, "// ");
    (58251, 0, "// ");
    (58185, 0, "// ");
    (58118, 0, "// ");
    (58117, 0, "\n");
    (58118, 0, "/");
    (58119, 0, "/");
    (58120, 0, " ");
    (58121, 0, "N");
    (58122, 0, "e");
    (58123, 0, "e");
    (58124, 0, "d");
    (58125, 0, "s");
    (58126, 0, " ");
    (58127, 0, "m");
    (58128, 0, "e");
    (58129, 0, " ");
    (58130, 0, "t");
    (58131, 0, "o");
    (58132, 0, " ");
    (58133, 0, "r");
    (58134, 0, "e");
    (58135, 0, "l");
    (58136, 0, "a");
    (58137, 0, "x");
    (58138, 0, " ");
    (58139, 0, "t");
    (58140, 0, "h");
    (58141, 0, "e");
    (58142, 0, " ");
    (58143, 0, "E");
    (58144, 0, "x");
    (58145, 0, "a");
    (58146, 0, "c");
    (58147, 0, "t");
    (58148, 0, "I");
    (58148, 1, "");
    (58148, 0, "S");
    (58149, 0, "i");
    (58150, 0, "z");
    (58151, 0, "e");
    (58152, 0, "I");
    (58153, 0, "t");
    (58154, 0, "e");
    (58155, 0, "r");
    (58156, 0, "a");
    (58157, 0, "t");
    (58158, 0, "o");
    (58159, 0, "r");
    (58160, 0, " ");
    (58161, 0, "c");
    (58162, 0, "o");
    (58163, 0, "n");
    (58164, 0, "s");
    (58165, 0, "t");
    (58166, 0, "r");
    (58167, 0, "a");
    (58168, 0, "i");
    (58169, 0, "t");
    (58170, 0, "n");
    (58170, 1, "");
    (58169, 1, "");
    (58169, 0, "n");
    (58170, 0, "t");
    (58171, 0, " ");
    (58172, 0, "o");
    (58173, 0, "n");
    (58174, 0, " ");
    (58175, 0, "i");
    (58176, 0, "n");
    (58177, 0, "s");
    (58178, 0, "e");
    (58179, 0, "r");
    (58180, 0, "t");
    (58181, 0, ".");
    (59202, 0, "O");
    (59203, 0, "p");
    (59204, 0, "t");
    (59205, 0, "i");
    (59206, 0, "o");
    (59207, 0, "n");
    (59208, 0, "<");
    (59214, 0, ">");
    (59795, 0, "\n        ");
    (59804, 0, "i");
    (59805, 0, "f");
    (59806, 0, " ");
    (59807, 0, "l");
    (59808, 0, "e");
    (59809, 0, "t");
    (59810, 0, " ");
    (59811, 0, "s");
    (59812, 0, "e");
    (59813, 0, "l");
    (59814, 0, "f");
    (59815, 0, ".");
    (59816, 0, "r");
    (59817, 0, "e");
    (59818, 0, "m");
    (59819, 0, "a");
    (59816, 4, "remaining_items");
    (59810, 0, " ");
    (59811, 0, "r");
    (59812, 0, " ");
    (59813, 0, "=");
    (59835, 0, " ");
    (59836, 0, "{");
    (59846, 0, "    ");
    (59900, 0, "\n            ");
    (59901, 12, "        }");
    (59910, 0, " ");
    (59911, 0, "e");
    (59912, 0, "l");
    (59913, 0, "s");
    (59914, 0, "e");
    (59915, 0, " ");
    (59916, 0, "{");
    (59917, 0, "\n            ");
    (59930, 0, "(");
    (59931, 0, "0");
    (59932, 0, ",");
    (59933, 0, " ");
    (59934, 0, "N");
    (59935, 0, "o");
    (59936, 0, "n");
    (59937, 0, "e");
    (59938, 0, ")");
    (59939, 0, "\n            ");
    (59940, 12, "        }");
    (59878, 20, "r");
    (59851, 20, "r");
    (59811, 0, "S");
    (59812, 0, "o");
    (59813, 0, "m");
    (59814, 0, "e");
    (59815, 0, "(");
    (59817, 0, ")");
    (59232, 1, "");
    (59232, 0, ",");
    (59233, 0, " ");
    (59234, 0, "o");
    (59234, 1, "");
    (59234, 0, "i");
    (59235, 0, "f");
    (59236, 0, " ");
    (59237, 0, "k");
    (59238, 0, "n");
    (59239, 0, "o");
    (59240, 0, "w");
    (59241, 0, "n");
    (59242, 0, ".");
    (24805, 0, "S");
    (24806, 0, "o");
    (24807, 0, "m");
    (24808, 0, "e");
    (24809, 0, "(");
    (24826, 0, ")");
    (24843, 0, "\n    ");
    (24848, 0, "\n    ");
    (24844, 4, "");
    (24849, 0, "f");
    (24850, 0, "n");
    (24851, 0, " ");
    (24852, 0, "i");
    (24853, 0, "t");
    (24854, 0, "e");
    (24855, 0, "r");
    (24856, 0, "_");
    (24857, 0, "f");
    (24858, 0, "r");
    (24859, 0, "o");
    (24860, 0, "m");
    (24861, 0, "_");
    (24862, 0, "n");
    (24863, 0, "o");
    (24864, 0, "d");
    (24865, 0, "e");
    (24849, 0, "p");
    (24850, 0, "u");
    (24851, 0, "b");
    (24852, 0, "(");
    (24853, 0, "c");
    (24854, 0, "r");
    (24855, 0, "a");
    (24856, 0, "t");
    (24857, 0, "e");
    (24858, 0, ")");
    (24859, 0, " ");
    (24877, 0, "(");
    (24843, 35, "");
    (12430, 0, "\n    ");
    (12435, 0, "\n    ");
    (12431, 4, "");
    ( 12436,
      0,
      "\n\
      \    pub fn iter(&self) -> ListItemIter<Item> {\n\
      \        ListItemIter {\n\
      \            node: Some(&self.head),\n\
      \            index: 0,\n\
      \            remaining_items: Some(self.len_items())\n\
      \        }\n\
      \    }" );
    (12432, 4, "");
    (12431, 1, "");
    (12430, 1, "");
    (12430, 0, "\n    ");
    (12443, 0, "(");
    (12431, 4, "");
    (12440, 0, "c");
    (12441, 0, "r");
    (12442, 0, "a");
    (12443, 0, "t");
    (12444, 0, "e");
    (12445, 0, ")");
    (12460, 0, ",");
    (12461, 0, " ");
    (12462, 0, "u");
    (12463, 0, "s");
    (12464, 0, "i");
    (12465, 0, "z");
    (12466, 0, "e");
    (12462, 0, "i");
    (12463, 0, "n");
    (12464, 0, "d");
    (12465, 0, "e");
    (12466, 0, "x");
    (12467, 0, ":");
    (12468, 0, " ");
    (12462, 0, "l");
    (12463, 0, "o");
    (12464, 0, "c");
    (12465, 0, "a");
    (12466, 0, "l");
    (12467, 0, "_");
    (12557, 5, "");
    (12611, 22, "N");
    (12612, 0, "o");
    (12613, 0, "n");
    (12614, 0, "e");
    (12614, 1, "");
    (12614, 0, "e");
    (12580, 1, "");
    (12579, 1, "");
    (12579, 0, "l");
    (12580, 0, "o");
    (12581, 0, "c");
    (12582, 0, "a");
    (12583, 0, "l");
    (12579, 5, "local_index");
    (12590, 0, ",");
    (3594, 0, "impl ListItem for i32 {}\n");
    (3619, 0, "impl ListItem for i32 {}\n");
    (3637, 3, "u");
    (3638, 0, "s");
    (3639, 0, "i");
    (3640, 0, "z");
    (3641, 0, "e");
    (3664, 3, "i");
    (3665, 0, "s");
    (3666, 0, "i");
    (3667, 0, "z");
    (3668, 0, "e");
    (3852, 0, "impl ListItem for &i32 {}\n");
    (3878, 0, "impl ListItem for &i32 {}\n");
    (3897, 3, "u");
    (3898, 0, "s");
    (3899, 0, "i");
    (3900, 0, "z");
    (3901, 0, "e");
    (3925, 3, "i");
    (3926, 0, "s");
    (3927, 0, "i");
    (3928, 0, "z");
    (3929, 0, "e");
    (50203, 1, "");
    (50199, 3, "t");
    (50197, 1, "del");
    (50192, 4, "n");
    (50190, 1, "");
    (48980, 1, "");
    (48976, 3, "t");
    (48974, 1, "del");
    (48969, 4, "n");
    (48967, 1, "");
    (4356, 1, "");
    (4352, 3, "t");
    (4350, 1, "del");
    (4345, 4, "n");
    (4343, 1, "");
    (4149, 1, "");
    (4145, 3, "t");
    (4143, 1, "del");
    (4138, 4, "n");
    (4136, 1, "");
    (55274, 3, "");
    (55272, 1, "_se");
    (55271, 0, "o");
    (43854, 3, "");
    (43852, 1, "_se");
    (43851, 0, "o");
    (40082, 3, "");
    (40080, 1, "_se");
    (40079, 0, "o");
    (4266, 3, "");
    (4264, 1, "_se");
    (4263, 0, "o");
    (4068, 3, "");
    (4066, 1, "_se");
    (4065, 0, "o");
    (2354, 0, "\n");
    (2355, 0, "\n");
    ( 2356,
      0,
      "//! Utilities for formatting and printing strings.\n\n\
       #![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n\
       use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n\
       use crate::marker::PhantomData;\n\
       use crate::mem;\n\
       use crate::num::flt2dec;\n\
       use crate::ops::Deref;\n\
       use crate::result;\n\
       use crate::str;\n\n\
       mod builders;\n\
       mod float;\n\
       mod num;\n\n\
       #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
       /// Possible alignments returned by `Formatter::align`\n\
       #[derive(Debug)]\n\
       pub enum Alignment {\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be left-aligned.\n\
      \    Left,\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be right-aligned.\n\
      \    Right,\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be center-aligned.\n\
      \    Center,\n\
       }\n\n\
       #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
       pub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, \
       DebugTuple};\n\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       #[doc(hidden)]\n\
       pub mod rt {\n\
      \    pub mod v1;\n\
       }\n\n\
       /// The type returned by formatter methods.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// #[derive(Debug)]\n\
       /// struct Triangle {\n\
       ///     a: f32,\n\
       ///     b: f32,\n\
       ///     c: f32\n\
       /// }\n\
       ///\n\
       /// impl fmt::Display for Triangle {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n\
       ///\n\
       /// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub type Result = result::Result<(), Error>;\n\n\
       /// The error type which is returned from formatting a message into a \
       stream.\n\
       ///\n\
       /// This type does not support transmission of an error other than that \
       an error\n\
       /// occurred. Any extra information must be arranged to be transmitted \
       through\n\
       /// some other means.\n\
       ///\n\
       /// An important thing to remember is that the type `fmt::Error` should \
       not be\n\
       /// confused with [`std::io::Error`] or [`std::error::Error`], which \
       you may also\n\
       /// have in scope.\n\
       ///\n\
       /// [`std::io::Error`]: ../../std/io/struct.Error.html\n\
       /// [`std::error::Error`]: ../../std/error/trait.Error.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// ```rust\n\
       /// use std::fmt::{self, write};\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// if let Err(fmt::Error) = write(&mut output, format_args!(\"Hello \
       {}!\", \"world\")) {\n\
       ///     panic!(\"An error occurred\");\n\
       /// }\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, \
       PartialOrd)]\n\
       pub struct Error;\n\n\
       /// A collection of methods that are required to format a message into \
       a stream.\n\
       ///\n\
       /// This trait is the type which this modules requires when formatting\n\
       /// information. This is similar to the standard library's \
       [`io::Write`] trait,\n\
       /// but it is only intended for use in libcore.\n\
       ///\n\
       /// This trait should generally not be implemented by consumers of the \
       standard\n\
       /// library. The [`write!`] macro accepts an instance of [`io::Write`], \
       and the\n\
       /// [`io::Write`] trait is favored over implementing this trait.\n\
       ///\n\
       /// [`write!`]: ../../std/macro.write.html\n\
       /// [`io::Write`]: ../../std/io/trait.Write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Write {\n\
      \    /// Writes a string slice into this writer, returning whether the \
       write\n\
      \    /// succeeded.\n\
      \    ///\n\
      \    /// This method can only succeed if the entire string slice was \
       successfully\n\
      \    /// written, and this method will not return until all data has been\n\
      \    /// written or an error occurs.\n\
      \    ///\n\
      \    /// # Errors\n\
      \    ///\n\
      \    /// This function will return an instance of [`Error`] on error.\n\
      \    ///\n\
      \    /// [`Error`]: struct.Error.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n\
      \    ///     f.write_str(s)\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, \"hola\").unwrap();\n\
      \    /// assert_eq!(&buf, \"hola\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn write_str(&mut self, s: &str) -> Result;\n\n\
      \    /// Writes a [`char`] into this writer, returning whether the write \
       succeeded.\n\
      \    ///\n\
      \    /// A single [`char`] may be encoded as more than one byte.\n\
      \    /// This method can only succeed if the entire byte sequence was \
       successfully\n\
      \    /// written, and this method will not return until all data has been\n\
      \    /// written or an error occurs.\n\
      \    ///\n\
      \    /// # Errors\n\
      \    ///\n\
      \    /// This function will return an instance of [`Error`] on error.\n\
      \    ///\n\
      \    /// [`char`]: ../../std/primitive.char.html\n\
      \    /// [`Error`]: struct.Error.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n\
      \    ///     f.write_char(c)\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, 'a').unwrap();\n\
      \    /// writer(&mut buf, 'b').unwrap();\n\
      \    /// assert_eq!(&buf, \"ab\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        self.write_str(c.encode_utf8(&mut [0; 4]))\n\
      \    }\n\n\
      \    /// Glue for usage of the [`write!`] macro with implementors of \
       this trait.\n\
      \    ///\n\
      \    /// This method should generally not be invoked manually, but \
       rather through\n\
      \    /// the [`write!`] macro itself.\n\
      \    ///\n\
      \    /// [`write!`]: ../../std/macro.write.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n\
      \    ///     f.write_fmt(format_args!(\"{}\", s))\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, \"world\").unwrap();\n\
      \    /// assert_eq!(&buf, \"world\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn write_fmt(mut self: &mut Self, args: Arguments<'_>) -> Result {\n\
      \        write(&mut self, args)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\n\
       impl<W: Write + ?Sized> Write for &mut W {\n\
      \    fn write_str(&mut self, s: &str) -> Result {\n\
      \        (**self).write_str(s)\n\
      \    }\n\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        (**self).write_char(c)\n\
      \    }\n\n\
      \    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n\
      \        (**self).write_fmt(args)\n\
      \    }\n\
       }\n\n\
       /// Configuration for formatting.\n\
       ///\n\
       /// A `Formatter` represents various options related to formatting. \
       Users do not\n\
       /// construct `Formatter`s directly; a mutable reference to one is \
       passed to\n\
       /// the `fmt` method of all formatting traits, like [`Debug`] and \
       [`Display`].\n\
       ///\n\
       /// To interact with a `Formatter`, you'll call various methods to \
       change the\n\
       /// various options related to formatting. For examples, please see the\n\
       /// documentation of the methods defined on `Formatter` below.\n\
       ///\n\
       /// [`Debug`]: trait.Debug.html\n\
       /// [`Display`]: trait.Display.html\n\
       #[allow(missing_debug_implementations)]\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub struct Formatter<'a> {\n\
      \    flags: u32,\n\
      \    fill: char,\n\
      \    align: rt::v1::Alignment,\n\
      \    width: Option<usize>,\n\
      \    precision: Option<usize>,\n\n\
      \    buf: &'a mut (dyn Write + 'a),\n\
       }\n\n\
       // NB. Argument is essentially an optimized partially applied \
       formatting function,\n\
       // equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n\n\
       extern \"C\" {\n\
      \    type Opaque;\n\
       }\n\n\
       /// This struct represents the generic \"argument\" which is taken by \
       the Xprintf\n\
       /// family of functions. It contains a function to format the given \
       value. At\n\
       /// compile time it is ensured that the function and the value have the \
       correct\n\
       /// types, and then this struct is used to canonicalize arguments to \
       one type.\n\
       #[derive(Copy, Clone)]\n\
       #[allow(missing_debug_implementations)]\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       #[doc(hidden)]\n\
       pub struct ArgumentV1<'a> {\n\
      \    value: &'a Opaque,\n\
      \    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n\
       }\n\n\
       // This guarantees a single stable value for the function pointer \
       associated with\n\
       // indices/counts in the formatting infrastructure.\n\
       //\n\
       // Note that a function defined as such would not be correct as \
       functions are\n\
       // always tagged unnamed_addr with the current lowering to LLVM IR, so \
       their\n\
       // address is not considered important to LLVM and as such the as_usize \
       cast\n\
       // could have been miscompiled. In practice, we never call as_usize on \
       non-usize\n\
       // containing data (as a matter of static generation of the formatting\n\
       // arguments), so this is merely an additional check.\n\
       //\n\
       // We primarily want to ensure that the function pointer at \
       `USIZE_MARKER` has\n\
       // an address corresponding *only* to functions that also take `&usize` \
       as their\n\
       // first argument. The read_volatile here ensures that we can safely \
       ready out a\n\
       // usize from the passed reference and that this address does not point \
       at a\n\
       // non-usize taking function.\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, \
       _| {\n\
      \    // SAFETY: ptr is a reference\n\
      \    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n\
      \    loop {}\n\
       };\n\n\
       impl<'a> ArgumentV1<'a> {\n\
      \    #[doc(hidden)]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> \
       Result) -> ArgumentV1<'b> {\n\
      \        // SAFETY: `mem::transmute(x)` is safe because\n\
      \        //     1. `&'b T` keeps the lifetime it originated with `'b`\n\
      \        //              (so as to not have an unbounded lifetime)\n\
      \        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n\
      \        //              (when `T` is `Sized`, as it is here)\n\
      \        // `mem::transmute(f)` is safe since `fn(&T, &mut \
       Formatter<'_>) -> Result`\n\
      \        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the \
       same ABI\n\
      \        // (as long as `T` is `Sized`)\n\
      \        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: \
       mem::transmute(x) } }\n\
      \    }\n\n\
      \    #[doc(hidden)]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n\
      \        ArgumentV1::new(x, USIZE_MARKER)\n\
      \    }\n\n\
      \    fn as_usize(&self) -> Option<usize> {\n\
      \        if self.formatter as usize == USIZE_MARKER as usize {\n\
      \            // SAFETY: The `formatter` field is only set to \
       USIZE_MARKER if\n\
      \            // the value is a usize, so this is safe\n\
      \            Some(unsafe { *(self.value as *const _ as *const usize) })\n\
      \        } else {\n\
      \            None\n\
      \        }\n\
      \    }\n\
       }\n\n\
       // flags available in the v1 format of format_args\n\
       #[derive(Copy, Clone)]\n\
       enum FlagV1 {\n\
      \    SignPlus,\n\
      \    SignMinus,\n\
      \    Alternate,\n\
      \    SignAwareZeroPad,\n\
      \    DebugLowerHex,\n\
      \    DebugUpperHex,\n\
       }\n\n\
       impl<'a> Arguments<'a> {\n\
      \    /// When using the format_args!() macro, this function is used to \
       generate the\n\
      \    /// Arguments structure.\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> \
       Arguments<'a> {\n\
      \        Arguments { pieces, fmt: None, args }\n\
      \    }\n\n\
      \    /// This function is used to specify nonstandard formatting \
       parameters.\n\
      \    /// The `pieces` array must be at least as long as `fmt` to construct\n\
      \    /// a valid Arguments structure. Also, any `Count` within `fmt` \
       that is\n\
      \    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n\
      \    /// created with `argumentusize`. However, failing to do so doesn't \
       cause\n\
      \    /// unsafety, but will ignore invalid .\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new_v1_formatted(\n\
      \        pieces: &'a [&'a str],\n\
      \        args: &'a [ArgumentV1<'a>],\n\
      \        fmt: &'a [rt::v1::Argument],\n\
      \    ) -> Arguments<'a> {\n\
      \        Arguments { pieces, fmt: Some(fmt), args }\n\
      \    }\n\n\
      \    /// Estimates the length of the formatted text.\n\
      \    ///\n\
      \    /// This is intended to be used for setting initial `String` capacity\n\
      \    /// when using `format!`. Note: this is neither the lower nor upper \
       bound.\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn estimated_capacity(&self) -> usize {\n\
      \        let pieces_length: usize = self.pieces.iter().map(|x| \
       x.len()).sum();\n\n\
      \        if self.args.is_empty() {\n\
      \            pieces_length\n\
      \        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n\
      \            // If the format string starts with an argument,\n\
      \            // don't preallocate anything, unless length\n\
      \            // of pieces is significant.\n\
      \            0\n\
      \        } else {\n\
      \            // There are some arguments, so any additional push\n\
      \            // will reallocate the string. To avoid that,\n\
      \            // we're \"pre-doubling\" the capacity here.\n\
      \            pieces_length.checked_mul(2).unwrap_or(0)\n\
      \        }\n\
      \    }\n\
       }\n\n\
       /// This structure represents a safely precompiled version of a format \
       string\n\
       /// and its arguments. This cannot be generated at runtime because it \
       cannot\n\
       /// safely be done, so no constructors are given and the fields are \
       private\n\
       /// to prevent modification.\n\
       ///\n\
       /// The [`format_args!`] macro will safely create an instance of this \
       structure.\n\
       /// The macro validates the format string at compile-time so usage of the\n\
       /// [`write`] and [`format`] functions can be safely performed.\n\
       ///\n\
       /// You can use the `Arguments<'a>` that [`format_args!`] returns in \
       `Debug`\n\
       /// and `Display` contexts as seen below. The example also shows that \
       `Debug`\n\
       /// and `Display` format to the same thing: the interpolated format \
       string\n\
       /// in `format_args!`.\n\
       ///\n\
       /// ```rust\n\
       /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n\
       /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n\
       /// assert_eq!(\"1 foo 2\", display);\n\
       /// assert_eq!(display, debug);\n\
       /// ```\n\
       ///\n\
       /// [`format_args!`]: ../../std/macro.format_args.html\n\
       /// [`format`]: ../../std/fmt/fn.format.html\n\
       /// [`write`]: ../../std/fmt/fn.write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[derive(Copy, Clone)]\n\
       pub struct Arguments<'a> {\n\
      \    // Format string pieces to print.\n\
      \    pieces: &'a [&'a str],\n\n\
      \    // Placeholder specs, or `None` if all specs are default (as in \
       \"{}{}\").\n\
      \    fmt: Option<&'a [rt::v1::Argument]>,\n\n\
      \    // Dynamic arguments for interpolation, to be interleaved with string\n\
      \    // pieces. (Every argument is preceded by a string piece.)\n\
      \    args: &'a [ArgumentV1<'a>],\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for Arguments<'_> {\n\
      \    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(self, fmt)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for Arguments<'_> {\n\
      \    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n\
      \        write(fmt.buf, *self)\n\
      \    }\n\
       }\n\n\
       /// `?` formatting.\n\
       ///\n\
       /// `Debug` should format the output in a programmer-facing, debugging \
       context.\n\
       ///\n\
       /// Generally speaking, you should just `derive` a `Debug` \
       implementation.\n\
       ///\n\
       /// When used with the alternate format specifier `#?`, the output is \
       pretty-printed.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// This trait can be used with `#[derive]` if all fields implement \
       `Debug`. When\n\
       /// `derive`d for structs, it will use the name of the `struct`, then \
       `{`, then a\n\
       /// comma-separated list of each field's name and `Debug` value, then \
       `}`. For\n\
       /// `enum`s, it will use the name of the variant and, if applicable, \
       `(`, then the\n\
       /// `Debug` values of the fields, then `)`.\n\
       ///\n\
       /// # Stability\n\
       ///\n\
       /// Derived `Debug` formats are not stable, and so may change with \
       future Rust\n\
       /// versions. Additionally, `Debug` implementations of types provided \
       by the\n\
       /// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not \
       stable, and\n\
       /// may also change with future Rust versions.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Deriving an implementation:\n\
       ///\n\
       /// ```\n\
       /// #[derive(Debug)]\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin \
       is: Point { x: 0, y: 0 }\");\n\
       /// ```\n\
       ///\n\
       /// Manually implementing:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// impl fmt::Debug for Point {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         f.debug_struct(\"Point\")\n\
       ///          .field(\"x\", &self.x)\n\
       ///          .field(\"y\", &self.y)\n\
       ///          .finish()\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin \
       is: Point { x: 0, y: 0 }\");\n\
       /// ```\n\
       ///\n\
       /// There are a number of helper methods on the [`Formatter`] struct to \
       help you with manual\n\
       /// implementations, such as [`debug_struct`].\n\
       ///\n\
       /// `Debug` implementations using either `derive` or the debug builder \
       API\n\
       /// on [`Formatter`] support pretty-printing using the alternate flag: \
       `{:#?}`.\n\
       ///\n\
       /// [`debug_struct`]: \
       ../../std/fmt/struct.Formatter.html#method.debug_struct\n\
       /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n\
       ///\n\
       /// Pretty-printing with `#?`:\n\
       ///\n\
       /// ```\n\
       /// #[derive(Debug)]\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n\
       /// \"The origin is: Point {\n\
       ///     x: 0,\n\
       ///     y: 0,\n\
       /// }\");\n\
       /// ```\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[rustc_on_unimplemented(\n\
      \    on(\n\
      \        crate_local,\n\
      \        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n\
      \        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n\
      \    ),\n\
      \    message = \"`{Self}` doesn't implement `{Debug}`\",\n\
      \    label = \"`{Self}` cannot be formatted using `{{:?}}` because it \
       doesn't implement `{Debug}`\"\n\
       )]\n\
       #[doc(alias = \"{:?}\")]\n\
       #[rustc_diagnostic_item = \"debug_trait\"]\n\
       pub trait Debug {\n\
      \    /// Formats the value using the given formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Position {\n\
      \    ///     longitude: f32,\n\
      \    ///     latitude: f32,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Debug for Position {\n\
      \    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \    ///         f.debug_tuple(\"\")\n\
      \    ///          .field(&self.longitude)\n\
      \    ///          .field(&self.latitude)\n\
      \    ///          .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n\
      \    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:#?}\", position), \"(\n\
      \    ///     1.987,\n\
      \    ///     2.983,\n\
      \    /// )\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       // Separate module to reexport the macro `Debug` from prelude without \
       the trait `Debug`.\n\
       pub(crate) mod macros {\n\
      \    /// Derive macro generating an impl of the trait `Debug`.\n\
      \    #[rustc_builtin_macro]\n\
      \    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n\
      \    #[allow_internal_unstable(core_intrinsics)]\n\
      \    pub macro Debug($item:item) {\n\
      \        /* compiler built-in */\n\
      \    }\n\
       }\n\
       #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n\
       #[doc(inline)]\n\
       pub use macros::Debug;\n\n\
       /// Format trait for an empty format, `{}`.\n\
       ///\n\
       /// `Display` is similar to [`Debug`][debug], but `Display` is for \
       user-facing\n\
       /// output, and so cannot be derived.\n\
       ///\n\
       /// [debug]: trait.Debug.html\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Implementing `Display` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// impl fmt::Display for Point {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         write!(f, \"({}, {})\", self.x, self.y)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: \
       (0, 0)\");\n\
       /// ```\n\
       #[rustc_on_unimplemented(\n\
      \    on(\n\
      \        _Self = \"std::path::Path\",\n\
      \        label = \"`{Self}` cannot be formatted with the default \
       formatter; call `.display()` on it\",\n\
      \        note = \"call `.display()` or `.to_string_lossy()` to safely \
       print paths, \\\n\
      \                as they may contain non-Unicode data\"\n\
      \    ),\n\
      \    message = \"`{Self}` doesn't implement `{Display}`\",\n\
      \    label = \"`{Self}` cannot be formatted with the default formatter\",\n\
      \    note = \"in format strings you may be able to use `{{:?}}` (or \
       {{:#?}} for pretty-print) instead\"\n\
       )]\n\
       #[doc(alias = \"{}\")]\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Display {\n\
      \    /// Formats the value using the given formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Position {\n\
      \    ///     longitude: f32,\n\
      \    ///     latitude: f32,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Display for Position {\n\
      \    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\"(1.987, 2.983)\",\n\
      \    ///            format!(\"{}\", Position { longitude: 1.987, \
       latitude: 2.983, }));\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `o` formatting.\n\
       ///\n\
       /// The `Octal` trait should format its output as a number in base-8.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0o` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '52' in octal\n\
       ///\n\
       /// assert_eq!(format!(\"{:o}\", x), \"52\");\n\
       /// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `Octal` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Octal for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(9);\n\
       ///\n\
       /// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: \
       11\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: \
       0o0011\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Octal {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `b` formatting.\n\
       ///\n\
       /// The `Binary` trait should format its output as a number in binary.\n\
       ///\n\
       /// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0b` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with [`i32`]:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '101010' in binary\n\
       ///\n\
       /// assert_eq!(format!(\"{:b}\", x), \"101010\");\n\
       /// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:b}\", -16), \
       \"11111111111111111111111111110000\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `Binary` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Binary for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(107);\n\
       ///\n\
       /// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: \
       1101011\");\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l as binary is: {:#032b}\", l),\n\
       ///     \"l as binary is: 0b000000000000000000000001101011\"\n\
       /// );\n\
       /// ```\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       /// [`i8`]: ../../std/primitive.i8.html\n\
       /// [`i128`]: ../../std/primitive.i128.html\n\
       /// [`isize`]: ../../std/primitive.isize.html\n\
       /// [`i32`]: ../../std/primitive.i32.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Binary {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `x` formatting.\n\
       ///\n\
       /// The `LowerHex` trait should format its output as a number in \
       hexadecimal, with `a` through `f`\n\
       /// in lower case.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0x` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '2a' in hex\n\
       ///\n\
       /// assert_eq!(format!(\"{:x}\", x), \"2a\");\n\
       /// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `LowerHex` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::LowerHex for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::LowerHex::fmt(&val, f) // delegate to i32's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(9);\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: \
       0x00000009\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait LowerHex {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `X` formatting.\n\
       ///\n\
       /// The `UpperHex` trait should format its output as a number in \
       hexadecimal, with `A` through `F`\n\
       /// in upper case.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0x` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '2A' in hex\n\
       ///\n\
       /// assert_eq!(format!(\"{:X}\", x), \"2A\");\n\
       /// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `UpperHex` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::UpperHex for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::UpperHex::fmt(&val, f) // delegate to i32's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(i32::MAX);\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: \
       7FFFFFFF\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: \
       0x7FFFFFFF\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait UpperHex {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `p` formatting.\n\
       ///\n\
       /// The `Pointer` trait should format its output as a memory location. \
       This is commonly presented\n\
       /// as hexadecimal.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `&i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = &42;\n\
       ///\n\
       /// let address = format!(\"{:p}\", x); // this produces something like \
       '0x7f06092ac6d0'\n\
       /// ```\n\
       ///\n\
       /// Implementing `Pointer` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Pointer for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         // use `as` to convert to a `*const T`, which implements \
       Pointer, which we can use\n\
       ///\n\
       ///         let ptr = self as *const Self;\n\
       ///         fmt::Pointer::fmt(&ptr, f)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(42);\n\
       ///\n\
       /// println!(\"l is in memory here: {:p}\", l);\n\
       ///\n\
       /// let l_ptr = format!(\"{:018p}\", l);\n\
       /// assert_eq!(l_ptr.len(), 18);\n\
       /// assert_eq!(&l_ptr[..2], \"0x\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Pointer {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `e` formatting.\n\
       ///\n\
       /// The `LowerExp` trait should format its output in scientific \
       notation with a lower-case `e`.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `f64`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n\
       ///\n\
       /// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `LowerExp` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::LowerExp for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = f64::from(self.0);\n\
       ///         fmt::LowerExp::fmt(&val, f) // delegate to f64's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(100);\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:e}\", l),\n\
       ///     \"l in scientific notation is: 1e2\"\n\
       /// );\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:05e}\", l),\n\
       ///     \"l in scientific notation is: 001e2\"\n\
       /// );\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait LowerExp {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `E` formatting.\n\
       ///\n\
       /// The `UpperExp` trait should format its output in scientific \
       notation with an upper-case `E`.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `f64`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n\
       ///\n\
       /// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `UpperExp` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::UpperExp for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = f64::from(self.0);\n\
       ///         fmt::UpperExp::fmt(&val, f) // delegate to f64's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(100);\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:E}\", l),\n\
       ///     \"l in scientific notation is: 1E2\"\n\
       /// );\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:05E}\", l),\n\
       ///     \"l in scientific notation is: 001E2\"\n\
       /// );\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait UpperExp {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// The `write` function takes an output stream, and an `Arguments` \
       struct\n\
       /// that can be precompiled with the `format_args!` macro.\n\
       ///\n\
       /// The arguments will be formatted according to the specified format \
       string\n\
       /// into the output stream provided.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n\
       ///     .expect(\"Error occurred while trying to write in String\");\n\
       /// assert_eq!(output, \"Hello world!\");\n\
       /// ```\n\
       ///\n\
       /// Please note that using [`write!`] might be preferable. Example:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt::Write;\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// write!(&mut output, \"Hello {}!\", \"world\")\n\
       ///     .expect(\"Error occurred while trying to write in String\");\n\
       /// assert_eq!(output, \"Hello world!\");\n\
       /// ```\n\
       ///\n\
       /// [`write!`]: ../../std/macro.write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n\
      \    let mut formatter = Formatter {\n\
      \        flags: 0,\n\
      \        width: None,\n\
      \        precision: None,\n\
      \        buf: output,\n\
      \        align: rt::v1::Alignment::Unknown,\n\
      \        fill: ' ',\n\
      \    };\n\n\
      \    let mut idx = 0;\n\n\
      \    match args.fmt {\n\
      \        None => {\n\
      \            // We can use default formatting parameters for all \
       arguments.\n\
      \            for (arg, piece) in \
       args.args.iter().zip(args.pieces.iter()) {\n\
      \                formatter.buf.write_str(*piece)?;\n\
      \                (arg.formatter)(arg.value, &mut formatter)?;\n\
      \                idx += 1;\n\
      \            }\n\
      \        }\n\
      \        Some(fmt) => {\n\
      \            // Every spec has a corresponding argument that is preceded \
       by\n\
      \            // a string piece.\n\
      \            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n\
      \                formatter.buf.write_str(*piece)?;\n\
      \                run(&mut formatter, arg, &args.args)?;\n\
      \                idx += 1;\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // There can be only one trailing string piece left.\n\
      \    if let Some(piece) = args.pieces.get(idx) {\n\
      \        formatter.buf.write_str(*piece)?;\n\
      \    }\n\n\
      \    Ok(())\n\
       }\n\n\
       fn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: \
       &[ArgumentV1<'_>]) -> Result {\n\
      \    fmt.fill = arg.format.fill;\n\
      \    fmt.align = arg.format.align;\n\
      \    fmt.flags = arg.format.flags;\n\
      \    fmt.width = getcount(args, &arg.format.width);\n\
      \    fmt.precision = getcount(args, &arg.format.precision);\n\n\
      \    // Extract the correct argument\n\
      \    let value = args[arg.position];\n\n\
      \    // Then actually do some printing\n\
      \    (value.formatter)(value.value, fmt)\n\
       }\n\n\
       fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> \
       Option<usize> {\n\
      \    match *cnt {\n\
      \        rt::v1::Count::Is(n) => Some(n),\n\
      \        rt::v1::Count::Implied => None,\n\
      \        rt::v1::Count::Param(i) => args[i].as_usize(),\n\
      \    }\n\
       }\n\n\
       /// Padding after the end of something. Returned by `Formatter::padding`.\n\
       #[must_use = \"don't forget to write the post padding\"]\n\
       struct PostPadding {\n\
      \    fill: char,\n\
      \    padding: usize,\n\
       }\n\n\
       impl PostPadding {\n\
      \    fn new(fill: char, padding: usize) -> PostPadding {\n\
      \        PostPadding { fill, padding }\n\
      \    }\n\n\
      \    /// Write this post padding.\n\
      \    fn write(self, buf: &mut dyn Write) -> Result {\n\
      \        for _ in 0..self.padding {\n\
      \            buf.write_char(self.fill)?;\n\
      \        }\n\
      \        Ok(())\n\
      \    }\n\
       }\n\n\
       impl<'a> Formatter<'a> {\n\
      \    fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n\
      \    where\n\
      \        'b: 'c,\n\
      \        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n\
      \    {\n\
      \        Formatter {\n\
      \            // We want to change this\n\
      \            buf: wrap(self.buf),\n\n\
      \            // And preserve these\n\
      \            flags: self.flags,\n\
      \            fill: self.fill,\n\
      \            align: self.align,\n\
      \            width: self.width,\n\
      \            precision: self.precision,\n\
      \        }\n\
      \    }\n\n\
      \    // Helper methods used for padding and processing formatting \
       arguments that\n\
      \    // all formatting traits can use.\n\n\
      \    /// Performs the correct padding for an integer which has already \
       been\n\
      \    /// emitted into a str. The str should *not* contain the sign for the\n\
      \    /// integer, that will be added by this method.\n\
      \    ///\n\
      \    /// # Arguments\n\
      \    ///\n\
      \    /// * is_nonnegative - whether the original integer was either \
       positive or zero.\n\
      \    /// * prefix - if the '#' character (Alternate) is provided, this\n\
      \    ///   is the prefix to put in front of the number.\n\
      \    /// * buf - the byte array that the number has been formatted into\n\
      \    ///\n\
      \    /// This function will correctly account for the flags provided as \
       well as\n\
      \    /// the minimum width. It will not take precision into account.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo { nb: i32 };\n\
      \    ///\n\
      \    /// impl Foo {\n\
      \    ///     fn new(nb: i32) -> Foo {\n\
      \    ///         Foo {\n\
      \    ///             nb,\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         // We need to remove \"-\" from the number output.\n\
      \    ///         let tmp = self.nb.abs().to_string();\n\
      \    ///\n\
      \    ///         formatter.pad_integral(self.nb > 0, \"Foo \", &tmp)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\n\
      \    /// assert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n\
      \    /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, \
       buf: &str) -> Result {\n\
      \        let mut width = buf.len();\n\n\
      \        let mut sign = None;\n\
      \        if !is_nonnegative {\n\
      \            sign = Some('-');\n\
      \            width += 1;\n\
      \        } else if self.sign_plus() {\n\
      \            sign = Some('+');\n\
      \            width += 1;\n\
      \        }\n\n\
      \        let prefix = if self.alternate() {\n\
      \            width += prefix.chars().count();\n\
      \            Some(prefix)\n\
      \        } else {\n\
      \            None\n\
      \        };\n\n\
      \        // Writes the sign if it exists, and then the prefix if it was \
       requested\n\
      \        #[inline(never)]\n\
      \        fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, \
       prefix: Option<&str>) -> Result {\n\
      \            if let Some(c) = sign {\n\
      \                f.buf.write_char(c)?;\n\
      \            }\n\
      \            if let Some(prefix) = prefix { f.buf.write_str(prefix) } \
       else { Ok(()) }\n\
      \        }\n\n\
      \        // The `width` field is more of a `min-width` parameter at this \
       point.\n\
      \        match self.width {\n\
      \            // If there's no minimum length requirements then we can just\n\
      \            // write the bytes.\n\
      \            None => {\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)\n\
      \            }\n\
      \            // Check if we're over the minimum width, if so then we can \
       also\n\
      \            // just write the bytes.\n\
      \            Some(min) if width >= min => {\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)\n\
      \            }\n\
      \            // The sign and prefix goes before the padding if the fill \
       character\n\
      \            // is zero\n\
      \            Some(min) if self.sign_aware_zero_pad() => {\n\
      \                let old_fill = crate::mem::replace(&mut self.fill, '0');\n\
      \                let old_align = crate::mem::replace(&mut self.align, \
       rt::v1::Alignment::Right);\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                let post_padding = self.padding(min - width, \
       rt::v1::Alignment::Right)?;\n\
      \                self.buf.write_str(buf)?;\n\
      \                post_padding.write(self.buf)?;\n\
      \                self.fill = old_fill;\n\
      \                self.align = old_align;\n\
      \                Ok(())\n\
      \            }\n\
      \            // Otherwise, the sign and prefix goes after the padding\n\
      \            Some(min) => {\n\
      \                let post_padding = self.padding(min - width, \
       rt::v1::Alignment::Right)?;\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)?;\n\
      \                post_padding.write(self.buf)\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// This function takes a string slice and emits it to the internal \
       buffer\n\
      \    /// after applying the relevant formatting flags specified. The flags\n\
      \    /// recognized for generic strings are:\n\
      \    ///\n\
      \    /// * width - the minimum width of what to emit\n\
      \    /// * fill/align - what to emit and where to emit it if the string\n\
      \    ///                provided needs to be padded\n\
      \    /// * precision - the maximum length to emit, the string is \
       truncated if it\n\
      \    ///               is longer than this length\n\
      \    ///\n\
      \    /// Notably this function ignores the `flag` parameters.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.pad(\"Foo\")\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\n\
      \    /// assert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn pad(&mut self, s: &str) -> Result {\n\
      \        // Make sure there's a fast path up front\n\
      \        if self.width.is_none() && self.precision.is_none() {\n\
      \            return self.buf.write_str(s);\n\
      \        }\n\
      \        // The `precision` field can be interpreted as a `max-width` \
       for the\n\
      \        // string being formatted.\n\
      \        let s = if let Some(max) = self.precision {\n\
      \            // If our string is longer that the precision, then we must \
       have\n\
      \            // truncation. However other flags like `fill`, `width` and \
       `align`\n\
      \            // must act as always.\n\
      \            if let Some((i, _)) = s.char_indices().nth(max) {\n\
      \                // LLVM here can't prove that `..i` won't panic \
       `&s[..i]`, but\n\
      \                // we know that it can't panic. Use `get` + `unwrap_or` \
       to avoid\n\
      \                // `unsafe` and otherwise don't emit any panic-related \
       code\n\
      \                // here.\n\
      \                s.get(..i).unwrap_or(&s)\n\
      \            } else {\n\
      \                &s\n\
      \            }\n\
      \        } else {\n\
      \            &s\n\
      \        };\n\
      \        // The `width` field is more of a `min-width` parameter at this \
       point.\n\
      \        match self.width {\n\
      \            // If we're under the maximum length, and there's no \
       minimum length\n\
      \            // requirements, then we can just emit the string\n\
      \            None => self.buf.write_str(s),\n\
      \            // If we're under the maximum width, check if we're over \
       the minimum\n\
      \            // width, if so it's as easy as just emitting the string.\n\
      \            Some(width) if s.chars().count() >= width => \
       self.buf.write_str(s),\n\
      \            // If we're under both the maximum and the minimum width, \
       then fill\n\
      \            // up the minimum width with the specified string + some \
       alignment.\n\
      \            Some(width) => {\n\
      \                let align = rt::v1::Alignment::Left;\n\
      \                let post_padding = self.padding(width - \
       s.chars().count(), align)?;\n\
      \                self.buf.write_str(s)?;\n\
      \                post_padding.write(self.buf)\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Write the pre-padding and return the unwritten post-padding. \
       Callers are\n\
      \    /// responsible for ensuring post-padding is written after the \
       thing that is\n\
      \    /// being padded.\n\
      \    fn padding(\n\
      \        &mut self,\n\
      \        padding: usize,\n\
      \        default: rt::v1::Alignment,\n\
      \    ) -> result::Result<PostPadding, Error> {\n\
      \        let align = match self.align {\n\
      \            rt::v1::Alignment::Unknown => default,\n\
      \            _ => self.align,\n\
      \        };\n\n\
      \        let (pre_pad, post_pad) = match align {\n\
      \            rt::v1::Alignment::Left => (0, padding),\n\
      \            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => \
       (padding, 0),\n\
      \            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / \
       2),\n\
      \        };\n\n\
      \        for _ in 0..pre_pad {\n\
      \            self.buf.write_char(self.fill)?;\n\
      \        }\n\n\
      \        Ok(PostPadding::new(self.fill, post_pad))\n\
      \    }\n\n\
      \    /// Takes the formatted parts and applies the padding.\n\
      \    /// Assumes that the caller already has rendered the parts with \
       required precision,\n\
      \    /// so that `self.precision` can be ignored.\n\
      \    fn pad_formatted_parts(&mut self, formatted: \
       &flt2dec::Formatted<'_>) -> Result {\n\
      \        if let Some(mut width) = self.width {\n\
      \            // for the sign-aware zero padding, we render the sign \
       first and\n\
      \            // behave as if we had no sign from the beginning.\n\
      \            let mut formatted = formatted.clone();\n\
      \            let old_fill = self.fill;\n\
      \            let old_align = self.align;\n\
      \            let mut align = old_align;\n\
      \            if self.sign_aware_zero_pad() {\n\
      \                // a sign always goes first\n\
      \                let sign = formatted.sign;\n\
      \                self.buf.write_str(sign)?;\n\n\
      \                // remove the sign from the formatted parts\n\
      \                formatted.sign = \"\";\n\
      \                width = width.saturating_sub(sign.len());\n\
      \                align = rt::v1::Alignment::Right;\n\
      \                self.fill = '0';\n\
      \                self.align = rt::v1::Alignment::Right;\n\
      \            }\n\n\
      \            // remaining parts go through the ordinary padding process.\n\
      \            let len = formatted.len();\n\
      \            let ret = if width <= len {\n\
      \                // no padding\n\
      \                self.write_formatted_parts(&formatted)\n\
      \            } else {\n\
      \                let post_padding = self.padding(width - len, align)?;\n\
      \                self.write_formatted_parts(&formatted)?;\n\
      \                post_padding.write(self.buf)\n\
      \            };\n\
      \            self.fill = old_fill;\n\
      \            self.align = old_align;\n\
      \            ret\n\
      \        } else {\n\
      \            // this is the common case and we take a shortcut\n\
      \            self.write_formatted_parts(formatted)\n\
      \        }\n\
      \    }\n\n\
      \    fn write_formatted_parts(&mut self, formatted: \
       &flt2dec::Formatted<'_>) -> Result {\n\
      \        fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n\
      \            // SAFETY: This is used for `flt2dec::Part::Num` and \
       `flt2dec::Part::Copy`.\n\
      \            // It's safe to use for `flt2dec::Part::Num` since every \
       char `c` is between\n\
      \            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n\
      \            // It's also probably safe in practice to use for \
       `flt2dec::Part::Copy(buf)`\n\
      \            // since `buf` should be plain ASCII, but it's possible for \
       someone to pass\n\
      \            // in a bad value for `buf` into `flt2dec::to_shortest_str` \
       since it is a\n\
      \            // public function.\n\
      \            // FIXME: Determine whether this could result in UB.\n\
      \            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n\
      \        }\n\n\
      \        if !formatted.sign.is_empty() {\n\
      \            self.buf.write_str(formatted.sign)?;\n\
      \        }\n\
      \        for part in formatted.parts {\n\
      \            match *part {\n\
      \                flt2dec::Part::Zero(mut nzeroes) => {\n\
      \                    const ZEROES: &str = // 64 zeroes\n\
      \                        \
       \"0000000000000000000000000000000000000000000000000000000000000000\";\n\
      \                    while nzeroes > ZEROES.len() {\n\
      \                        self.buf.write_str(ZEROES)?;\n\
      \                        nzeroes -= ZEROES.len();\n\
      \                    }\n\
      \                    if nzeroes > 0 {\n\
      \                        self.buf.write_str(&ZEROES[..nzeroes])?;\n\
      \                    }\n\
      \                }\n\
      \                flt2dec::Part::Num(mut v) => {\n\
      \                    let mut s = [0; 5];\n\
      \                    let len = part.len();\n\
      \                    for c in s[..len].iter_mut().rev() {\n\
      \                        *c = b'0' + (v % 10) as u8;\n\
      \                        v /= 10;\n\
      \                    }\n\
      \                    write_bytes(self.buf, &s[..len])?;\n\
      \                }\n\
      \                flt2dec::Part::Copy(buf) => {\n\
      \                    write_bytes(self.buf, buf)?;\n\
      \                }\n\
      \            }\n\
      \        }\n\
      \        Ok(())\n\
      \    }\n\n\
      \    /// Writes some data to the underlying buffer contained within this\n\
      \    /// formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.write_str(\"Foo\")\n\
      \    ///         // This is equivalent to:\n\
      \    ///         // write!(formatter, \"Foo\")\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo), \"Foo\");\n\
      \    /// assert_eq!(&format!(\"{:0>8}\", Foo), \"Foo\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn write_str(&mut self, data: &str) -> Result {\n\
      \        self.buf.write_str(data)\n\
      \    }\n\n\
      \    /// Writes some formatted information into this instance.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\n\
      \    /// assert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n\
      \        write(self.buf, fmt)\n\
      \    }\n\n\
      \    /// Flags for formatting\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    #[rustc_deprecated(\n\
      \        since = \"1.24.0\",\n\
      \        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n\
      \                  or `sign_aware_zero_pad` methods instead\"\n\
      \    )]\n\
      \    pub fn flags(&self) -> u32 {\n\
      \        self.flags\n\
      \    }\n\n\
      \    /// Character used as 'fill' whenever there is alignment.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         let c = formatter.fill();\n\
      \    ///         if let Some(width) = formatter.width() {\n\
      \    ///             for _ in 0..width {\n\
      \    ///                 write!(formatter, \"{}\", c)?;\n\
      \    ///             }\n\
      \    ///             Ok(())\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"{}\", c)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// // We set alignment to the left with \">\".\n\
      \    /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n\
      \    /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn fill(&self) -> char {\n\
      \        self.fill\n\
      \    }\n\n\
      \    /// Flag indicating what form of alignment was requested.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// extern crate core;\n\
      \    ///\n\
      \    /// use std::fmt::{self, Alignment};\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         let s = if let Some(s) = formatter.align() {\n\
      \    ///             match s {\n\
      \    ///                 Alignment::Left    => \"left\",\n\
      \    ///                 Alignment::Right   => \"right\",\n\
      \    ///                 Alignment::Center  => \"center\",\n\
      \    ///             }\n\
      \    ///         } else {\n\
      \    ///             \"into the void\"\n\
      \    ///         };\n\
      \    ///         write!(formatter, \"{}\", s)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n\
      \    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n\
      \    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    pub fn align(&self) -> Option<Alignment> {\n\
      \        match self.align {\n\
      \            rt::v1::Alignment::Left => Some(Alignment::Left),\n\
      \            rt::v1::Alignment::Right => Some(Alignment::Right),\n\
      \            rt::v1::Alignment::Center => Some(Alignment::Center),\n\
      \            rt::v1::Alignment::Unknown => None,\n\
      \        }\n\
      \    }\n\n\
      \    /// Optionally specified integer width that the output should be.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if let Some(width) = formatter.width() {\n\
      \    ///             // If we received a width, we use it\n\
      \    ///             write!(formatter, \"{:width$}\", \
       &format!(\"Foo({})\", self.0), width = width)\n\
      \    ///         } else {\n\
      \    ///             // Otherwise we do nothing special\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn width(&self) -> Option<usize> {\n\
      \        self.width\n\
      \    }\n\n\
      \    /// Optionally specified precision for numeric types. \
       Alternatively, the\n\
      \    /// maximum width for string types.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(f32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if let Some(precision) = formatter.precision() {\n\
      \    ///             // If we received a precision, we use it.\n\
      \    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n\
      \    ///         } else {\n\
      \    ///             // Otherwise we default to 2.\n\
      \    ///             write!(formatter, \"Foo({:.2})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn precision(&self) -> Option<usize> {\n\
      \        self.precision\n\
      \    }\n\n\
      \    /// Determines if the `+` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.sign_plus() {\n\
      \    ///             write!(formatter,\n\
      \    ///                    \"Foo({}{})\",\n\
      \    ///                    if self.0 < 0 { '-' } else { '+' },\n\
      \    ///                    self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_plus(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `-` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.sign_minus() {\n\
      \    ///             // You want a minus sign? Have one!\n\
      \    ///             write!(formatter, \"-Foo({})\", self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_minus(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `#` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.alternate() {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"{}\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn alternate(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::Alternate as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `0` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         assert!(formatter.sign_aware_zero_pad());\n\
      \    ///         assert_eq!(formatter.width(), Some(4));\n\
      \    ///         // We ignore the formatter's options.\n\
      \    ///         write!(formatter, \"{}\", self.0)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_aware_zero_pad(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n\
      \    }\n\n\
      \    // FIXME: Decide what public API we want for these two flags.\n\
      \    // https://github.com/rust-lang/rust/issues/48584\n\
      \    fn debug_lower_hex(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n\
      \    }\n\n\
      \    fn debug_upper_hex(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n\
      \    }\n\n\
      \    /// Creates a [`DebugStruct`] builder designed to assist with \
       creation of\n\
      \    /// [`fmt::Debug`] implementations for structs.\n\
      \    ///\n\
      \    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n\
      \    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    /// use std::net::Ipv4Addr;\n\
      \    ///\n\
      \    /// struct Foo {\n\
      \    ///     bar: i32,\n\
      \    ///     baz: String,\n\
      \    ///     addr: Ipv4Addr,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_struct(\"Foo\")\n\
      \    ///             .field(\"bar\", &self.bar)\n\
      \    ///             .field(\"baz\", &self.baz)\n\
      \    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n\
      \    ///             .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 \
       }\",\n\
      \    ///     format!(\"{:?}\", Foo {\n\
      \    ///         bar: 10,\n\
      \    ///         baz: \"Hello World\".to_string(),\n\
      \    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n\
      \    ///     })\n\
      \    /// );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_struct<'b>(&'b mut self, name: &str) -> \
       DebugStruct<'b, 'a> {\n\
      \        builders::debug_struct_new(self, name)\n\
      \    }\n\n\
      \    /// Creates a `DebugTuple` builder designed to assist with creation \
       of\n\
      \    /// `fmt::Debug` implementations for tuple structs.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    /// use std::marker::PhantomData;\n\
      \    ///\n\
      \    /// struct Foo<T>(i32, String, PhantomData<T>);\n\
      \    ///\n\
      \    /// impl<T> fmt::Debug for Foo<T> {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_tuple(\"Foo\")\n\
      \    ///             .field(&self.0)\n\
      \    ///             .field(&self.1)\n\
      \    ///             .field(&format_args!(\"_\"))\n\
      \    ///             .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     \"Foo(10, \\\"Hello\\\", _)\",\n\
      \    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), \
       PhantomData::<u8>))\n\
      \    /// );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, \
       'a> {\n\
      \        builders::debug_tuple_new(self, name)\n\
      \    }\n\n\
      \    /// Creates a `DebugList` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for list-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<i32>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_list().entries(self.0.iter()).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n\
      \        builders::debug_list_new(self)\n\
      \    }\n\n\
      \    /// Creates a `DebugSet` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for set-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<i32>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_set().entries(self.0.iter()).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n\
      \    /// ```\n\
      \    ///\n\
      \    /// [`format_args!`]: ../../std/macro.format_args.html\n\
      \    ///\n\
      \    /// In this more complex example, we use [`format_args!`] and \
       `.debug_set()`\n\
      \    /// to build a list of match arms:\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n\
      \    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n\
      \    ///\n\
      \    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n\
      \    /// where\n\
      \    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n\
      \    /// {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         L::fmt(&(self.0).0, fmt)?;\n\
      \    ///         fmt.write_str(\" => \")?;\n\
      \    ///         R::fmt(&(self.0).1, fmt)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n\
      \    /// where\n\
      \    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n\
      \    /// {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_set()\n\
      \    ///         .entries(self.0.iter().map(Arm))\n\
      \    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n\
      \    ///         .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n\
      \        builders::debug_set_new(self)\n\
      \    }\n\n\
      \    /// Creates a `DebugMap` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for map-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<(String, i32)>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref \
       v)| (k, v))).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), \
       (\"B\".to_string(), 11)])),\n\
      \    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n\
      \    ///  );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n\
      \        builders::debug_map_new(self)\n\
      \    }\n\
       }\n\n\
       #[stable(since = \"1.2.0\", feature = \"formatter_write\")]\n\
       impl Write for Formatter<'_> {\n\
      \    fn write_str(&mut self, s: &str) -> Result {\n\
      \        self.buf.write_str(s)\n\
      \    }\n\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        self.buf.write_char(c)\n\
      \    }\n\n\
      \    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n\
      \        write(self.buf, args)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for Error {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(\"an error occurred when formatting an argument\", \
       f)\n\
      \    }\n\
       }\n\n\
       // Implementations of the core formatting traits\n\n\
       macro_rules! fmt_refs {\n\
      \    ($($tr:ident),*) => {\n\
      \        $(\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<T: ?Sized + $tr> $tr for &T {\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result { \
       $tr::fmt(&**self, f) }\n\
      \        }\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<T: ?Sized + $tr> $tr for &mut T {\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result { \
       $tr::fmt(&**self, f) }\n\
      \        }\n\
      \        )*\n\
      \    }\n\
       }\n\n\
       fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, \
       LowerExp, UpperExp }\n\n\
       #[unstable(feature = \"never_type\", issue = \"35121\")]\n\
       impl Debug for ! {\n\
      \    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n\
      \        *self\n\
      \    }\n\
       }\n\n\
       #[unstable(feature = \"never_type\", issue = \"35121\")]\n\
       impl Display for ! {\n\
      \    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n\
      \        *self\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for bool {\n\
      \    #[inline]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(self, f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for bool {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for str {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.write_char('\"')?;\n\
      \        let mut from = 0;\n\
      \        for (i, c) in self.char_indices() {\n\
      \            let esc = c.escape_debug();\n\
      \            // If char needs escaping, flush backlog so far and write, \
       else skip\n\
      \            if esc.len() != 1 {\n\
      \                f.write_str(&self[from..i])?;\n\
      \                for c in esc {\n\
      \                    f.write_char(c)?;\n\
      \                }\n\
      \                from = i + c.len_utf8();\n\
      \            }\n\
      \        }\n\
      \        f.write_str(&self[from..])?;\n\
      \        f.write_char('\"')\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for str {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(self)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for char {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.write_char('\\'')?;\n\
      \        for c in self.escape_debug() {\n\
      \            f.write_char(c)?\n\
      \        }\n\
      \        f.write_char('\\'')\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for char {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        if f.width.is_none() && f.precision.is_none() {\n\
      \            f.write_char(*self)\n\
      \        } else {\n\
      \            f.pad(self.encode_utf8(&mut [0; 4]))\n\
      \        }\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for *const T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        let old_width = f.width;\n\
      \        let old_flags = f.flags;\n\n\
      \        // The alternate flag is already treated by LowerHex as being \
       special-\n\
      \        // it denotes whether to prefix with 0x. We use it to work out \
       whether\n\
      \        // or not to zero extend, and then unconditionally set it to \
       get the\n\
      \        // prefix.\n\
      \        if f.alternate() {\n\
      \            f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n\n\
      \            if f.width.is_none() {\n\
      \                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n\
      \            }\n\
      \        }\n\
      \        f.flags |= 1 << (FlagV1::Alternate as u32);\n\n\
      \        let ret = LowerHex::fmt(&(*self as *const () as usize), f);\n\n\
      \        f.width = old_width;\n\
      \        f.flags = old_flags;\n\n\
      \        ret\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for *mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(*self as *const T), f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for &T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(*self as *const T), f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for &mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(&**self as *const T), f)\n\
      \    }\n\
       }\n\n\
       // Implementation of Display/Debug for various core types\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for *const T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(self, f)\n\
      \    }\n\
       }\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for *mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(self, f)\n\
      \    }\n\
       }\n\n\
       macro_rules! peel {\n\
      \    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n\
       }\n\n\
       macro_rules! tuple {\n\
      \    () => ();\n\
      \    ( $($name:ident,)+ ) => (\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<$($name:Debug),+> Debug for ($($name,)+) where \
       last_type!($($name,)+): ?Sized {\n\
      \            #[allow(non_snake_case, unused_assignments)]\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \                let mut builder = f.debug_tuple(\"\");\n\
      \                let ($(ref $name,)+) = *self;\n\
      \                $(\n\
      \                    builder.field(&$name);\n\
      \                )+\n\n\
      \                builder.finish()\n\
      \            }\n\
      \        }\n\
      \        peel! { $($name,)+ }\n\
      \    )\n\
       }\n\n\
       macro_rules! last_type {\n\
      \    ($a:ident,) => { $a };\n\
      \    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n\
       }\n\n\
       tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: Debug> Debug for [T] {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.debug_list().entries(self.iter()).finish()\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for () {\n\
      \    #[inline]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(\"()\")\n\
      \    }\n\
       }\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for PhantomData<T> {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(\"PhantomData\")\n\
      \    }\n\
       }" );
    (2356, 69106, "");
    ( 2356,
      0,
      "//! Utilities for formatting and printing strings.\n\n\
       #![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n\
       use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n\
       use crate::marker::PhantomData;\n\
       use crate::mem;\n\
       use crate::num::flt2dec;\n\
       use crate::ops::Deref;\n\
       use crate::result;\n\
       use crate::str;\n\n\
       mod builders;\n\
       mod float;\n\
       mod num;\n\n\
       #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
       /// Possible alignments returned by `Formatter::align`\n\
       #[derive(Debug)]\n\
       pub enum Alignment {\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be left-aligned.\n\
      \    Left,\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be right-aligned.\n\
      \    Right,\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    /// Indication that contents should be center-aligned.\n\
      \    Center,\n\
       }\n\n\
       #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
       pub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, \
       DebugTuple};\n\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       #[doc(hidden)]\n\
       pub mod rt {\n\
      \    pub mod v1;\n\
       }\n\n\
       /// The type returned by formatter methods.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// #[derive(Debug)]\n\
       /// struct Triangle {\n\
       ///     a: f32,\n\
       ///     b: f32,\n\
       ///     c: f32\n\
       /// }\n\
       ///\n\
       /// impl fmt::Display for Triangle {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n\
       ///\n\
       /// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub type Result = result::Result<(), Error>;\n\n\
       /// The error type which is returned from formatting a message into a \
       stream.\n\
       ///\n\
       /// This type does not support transmission of an error other than that \
       an error\n\
       /// occurred. Any extra information must be arranged to be transmitted \
       through\n\
       /// some other means.\n\
       ///\n\
       /// An important thing to remember is that the type `fmt::Error` should \
       not be\n\
       /// confused with [`std::io::Error`] or [`std::error::Error`], which \
       you may also\n\
       /// have in scope.\n\
       ///\n\
       /// [`std::io::Error`]: ../../std/io/struct.Error.html\n\
       /// [`std::error::Error`]: ../../std/error/trait.Error.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// ```rust\n\
       /// use std::fmt::{self, write};\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// if let Err(fmt::Error) = write(&mut output, format_args!(\"Hello \
       {}!\", \"world\")) {\n\
       ///     panic!(\"An error occurred\");\n\
       /// }\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, \
       PartialOrd)]\n\
       pub struct Error;\n\n\
       /// A collection of methods that are required to format a message into \
       a stream.\n\
       ///\n\
       /// This trait is the type which this modules requires when formatting\n\
       /// information. This is similar to the standard library's \
       [`io::Write`] trait,\n\
       /// but it is only intended for use in libcore.\n\
       ///\n\
       /// This trait should generally not be implemented by consumers of the \
       standard\n\
       /// library. The [`write!`] macro accepts an instance of [`io::Write`], \
       and the\n\
       /// [`io::Write`] trait is favored over implementing this trait.\n\
       ///\n\
       /// [`write!`]: ../../std/macro.write.html\n\
       /// [`io::Write`]: ../../std/io/trait.Write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Write {\n\
      \    /// Writes a string slice into this writer, returning whether the \
       write\n\
      \    /// succeeded.\n\
      \    ///\n\
      \    /// This method can only succeed if the entire string slice was \
       successfully\n\
      \    /// written, and this method will not return until all data has been\n\
      \    /// written or an error occurs.\n\
      \    ///\n\
      \    /// # Errors\n\
      \    ///\n\
      \    /// This function will return an instance of [`Error`] on error.\n\
      \    ///\n\
      \    /// [`Error`]: struct.Error.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n\
      \    ///     f.write_str(s)\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, \"hola\").unwrap();\n\
      \    /// assert_eq!(&buf, \"hola\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn write_str(&mut self, s: &str) -> Result;\n\n\
      \    /// Writes a [`char`] into this writer, returning whether the write \
       succeeded.\n\
      \    ///\n\
      \    /// A single [`char`] may be encoded as more than one byte.\n\
      \    /// This method can only succeed if the entire byte sequence was \
       successfully\n\
      \    /// written, and this method will not return until all data has been\n\
      \    /// written or an error occurs.\n\
      \    ///\n\
      \    /// # Errors\n\
      \    ///\n\
      \    /// This function will return an instance of [`Error`] on error.\n\
      \    ///\n\
      \    /// [`char`]: ../../std/primitive.char.html\n\
      \    /// [`Error`]: struct.Error.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n\
      \    ///     f.write_char(c)\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, 'a').unwrap();\n\
      \    /// writer(&mut buf, 'b').unwrap();\n\
      \    /// assert_eq!(&buf, \"ab\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        self.write_str(c.encode_utf8(&mut [0; 4]))\n\
      \    }\n\n\
      \    /// Glue for usage of the [`write!`] macro with implementors of \
       this trait.\n\
      \    ///\n\
      \    /// This method should generally not be invoked manually, but \
       rather through\n\
      \    /// the [`write!`] macro itself.\n\
      \    ///\n\
      \    /// [`write!`]: ../../std/macro.write.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt::{Error, Write};\n\
      \    ///\n\
      \    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n\
      \    ///     f.write_fmt(format_args!(\"{}\", s))\n\
      \    /// }\n\
      \    ///\n\
      \    /// let mut buf = String::new();\n\
      \    /// writer(&mut buf, \"world\").unwrap();\n\
      \    /// assert_eq!(&buf, \"world\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn write_fmt(mut self: &mut Self, args: Arguments<'_>) -> Result {\n\
      \        write(&mut self, args)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\n\
       impl<W: Write + ?Sized> Write for &mut W {\n\
      \    fn write_str(&mut self, s: &str) -> Result {\n\
      \        (**self).write_str(s)\n\
      \    }\n\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        (**self).write_char(c)\n\
      \    }\n\n\
      \    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n\
      \        (**self).write_fmt(args)\n\
      \    }\n\
       }\n\n\
       /// Configuration for formatting.\n\
       ///\n\
       /// A `Formatter` represents various options related to formatting. \
       Users do not\n\
       /// construct `Formatter`s directly; a mutable reference to one is \
       passed to\n\
       /// the `fmt` method of all formatting traits, like [`Debug`] and \
       [`Display`].\n\
       ///\n\
       /// To interact with a `Formatter`, you'll call various methods to \
       change the\n\
       /// various options related to formatting. For examples, please see the\n\
       /// documentation of the methods defined on `Formatter` below.\n\
       ///\n\
       /// [`Debug`]: trait.Debug.html\n\
       /// [`Display`]: trait.Display.html\n\
       #[allow(missing_debug_implementations)]\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub struct Formatter<'a> {\n\
      \    flags: u32,\n\
      \    fill: char,\n\
      \    align: rt::v1::Alignment,\n\
      \    width: Option<usize>,\n\
      \    precision: Option<usize>,\n\n\
      \    buf: &'a mut (dyn Write + 'a),\n\
       }\n\n\
       // NB. Argument is essentially an optimized partially applied \
       formatting function,\n\
       // equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n\n\
       extern \"C\" {\n\
      \    type Opaque;\n\
       }\n\n\
       /// This struct represents the generic \"argument\" which is taken by \
       the Xprintf\n\
       /// family of functions. It contains a function to format the given \
       value. At\n\
       /// compile time it is ensured that the function and the value have the \
       correct\n\
       /// types, and then this struct is used to canonicalize arguments to \
       one type.\n\
       #[derive(Copy, Clone)]\n\
       #[allow(missing_debug_implementations)]\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       #[doc(hidden)]\n\
       pub struct ArgumentV1<'a> {\n\
      \    value: &'a Opaque,\n\
      \    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n\
       }\n\n\
       // This guarantees a single stable value for the function pointer \
       associated with\n\
       // indices/counts in the formatting infrastructure.\n\
       //\n\
       // Note that a function defined as such would not be correct as \
       functions are\n\
       // always tagged unnamed_addr with the current lowering to LLVM IR, so \
       their\n\
       // address is not considered important to LLVM and as such the as_usize \
       cast\n\
       // could have been miscompiled. In practice, we never call as_usize on \
       non-usize\n\
       // containing data (as a matter of static generation of the formatting\n\
       // arguments), so this is merely an additional check.\n\
       //\n\
       // We primarily want to ensure that the function pointer at \
       `USIZE_MARKER` has\n\
       // an address corresponding *only* to functions that also take `&usize` \
       as their\n\
       // first argument. The read_volatile here ensures that we can safely \
       ready out a\n\
       // usize from the passed reference and that this address does not point \
       at a\n\
       // non-usize taking function.\n\
       #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
       static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, \
       _| {\n\
      \    // SAFETY: ptr is a reference\n\
      \    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n\
      \    loop {}\n\
       };\n\n\
       impl<'a> ArgumentV1<'a> {\n\
      \    #[doc(hidden)]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> \
       Result) -> ArgumentV1<'b> {\n\
      \        // SAFETY: `mem::transmute(x)` is safe because\n\
      \        //     1. `&'b T` keeps the lifetime it originated with `'b`\n\
      \        //              (so as to not have an unbounded lifetime)\n\
      \        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n\
      \        //              (when `T` is `Sized`, as it is here)\n\
      \        // `mem::transmute(f)` is safe since `fn(&T, &mut \
       Formatter<'_>) -> Result`\n\
      \        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the \
       same ABI\n\
      \        // (as long as `T` is `Sized`)\n\
      \        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: \
       mem::transmute(x) } }\n\
      \    }\n\n\
      \    #[doc(hidden)]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n\
      \        ArgumentV1::new(x, USIZE_MARKER)\n\
      \    }\n\n\
      \    fn as_usize(&self) -> Option<usize> {\n\
      \        if self.formatter as usize == USIZE_MARKER as usize {\n\
      \            // SAFETY: The `formatter` field is only set to \
       USIZE_MARKER if\n\
      \            // the value is a usize, so this is safe\n\
      \            Some(unsafe { *(self.value as *const _ as *const usize) })\n\
      \        } else {\n\
      \            None\n\
      \        }\n\
      \    }\n\
       }\n\n\
       // flags available in the v1 format of format_args\n\
       #[derive(Copy, Clone)]\n\
       enum FlagV1 {\n\
      \    SignPlus,\n\
      \    SignMinus,\n\
      \    Alternate,\n\
      \    SignAwareZeroPad,\n\
      \    DebugLowerHex,\n\
      \    DebugUpperHex,\n\
       }\n\n\
       impl<'a> Arguments<'a> {\n\
      \    /// When using the format_args!() macro, this function is used to \
       generate the\n\
      \    /// Arguments structure.\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> \
       Arguments<'a> {\n\
      \        Arguments { pieces, fmt: None, args }\n\
      \    }\n\n\
      \    /// This function is used to specify nonstandard formatting \
       parameters.\n\
      \    /// The `pieces` array must be at least as long as `fmt` to construct\n\
      \    /// a valid Arguments structure. Also, any `Count` within `fmt` \
       that is\n\
      \    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n\
      \    /// created with `argumentusize`. However, failing to do so doesn't \
       cause\n\
      \    /// unsafety, but will ignore invalid .\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn new_v1_formatted(\n\
      \        pieces: &'a [&'a str],\n\
      \        args: &'a [ArgumentV1<'a>],\n\
      \        fmt: &'a [rt::v1::Argument],\n\
      \    ) -> Arguments<'a> {\n\
      \        Arguments { pieces, fmt: Some(fmt), args }\n\
      \    }\n\n\
      \    /// Estimates the length of the formatted text.\n\
      \    ///\n\
      \    /// This is intended to be used for setting initial `String` capacity\n\
      \    /// when using `format!`. Note: this is neither the lower nor upper \
       bound.\n\
      \    #[doc(hidden)]\n\
      \    #[inline]\n\
      \    #[unstable(feature = \"fmt_internals\", reason = \"internal to \
       format_args!\", issue = \"none\")]\n\
      \    pub fn estimated_capacity(&self) -> usize {\n\
      \        let pieces_length: usize = self.pieces.iter().map(|x| \
       x.len()).sum();\n\n\
      \        if self.args.is_empty() {\n\
      \            pieces_length\n\
      \        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n\
      \            // If the format string starts with an argument,\n\
      \            // don't preallocate anything, unless length\n\
      \            // of pieces is significant.\n\
      \            0\n\
      \        } else {\n\
      \            // There are some arguments, so any additional push\n\
      \            // will reallocate the string. To avoid that,\n\
      \            // we're \"pre-doubling\" the capacity here.\n\
      \            pieces_length.checked_mul(2).unwrap_or(0)\n\
      \        }\n\
      \    }\n\
       }\n\n\
       /// This structure represents a safely precompiled version of a format \
       string\n\
       /// and its arguments. This cannot be generated at runtime because it \
       cannot\n\
       /// safely be done, so no constructors are given and the fields are \
       private\n\
       /// to prevent modification.\n\
       ///\n\
       /// The [`format_args!`] macro will safely create an instance of this \
       structure.\n\
       /// The macro validates the format string at compile-time so usage of the\n\
       /// [`write`] and [`format`] functions can be safely performed.\n\
       ///\n\
       /// You can use the `Arguments<'a>` that [`format_args!`] returns in \
       `Debug`\n\
       /// and `Display` contexts as seen below. The example also shows that \
       `Debug`\n\
       /// and `Display` format to the same thing: the interpolated format \
       string\n\
       /// in `format_args!`.\n\
       ///\n\
       /// ```rust\n\
       /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n\
       /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n\
       /// assert_eq!(\"1 foo 2\", display);\n\
       /// assert_eq!(display, debug);\n\
       /// ```\n\
       ///\n\
       /// [`format_args!`]: ../../std/macro.format_args.html\n\
       /// [`format`]: ../../std/fmt/fn.format.html\n\
       /// [`write`]: ../../std/fmt/fn.write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[derive(Copy, Clone)]\n\
       pub struct Arguments<'a> {\n\
      \    // Format string pieces to print.\n\
      \    pieces: &'a [&'a str],\n\n\
      \    // Placeholder specs, or `None` if all specs are default (as in \
       \"{}{}\").\n\
      \    fmt: Option<&'a [rt::v1::Argument]>,\n\n\
      \    // Dynamic arguments for interpolation, to be interleaved with string\n\
      \    // pieces. (Every argument is preceded by a string piece.)\n\
      \    args: &'a [ArgumentV1<'a>],\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for Arguments<'_> {\n\
      \    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(self, fmt)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for Arguments<'_> {\n\
      \    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n\
      \        write(fmt.buf, *self)\n\
      \    }\n\
       }\n\n\
       /// `?` formatting.\n\
       ///\n\
       /// `Debug` should format the output in a programmer-facing, debugging \
       context.\n\
       ///\n\
       /// Generally speaking, you should just `derive` a `Debug` \
       implementation.\n\
       ///\n\
       /// When used with the alternate format specifier `#?`, the output is \
       pretty-printed.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// This trait can be used with `#[derive]` if all fields implement \
       `Debug`. When\n\
       /// `derive`d for structs, it will use the name of the `struct`, then \
       `{`, then a\n\
       /// comma-separated list of each field's name and `Debug` value, then \
       `}`. For\n\
       /// `enum`s, it will use the name of the variant and, if applicable, \
       `(`, then the\n\
       /// `Debug` values of the fields, then `)`.\n\
       ///\n\
       /// # Stability\n\
       ///\n\
       /// Derived `Debug` formats are not stable, and so may change with \
       future Rust\n\
       /// versions. Additionally, `Debug` implementations of types provided \
       by the\n\
       /// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not \
       stable, and\n\
       /// may also change with future Rust versions.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Deriving an implementation:\n\
       ///\n\
       /// ```\n\
       /// #[derive(Debug)]\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin \
       is: Point { x: 0, y: 0 }\");\n\
       /// ```\n\
       ///\n\
       /// Manually implementing:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// impl fmt::Debug for Point {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         f.debug_struct(\"Point\")\n\
       ///          .field(\"x\", &self.x)\n\
       ///          .field(\"y\", &self.y)\n\
       ///          .finish()\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin \
       is: Point { x: 0, y: 0 }\");\n\
       /// ```\n\
       ///\n\
       /// There are a number of helper methods on the [`Formatter`] struct to \
       help you with manual\n\
       /// implementations, such as [`debug_struct`].\n\
       ///\n\
       /// `Debug` implementations using either `derive` or the debug builder \
       API\n\
       /// on [`Formatter`] support pretty-printing using the alternate flag: \
       `{:#?}`.\n\
       ///\n\
       /// [`debug_struct`]: \
       ../../std/fmt/struct.Formatter.html#method.debug_struct\n\
       /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n\
       ///\n\
       /// Pretty-printing with `#?`:\n\
       ///\n\
       /// ```\n\
       /// #[derive(Debug)]\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n\
       /// \"The origin is: Point {\n\
       ///     x: 0,\n\
       ///     y: 0,\n\
       /// }\");\n\
       /// ```\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       #[rustc_on_unimplemented(\n\
      \    on(\n\
      \        crate_local,\n\
      \        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n\
      \        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n\
      \    ),\n\
      \    message = \"`{Self}` doesn't implement `{Debug}`\",\n\
      \    label = \"`{Self}` cannot be formatted using `{{:?}}` because it \
       doesn't implement `{Debug}`\"\n\
       )]\n\
       #[doc(alias = \"{:?}\")]\n\
       #[rustc_diagnostic_item = \"debug_trait\"]\n\
       pub trait Debug {\n\
      \    /// Formats the value using the given formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Position {\n\
      \    ///     longitude: f32,\n\
      \    ///     latitude: f32,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Debug for Position {\n\
      \    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \    ///         f.debug_tuple(\"\")\n\
      \    ///          .field(&self.longitude)\n\
      \    ///          .field(&self.latitude)\n\
      \    ///          .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n\
      \    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:#?}\", position), \"(\n\
      \    ///     1.987,\n\
      \    ///     2.983,\n\
      \    /// )\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       // Separate module to reexport the macro `Debug` from prelude without \
       the trait `Debug`.\n\
       pub(crate) mod macros {\n\
      \    /// Derive macro generating an impl of the trait `Debug`.\n\
      \    #[rustc_builtin_macro]\n\
      \    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n\
      \    #[allow_internal_unstable(core_intrinsics)]\n\
      \    pub macro Debug($item:item) {\n\
      \        /* compiler built-in */\n\
      \    }\n\
       }\n\
       #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n\
       #[doc(inline)]\n\
       pub use macros::Debug;\n\n\
       /// Format trait for an empty format, `{}`.\n\
       ///\n\
       /// `Display` is similar to [`Debug`][debug], but `Display` is for \
       user-facing\n\
       /// output, and so cannot be derived.\n\
       ///\n\
       /// [debug]: trait.Debug.html\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Implementing `Display` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Point {\n\
       ///     x: i32,\n\
       ///     y: i32,\n\
       /// }\n\
       ///\n\
       /// impl fmt::Display for Point {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         write!(f, \"({}, {})\", self.x, self.y)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let origin = Point { x: 0, y: 0 };\n\
       ///\n\
       /// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: \
       (0, 0)\");\n\
       /// ```\n\
       #[rustc_on_unimplemented(\n\
      \    on(\n\
      \        _Self = \"std::path::Path\",\n\
      \        label = \"`{Self}` cannot be formatted with the default \
       formatter; call `.display()` on it\",\n\
      \        note = \"call `.display()` or `.to_string_lossy()` to safely \
       print paths, \\\n\
      \                as they may contain non-Unicode data\"\n\
      \    ),\n\
      \    message = \"`{Self}` doesn't implement `{Display}`\",\n\
      \    label = \"`{Self}` cannot be formatted with the default formatter\",\n\
      \    note = \"in format strings you may be able to use `{{:?}}` (or \
       {{:#?}} for pretty-print) instead\"\n\
       )]\n\
       #[doc(alias = \"{}\")]\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Display {\n\
      \    /// Formats the value using the given formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Position {\n\
      \    ///     longitude: f32,\n\
      \    ///     latitude: f32,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Display for Position {\n\
      \    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
      \    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\"(1.987, 2.983)\",\n\
      \    ///            format!(\"{}\", Position { longitude: 1.987, \
       latitude: 2.983, }));\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `o` formatting.\n\
       ///\n\
       /// The `Octal` trait should format its output as a number in base-8.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0o` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '52' in octal\n\
       ///\n\
       /// assert_eq!(format!(\"{:o}\", x), \"52\");\n\
       /// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `Octal` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Octal for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(9);\n\
       ///\n\
       /// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: \
       11\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: \
       0o0011\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Octal {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `b` formatting.\n\
       ///\n\
       /// The `Binary` trait should format its output as a number in binary.\n\
       ///\n\
       /// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0b` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with [`i32`]:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '101010' in binary\n\
       ///\n\
       /// assert_eq!(format!(\"{:b}\", x), \"101010\");\n\
       /// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:b}\", -16), \
       \"11111111111111111111111111110000\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `Binary` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Binary for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(107);\n\
       ///\n\
       /// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: \
       1101011\");\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l as binary is: {:#032b}\", l),\n\
       ///     \"l as binary is: 0b000000000000000000000001101011\"\n\
       /// );\n\
       /// ```\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       /// [`i8`]: ../../std/primitive.i8.html\n\
       /// [`i128`]: ../../std/primitive.i128.html\n\
       /// [`isize`]: ../../std/primitive.isize.html\n\
       /// [`i32`]: ../../std/primitive.i32.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Binary {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `x` formatting.\n\
       ///\n\
       /// The `LowerHex` trait should format its output as a number in \
       hexadecimal, with `a` through `f`\n\
       /// in lower case.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0x` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '2a' in hex\n\
       ///\n\
       /// assert_eq!(format!(\"{:x}\", x), \"2a\");\n\
       /// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `LowerHex` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::LowerHex for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::LowerHex::fmt(&val, f) // delegate to i32's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(9);\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: \
       0x00000009\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait LowerHex {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `X` formatting.\n\
       ///\n\
       /// The `UpperHex` trait should format its output as a number in \
       hexadecimal, with `A` through `F`\n\
       /// in upper case.\n\
       ///\n\
       /// For primitive signed integers (`i8` to `i128`, and `isize`),\n\
       /// negative values are formatted as the twos complement representation.\n\
       ///\n\
       /// The alternate flag, `#`, adds a `0x` in front of the output.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42; // 42 is '2A' in hex\n\
       ///\n\
       /// assert_eq!(format!(\"{:X}\", x), \"2A\");\n\
       /// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n\
       ///\n\
       /// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `UpperHex` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::UpperHex for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = self.0;\n\
       ///\n\
       ///         fmt::UpperHex::fmt(&val, f) // delegate to i32's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(i32::MAX);\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: \
       7FFFFFFF\");\n\
       ///\n\
       /// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: \
       0x7FFFFFFF\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait UpperHex {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `p` formatting.\n\
       ///\n\
       /// The `Pointer` trait should format its output as a memory location. \
       This is commonly presented\n\
       /// as hexadecimal.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `&i32`:\n\
       ///\n\
       /// ```\n\
       /// let x = &42;\n\
       ///\n\
       /// let address = format!(\"{:p}\", x); // this produces something like \
       '0x7f06092ac6d0'\n\
       /// ```\n\
       ///\n\
       /// Implementing `Pointer` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::Pointer for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         // use `as` to convert to a `*const T`, which implements \
       Pointer, which we can use\n\
       ///\n\
       ///         let ptr = self as *const Self;\n\
       ///         fmt::Pointer::fmt(&ptr, f)\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(42);\n\
       ///\n\
       /// println!(\"l is in memory here: {:p}\", l);\n\
       ///\n\
       /// let l_ptr = format!(\"{:018p}\", l);\n\
       /// assert_eq!(l_ptr.len(), 18);\n\
       /// assert_eq!(&l_ptr[..2], \"0x\");\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait Pointer {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `e` formatting.\n\
       ///\n\
       /// The `LowerExp` trait should format its output in scientific \
       notation with a lower-case `e`.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `f64`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n\
       ///\n\
       /// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `LowerExp` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::LowerExp for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = f64::from(self.0);\n\
       ///         fmt::LowerExp::fmt(&val, f) // delegate to f64's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(100);\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:e}\", l),\n\
       ///     \"l in scientific notation is: 1e2\"\n\
       /// );\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:05e}\", l),\n\
       ///     \"l in scientific notation is: 001e2\"\n\
       /// );\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait LowerExp {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// `E` formatting.\n\
       ///\n\
       /// The `UpperExp` trait should format its output in scientific \
       notation with an upper-case `E`.\n\
       ///\n\
       /// For more information on formatters, see [the module-level \
       documentation][module].\n\
       ///\n\
       /// [module]: ../../std/fmt/index.html\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage with `f64`:\n\
       ///\n\
       /// ```\n\
       /// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n\
       ///\n\
       /// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n\
       /// ```\n\
       ///\n\
       /// Implementing `UpperExp` on a type:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// struct Length(i32);\n\
       ///\n\
       /// impl fmt::UpperExp for Length {\n\
       ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n\
       ///         let val = f64::from(self.0);\n\
       ///         fmt::UpperExp::fmt(&val, f) // delegate to f64's \
       implementation\n\
       ///     }\n\
       /// }\n\
       ///\n\
       /// let l = Length(100);\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:E}\", l),\n\
       ///     \"l in scientific notation is: 1E2\"\n\
       /// );\n\
       ///\n\
       /// assert_eq!(\n\
       ///     format!(\"l in scientific notation is: {:05E}\", l),\n\
       ///     \"l in scientific notation is: 001E2\"\n\
       /// );\n\
       /// ```\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub trait UpperExp {\n\
      \    /// Formats the value using the given formatter.\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n\
       }\n\n\
       /// The `write` function takes an output stream, and an `Arguments` \
       struct\n\
       /// that can be precompiled with the `format_args!` macro.\n\
       ///\n\
       /// The arguments will be formatted according to the specified format \
       string\n\
       /// into the output stream provided.\n\
       ///\n\
       /// # Examples\n\
       ///\n\
       /// Basic usage:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt;\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n\
       ///     .expect(\"Error occurred while trying to write in String\");\n\
       /// assert_eq!(output, \"Hello world!\");\n\
       /// ```\n\
       ///\n\
       /// Please note that using [`write!`] might be preferable. Example:\n\
       ///\n\
       /// ```\n\
       /// use std::fmt::Write;\n\
       ///\n\
       /// let mut output = String::new();\n\
       /// write!(&mut output, \"Hello {}!\", \"world\")\n\
       ///     .expect(\"Error occurred while trying to write in String\");\n\
       /// assert_eq!(output, \"Hello world!\");\n\
       /// ```\n\
       ///\n\
       /// [`write!`]: ../../std/macro.write.html\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n\
      \    let mut formatter = Formatter {\n\
      \        flags: 0,\n\
      \        width: None,\n\
      \        precision: None,\n\
      \        buf: output,\n\
      \        align: rt::v1::Alignment::Unknown,\n\
      \        fill: ' ',\n\
      \    };\n\n\
      \    let mut idx = 0;\n\n\
      \    match args.fmt {\n\
      \        None => {\n\
      \            // We can use default formatting parameters for all \
       arguments.\n\
      \            for (arg, piece) in \
       args.args.iter().zip(args.pieces.iter()) {\n\
      \                formatter.buf.write_str(*piece)?;\n\
      \                (arg.formatter)(arg.value, &mut formatter)?;\n\
      \                idx += 1;\n\
      \            }\n\
      \        }\n\
      \        Some(fmt) => {\n\
      \            // Every spec has a corresponding argument that is preceded \
       by\n\
      \            // a string piece.\n\
      \            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n\
      \                formatter.buf.write_str(*piece)?;\n\
      \                run(&mut formatter, arg, &args.args)?;\n\
      \                idx += 1;\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    // There can be only one trailing string piece left.\n\
      \    if let Some(piece) = args.pieces.get(idx) {\n\
      \        formatter.buf.write_str(*piece)?;\n\
      \    }\n\n\
      \    Ok(())\n\
       }\n\n\
       fn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: \
       &[ArgumentV1<'_>]) -> Result {\n\
      \    fmt.fill = arg.format.fill;\n\
      \    fmt.align = arg.format.align;\n\
      \    fmt.flags = arg.format.flags;\n\
      \    fmt.width = getcount(args, &arg.format.width);\n\
      \    fmt.precision = getcount(args, &arg.format.precision);\n\n\
      \    // Extract the correct argument\n\
      \    let value = args[arg.position];\n\n\
      \    // Then actually do some printing\n\
      \    (value.formatter)(value.value, fmt)\n\
       }\n\n\
       fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> \
       Option<usize> {\n\
      \    match *cnt {\n\
      \        rt::v1::Count::Is(n) => Some(n),\n\
      \        rt::v1::Count::Implied => None,\n\
      \        rt::v1::Count::Param(i) => args[i].as_usize(),\n\
      \    }\n\
       }\n\n\
       /// Padding after the end of something. Returned by `Formatter::padding`.\n\
       #[must_use = \"don't forget to write the post padding\"]\n\
       struct PostPadding {\n\
      \    fill: char,\n\
      \    padding: usize,\n\
       }\n\n\
       impl PostPadding {\n\
      \    fn new(fill: char, padding: usize) -> PostPadding {\n\
      \        PostPadding { fill, padding }\n\
      \    }\n\n\
      \    /// Write this post padding.\n\
      \    fn write(self, buf: &mut dyn Write) -> Result {\n\
      \        for _ in 0..self.padding {\n\
      \            buf.write_char(self.fill)?;\n\
      \        }\n\
      \        Ok(())\n\
      \    }\n\
       }\n\n\
       impl<'a> Formatter<'a> {\n\
      \    fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n\
      \    where\n\
      \        'b: 'c,\n\
      \        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n\
      \    {\n\
      \        Formatter {\n\
      \            // We want to change this\n\
      \            buf: wrap(self.buf),\n\n\
      \            // And preserve these\n\
      \            flags: self.flags,\n\
      \            fill: self.fill,\n\
      \            align: self.align,\n\
      \            width: self.width,\n\
      \            precision: self.precision,\n\
      \        }\n\
      \    }\n\n\
      \    // Helper methods used for padding and processing formatting \
       arguments that\n\
      \    // all formatting traits can use.\n\n\
      \    /// Performs the correct padding for an integer which has already \
       been\n\
      \    /// emitted into a str. The str should *not* contain the sign for the\n\
      \    /// integer, that will be added by this method.\n\
      \    ///\n\
      \    /// # Arguments\n\
      \    ///\n\
      \    /// * is_nonnegative - whether the original integer was either \
       positive or zero.\n\
      \    /// * prefix - if the '#' character (Alternate) is provided, this\n\
      \    ///   is the prefix to put in front of the number.\n\
      \    /// * buf - the byte array that the number has been formatted into\n\
      \    ///\n\
      \    /// This function will correctly account for the flags provided as \
       well as\n\
      \    /// the minimum width. It will not take precision into account.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo { nb: i32 };\n\
      \    ///\n\
      \    /// impl Foo {\n\
      \    ///     fn new(nb: i32) -> Foo {\n\
      \    ///         Foo {\n\
      \    ///             nb,\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         // We need to remove \"-\" from the number output.\n\
      \    ///         let tmp = self.nb.abs().to_string();\n\
      \    ///\n\
      \    ///         formatter.pad_integral(self.nb > 0, \"Foo \", &tmp)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\n\
      \    /// assert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n\
      \    /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, \
       buf: &str) -> Result {\n\
      \        let mut width = buf.len();\n\n\
      \        let mut sign = None;\n\
      \        if !is_nonnegative {\n\
      \            sign = Some('-');\n\
      \            width += 1;\n\
      \        } else if self.sign_plus() {\n\
      \            sign = Some('+');\n\
      \            width += 1;\n\
      \        }\n\n\
      \        let prefix = if self.alternate() {\n\
      \            width += prefix.chars().count();\n\
      \            Some(prefix)\n\
      \        } else {\n\
      \            None\n\
      \        };\n\n\
      \        // Writes the sign if it exists, and then the prefix if it was \
       requested\n\
      \        #[inline(never)]\n\
      \        fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, \
       prefix: Option<&str>) -> Result {\n\
      \            if let Some(c) = sign {\n\
      \                f.buf.write_char(c)?;\n\
      \            }\n\
      \            if let Some(prefix) = prefix { f.buf.write_str(prefix) } \
       else { Ok(()) }\n\
      \        }\n\n\
      \        // The `width` field is more of a `min-width` parameter at this \
       point.\n\
      \        match self.width {\n\
      \            // If there's no minimum length requirements then we can just\n\
      \            // write the bytes.\n\
      \            None => {\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)\n\
      \            }\n\
      \            // Check if we're over the minimum width, if so then we can \
       also\n\
      \            // just write the bytes.\n\
      \            Some(min) if width >= min => {\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)\n\
      \            }\n\
      \            // The sign and prefix goes before the padding if the fill \
       character\n\
      \            // is zero\n\
      \            Some(min) if self.sign_aware_zero_pad() => {\n\
      \                let old_fill = crate::mem::replace(&mut self.fill, '0');\n\
      \                let old_align = crate::mem::replace(&mut self.align, \
       rt::v1::Alignment::Right);\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                let post_padding = self.padding(min - width, \
       rt::v1::Alignment::Right)?;\n\
      \                self.buf.write_str(buf)?;\n\
      \                post_padding.write(self.buf)?;\n\
      \                self.fill = old_fill;\n\
      \                self.align = old_align;\n\
      \                Ok(())\n\
      \            }\n\
      \            // Otherwise, the sign and prefix goes after the padding\n\
      \            Some(min) => {\n\
      \                let post_padding = self.padding(min - width, \
       rt::v1::Alignment::Right)?;\n\
      \                write_prefix(self, sign, prefix)?;\n\
      \                self.buf.write_str(buf)?;\n\
      \                post_padding.write(self.buf)\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// This function takes a string slice and emits it to the internal \
       buffer\n\
      \    /// after applying the relevant formatting flags specified. The flags\n\
      \    /// recognized for generic strings are:\n\
      \    ///\n\
      \    /// * width - the minimum width of what to emit\n\
      \    /// * fill/align - what to emit and where to emit it if the string\n\
      \    ///                provided needs to be padded\n\
      \    /// * precision - the maximum length to emit, the string is \
       truncated if it\n\
      \    ///               is longer than this length\n\
      \    ///\n\
      \    /// Notably this function ignores the `flag` parameters.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.pad(\"Foo\")\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\n\
      \    /// assert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn pad(&mut self, s: &str) -> Result {\n\
      \        // Make sure there's a fast path up front\n\
      \        if self.width.is_none() && self.precision.is_none() {\n\
      \            return self.buf.write_str(s);\n\
      \        }\n\
      \        // The `precision` field can be interpreted as a `max-width` \
       for the\n\
      \        // string being formatted.\n\
      \        let s = if let Some(max) = self.precision {\n\
      \            // If our string is longer that the precision, then we must \
       have\n\
      \            // truncation. However other flags like `fill`, `width` and \
       `align`\n\
      \            // must act as always.\n\
      \            if let Some((i, _)) = s.char_indices().nth(max) {\n\
      \                // LLVM here can't prove that `..i` won't panic \
       `&s[..i]`, but\n\
      \                // we know that it can't panic. Use `get` + `unwrap_or` \
       to avoid\n\
      \                // `unsafe` and otherwise don't emit any panic-related \
       code\n\
      \                // here.\n\
      \                s.get(..i).unwrap_or(&s)\n\
      \            } else {\n\
      \                &s\n\
      \            }\n\
      \        } else {\n\
      \            &s\n\
      \        };\n\
      \        // The `width` field is more of a `min-width` parameter at this \
       point.\n\
      \        match self.width {\n\
      \            // If we're under the maximum length, and there's no \
       minimum length\n\
      \            // requirements, then we can just emit the string\n\
      \            None => self.buf.write_str(s),\n\
      \            // If we're under the maximum width, check if we're over \
       the minimum\n\
      \            // width, if so it's as easy as just emitting the string.\n\
      \            Some(width) if s.chars().count() >= width => \
       self.buf.write_str(s),\n\
      \            // If we're under both the maximum and the minimum width, \
       then fill\n\
      \            // up the minimum width with the specified string + some \
       alignment.\n\
      \            Some(width) => {\n\
      \                let align = rt::v1::Alignment::Left;\n\
      \                let post_padding = self.padding(width - \
       s.chars().count(), align)?;\n\
      \                self.buf.write_str(s)?;\n\
      \                post_padding.write(self.buf)\n\
      \            }\n\
      \        }\n\
      \    }\n\n\
      \    /// Write the pre-padding and return the unwritten post-padding. \
       Callers are\n\
      \    /// responsible for ensuring post-padding is written after the \
       thing that is\n\
      \    /// being padded.\n\
      \    fn padding(\n\
      \        &mut self,\n\
      \        padding: usize,\n\
      \        default: rt::v1::Alignment,\n\
      \    ) -> result::Result<PostPadding, Error> {\n\
      \        let align = match self.align {\n\
      \            rt::v1::Alignment::Unknown => default,\n\
      \            _ => self.align,\n\
      \        };\n\n\
      \        let (pre_pad, post_pad) = match align {\n\
      \            rt::v1::Alignment::Left => (0, padding),\n\
      \            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => \
       (padding, 0),\n\
      \            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / \
       2),\n\
      \        };\n\n\
      \        for _ in 0..pre_pad {\n\
      \            self.buf.write_char(self.fill)?;\n\
      \        }\n\n\
      \        Ok(PostPadding::new(self.fill, post_pad))\n\
      \    }\n\n\
      \    /// Takes the formatted parts and applies the padding.\n\
      \    /// Assumes that the caller already has rendered the parts with \
       required precision,\n\
      \    /// so that `self.precision` can be ignored.\n\
      \    fn pad_formatted_parts(&mut self, formatted: \
       &flt2dec::Formatted<'_>) -> Result {\n\
      \        if let Some(mut width) = self.width {\n\
      \            // for the sign-aware zero padding, we render the sign \
       first and\n\
      \            // behave as if we had no sign from the beginning.\n\
      \            let mut formatted = formatted.clone();\n\
      \            let old_fill = self.fill;\n\
      \            let old_align = self.align;\n\
      \            let mut align = old_align;\n\
      \            if self.sign_aware_zero_pad() {\n\
      \                // a sign always goes first\n\
      \                let sign = formatted.sign;\n\
      \                self.buf.write_str(sign)?;\n\n\
      \                // remove the sign from the formatted parts\n\
      \                formatted.sign = \"\";\n\
      \                width = width.saturating_sub(sign.len());\n\
      \                align = rt::v1::Alignment::Right;\n\
      \                self.fill = '0';\n\
      \                self.align = rt::v1::Alignment::Right;\n\
      \            }\n\n\
      \            // remaining parts go through the ordinary padding process.\n\
      \            let len = formatted.len();\n\
      \            let ret = if width <= len {\n\
      \                // no padding\n\
      \                self.write_formatted_parts(&formatted)\n\
      \            } else {\n\
      \                let post_padding = self.padding(width - len, align)?;\n\
      \                self.write_formatted_parts(&formatted)?;\n\
      \                post_padding.write(self.buf)\n\
      \            };\n\
      \            self.fill = old_fill;\n\
      \            self.align = old_align;\n\
      \            ret\n\
      \        } else {\n\
      \            // this is the common case and we take a shortcut\n\
      \            self.write_formatted_parts(formatted)\n\
      \        }\n\
      \    }\n\n\
      \    fn write_formatted_parts(&mut self, formatted: \
       &flt2dec::Formatted<'_>) -> Result {\n\
      \        fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n\
      \            // SAFETY: This is used for `flt2dec::Part::Num` and \
       `flt2dec::Part::Copy`.\n\
      \            // It's safe to use for `flt2dec::Part::Num` since every \
       char `c` is between\n\
      \            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n\
      \            // It's also probably safe in practice to use for \
       `flt2dec::Part::Copy(buf)`\n\
      \            // since `buf` should be plain ASCII, but it's possible for \
       someone to pass\n\
      \            // in a bad value for `buf` into `flt2dec::to_shortest_str` \
       since it is a\n\
      \            // public function.\n\
      \            // FIXME: Determine whether this could result in UB.\n\
      \            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n\
      \        }\n\n\
      \        if !formatted.sign.is_empty() {\n\
      \            self.buf.write_str(formatted.sign)?;\n\
      \        }\n\
      \        for part in formatted.parts {\n\
      \            match *part {\n\
      \                flt2dec::Part::Zero(mut nzeroes) => {\n\
      \                    const ZEROES: &str = // 64 zeroes\n\
      \                        \
       \"0000000000000000000000000000000000000000000000000000000000000000\";\n\
      \                    while nzeroes > ZEROES.len() {\n\
      \                        self.buf.write_str(ZEROES)?;\n\
      \                        nzeroes -= ZEROES.len();\n\
      \                    }\n\
      \                    if nzeroes > 0 {\n\
      \                        self.buf.write_str(&ZEROES[..nzeroes])?;\n\
      \                    }\n\
      \                }\n\
      \                flt2dec::Part::Num(mut v) => {\n\
      \                    let mut s = [0; 5];\n\
      \                    let len = part.len();\n\
      \                    for c in s[..len].iter_mut().rev() {\n\
      \                        *c = b'0' + (v % 10) as u8;\n\
      \                        v /= 10;\n\
      \                    }\n\
      \                    write_bytes(self.buf, &s[..len])?;\n\
      \                }\n\
      \                flt2dec::Part::Copy(buf) => {\n\
      \                    write_bytes(self.buf, buf)?;\n\
      \                }\n\
      \            }\n\
      \        }\n\
      \        Ok(())\n\
      \    }\n\n\
      \    /// Writes some data to the underlying buffer contained within this\n\
      \    /// formatter.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.write_str(\"Foo\")\n\
      \    ///         // This is equivalent to:\n\
      \    ///         // write!(formatter, \"Foo\")\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo), \"Foo\");\n\
      \    /// assert_eq!(&format!(\"{:0>8}\", Foo), \"Foo\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn write_str(&mut self, data: &str) -> Result {\n\
      \        self.buf.write_str(data)\n\
      \    }\n\n\
      \    /// Writes some formatted information into this instance.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\n\
      \    /// assert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n\
      \        write(self.buf, fmt)\n\
      \    }\n\n\
      \    /// Flags for formatting\n\
      \    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \    #[rustc_deprecated(\n\
      \        since = \"1.24.0\",\n\
      \        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n\
      \                  or `sign_aware_zero_pad` methods instead\"\n\
      \    )]\n\
      \    pub fn flags(&self) -> u32 {\n\
      \        self.flags\n\
      \    }\n\n\
      \    /// Character used as 'fill' whenever there is alignment.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         let c = formatter.fill();\n\
      \    ///         if let Some(width) = formatter.width() {\n\
      \    ///             for _ in 0..width {\n\
      \    ///                 write!(formatter, \"{}\", c)?;\n\
      \    ///             }\n\
      \    ///             Ok(())\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"{}\", c)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// // We set alignment to the left with \">\".\n\
      \    /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n\
      \    /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn fill(&self) -> char {\n\
      \        self.fill\n\
      \    }\n\n\
      \    /// Flag indicating what form of alignment was requested.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// extern crate core;\n\
      \    ///\n\
      \    /// use std::fmt::{self, Alignment};\n\
      \    ///\n\
      \    /// struct Foo;\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         let s = if let Some(s) = formatter.align() {\n\
      \    ///             match s {\n\
      \    ///                 Alignment::Left    => \"left\",\n\
      \    ///                 Alignment::Right   => \"right\",\n\
      \    ///                 Alignment::Center  => \"center\",\n\
      \    ///             }\n\
      \    ///         } else {\n\
      \    ///             \"into the void\"\n\
      \    ///         };\n\
      \    ///         write!(formatter, \"{}\", s)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n\
      \    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n\
      \    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n\
      \    pub fn align(&self) -> Option<Alignment> {\n\
      \        match self.align {\n\
      \            rt::v1::Alignment::Left => Some(Alignment::Left),\n\
      \            rt::v1::Alignment::Right => Some(Alignment::Right),\n\
      \            rt::v1::Alignment::Center => Some(Alignment::Center),\n\
      \            rt::v1::Alignment::Unknown => None,\n\
      \        }\n\
      \    }\n\n\
      \    /// Optionally specified integer width that the output should be.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if let Some(width) = formatter.width() {\n\
      \    ///             // If we received a width, we use it\n\
      \    ///             write!(formatter, \"{:width$}\", \
       &format!(\"Foo({})\", self.0), width = width)\n\
      \    ///         } else {\n\
      \    ///             // Otherwise we do nothing special\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn width(&self) -> Option<usize> {\n\
      \        self.width\n\
      \    }\n\n\
      \    /// Optionally specified precision for numeric types. \
       Alternatively, the\n\
      \    /// maximum width for string types.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(f32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if let Some(precision) = formatter.precision() {\n\
      \    ///             // If we received a precision, we use it.\n\
      \    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n\
      \    ///         } else {\n\
      \    ///             // Otherwise we default to 2.\n\
      \    ///             write!(formatter, \"Foo({:.2})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn precision(&self) -> Option<usize> {\n\
      \        self.precision\n\
      \    }\n\n\
      \    /// Determines if the `+` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.sign_plus() {\n\
      \    ///             write!(formatter,\n\
      \    ///                    \"Foo({}{})\",\n\
      \    ///                    if self.0 < 0 { '-' } else { '+' },\n\
      \    ///                    self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_plus(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `-` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.sign_minus() {\n\
      \    ///             // You want a minus sign? Have one!\n\
      \    ///             write!(formatter, \"-Foo({})\", self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_minus(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `#` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         if formatter.alternate() {\n\
      \    ///             write!(formatter, \"Foo({})\", self.0)\n\
      \    ///         } else {\n\
      \    ///             write!(formatter, \"{}\", self.0)\n\
      \    ///         }\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n\
      \    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn alternate(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::Alternate as u32) != 0\n\
      \    }\n\n\
      \    /// Determines if the `0` flag was specified.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(i32);\n\
      \    ///\n\
      \    /// impl fmt::Display for Foo {\n\
      \    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> \
       fmt::Result {\n\
      \    ///         assert!(formatter.sign_aware_zero_pad());\n\
      \    ///         assert_eq!(formatter.width(), Some(4));\n\
      \    ///         // We ignore the formatter's options.\n\
      \    ///         write!(formatter, \"{}\", self.0)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n\
      \    pub fn sign_aware_zero_pad(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n\
      \    }\n\n\
      \    // FIXME: Decide what public API we want for these two flags.\n\
      \    // https://github.com/rust-lang/rust/issues/48584\n\
      \    fn debug_lower_hex(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n\
      \    }\n\n\
      \    fn debug_upper_hex(&self) -> bool {\n\
      \        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n\
      \    }\n\n\
      \    /// Creates a [`DebugStruct`] builder designed to assist with \
       creation of\n\
      \    /// [`fmt::Debug`] implementations for structs.\n\
      \    ///\n\
      \    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n\
      \    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    /// use std::net::Ipv4Addr;\n\
      \    ///\n\
      \    /// struct Foo {\n\
      \    ///     bar: i32,\n\
      \    ///     baz: String,\n\
      \    ///     addr: Ipv4Addr,\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_struct(\"Foo\")\n\
      \    ///             .field(\"bar\", &self.bar)\n\
      \    ///             .field(\"baz\", &self.baz)\n\
      \    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n\
      \    ///             .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 \
       }\",\n\
      \    ///     format!(\"{:?}\", Foo {\n\
      \    ///         bar: 10,\n\
      \    ///         baz: \"Hello World\".to_string(),\n\
      \    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n\
      \    ///     })\n\
      \    /// );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_struct<'b>(&'b mut self, name: &str) -> \
       DebugStruct<'b, 'a> {\n\
      \        builders::debug_struct_new(self, name)\n\
      \    }\n\n\
      \    /// Creates a `DebugTuple` builder designed to assist with creation \
       of\n\
      \    /// `fmt::Debug` implementations for tuple structs.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    /// use std::marker::PhantomData;\n\
      \    ///\n\
      \    /// struct Foo<T>(i32, String, PhantomData<T>);\n\
      \    ///\n\
      \    /// impl<T> fmt::Debug for Foo<T> {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_tuple(\"Foo\")\n\
      \    ///             .field(&self.0)\n\
      \    ///             .field(&self.1)\n\
      \    ///             .field(&format_args!(\"_\"))\n\
      \    ///             .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     \"Foo(10, \\\"Hello\\\", _)\",\n\
      \    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), \
       PhantomData::<u8>))\n\
      \    /// );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, \
       'a> {\n\
      \        builders::debug_tuple_new(self, name)\n\
      \    }\n\n\
      \    /// Creates a `DebugList` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for list-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<i32>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_list().entries(self.0.iter()).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n\
      \        builders::debug_list_new(self)\n\
      \    }\n\n\
      \    /// Creates a `DebugSet` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for set-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<i32>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_set().entries(self.0.iter()).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n\
      \    /// ```\n\
      \    ///\n\
      \    /// [`format_args!`]: ../../std/macro.format_args.html\n\
      \    ///\n\
      \    /// In this more complex example, we use [`format_args!`] and \
       `.debug_set()`\n\
      \    /// to build a list of match arms:\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n\
      \    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n\
      \    ///\n\
      \    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n\
      \    /// where\n\
      \    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n\
      \    /// {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         L::fmt(&(self.0).0, fmt)?;\n\
      \    ///         fmt.write_str(\" => \")?;\n\
      \    ///         R::fmt(&(self.0).1, fmt)\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n\
      \    /// where\n\
      \    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n\
      \    /// {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_set()\n\
      \    ///         .entries(self.0.iter().map(Arm))\n\
      \    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n\
      \    ///         .finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n\
      \        builders::debug_set_new(self)\n\
      \    }\n\n\
      \    /// Creates a `DebugMap` builder designed to assist with creation of\n\
      \    /// `fmt::Debug` implementations for map-like structures.\n\
      \    ///\n\
      \    /// # Examples\n\
      \    ///\n\
      \    /// ```rust\n\
      \    /// use std::fmt;\n\
      \    ///\n\
      \    /// struct Foo(Vec<(String, i32)>);\n\
      \    ///\n\
      \    /// impl fmt::Debug for Foo {\n\
      \    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n\
      \    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref \
       v)| (k, v))).finish()\n\
      \    ///     }\n\
      \    /// }\n\
      \    ///\n\
      \    /// assert_eq!(\n\
      \    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), \
       (\"B\".to_string(), 11)])),\n\
      \    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n\
      \    ///  );\n\
      \    /// ```\n\
      \    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n\
      \    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n\
      \        builders::debug_map_new(self)\n\
      \    }\n\
       }\n\n\
       #[stable(since = \"1.2.0\", feature = \"formatter_write\")]\n\
       impl Write for Formatter<'_> {\n\
      \    fn write_str(&mut self, s: &str) -> Result {\n\
      \        self.buf.write_str(s)\n\
      \    }\n\n\
      \    fn write_char(&mut self, c: char) -> Result {\n\
      \        self.buf.write_char(c)\n\
      \    }\n\n\
      \    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n\
      \        write(self.buf, args)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for Error {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(\"an error occurred when formatting an argument\", \
       f)\n\
      \    }\n\
       }\n\n\
       // Implementations of the core formatting traits\n\n\
       macro_rules! fmt_refs {\n\
      \    ($($tr:ident),*) => {\n\
      \        $(\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<T: ?Sized + $tr> $tr for &T {\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result { \
       $tr::fmt(&**self, f) }\n\
      \        }\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<T: ?Sized + $tr> $tr for &mut T {\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result { \
       $tr::fmt(&**self, f) }\n\
      \        }\n\
      \        )*\n\
      \    }\n\
       }\n\n\
       fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, \
       LowerExp, UpperExp }\n\n\
       #[unstable(feature = \"never_type\", issue = \"35121\")]\n\
       impl Debug for ! {\n\
      \    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n\
      \        *self\n\
      \    }\n\
       }\n\n\
       #[unstable(feature = \"never_type\", issue = \"35121\")]\n\
       impl Display for ! {\n\
      \    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n\
      \        *self\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for bool {\n\
      \    #[inline]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(self, f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for bool {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for str {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.write_char('\"')?;\n\
      \        let mut from = 0;\n\
      \        for (i, c) in self.char_indices() {\n\
      \            let esc = c.escape_debug();\n\
      \            // If char needs escaping, flush backlog so far and write, \
       else skip\n\
      \            if esc.len() != 1 {\n\
      \                f.write_str(&self[from..i])?;\n\
      \                for c in esc {\n\
      \                    f.write_char(c)?;\n\
      \                }\n\
      \                from = i + c.len_utf8();\n\
      \            }\n\
      \        }\n\
      \        f.write_str(&self[from..])?;\n\
      \        f.write_char('\"')\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for str {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(self)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for char {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.write_char('\\'')?;\n\
      \        for c in self.escape_debug() {\n\
      \            f.write_char(c)?\n\
      \        }\n\
      \        f.write_char('\\'')\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Display for char {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        if f.width.is_none() && f.precision.is_none() {\n\
      \            f.write_char(*self)\n\
      \        } else {\n\
      \            f.pad(self.encode_utf8(&mut [0; 4]))\n\
      \        }\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for *const T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        let old_width = f.width;\n\
      \        let old_flags = f.flags;\n\n\
      \        // The alternate flag is already treated by LowerHex as being \
       special-\n\
      \        // it denotes whether to prefix with 0x. We use it to work out \
       whether\n\
      \        // or not to zero extend, and then unconditionally set it to \
       get the\n\
      \        // prefix.\n\
      \        if f.alternate() {\n\
      \            f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n\n\
      \            if f.width.is_none() {\n\
      \                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n\
      \            }\n\
      \        }\n\
      \        f.flags |= 1 << (FlagV1::Alternate as u32);\n\n\
      \        let ret = LowerHex::fmt(&(*self as *const () as usize), f);\n\n\
      \        f.width = old_width;\n\
      \        f.flags = old_flags;\n\n\
      \        ret\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for *mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(*self as *const T), f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for &T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(*self as *const T), f)\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Pointer for &mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(&(&**self as *const T), f)\n\
      \    }\n\
       }\n\n\
       // Implementation of Display/Debug for various core types\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for *const T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(self, f)\n\
      \    }\n\
       }\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for *mut T {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        Pointer::fmt(self, f)\n\
      \    }\n\
       }\n\n\
       macro_rules! peel {\n\
      \    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n\
       }\n\n\
       macro_rules! tuple {\n\
      \    () => ();\n\
      \    ( $($name:ident,)+ ) => (\n\
      \        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
      \        impl<$($name:Debug),+> Debug for ($($name,)+) where \
       last_type!($($name,)+): ?Sized {\n\
      \            #[allow(non_snake_case, unused_assignments)]\n\
      \            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \                let mut builder = f.debug_tuple(\"\");\n\
      \                let ($(ref $name,)+) = *self;\n\
      \                $(\n\
      \                    builder.field(&$name);\n\
      \                )+\n\n\
      \                builder.finish()\n\
      \            }\n\
      \        }\n\
      \        peel! { $($name,)+ }\n\
      \    )\n\
       }\n\n\
       macro_rules! last_type {\n\
      \    ($a:ident,) => { $a };\n\
      \    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n\
       }\n\n\
       tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: Debug> Debug for [T] {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.debug_list().entries(self.iter()).finish()\n\
      \    }\n\
       }\n\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl Debug for () {\n\
      \    #[inline]\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(\"()\")\n\
      \    }\n\
       }\n\
       #[stable(feature = \"rust1\", since = \"1.0.0\")]\n\
       impl<T: ?Sized> Debug for PhantomData<T> {\n\
      \    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\
      \        f.pad(\"PhantomData\")\n\
      \    }\n\
       }" );
    (2356, 69106, "");
    (2356, 0, "i");
    (2357, 0, "m");
    (2358, 0, "p");
    (2359, 0, "l");
    (2356, 4, "");
    ( 2259,
      0,
      "impl<Item: ListItem> Default for ItemMarker<Item> {\n\
      \    fn default() -> Self { Self::null() }\n\
       }\n\n" );
    (2377, 7, "D");
    (2378, 0, "e");
    (2379, 0, "b");
    (2380, 0, "u");
    (2381, 0, "g");
    (2377, 0, "f");
    (2378, 0, "m");
    (2379, 0, "t");
    (2380, 0, ":");
    (2381, 0, ":");
    (2415, 37, "");
    (2415, 0, "f");
    (2416, 0, "n");
    (2417, 0, " ");
    (2418, 0, "f");
    (2419, 0, "m");
    (2420, 0, "t");
    (2421, 0, "(");
    (2422, 0, "&");
    (2423, 0, "s");
    (2424, 0, "e");
    (2425, 0, "l");
    (2426, 0, "f");
    (2427, 0, ",");
    (2428, 0, " ");
    (2429, 0, "f");
    (2430, 0, ":");
    (2431, 0, " ");
    (2432, 0, "&");
    (2433, 0, "m");
    (2434, 0, "u");
    (2435, 0, "t");
    (2436, 0, " ");
    (2437, 0, "F");
    (2438, 0, "o");
    (2439, 0, "r");
    (2440, 0, "m");
    (2441, 0, "a");
    (2442, 0, "t");
    (2443, 0, "t");
    (2444, 0, "e");
    (2445, 0, "r");
    (2446, 0, "<");
    (2447, 0, "'");
    (2448, 0, "_");
    (2449, 0, "'");
    (2449, 1, "");
    (2449, 0, ">");
    (2450, 0, ")");
    (2451, 0, " ");
    (2452, 0, "-");
    (2453, 0, ">");
    (2454, 0, " ");
    (2455, 0, "R");
    (2456, 0, "e");
    (2457, 0, "s");
    (2458, 0, "u");
    (2459, 0, "l");
    (2460, 0, "t");
    (2461, 0, " ");
    (2462, 0, "{");
    (2463, 0, "\n        ");
    (2472, 0, "\n        ");
    (2464, 8, "");
    (2465, 8, "    }");
    (2464, 0, "        ");
    (2472, 0, "f");
    (2473, 0, ".");
    (2474, 0, "p");
    (2475, 0, "a");
    (2476, 0, "d");
    (2477, 0, "(");
    (2478, 0, "\"");
    (2479, 0, "I");
    (2480, 0, "t");
    (2481, 0, "e");
    (2482, 0, "m");
    (2483, 0, "M");
    (2484, 0, "a");
    (2485, 0, "r");
    (2486, 0, "k");
    (2487, 0, "e");
    (2488, 0, "r");
    (2489, 0, "\"");
    (2490, 0, ")");
    (2491, 0, ";");
    (2491, 1, "");
    (2437, 0, "f");
    (2438, 0, "m");
    (2439, 0, "t");
    (2440, 0, ":");
    (2441, 0, ":");
    (2460, 0, "s");
    (2461, 0, "t");
    (2462, 0, ":");
    (2462, 1, "");
    (2462, 0, "d");
    (2463, 0, ":");
    (2464, 0, ":");
    (2460, 3, "f");
    (2461, 0, "m");
    (2462, 0, "t");
    (3651, 0, "\nimpl ListItem for u8 {}");
    (3651, 0, "\nimpl ListItem for u8 {}");
    (3675, 0, "\n");
    (3646, 2, "b");
    (3647, 0, "o");
    (3648, 0, "o");
    (3649, 0, "l");
    (3672, 2, "c");
    (3673, 0, "h");
    (3674, 0, "a");
    (3675, 0, "r");
    (3680, 1, "");
    (3933, 0, "\n");
    (3933, 0, "impl ListItem for bool {}\nimpl ListItem for char {}\n");
    (3984, 1, "");
    (3951, 0, "&");
    (3978, 0, "&");
    (3154, 0, "\n    ");
    (3159, 0, "\n    ");
    (3155, 4, "");
    (3160, 0, "f");
    (3161, 0, "n");
    (3162, 0, " ");
    (3163, 0, "m");
    (3164, 0, "e");
    (3165, 0, "r");
    (3166, 0, "g");
    (3167, 0, "e");
    (3168, 0, "_");
    (3169, 0, "i");
    (3170, 0, "n");
    (3171, 0, "t");
    (3172, 0, "o");
    (3173, 0, "(");
    (3174, 0, "&");
    (3175, 0, "m");
    (3176, 0, "u");
    (3177, 0, "t");
    (3178, 0, " ");
    (3179, 0, "s");
    (3180, 0, "e");
    (3181, 0, "l");
    (3182, 0, "f");
    (3183, 0, ",");
    (3184, 0, " ");
    (3185, 0, "o");
    (3186, 0, "t");
    (3187, 0, "h");
    (3188, 0, "e");
    (3189, 0, "r");
    (3190, 0, ":");
    (3191, 0, " ");
    (3192, 0, "&");
    (3193, 0, "S");
    (3194, 0, "e");
    (3195, 0, "p");
    (3196, 0, "l");
    (3197, 0, "f");
    (3197, 1, "");
    (3196, 1, "");
    (3195, 1, "");
    (3195, 0, "l");
    (3196, 0, "f");
    (3197, 0, ")");
    (3198, 0, " ");
    (3199, 0, "-");
    (3199, 1, "");
    (3199, 0, "-");
    (3200, 0, ">");
    (3201, 0, " ");
    (3202, 0, "b");
    (3203, 0, "o");
    (3204, 0, "o");
    (3205, 0, "l");
    (3206, 0, ";");
    (3160, 0, "// ");
    (3156, 0, "    // fn merge_into(&mut self, other: &Self) -> bool;\n");
    (3215, 3, "");
    (3210, 0, "\n    ");
    (3223, 10, "c");
    (3211, 4, "");
    (3220, 0, "a");
    (3221, 0, "n");
    (3222, 0, "_");
    (3223, 0, "m");
    (3224, 0, "e");
    (3225, 0, "r");
    (3226, 0, "g");
    (3227, 0, "e");
    (3230, 4, "");
    (3258, 0, "\n    ");
    (3263, 0, "f");
    (3264, 0, "n");
    (3265, 0, " ");
    (3266, 0, "m");
    (3267, 0, "e");
    (3268, 0, "r");
    (3269, 0, "g");
    (3270, 0, "e");
    (3271, 0, "(");
    (3272, 0, "&");
    (3272, 1, "");
    (3272, 0, "s");
    (3273, 0, "e");
    (3274, 0, "l");
    (3275, 0, "f");
    (3276, 0, ",");
    (3277, 0, " ");
    (3278, 0, "t");
    (3279, 0, "h");
    (3279, 1, "");
    (3278, 1, "");
    (3278, 0, "i");
    (3279, 0, "t");
    (3280, 0, "h");
    (3281, 0, "e");
    (3282, 0, "r");
    (3283, 0, ":");
    (3284, 0, " ");
    (3285, 0, "S");
    (3286, 0, "e");
    (3287, 0, "l");
    (3288, 0, "f");
    (3278, 1, "");
    (3278, 0, "o");
    (3289, 0, ")");
    (3290, 0, " ");
    (3291, 0, "-");
    (3292, 0, ".");
    (3293, 0, " ");
    (3294, 0, "S");
    (3294, 1, "");
    (3293, 1, "");
    (3292, 1, "");
    (3292, 0, ">");
    (3293, 0, " ");
    (3294, 0, "S");
    (3295, 0, "e");
    (3296, 0, "l");
    (3297, 0, "f");
    (3298, 0, ";");
    (3299, 0, "\n    ");
    (3300, 4, "");
    (3263, 0, "// ");
    (3216, 0, "// ");
    (3306, 0, "\n    ");
    (3311, 0, "f");
    (3312, 0, "n");
    (3313, 0, " ");
    (3314, 0, "t");
    (3315, 0, "r");
    (3316, 0, "y");
    (3317, 0, "_");
    (3318, 0, "m");
    (3319, 0, "e");
    (3320, 0, "r");
    (3321, 0, "g");
    (3322, 0, "e");
    (3323, 0, "(");
    (3324, 0, "&");
    (3325, 0, "s");
    (3326, 0, "e");
    (3327, 0, "l");
    (3328, 0, "f");
    (3329, 0, ",");
    (3330, 0, " ");
    (3331, 0, "o");
    (3332, 0, "t");
    (3333, 0, "h");
    (3334, 0, "e");
    (3335, 0, "r");
    (3336, 0, ":");
    (3337, 0, " ");
    (3338, 0, "&");
    (3339, 0, "s");
    (3340, 0, "e");
    (3341, 0, "l");
    (3342, 0, "f");
    (3343, 0, ")");
    (3344, 0, " ");
    (3345, 0, "-");
    (3346, 0, ">");
    (3347, 0, " ");
    (3348, 0, "O");
    (3349, 0, "p");
    (3350, 0, "t");
    (3351, 0, "i");
    (3352, 0, "o");
    (3353, 0, "n");
    (3354, 0, "<");
    (3355, 0, "S");
    (3356, 0, "e");
    (3357, 0, "l");
    (3358, 0, "f");
    (3359, 0, ")");
    (3359, 1, "");
    (3359, 0, ">");
    (3360, 0, ";");
    (3361, 0, "/");
    (3362, 0, "/");
    (3362, 1, "");
    (3361, 1, "");
    (3311, 0, "// ");
    (3211, 153, "");
    (3210, 1, "");
    (3160, 3, "");
    (3206, 1, "");
    (3206, 0, " ");
    (3207, 0, "{");
    (3208, 0, "\n        ");
    (3209, 8, "    }");
    (3208, 0, "\n        ");
    (3217, 0, "f");
    (3218, 0, "a");
    (3219, 0, "l");
    (3220, 0, "s");
    (3221, 0, "e");
    (3155, 0, "\n    ");
    (3160, 0, "/");
    (3161, 0, "/");
    (3162, 0, " ");
    (3163, 0, "T");
    (3164, 0, "r");
    (3165, 0, "y");
    (3156, 10, "");
    (3155, 1, "");
    (3185, 0, "_");
    (3163, 0, "t");
    (3164, 0, "r");
    (3165, 0, "y");
    (3166, 0, "_");
    (3176, 1, "");
    (3175, 1, "");
    (3174, 1, "");
    (3173, 1, "");
    (3172, 1, "");
    (3172, 0, "_into");
    (2835, 0, "\n    ");
    (3168, 14, "m");
    (2836, 4, "");
    (3165, 0, "e");
    (3166, 0, "r");
    (3167, 0, "g");
    (3168, 0, "e");
    (3169, 0, "_");
    (3170, 0, "f");
    (3171, 0, "r");
    (3172, 0, "o");
    (3173, 0, "m");
    (2836, 0, "/");
    (2837, 0, "/");
    (2838, 0, "/");
    (2838, 1, "");
    (2837, 1, "");
    (2836, 1, "");
    (2836, 0, "        ");
    (2844, 0, "/");
    (2845, 0, "/");
    (2846, 0, "/");
    (2846, 1, "");
    (2845, 1, "");
    (2844, 1, "");
    (2840, 4, "");
    (2840, 0, "/");
    (2841, 0, "/");
    (2842, 0, "/");
    (2843, 0, "/");
    (2844, 0, " ");
    (2844, 1, "");
    (2843, 1, "");
    (2843, 0, " ");
    (2844, 0, "T");
    (2845, 0, "h");
    (2846, 0, "e");
    (2847, 0, " ");
    (2848, 0, "u");
    (2849, 0, "s");
    (2850, 0, "e");
    (2851, 0, "r");
    (2848, 4, "l");
    (2849, 0, "e");
    (2850, 0, "n");
    (2851, 0, "g");
    (2844, 8, "A");
    (2845, 0, "n");
    (2846, 0, " ");
    (2847, 0, "o");
    (2848, 0, "p");
    (2849, 0, "t");
    (2850, 0, "i");
    (2851, 0, "m");
    (2852, 0, "i");
    (2853, 0, "z");
    (2854, 0, "e");
    (2855, 0, "d");
    (2856, 0, " ");
    (2857, 0, "v");
    (2858, 0, "e");
    (2859, 0, "r");
    (2857, 3, "m");
    (2858, 0, "e");
    (2859, 0, "t");
    (2860, 0, "h");
    (2861, 0, "o");
    (2862, 0, "d");
    (2863, 0, " ");
    (2864, 0, "t");
    (2865, 0, "o");
    (2866, 0, " ");
    (2867, 0, "c");
    (2868, 0, "a");
    (2869, 0, "l");
    (2870, 0, "c");
    (2871, 0, "u");
    (2872, 0, "l");
    (2873, 0, "a");
    (2874, 0, "t");
    (2875, 0, "e");
    (2876, 0, " ");
    (2877, 0, "t");
    (2878, 0, "h");
    (2879, 0, "e");
    (2880, 0, " ");
    (2881, 0, "u");
    (2882, 0, "s");
    (2883, 0, "e");
    (2884, 0, "r");
    (2885, 0, "l");
    (2886, 0, "e");
    (2887, 0, "n");
    (2888, 0, " ");
    (2889, 0, "o");
    (2890, 0, "f");
    (2891, 0, " ");
    (2892, 0, "a");
    (2893, 0, " ");
    (2894, 0, "s");
    (2895, 0, "l");
    (2896, 0, "i");
    (2897, 0, "c");
    (2898, 0, "e");
    (2899, 0, " ");
    (2900, 0, "o");
    (2901, 0, "f");
    (2902, 0, " ");
    (2903, 0, "L");
    (2904, 0, "i");
    (2905, 0, "s");
    (2906, 0, "t");
    (2907, 0, "I");
    (2908, 0, "t");
    (2909, 0, "e");
    (2910, 0, "m");
    (2911, 0, "s");
    (2912, 0, ".");
    (2913, 0, " ");
    (2914, 0, "T");
    (2915, 0, "h");
    (2916, 0, "e");
    (2917, 0, " ");
    (2918, 0, "d");
    (2919, 0, "e");
    (2920, 0, "f");
    (2921, 0, "a");
    (2922, 0, "u");
    (2923, 0, "l");
    (2924, 0, "t");
    (2925, 0, " ");
    (2926, 0, "i");
    (2927, 0, "m");
    (2928, 0, "p");
    (2929, 0, "l");
    (2930, 0, "e");
    (2931, 0, "m");
    (2932, 0, "e");
    (2933, 0, "n");
    (2934, 0, "t");
    (2935, 0, "a");
    (2936, 0, "t");
    (2937, 0, "i");
    (2938, 0, "o");
    (2939, 0, "n");
    (2940, 0, " ");
    (2941, 0, "s");
    (2942, 0, "i");
    (2943, 0, "m");
    (2944, 0, "p");
    (2945, 0, "l");
    (2946, 0, "y");
    (2947, 0, " ");
    (2948, 0, "c");
    (2949, 0, "a");
    (2950, 0, "l");
    (2951, 0, "l");
    (2952, 0, "s");
    (2953, 0, " ");
    (2954, 0, "g");
    (2954, 1, "");
    (2954, 0, "[");
    (2955, 0, "`");
    (2956, 0, "g");
    (2957, 0, "e");
    (2958, 0, "t");
    (2959, 0, "_");
    (2960, 0, "u");
    (2961, 0, "s");
    (2962, 0, "e");
    (2963, 0, "r");
    (2964, 0, "s");
    (2965, 0, "i");
    (2966, 0, "z");
    (2967, 0, "e");
    (2968, 0, "`");
    (2969, 0, "]");
    (2970, 0, " ");
    (2971, 0, "i");
    (2972, 0, "n");
    (2973, 0, " ");
    (2974, 0, "a");
    (2975, 0, " ");
    (2976, 0, "l");
    (2977, 0, "o");
    (2978, 0, "o");
    (2979, 0, "p");
    (2980, 0, ".");
    ( 2836,
      145,
      "    /// An optimized method to calculate the userlen of a slice of \
       ListItems.\n\
      \    /// The default implementation simply calls [`get_usersize`] in a \
       loop." );
    (3144, 0, "\n    ");
    (3149, 0, "/");
    (3150, 0, "/");
    (3151, 0, "/");
    (3152, 0, " ");
    (3153, 0, "S");
    (3154, 0, "p");
    (3155, 0, "l");
    (3156, 0, "i");
    (3157, 0, "t");
    (3158, 0, " ");
    (3159, 0, "t");
    (3160, 0, "h");
    (3161, 0, "e");
    (3162, 0, " ");
    (3163, 0, "s");
    (3164, 0, "p");
    (3165, 0, "e");
    (3163, 3, "n");
    (3164, 0, "a");
    (3165, 0, "m");
    (3166, 0, "e");
    (3167, 0, "d");
    (3168, 0, " ");
    (3169, 0, "i");
    (3170, 0, "t");
    (3171, 0, "e");
    (3172, 0, "m");
    (3173, 0, " ");
    (3174, 0, "a");
    (3175, 0, "t");
    (3174, 2, "i");
    (3175, 0, "n");
    (3176, 0, " ");
    (3177, 0, "a");
    (3177, 1, "");
    (3176, 1, "");
    (3176, 0, "t");
    (3177, 0, "o");
    (3178, 0, " ");
    (3179, 0, "a");
    (3180, 0, " ");
    (3181, 0, "p");
    (3182, 0, "a");
    (3183, 0, "i");
    (3184, 0, "r");
    (3185, 0, " ");
    (3186, 0, "o");
    (3187, 0, "f");
    (3188, 0, " ");
    (3189, 0, "i");
    (3190, 0, "t");
    (3191, 0, "e");
    (3192, 0, "m");
    (3193, 0, "s");
    (3163, 5, "p");
    (3164, 0, "a");
    (3165, 0, "s");
    (3166, 0, "s");
    (3167, 0, "e");
    (3168, 0, "d");
    (3195, 0, " ");
    (3196, 0, "a");
    (3197, 0, "t");
    (3198, 0, " ");
    (3199, 0, "a");
    (3200, 0, " ");
    (3201, 0, "s");
    (3202, 0, "p");
    (3202, 1, "");
    (3201, 1, "");
    (3200, 1, "");
    (3199, 1, "");
    (3199, 0, "a");
    (3200, 0, " ");
    (3201, 0, "s");
    (3201, 1, "");
    (3200, 1, "");
    (3199, 1, "");
    (3198, 1, "");
    (3198, 0, " ");
    (3199, 0, "s");
    (3200, 0, "o");
    (3201, 0, "m");
    (3202, 0, "e");
    (3203, 0, " ");
    (3204, 0, "s");
    (3205, 0, "p");
    (3206, 0, "e");
    (3207, 0, "c");
    (3208, 0, "i");
    (3209, 0, "f");
    (3210, 0, "i");
    (3211, 0, "e");
    (3212, 0, "d");
    (3213, 0, " ");
    (3214, 0, "o");
    (3215, 0, "f");
    (3216, 0, "f");
    (3217, 0, "s");
    (3218, 0, "e");
    (3219, 0, "t");
    (3220, 0, ".");
    (3204, 10, "");
    (3230, 1, "");
    ( 19527,
      0,
      "\n\
      \    pub(super) unsafe fn current_item<'a>(&self) -> Option<&'a Item> {\n\
      \        let node = &*self.here_ptr();\n\
      \        if self.local_index < node.num_items as usize {\n\
      \            // Ok - just return the current item.\n\
      \            Some(&*(node.items[self.local_index].as_ptr()))\n\
      \        } else {\n\
      \            // Peek the first item in the next node.\n\
      \            self.peek_next_item().map(|ptr| &*ptr)\n\
      \        }\n\
      \    }\n" );
    (19966, 12, "t");
    (19967, 0, "a");
    (19968, 0, "k");
    (19969, 0, "e");
    (19970, 0, "_");
    (19971, 0, "i");
    (19972, 0, "t");
    (19973, 0, "e");
    (19974, 0, "m");
    (19981, 0, "m");
    (19982, 0, "u");
    (19983, 0, "t");
    (19984, 0, " ");
    (20001, 1, "");
    (20001, 1, "");
    (20001, 1, "");
    (20001, 1, "");
    (20295, 0, "// ");
    (20282, 0, "\n            ");
    (20295, 0, "u");
    (20296, 0, "n");
    (20297, 0, "i");
    (20298, 0, "m");
    (20299, 0, "p");
    (20300, 0, "l");
    (20295, 6, "unimplemented");
    (20308, 0, "(");
    (20309, 0, ")");
    (20310, 0, ";");
    (20380, 0, "// ");
    (20370, 0, "// ");
    (20316, 0, "// ");
    (20287, 0, "// ");
    (20234, 0, "// ");
    (20217, 0, "// ");
    (20157, 0, "// ");
    (20107, 0, "// ");
    (20051, 0, "// ");
    (20013, 0, "// ");
    (19945, 0, "// ");
    (19532, 11, "");
    (19532, 0, "pub(super) ");
    (20410, 3, "");
    (20397, 3, "");
    (20340, 3, "");
    (20308, 3, "");
    (20252, 3, "");
    (20232, 3, "");
    (20169, 3, "");
    (20116, 3, "");
    (20057, 3, "");
    (20016, 3, "");
    (19945, 3, "");
    (20380, 0, "// ");
    (20370, 0, "// ");
    (20316, 0, "// ");
    (20287, 0, "// ");
    (20234, 0, "// ");
    (20217, 0, "// ");
    (20157, 0, "// ");
    (20107, 0, "// ");
    (20051, 0, "// ");
    (20013, 0, "// ");
    (19945, 0, "// ");
    (19243, 11, "");
    (19892, 1, "");
    (19889, 2, "nod");
    (19266, 1, "");
    (19263, 2, "nod");
    (19298, 212, "");
    (19302, 0, "// ");
    (19243, 0, "// ");
    ( 19656,
      50,
      "        let next = (*self.here_ptr()).get_next_ptr();\n\
      \        if next.is_null() { None }\n\
      \        else {\n\
      \            debug_assert!((*next).num_items > 0);\n\
      \            Some((*next).items[0].as_mut_ptr())\n\
      \        }\n" );
    (19868, 0, "    ");
    (19858, 8, "            ");
    (19810, 12, "                ");
    (19760, 12, "                ");
    (19745, 8, "            ");
    (19710, 8, "            ");
    (19656, 8, "            ");
    (19892, 4, "");
    (19878, 12, "        ");
    (19826, 16, "            ");
    (19772, 16, "            ");
    (19753, 12, "        ");
    (19714, 12, "        ");
    (19656, 12, "        ");
    (19656, 212, "            self.peek_next_node().map(|ptr| &*ptr)");
    (19305, 3, "");
    (19243, 3, "");
    ( 19298,
      0,
      "        let next = (*self.here_ptr()).get_next_ptr();\n\
      \        if next.is_null() { None }\n\
      \        else {\n\
      \            debug_assert!((*next).num_items > 0);\n\
      \            Some((*next).items[0].as_mut_ptr())\n\
      \        }\n" );
    (19893, 0, "_start");
    (19267, 0, "_start");
    (20411, 3, "");
    (20398, 3, "");
    (20341, 3, "");
    (20309, 3, "");
    (20253, 3, "");
    (20233, 3, "");
    (20170, 3, "");
    (20117, 3, "");
    (20058, 3, "");
    (20017, 3, "");
    (19946, 3, "");
    (19975, 1, "");
    (19974, 1, "");
    (19973, 1, "");
    (19972, 1, "");
    (19972, 0, "p");
    (19973, 0, "r");
    (19974, 0, "e");
    (19975, 0, "v");
    (19976, 0, "_");
    (19976, 1, "");
    (20047, 0, "\n        ");
    (20056, 0, "i");
    (20057, 0, "f");
    (20058, 0, " ");
    (20059, 0, "s");
    (20060, 0, "e");
    (20061, 0, "l");
    (20062, 0, "f");
    (20063, 0, ".");
    (20064, 0, "i");
    (20065, 0, "n");
    (20066, 0, "d");
    (20067, 0, "e");
    (20064, 4, "l");
    (20065, 0, "o");
    (20066, 0, "c");
    (20067, 0, "a");
    (20068, 0, "l");
    (20064, 5, "local_index");
    (20075, 0, " ");
    (20076, 0, "=");
    (20077, 0, "=");
    (20078, 0, " ");
    (20079, 0, "0");
    (20080, 0, " ");
    (20081, 0, "{");
    (20082, 0, " ");
    (20083, 0, "N");
    (20084, 0, "o");
    (20085, 0, "n");
    (20086, 0, "e");
    (20087, 0, " ");
    (20088, 0, "}");
    (20098, 0, "e");
    (20099, 0, "l");
    (20100, 0, "s");
    (20101, 0, "e");
    (20102, 0, " ");
    (20270, 153, "");
    (20103, 45, "");
    (20102, 1, "");
    (20102, 0, " if self.local_index < node.num_items as usize");
    (20103, 45, "");
    (20102, 1, "");
    (20104, 0, "\n            ");
    (20117, 0, "d");
    (20118, 0, "e");
    (20119, 0, "b");
    (20120, 0, "u");
    (20121, 0, "g");
    (20117, 5, "debug_assert!");
    (20130, 0, "(");
    (20131, 0, "if self.local_index < node.num_items as usize");
    (20131, 3, "");
    (20298, 0, "// ");
    (20288, 0, "// ");
    (20228, 0, "// ");
    (20178, 0, "// ");
    (20109, 0, "// ");
    (20094, 0, "// ");
    (20052, 0, "// ");
    (20014, 0, "// ");
    (19946, 0, "// ");
    (3265, 0, "\n    fn split_item(self, _at: usize) -> (Self, Self) {");
    (3270, 0, "// ");
    (3230, 0, "&");
    (1069, 2, "2");
  |]
