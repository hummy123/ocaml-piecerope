let str = "/// This is an implementation of a general purpose skip list. It was originally\n/// ported from a version of skiplists intended for efficient string handling\n/// found here - https://github.com/josephg/rustrope\n\n/// This implementation is not optimized for strings (there's some string\n/// specific features like unicode handling which have been intentionally\n/// removed for simplicity). But it does have another somewhat unusual feature -\n/// users can specify their own size function, and lookups, inserts and deletes\n/// can use their custom length property to specify offsets.\n\n/// Unlike other rust rope implementations, this implementation should be very\n/// fast; but it manages that through heavy use of unsafe pointers and C-style\n/// dynamic arrays.\n\nuse std::{mem, ptr};\nuse std::alloc::{alloc, dealloc, Layout};\nuse std::cmp::min;\n\nuse rand::{RngCore, Rng, SeedableRng};\nuse rand::rngs::SmallRng;\n\n/// The likelyhood a node will have height (n+1) instead of n\nconst BIAS: u8 = 100; // out of 256.\n\n/// The number of items in each node. Must fit in a u8 thanks to Node.\n#[cfg(test)]\nconst NODE_NUM_ITEMS: usize = 100;\nconst NODE_NUM_ITEMS: usize = 1;\n\n/// Rope operations will move to linear time after NODE_STR_SIZE * 2 ^\n/// MAX_HEIGHT length. (With a smaller constant the higher this is). On the flip\n/// side, cursors grow linearly with this number; so smaller is marginally\n/// better when the contents are smaller.\nconst MAX_HEIGHT: usize = 10;\n\nconst MAX_HEIGHT_U8: u8 = MAX_HEIGHT as u8; // convenience.\n\n/// The whole list is configured through a single generic trait parameter\npub trait ListConfig {\n    type Item: Default + Copy;\n\n    /// Applications which have custom sizes (or do their own\n    /// run-length-encoding) can define their own size function for items. When\n    /// items are inserted or replaced, the position is specified using the\n    /// custom size defined here.\n    fn get_usersize(_item: &Self::Item) -> usize { 1 }\n\n    fn userlen_of_slice(items: &[Self::Item]) -> usize {\n        items.iter().fold(0, |acc, item| {\n            acc + Self::get_usersize(item)\n        })\n    }\n\n    fn split_item(_item: Self::Item) -> (Self::Item, Self::Item) {\n        unimplemented!(\"Cannot insert in the middle of an item - split_item is not defined in trait\");\n    }\n\n    // type RngType: rand::RngCore = rand::rngs::SmallRng;\n    // fn get_rng() -> Self::RngType {\n    //     use rand::SeedableRng;\n    //     // rand::rngs::SmallRng::from_seed(SeedableRng::seed_from_u64(10))\n    //     rand::rngs::SmallRng::from_entropy()\n    // }\n}\n\n/// This represents a single entry in either the nexts pointers list or in an\n/// iterator.\n#[derive(Debug, PartialEq, Eq)]\nstruct SkipEntry<C: ListConfig> {\n    /// The node being pointed to.\n    node: *mut Node<C>,\n\n    /// The number of *items* between the start of the current node and the\n    /// start of the next node. That means nexts entry 0 contains the length of\n    /// the current node.\n    skip_usersize: usize,\n}\n\n// We can't use #[derive()] here for Copy and Clone due to a bug in the rust\n// compiler: https://github.com/rust-lang/rust/issues/26925\nimpl<C: ListConfig> Copy for SkipEntry<C> {}\nimpl<C: ListConfig> Clone for SkipEntry<C> {\n    fn clone(&self) -> Self { *self }\n}\n\nimpl<C: ListConfig> SkipEntry<C> {\n    fn new_null() -> Self {\n        SkipEntry { node: ptr::null_mut(), skip_usersize: 0 }\n    }\n}\n\n\n/// The node structure is designed in a very fancy way which would be more at\n/// home in C or something like that. The basic idea is that the node structure\n/// is fixed size in memory, but the proportion of that space taken up by\n/// characters and by the height differ depending on a node's height. This\n/// results in a lot of `unsafe` blocks. I think the tradeoff is worth it but I\n/// could be wrong here. You probably wouldn't lose much performance in practice\n/// by replacing the inline structure with a smallvec - but that would waste\n/// memory in small nodes, and require extra pointer indirection on large nodes.\n/// It also wouldn't remove all the unsafe here.\n///\n/// A different representation (which might be better or worse - I can't tell)\n/// would be to have the nodes all be the same size in memory and change the\n/// *proportion* of the node's memory that is used by the string field vs the\n/// next pointers. That might be lighter weight for the allocator because the\n/// struct itself would be a fixed size; but I'm not sure if it would be better.\n#[repr(C)] // Prevent parameter reordering.\nstruct Node<C: ListConfig> {\n    /// We start with the items themselves. Only the first `num_items` of this\n    /// list is in use. The user specified length of the items in the node is\n    /// stored in nexts[0].skip_items. This is initialized with\n    /// Default::default() for the type, but when MaybeUninit completely lands,\n    /// it will be possible to make this a tiny bit faster by leaving the list\n    /// initially uninitialized.\n    items: [C::Item; NODE_NUM_ITEMS],\n\n    /// Number of items in `items` in use / filled.\n    num_items: u8,\n\n    /// Height of nexts array.\n    height: u8,\n\n    // #[repr(align(std::align_of::<SkipEntry>()))]\n    \n    /// In reality this array has the size of height, allocated using more or\n    /// less direct calls to malloc() at runtime based on the randomly generated\n    /// size. The size is always at least 1.\n    nexts: [SkipEntry<C>; 0],\n}\n\n// Make sure nexts uses correct alignment. This should be guaranteed by repr(C)\n// This test will fail if this ever stops being true.\n#[test]\nfn test_align() {\n    struct TestConfig;\n    impl ListConfig for TestConfig {\n        type Item = u8;\n        fn get_usersize(_item: &Self::Item) -> usize { 1 }\n    }\n    #[repr(C)] struct Check([SkipEntry<TestConfig>; 0]);\n    assert!(mem::align_of::<Check>() >= mem::align_of::<SkipEntry<TestConfig>>());\n    // TODO: It'd be good to also check the alignment of the nexts field in Node.\n}\n\nfn random_height<R: RngCore>(rng: &mut R) -> u8 {\n    let mut h: u8 = 1;\n    // Should I use a csrng here? Does it matter?\n    while h < MAX_HEIGHT_U8 && rng.gen::<u8>() < BIAS { h+=1; }\n    h\n}\n\n#[repr(C)]\npub struct SkipList<C: ListConfig> {\n    // TODO: Consider putting the head item on the heap. For the use case here\n    // its almost certainly fine either way. The code feels a bit cleaner if its\n    // on the heap (and then iterators will be able to outlast a move of the\n    // skiplist parent). But its also very nice having the code run fast for\n    // small lists. Most lists are small, and it makes sense to optimize for\n    // that.\n\n    // TODO: For safety, pointers in to this structure should be Pin<> if we\n    // ever want to hold on to iterators.\n\n    /// The total number of items in the skip list. This is not used internally -\n    /// just here for bookkeeping.\n    num_items: usize,\n    /// Size of the list in user specified units.\n    num_usercount: usize,\n\n    /// The RNG we use to generate node heights. Specifying it explicitly allows\n    /// unit tests and randomizer runs to be predictable, which is very helpful\n    /// during debugging. I'm still not sure how the type of this should be\n    /// specified. Should it be a generic parameter? Box<dyn *>?\n    /// ??\n    rng: SmallRng,\n\n    /// The first node is inline. The height is 1 more than the max height we've\n    /// ever used. The highest next entry points to {null, total usersize}.\n    head: Node<C>,\n\n    /// This is so dirty. The first node is embedded in SkipList; but we need to\n    /// allocate enough room for height to get arbitrarily large. I could insist\n    /// on SkipList always getting allocated on the heap, but for small lists its\n    /// much better to be on the stack.\n    ///\n    /// So this struct is repr(C) and I'm just padding out the struct directly.\n    /// All accesses should go through head because otherwise I think we violate\n    /// aliasing rules.\n    _nexts_padding: [SkipEntry<C>; MAX_HEIGHT],\n}\n\n\n\nimpl<C: ListConfig> Node<C> {\n    // Do I need to be explicit about the lifetime of the references being tied\n    // to the lifetime of the node?\n    fn nexts(&self) -> &[SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts(self.nexts.as_ptr(), self.height as usize)\n        }\n    }\n\n    fn nexts_mut(&mut self) -> &mut [SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.nexts.as_mut_ptr(), self.height as usize)\n        }\n    }\n\n    fn layout_with_height(height: u8) -> Layout {\n        Layout::from_size_align(\n            mem::size_of::<Node<C>>() + mem::size_of::<SkipEntry<C>>() * (height as usize),\n            mem::align_of::<Node<C>>()).unwrap()\n    }\n\n    fn alloc_with_height(height: u8) -> *mut Node<C> {\n        assert!(height >= 1 && height <= MAX_HEIGHT_U8);\n\n        unsafe {\n            let node = alloc(Self::layout_with_height(height)) as *mut Node<C>;\n            (*node) = Node {\n                items: [C::Item::default(); NODE_NUM_ITEMS],\n                num_items: 0,\n                height: height,\n                nexts: [],\n            };\n\n            for next in (*node).nexts_mut() {\n                *next = SkipEntry::new_null();\n            }\n\n            node\n        }\n    }\n\n    fn alloc<R: RngCore>(rng: &mut R) -> *mut Node<C> {\n        Self::alloc_with_height(random_height(rng))\n    }\n\n    unsafe fn free(p: *mut Node<C>) {\n        dealloc(p as *mut u8, Self::layout_with_height((*p).height));\n    }\n\n    fn content_slice(&self) -> &[C::Item] {\n        &self.items[..self.num_items as usize]\n    }\n\n    // The height is at least 1, so this is always valid.\n    fn first_skip_entry<'a>(&self) -> &'a SkipEntry<C> {\n        unsafe { &*self.nexts.as_ptr() }\n    }\n\n    fn first_skip_entry_mut<'a>(&mut self) -> &'a mut SkipEntry<C> {\n        unsafe { &mut *self.nexts.as_mut_ptr() }\n    }\n\n    // TODO: Rename to len() ?\n    fn get_userlen(&self) -> usize {\n        self.first_skip_entry().skip_usersize\n    }\n    \n    fn get_next_ptr(&self) -> *mut Node<C> {\n        self.first_skip_entry().node\n    }\n}\n\nstruct NodeIter<'a, C: ListConfig>(Option<&'a Node<C>>);\nimpl<'a, C: ListConfig> Iterator for NodeIter<'a, C> {\n    type Item = &'a Node<C>;\n\n    fn next(&mut self) -> Option<&'a Node<C>> {\n        let prev = self.0;\n        if let Some(n) = self.0 {\n            *self = NodeIter(unsafe { n.first_skip_entry().node.as_ref() });\n        }\n        prev\n    }\n}\n\n/// This is a set of pointers with metadata into a location in the list needed\n/// to skip ahead, delete and insert in items. A cursor is reasonably heavy\n/// weight - we fill in and maintain as many entries as the height of the list\n/// dictates.\n///\n/// This is not needed for simply iterating sequentially through nodes and data.\n/// For that look at NodeIter.\n///\n/// Note most/all methods using cursors are unsafe. This is because cursors use\n/// raw mutable pointers into the list, so when used the following rules have to\n/// be followed:\n///\n/// - Whenever a write happens (insert/remove/replace), any cursor not passed to\n///   the write function is invalid.\n/// - While a cursor is held the SkipList struct should be considered pinned and\n///   must not be moved or deleted\n#[derive(Copy, Clone, Debug)]\nstruct Cursor<C: ListConfig> {\n    // TODO: Add a phantom lifetime reference to the skip list root for safety.\n\n\n    /// The global user position of the cursor in the entire list. This is used\n    /// for when the max seen height increases, so we can populate previously\n    /// unused entries in the cursor and in the head node.\n    ///\n    /// This field isn't strictly necessary - earlier versions tacked this on to\n    /// the last item in entries... I'm still not sure the cleanest way to do\n    /// this.\n    userpos: usize,\n\n    /// When the userpos of an entry is 0 (totally valid and useful), a cursor\n    /// becomes ambiguous with regard to where exactly its pointing in the\n    /// current entry. This is used to resolve that ambiguity.\n    local_index: usize,\n\n    entries: [SkipEntry<C>; MAX_HEIGHT],\n}\n\nimpl<C: ListConfig> Cursor<C> {\n    fn update_offsets(&mut self, height: usize, by: isize) {\n        for i in 0..height {\n            unsafe {\n                // This is weird but makes sense when you realise the nexts in\n                // the cursor are pointers into the elements that have the\n                // actual pointers.\n                // Also adding a usize + isize is awful in rust :/\n                let skip = &mut (*self.entries[i].node).nexts_mut()[i].skip_usersize;\n                *skip = skip.wrapping_add(by as usize);\n            }\n        }\n    }\n\n    /// Move a cursor to the start of the next node. Returns the new node (or a\n    /// nullptr if this is the end of the list).\n    fn advance_node(&mut self) -> *mut Node<C> {\n        unsafe {\n            let SkipEntry { node: e, skip_usersize: offset } = self.entries[0];\n            // offset tells us how far into the current element we are (in\n            // usersize). We need to increment the offsets by the entry's\n            // remaining length to get to the start of the next node.\n            let advance_by = (*e).get_userlen() - offset;\n            let next = (*e).get_next_ptr();\n            let height = (*next).height as usize;\n\n            for i in 0..height {\n                self.entries[i] = SkipEntry {\n                    node: next,\n                    skip_usersize: 0\n                };\n            }\n\n            for i in height..self.entries.len() {\n                self.entries[i].skip_usersize += advance_by;\n            }\n\n            self.userpos += advance_by;\n            self.local_index = 0;\n\n            next\n        }\n    }\n\n    fn is_at_node_end(&self) -> bool {\n        self.local_index == unsafe { (*self.here_ptr()).num_items } as usize\n    }\n\n    fn advance_item(&mut self, height: u8) {\n        if self.is_at_node_end() { self.advance_node(); }\n        let usersize = C::get_usersize(unsafe { self.current_item() });\n\n        for entry in &mut self.entries[0..height as usize] {\n            entry.skip_usersize += usersize;\n        }\n        self.userpos += usersize;\n        self.local_index += 1;\n    }\n\n    fn advance_by_items(&mut self, num: usize, height: u8) {\n        for _ in 0..num { self.advance_item(height); }\n    }\n\n    unsafe fn current_item(&mut self) -> &C::Item {\n        &(*self.here_ptr()).items[self.local_index]\n    }\n\n    /// Get the pointer to the cursor's current node\n    fn here_ptr(&self) -> *mut Node<C> {\n        self.entries[0].node\n    }\n}\n\nimpl<C: ListConfig> PartialEq for Cursor<C> {\n    /// Warning: This returns false if one cursor is at the end of a node, and\n    /// the other at the start of the next node. Almost all code in this library\n    /// leaves cursors at the end of nodes, so this shouldn't matter too much in\n    /// practice.\n    fn eq(&self, other: &Self) -> bool {\n        if self.userpos != other.userpos\n            || self.local_index != other.local_index {return false; }\n\n        for i in 0..MAX_HEIGHT {\n            let a = &self.entries[i];\n            let b = &other.entries[i];\n            if a.node != b.node || a.skip_usersize != b.skip_usersize { return false; }\n        }\n        true\n    }\n}\nimpl<C: ListConfig> Eq for Cursor<C> {}\n\nimpl<C: ListConfig> SkipList<C> {\n    pub fn new() -> Self {\n        SkipList::<C> {\n            num_items: 0,\n            num_usercount: 0,\n            rng: SmallRng::seed_from_u64(123),\n            head: Node {\n                items: [C::Item::default(); NODE_NUM_ITEMS],\n                num_items: 0,\n                height: 1, // Stores max height of list nodes\n                nexts: [],\n            },\n            _nexts_padding: [SkipEntry::new_null(); MAX_HEIGHT],\n        }\n    }\n\n    pub fn new_from_slice(s: &[C::Item]) -> Self {\n        let mut rope = Self::new();\n        rope.insert_at(0, s);\n        rope\n    }\n\n    pub fn get_userlen(&self) -> usize {\n        self.num_usercount\n    }\n\n    fn iter(&self) -> NodeIter<C> { NodeIter(Some(&self.head)) }\n    \n    pub fn len_items(&self) -> usize {\n        self.num_items as usize\n    }\n\n    fn heads_mut(&mut self) -> &mut [SkipEntry<C>] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.head.nexts.as_mut_ptr(), self._nexts_padding.len())\n        }\n    }\n\n    /// Walk the list and validate internal constraints. This is used for\n    /// testing the structure itself, and should generally not be called by\n    /// users.\n    pub fn check(&self) {\n        // #[cfg(test)]\n        {\n            assert!(self.head.height >= 1);\n            assert!(self.head.height <= MAX_HEIGHT_U8);\n\n            // let skip_over = self.get_top_entry();\n            // println!(\"Skip over skip chars {}, num bytes {}\", skip_over.skip_items, self.num_bytes);\n\n            let mut iter = [SkipEntry {\n                // Bleh.\n                node: &self.head as *const Node<C> as *mut Node<C>,\n                // The skips will store the total distance travelled since the\n                // start of this traversal at each height. All the entries above\n                // head.height are ignored though.\n                skip_usersize: 0\n            }; MAX_HEIGHT];\n\n            let mut num_items = 0;\n            let mut num_usercount = 0;\n\n            for n in self.iter() {\n                // println!(\"visiting {:?}\", n.as_str());\n                let is_head = n as *const _ == &self.head as *const _;\n                if !is_head { assert!(n.num_items > 0); }\n                assert!(n.height <= MAX_HEIGHT_U8);\n                assert!(n.num_items as usize <= NODE_NUM_ITEMS);\n\n                // Make sure the number of items matches the count\n                let local_count = C::userlen_of_slice(&n.items[0..n.num_items as usize]);\n                assert_eq!(local_count, n.get_userlen());\n\n                // assert_eq!(n.as_str().chars().count(), n.num_chars());\n                for (i, entry) in iter[0..n.height as usize].iter_mut().enumerate() {\n                    assert_eq!(entry.node as *const Node<C>, n as *const Node<C>);\n                    assert_eq!(entry.skip_usersize, num_usercount);\n\n                    // println!(\"replacing entry {:?} with {:?}\", entry, n.nexts()[i].node);\n                    entry.node = n.nexts()[i].node;\n                    entry.skip_usersize += n.nexts()[i].skip_usersize;\n                }\n\n                num_items += n.num_items as usize;\n                num_usercount += n.get_userlen();\n            }\n\n            for entry in iter[0..self.head.height as usize].iter() {\n                // println!(\"{:?}\", entry);\n                assert!(entry.node.is_null());\n                assert_eq!(entry.skip_usersize, num_usercount);\n            }\n            \n            // println!(\"self bytes: {}, count bytes {}\", self.num_bytes, num_bytes);\n            assert_eq!(self.num_items, num_items);\n            assert_eq!(self.get_userlen(), num_usercount);\n        }\n    }\n    \n    \n    /// Internal function for creating a cursor at a particular location in the\n    /// skiplist. The returned cursor contains list of nodes which point past\n    /// the specified position, as well as offsets of how far into their\n    /// character lists the specified characters are.\n    ///\n    /// Sometimes a call to iter_at_userpos is ambiguous:\n    ///\n    /// - The item can contain items with zero usersize. The cursor could point\n    ///   to any of them.\n    /// - If the location is at the end of a node, it is equally valid to return\n    ///   a position at the start of the next node.\n    ///\n    /// Because its impossible to move backwards in the list, iter_at_userpos\n    /// returns the first admissible location with the specified userpos.\n    /// \n    /// Returns (cursor, offset into the specified item).\n    ///\n    /// TODO: This should be Pin<&self>.\n    fn iter_at_userpos(&self, target_userpos: usize) -> (Cursor<C>, usize) {\n        assert!(target_userpos <= self.get_userlen());\n\n        let mut e: *const Node<C> = &self.head;\n        let mut height = self.head.height as usize - 1;\n        \n        let mut offset = target_userpos; // How many more items to skip\n\n        // We're populating the head node pointer to simplify the case when the\n        // iterator grows. We could put offset into the skip_usersize but it\n        // would only be *mostly* correct, not always correct. (Since cursor\n        // entries above height are not updated by insert.)\n        let mut cursor = Cursor {\n            entries: [SkipEntry {\n                node: &self.head as *const _ as *mut _,\n                skip_usersize: usize::MAX\n            }; MAX_HEIGHT],\n            local_index: 0,\n            userpos: target_userpos,\n        };\n\n        loop { // while height >= 0\n            let en = unsafe { &*e };\n            let next = en.nexts()[height];\n            let skip = next.skip_usersize;\n            if offset > skip {\n                // Go right.\n                debug_assert!(e == &self.head || en.num_items > 0);\n                offset -= skip;\n                e = next.node;\n                assert!(!e.is_null(), \"Internal constraint violation: Reached rope end prematurely\");\n            } else {\n                // Record this and go down.\n                cursor.entries[height] = SkipEntry {\n                    skip_usersize: offset,\n                    node: e as *mut Node<C>, // This is pretty gross\n                };\n\n                if height == 0 { break; } else { height -= 1; }\n            }\n        };\n\n        // We should always land within the node we're pointing to.\n        debug_assert!(offset <= unsafe { &*cursor.here_ptr() }.get_userlen());\n\n        // We've found the node. Now look for the index within the node.\n        let en = unsafe { &*e };\n        let mut index = 0;\n\n        while offset > 0 {\n            assert!(index < en.num_items as usize);\n            \n            let usersize = C::get_usersize(&en.items[index]);\n            if usersize > offset { break; } // We're in the middle of an item.\n            offset -= usersize;\n            index += 1;\n        }\n        cursor.local_index = index;\n\n        (cursor, offset)\n    }\n\n    // Internal fn to create a new node at the specified iterator filled with\n    // the specified content. The passed cursor should point at the end of the\n    // previous node. It will be updated to point to the end of the newly\n    // inserted content.\n    unsafe fn insert_node_at(&mut self, cursor: &mut Cursor<C>, contents: &[C::Item], new_userlen: usize, move_cursor: bool) {\n        // println!(\"Insert_node_at {} len {}\", contents.len(), self.num_bytes);\n        debug_assert_eq!(new_userlen, C::userlen_of_slice(contents));\n        assert!(contents.len() <= NODE_NUM_ITEMS);\n\n        let new_node = Node::alloc(&mut self.rng);\n        (*new_node).num_items = contents.len() as u8;\n        (*new_node).items[..contents.len()].copy_from_slice(contents);\n        let new_height = (*new_node).height;\n\n        let mut head_height = self.head.height as usize;\n        let new_height_usize = new_height as usize;\n        while head_height < new_height_usize {\n            // This seems weird given we're about to overwrite these values\n            // below. What we're doing is retroactively setting up the cursor\n            // and head pointers *as if* the height had been this high all\n            // along. This way we only have to populate the higher head values\n            // lazily.\n            let total_userlen = self.num_usercount;\n            let nexts = self.heads_mut();\n            nexts[head_height].skip_usersize = total_userlen;\n            cursor.entries[head_height].skip_usersize = cursor.userpos;\n\n            head_height += 1; // This is ugly.\n            self.head.height += 1;\n        }\n\n        for i in 0..new_height_usize {\n            let prev_skip = &mut (*cursor.entries[i].node).nexts_mut()[i];\n            let new_nexts = (*new_node).nexts_mut();\n\n            // The new node points to the successor (or null)\n            new_nexts[i] = SkipEntry {\n                node: prev_skip.node,\n                skip_usersize: new_userlen + prev_skip.skip_usersize - cursor.entries[i].skip_usersize\n            };\n\n            // The previous node points to the new node\n            *prev_skip = SkipEntry {\n                node: new_node,\n                skip_usersize: cursor.entries[i].skip_usersize\n            };\n\n            // Move the iterator to the end of the newly inserted node.\n            if move_cursor {\n                cursor.entries[i] = SkipEntry {\n                    node: new_node,\n                    skip_usersize: new_userlen\n                };\n            }\n        }\n\n        for i in new_height_usize..head_height {\n            (*cursor.entries[i].node).nexts_mut()[i].skip_usersize += new_userlen;\n            if move_cursor {\n                cursor.entries[i].skip_usersize += new_userlen;\n            }\n        }\n        \n        self.num_items += contents.len();\n        self.num_usercount += new_userlen;\n        if move_cursor {\n            cursor.userpos += new_userlen;\n            cursor.local_index = contents.len();\n        }\n    }\n\n    unsafe fn insert_at_iter(&mut self, cursor: &mut Cursor<C>, contents: &[C::Item]) {\n        // iter specifies where to insert.\n\n        let mut e = cursor.here_ptr();\n\n        // The insertion offset into the destination node.\n        assert!(cursor.userpos <= self.num_usercount);\n        assert!(cursor.local_index <= (*e).num_items as usize);\n\n        // We might be able to insert the new data into the current node, depending on\n        // how big it is.\n        let num_inserted_items = contents.len();\n        let num_inserted_usercount = C::userlen_of_slice(contents);\n\n        // Can we insert into the current node?\n        let mut insert_here = (*e).num_items as usize + num_inserted_items <= NODE_NUM_ITEMS;\n\n        // Can we insert into the start of the successor node?\n        if !insert_here && cursor.local_index == (*e).num_items as usize && num_inserted_items <= NODE_NUM_ITEMS {\n            // We can insert into the subsequent node if:\n            // - We can't insert into the current node\n            // - There _is_ a next node to insert into\n            // - The insert would be at the start of the next node\n            // - There's room in the next node\n            if let Some(next) = (*e).first_skip_entry_mut().node.as_mut() {\n                if next.num_items as usize + num_inserted_items <= NODE_NUM_ITEMS {\n                    cursor.advance_node();\n                    e = next;\n\n                    insert_here = true;\n                }\n            }\n        }\n\n        let item_idx = cursor.local_index;\n        let e_num_items = (*e).num_items as usize; // convenience.\n\n        if insert_here {\n            // println!(\"insert_here {}\", contents);\n            // First push the current items later in the array\n            let c = &mut (*e).items;\n            if item_idx < e_num_items {\n                c[..].copy_within(item_idx..e_num_items,\n                    item_idx + num_inserted_items);\n            }\n\n            // Then copy in the new items\n            c[item_idx..item_idx + num_inserted_items].copy_from_slice(contents);\n\n            (*e).num_items += num_inserted_items as u8;\n            self.num_items += num_inserted_items;\n            self.num_usercount += num_inserted_usercount;\n\n            // .... aaaand update all the offset amounts.\n            cursor.update_offsets(self.head.height as usize, num_inserted_usercount as isize);\n\n            // Usually the cursor will be discarded after one change, but for\n            // consistency of compound edits we'll update the cursor to point to\n            // the end of the new content.\n            for entry in cursor.entries[0..self.head.height as usize].iter_mut() {\n                entry.skip_usersize += num_inserted_usercount;\n            }\n            cursor.userpos += num_inserted_usercount;\n            cursor.local_index += num_inserted_items;\n        } else {\n            // There isn't room. We'll need to add at least one new node to the\n            // list. We could be a bit more careful here and copy as much as\n            // possible into the current node - that would decrease the number\n            // of new nodes in some cases, but I don't think the performance\n            // difference will be large enough to justify the complexity.\n\n            // If we're not at the end of the current node, we'll need to remove\n            // the end of the current node's data and reinsert it later.\n            let num_end_items = e_num_items - item_idx;\n\n            let (end_items, end_usercount) = if num_end_items > 0 {\n                // We'll mark the items as deleted from the node, while leaving\n                // the data itself there for now to avoid a copy.\n\n                // Note that if we wanted to, it would also be correct (and\n                // slightly more space efficient) to pack some of the new\n                // string's characters into this node after trimming it.\n                let end_items = &(*e).items[item_idx..e_num_items];\n                (*e).num_items = item_idx as u8;\n                let end_usercount = (*e).get_userlen() - cursor.entries[0].skip_usersize;\n\n                cursor.update_offsets(self.head.height as usize, -(end_usercount as isize));\n\n                // We need to trim the size off because we'll add the characters\n                // back with insert_node_at.\n                self.num_usercount -= end_usercount;\n                self.num_items -= num_end_items;\n\n                (Some(end_items), end_usercount)\n            } else {\n                (None, 0)\n            };\n\n            // Now we insert new nodes containing the new character data. The\n            // data is broken into pieces with a maximum size of NODE_NUM_ITEMS.\n            // As further optimization, we could try and fit the last piece into\n            // the start of the subsequent node. That optimization hasn't been\n            // added.\n            \n            for chunk in contents.chunks(NODE_NUM_ITEMS) {\n                let userlen = C::userlen_of_slice(chunk);\n                self.insert_node_at(cursor, chunk, userlen, true);\n            }\n\n            // TODO: Consider recursively calling insert_at_iter() here instead\n            // of making a whole new node for the remaining content.\n            if let Some(end_items) = end_items {\n                // Passing false to indicate we don't want the cursor updated\n                // after this - it should remain at the end of the newly\n                // inserted content, which is *before* this end bit.\n                self.insert_node_at(cursor, end_items, end_usercount, false);\n            }\n        }\n    }\n\n    /// Interestingly unlike the original, here we only care about specifying\n    /// the number of removed items by counting them. We do not use usersize in\n    /// the deleted item count.\n    ///\n    /// If the deleted content occurs at the start of a node, the cursor passed\n    /// here must point to the end of the previous node, not the start of the\n    /// current node.\n    unsafe fn del_at_iter(&mut self, cursor: &mut Cursor<C>, mut num_deleted_items: usize) {\n        if num_deleted_items == 0 { return; }\n\n        let mut item_idx = cursor.local_index;\n        let mut e = cursor.here_ptr();\n        while num_deleted_items > 0 {\n            if item_idx == (*e).num_items as usize {\n                let entry = (*e).first_skip_entry();\n                // End of current node. Skip to the start of the next one. We're\n                // intentionally not updating the iterator because if we delete\n                // a whole node we need the iterator to point to the previous\n                // element. And if we only delete here, the iterator doesn't\n                // need to be moved.\n                e = entry.node;\n                if e.is_null() { panic!(\"Cannot delete past the end of the list\"); }\n                item_idx = 0;\n            }\n\n            let e_num_items = (*e).num_items as usize;\n            let removed_here = min(num_deleted_items, e_num_items - item_idx);\n            \n            let height = (*e).height as usize;\n            let removed_userlen;\n\n            if removed_here < e_num_items || e as *const _ == &self.head as *const _ {\n                // Just trim the node down.\n                let trailing_items = e_num_items - item_idx - removed_here;\n                \n                let c = &mut (*e).items;\n                removed_userlen = C::userlen_of_slice(&c[item_idx..item_idx + removed_here]);\n                if trailing_items > 0 {\n                    c[..].copy_within(item_idx + removed_here..e_num_items, item_idx);\n                }\n\n                (*e).num_items -= removed_here as u8;\n                self.num_items -= removed_here;\n                self.num_usercount -= removed_userlen;\n\n                for s in (*e).nexts_mut() {\n                    s.skip_usersize -= removed_userlen;\n                }\n            } else {\n                // Remove the node from the skip list entirely. e should be the\n                // next node after the position of the iterator.\n                assert_ne!(cursor.here_ptr(), e);\n\n                removed_userlen = (*e).get_userlen();\n                let next = (*e).first_skip_entry().node;\n\n                for i in 0..(*e).height as usize {\n                    let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n                    s.node = (*e).nexts_mut()[i].node;\n                    s.skip_usersize += (*e).nexts()[i].skip_usersize - removed_userlen;\n                }\n\n                self.num_items -= (*e).num_items as usize;\n                self.num_usercount -= removed_userlen;\n\n                Node::free(e);\n                e = next;\n            }\n\n            for i in height..self.head.height as usize {\n                let s = &mut (*cursor.entries[i].node).nexts_mut()[i];\n                s.skip_usersize -= removed_userlen;\n            }\n\n            num_deleted_items -= removed_here;\n        }\n    }\n\n    pub fn replace_at(&mut self, mut start_userpos: usize, mut removed_items: usize, mut inserted_content: &[C::Item]) {\n        if removed_items == 0 && inserted_content.len() == 0 { return; }\n\n        // For validation. This is where the cursor should end up.\n        let advanced_by = inserted_content.len();\n\n        start_userpos = min(start_userpos, self.get_userlen());\n\n        let (mut cursor, offset) = self.iter_at_userpos(start_userpos);\n        // let (mut index, offset) = unsafe { &*cursor.here_ptr() }.get_iter_idx(cursor.entries[0].skip_usersize, false);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n        // Replace as many items from removed_items as we can with inserted_content.\n        unsafe {\n            let mut replaced_items = min(removed_items, inserted_content.len());\n            removed_items -= replaced_items;\n\n            while replaced_items > 0 {\n                let mut e = cursor.here_ptr();\n                if cursor.local_index == (*e).num_items as usize {\n                    // Move to the next item.\n                    e = cursor.advance_node();\n                    if e.is_null() { panic!(\"Cannot replace past the end of the list\"); }\n                }\n\n                let index = cursor.local_index;\n\n                let e_num_items = (*e).num_items as usize;\n                let replaced_items_here = min(replaced_items, e_num_items - index);\n\n                let old_items = &mut (*e).items[index..index + replaced_items_here];\n                let new_items = &inserted_content[0..replaced_items_here];\n\n                // Replace the items themselves.\n                old_items.copy_from_slice(new_items);\n\n                // And bookkeeping. Bookkeeping forever.\n                let new_usersize = C::userlen_of_slice(new_items);\n                let usersize_delta = new_usersize as isize - C::userlen_of_slice(old_items) as isize;\n                if usersize_delta != 0 {\n                    cursor.update_offsets(self.head.height as usize, usersize_delta)\n                }\n\n                inserted_content = &inserted_content[replaced_items_here..];\n                replaced_items -= replaced_items_here;\n                // We'll hop to the next Node at the start of the next loop\n                // iteration if needed.\n                cursor.local_index += replaced_items_here;\n\n                for i in 0..self.head.height as usize {\n                    cursor.entries[i].skip_usersize += new_usersize;\n                }\n                cursor.userpos += new_usersize;\n            }\n\n            // Ok now one of two things must be true. Either we've run out of\n            // items to remove, or we've run out of items to insert.\n            if inserted_content.len() > 0 {\n                // Insert!\n                debug_assert!(removed_items == 0);\n                self.insert_at_iter(&mut cursor, inserted_content);\n            } else if removed_items > 0 {\n                self.del_at_iter(&mut cursor, removed_items);\n            }\n        }\n\n        // TODO: Assert that the iterator is after replaced content.\n        #[cfg(debug_assertions)] {\n            let (mut c2, _) = self.iter_at_userpos(start_userpos);\n            c2.advance_by_items(advanced_by, self.head.height);\n            if &cursor != &c2 { panic!(\"Invalid cursor after replace\"); }\n        }\n    }\n\n    pub fn insert_at(&mut self, mut userpos: usize, contents: &[C::Item]) {\n        if contents.len() == 0 { return; }\n        \n        userpos = min(userpos, self.get_userlen());\n        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n        unsafe { self.insert_at_iter(&mut cursor, contents); }\n\n        #[cfg(debug_assertions)] {\n            let (mut c2, _) = self.iter_at_userpos(userpos);\n            c2.advance_by_items(contents.len(), self.head.height);\n            if &cursor != &c2 { panic!(\"Invalid cursor after insert\"); }\n        }\n    }\n\n    pub fn del_at(&mut self, mut userpos: usize, num_items: usize) {\n        userpos = min(userpos, self.get_userlen());\n        // We can't easily trim num_items.\n        // num_items = min(length, self.num_chars() - pos);\n        if num_items == 0 { return; }\n\n        let (mut cursor, offset) = self.iter_at_userpos(userpos);\n        assert_eq!(offset, 0, \"Splitting nodes not yet supported\");\n\n        unsafe { self.del_at_iter(&mut cursor, num_items); }\n\n        #[cfg(debug_assertions)] {\n            let (c2, _) = self.iter_at_userpos(userpos);\n            if &cursor != &c2 { panic!(\"Invalid cursor after delete\"); }\n        }\n    }\n}\n\n\nimpl<C: ListConfig> SkipList<C> where C::Item: PartialEq {\n    pub fn eq_list(&self, other: &[C::Item]) -> bool {\n        let mut pos = 0;\n        let other_len = other.len();\n\n        for node in self.iter() {\n            let my_data = node.content_slice();\n            let my_len = my_data.len();\n\n            if pos + my_len > other_len || my_data != &other[pos..pos + my_data.len()] {\n                return false\n            }\n            pos += my_data.len();\n        }\n\n        return pos == other_len;\n    }\n}\n\nimpl<C: ListConfig> Drop for SkipList<C> {\n    fn drop(&mut self) {\n        let mut node = self.head.first_skip_entry().node;\n        unsafe {\n            while !node.is_null() {\n                let next = (*node).first_skip_entry().node;\n                Node::free(node);\n                node = next;\n            }\n        }\n    }\n}\n\n\nimpl<C: ListConfig> From<&[C::Item]> for SkipList<C> {\n    fn from(s: &[C::Item]) -> SkipList<C> {\n        SkipList::new_from_slice(s)\n    }\n}\n\nimpl<C: ListConfig> From<Vec<C::Item>> for SkipList<C> {\n    fn from(s: Vec<C::Item>) -> SkipList<C> {\n        SkipList::new_from_slice(s.as_slice())\n    }\n}\n\nimpl<C: ListConfig> Into<Vec<C::Item>> for &SkipList<C> {\n    fn into(self) -> Vec<C::Item> {\n        let mut content = Vec::with_capacity(self.num_items);\n\n        for node in self.iter() {\n            content.extend(node.content_slice().iter());\n        }\n\n        content\n    }\n}\n\nimpl<C: ListConfig> SkipList<C> where C::Item: std::fmt::Debug {\n    // TODO: Don't export this.\n    pub fn print(&self) {\n        println!(\"items: {}\\tuserlen: {}, height: {}\", self.num_items, self.get_userlen(), self.head.height);\n\n        print!(\"HEAD:\");\n        for s in self.head.nexts() {\n            print!(\" |{} \", s.skip_usersize);\n        }\n        println!(\"\");\n\n        for (i, node) in self.iter().enumerate() {\n            print!(\"{}:\", i);\n            for s in node.nexts() {\n                print!(\" |{} \", s.skip_usersize);\n            }\n            println!(\"      : {:?}\", node.content_slice());\n        }\n    }\n}\n\n// impl<T: Default + Copy, F: Fn(&T) -> usize> PartialEq for SkipList<T, F> {\n//     // This is quite complicated. It would be cleaner to just write a bytes\n//     // iterator, then iterate over the bytes of both strings comparing along the\n//     // way.\n//     // However, this should be faster because it can memcmp().\n\n//     // Another way to implement this would be to rewrite it as a comparison with\n//     // an iterator over &str. Then the rope vs rope comparison would be trivial,\n//     // but also we could add comparison functions with a single &str and stuff\n//     // very easily.\n//     fn eq(&self, other: &SkipList<T, F>) -> bool {\n//         if self.num_items != other.num_items\n//                 || self.num_chars() != other.num_chars() {\n//             return false\n//         }\n\n//         let mut other_iter = other.iter().map(|n| { n.as_str() });\n\n//         let mut os = other_iter.next();\n//         let mut opos: usize = 0; // Byte offset in os.\n//         for n in self.iter() {\n//             let s = n.as_str();\n//             let mut pos: usize = 0; // Current byte offset in s\n//             debug_assert_eq!(s.len(), n.num_bytes as usize);\n\n//             // Walk s.len() bytes through the other rope\n//             while pos < n.num_bytes as usize {\n//                 if let Some(oss) = os {\n//                     let amt = min(s.len() - pos, oss.len() - opos);\n//                     // println!(\"iter slen {} pos {} osslen {} amt {}\", s.len(), pos, oss.len(), amt);\n\n//                     if &s[pos..pos+amt] != &oss[opos..opos+amt] {\n//                         return false\n//                     }\n\n//                     pos += amt;\n//                     opos += amt;\n//                     debug_assert!(opos <= oss.len());\n\n//                     if opos == oss.len() {\n//                         os = other_iter.next();\n//                         opos = 0;\n//                     }\n//                 } else {\n//                     panic!(\"Internal string length does not match\");\n//                 }\n//             }\n//         }\n\n//         true\n//     }\n// }\n// impl<T: Default + Copy, F: Fn(&T) -> usize> Eq for SkipList<T, F> {}\n\n// impl<T: Default + Copy, F> Clone for SkipList<T, F> where F: Fn(&T) -> usize {\n//     fn clone(&self) -> Self {\n//         let mut r = SkipList::new(self.get_usersize);\n//         r.num_items = self.num_items;\n//         let head_str = self.head.as_str();\n//         r.head.items[..head_str.len()].copy_from_slice(head_str.as_bytes());\n//         r.head.num_bytes = self.head.num_bytes;\n//         r.head.height = self.head.height;\n        \n//         {\n//             // I could just edit the overflow memory directly, but this is safer\n//             // because of aliasing rules.\n//             let head_nexts = r.head.nexts_mut();\n//             for i in 0..self.head.height as usize {\n//                 head_nexts[i].skip_items = self.nexts[i].skip_items;\n//             }\n//         }\n\n//         let mut nodes = [&mut r.head as *mut Node; MAX_HEIGHT];\n\n//         // The first node the iterator will return is the head. Ignore it.\n//         let mut iter = self.iter();\n//         iter.next();\n//         for other in iter {\n//             // This also sets height.\n//             let height = other.height;\n//             let node = Node::alloc_with_height(height);\n//             unsafe {\n//                 (*node).num_bytes = other.num_bytes;\n//                 let len = other.num_bytes as usize;\n//                 (*node).items[..len].copy_from_slice(&other.items[..len]);\n\n//                 let other_nexts = other.nexts();\n//                 let nexts = (*node).nexts_mut();\n//                 for i in 0..height as usize {\n//                     nexts[i].skip_items = other_nexts[i].skip_items;\n//                     (*nodes[i]).nexts_mut()[i].node = node;\n//                     nodes[i] = node;\n//                 }\n//             }\n//         }\n\n//         r\n//     }\n// }\n"